{
  "info": {
    "author": "Frederic Hess",
    "author_email": "fhess@st-sa.ch",
    "bugtrack_url": null,
    "classifiers": [],
    "description": "===================\nPython digimat.saia\n===================\n\nThis is a Python 2.7 module allowing to create **client** and/or **server** `SAIA EtherSBus <https://wiki.wireshark.org/EtherSBus>`_  nodes. \nThis code allow you to create low cost (and hopefully reliable) communication services with any EtherSBus device, reading and writing data from/to them. By data (items),\nwe mean inputs, outputs, flags and registers. More data-types can be supported in the future. In the exemple below, a local\nSBus node with address 253 (station number, or localid, or lid in our terminology) is created. \n\n.. code-block:: python\n\n    >>> from digimat.saia import SAIANode\n    >>> node=SAIANode(253)\n\nCongratulations ! You just have powered up your first EtherSNode device with 2 lines of code. A background task handle now for you all the network SBus frames. \nOpen your SAIA PG5 Debugger and try to read/write some data to your node. When done, shutdown your node properly.\n\n.. code-block:: python\n\n    >>> node.stop()\n    >>> quit()\n\n\nSAIA EtherSBus\n--------------\n\nThe EtherSBus is mainly an UDP encapsulated version of the serial SAIA S-Bus. The EtherSBus is `natively implemented <https://www.sbc-support.com/fr/product-category/communication-protocols/>`_\nin any SAIA nodes having a LAN port, providing a very easy way to exchange (read/write) information with 3rd party devices. The digimat.saia module\nwas mainly created to partially explore the S-Bus mecanisms on Raspberry Pi devices before starting a deeper implementation\non our `Digimat <https://www.st-sa.ch/digimat.html>`_ HVAC BMS infrastructure. \n\nPlease consider this work as *in progress* (**buggy and incomplete**).\n\nAt this time, we don't have access to any S-Bus or EtherSBus protocol official specifications. If you own such documentation,\nplease forward it to us (fhess@st-sa.ch), as SAIA doesn't want to provide it ;( Some good starting points may include :\n\n* `SAIA faq <http://www.sbc-support.ch/faq>`_\n* `WireShark EtherSBus plugin source code <https://github.com/boundary/wireshark/blob/master/epan/dissectors/packet-sbus.c>`_\n* `SBPoll Python EtherSBus source code <http://mblogic.sourceforge.net/mbtools/sbpoll.html>`_\n\nUsing the SAIA PG5 debugger may also help understanding how things works. Wireshark has an excellent protocol decoder \nand you will find some .pcap samples by googling \"sbus pcap\".\n\nDon't forget that the SAIA dynamic addressing won't be your friend here as you must know the address of the variable\nyou want read/write. Consider fixing your variables to \"static\" addresses in your PG5 configuration.\n\n\nInstallation\n------------\n\nNothing specific here, just use pip (which will also install the digimat.jobs module)\n\n.. code-block:: bash\n\n    pip install -U digimat.saia\n\n\nEtherSBus Node\n--------------\n\nOnce created, the SAIANode object will implicitely start a background task responsible for protocol and bus variables management.\nThe task must be stop()ed before the program termination. The node contains a server (allowing other nodes to read an write \ndata to it). The node can also donnect to other remote SBus servers, to read/write remote data. Each server (local or remote)\nhas it's own memory representation (SAIAMemory).\n\nThe SAIAMemory object handle every SBus variables (inputs, outputs, flags, registers). The SAIAMemory object provide a SAIAFlags object, \naccessible trough a .flags property, itself providing access to every registered SAIAItemFlag object (item). The same principle is used for inputs \n(SAIAItemInputs), outputs (SAIAItemOutputs) and registers (SAIAItemRegisters). Note that there are shortcuts implemented : \n*node.flags* can be used instead of *node.memory.flags*.\n\n.. code-block:: python\n\n    >>> myflag=node.memory.flags[18]\n\n    >>> myflag\n    <class 'digimat.saia.memory.SAIAItemFlag'>\n\n    >>> myflag.value=True\n    >>> print myflag.value\n    True\n\nThe SAIAMemory object is initially created *empty* (with no items declared). Items are dynamically instanciated \"on-the-fly\" when they are accessed. In the example above,\nthe flag 18 is created on the first call, and returned in a SAIAItemFlag object. Subsequent calls to this item will always return the same object instance.\nEach item provide some helpers methods to facilitate value manipulation\n\n.. code-block:: python\n\n    myflag.off()\n    myflag.on()\n    myflag.toggle()\n    myflag.set()\n    myflag.clear()\n    myflag.value=1\n    myflag.value=True\n    print myflag.value\n\nBy default, \"on-the-fly-item-creation\" is active. This means that any data item (flag, input, output, register) which is accessed (locally or remotely)\nwill be dynamically instanciated if it doesn't exists.  This can create a large amount of unwanted memory consumption in case of abuse or bug. This mode can\nbe disabled, and accessing a non pre-declared item will fail.\n\n.. code-block:: python\n\n    >>> node.memory.enableOnTheFlyItemCreation(False)\n    >>> print node.memory.flags[19]\n    None\n\nItems can created by \"declaring\" them, individually or by range\n\n.. code-block:: python\n\n    >>> myflag=node.memory.flags.declare(index=18)\n    >>> myflags=node.flags.declareRange(index=100, count=3)\n    >>> print myflags\n    [127.0.0.1(253).SAIAItemFlag[100](value=OFF, age=1502487757s),\n    127.0.0.1(253).SAIAItemFlag[101](value=OFF, age=1502487757s),\n    127.0.0.1(253).SAIAItemFlag[102](value=OFF, age=1502487757s)]\n\nInputs, Outputs and Flags are boolean items. Registers are simple \"32 bits uint values\".\n\n.. code-block:: python\n\n    >>> myregister=node.memory.registers[0]\n    >>> myregister.value=100\n    >>> print register.value\n    100\n\nRegisters are always stored as \"raw 32 bits\" values (without encoding). Helpers are available to set/get the register value with common encodings\n\n.. code-block:: python\n\n    >>> myregister.float32=21.5\n    >>> print myregister.value\n    1101791232\n    >>> print myregister.float32\n    21.5\n\nActually, the following encoders/decoders accessors are implemented\n\n+---------------+-----------------------------------------------------+\n| **.float32**  | IEEE float32 encoding (big-endian)                  |\n+---------------+-----------------------------------------------------+\n| **.sfloat32** | Swapped IEEE float32 encoding (little-endian)       |\n+---------------+-----------------------------------------------------+\n| **.ffp**      | Motorola Fast Floating Point encoding (SAIA Float)  |\n+---------------+-----------------------------------------------------+\n| **.float**    | Alias for FFP encodings (easier to remember)        |\n+---------------+-----------------------------------------------------+\n| **.int10**    | x10 rounded value (21.5175 is encoded as 215)       |\n+---------------+-----------------------------------------------------+\n\nAs in SAIA float values seems to be FFP encoded, the ffp encoder is automatically used\nwhen writing a float value to a register (instead of an int)\n\n.. code-block:: python\n\n    >>> myregister.value=2\n    >>> print myregister.value\n    2\n    >>> myregister.value=2.0\n    >>> print myregister.value\n    2147483714\n    >>> print myregister.fft\n    2.0\n\n\nEtherSBus Client\n----------------\n\nThe node object allow access to (as many) remote EtherSBus nodes you need\n\n.. code-block:: python\n\n    >>> server=node.registerServer('192.168.0.100')\n    >>> myRemoteFlag=server.memory.flags[5]\n\nThe registration process provide a SAIAServer object, containing a SAIAMemory object to access remote items. Local and remote data can be manipulated \nin the same manner. When a remote data item (input, output, flag, register) is declared, an automatic pooling mecanism is launched in \nthe background task (manager). The default refresh rate is 60s per item,  modifiable with a myRemoteFlag.setRefreshDelay() call.\nAlternatively, the refresh rate can be specified for the whole item collection, with a node.memory.flags.setRefreshDelay() call. \nRefresh can be triggered on demand with a myRemoteFlag.refresh() call or more globally with for example node.memory.flags.refresh() and node.memory.refresh() calls. \nYou can query the elapsed time (in seconds) since the last value update (refresh) with the myRemoteFlag.age() method. Changing the remote data value is fully transparent\n\n.. code-block:: python\n\n    >>> myRemoteFlag.value=1\n\nFor a non local object, this will automatically queue a write order in the SAIAServer object with the new given value. The actual value of the item\nremains unchanged. When the write order has been executed, a refresh order is immediately triggered, thus allowing the actual value to be updated. \nThis tend to keep the value synchonized with the remote value, even if something goes wrong. \n\nThe background manager try to be as reactive and idle as possible, keeping ressources for your application. We tried to\ntrap most of the possible errors, allowing using this module to be used as a standalone service. Note that automatic SAIA address \nresolution is implemented, so that only remote IP address is required to register a remote node. If known, the SAIA station address *can* be\ngiven during registration\n\n.. code-block:: python\n\n    >>> server=node.registerServer(host, lid=54, port=5050)\n\n\nDumping & Debugging\n-------------------\n\nBy default, the module create and use a socket logger pointing on localhost. You can also give your own logger to the SAIANode\n\n.. code-block:: python\n\n    >>> node=SAIANode(253, logger=mylogger)\n\nLimited debug can also be done with objects .dump() methods. Try node.dump() or node.memory.dump()\nor node.memory.flags.dump(). For debugging purposes, you can simulate a remote node by registering a remote node by pointing on yourself\n\n.. code-block:: python\n\n    >>> server=node.registerServer('127.0.0.1')\n    >>> localFlag=node.memory.flags[1]\n    >>> remoteFlag=server.memory.flags[1]\n\n    >>> print localFlag.value, remoteFlag.value\n    False, False\n\n    >>> remoteFlag.value=1\n\n    # network data synchronisation is done by the background manager task\n\n    >>> print localFlag.value\n    True\n\nIn this example, localFlag and remoteFlag points to the same data, but the remoteFlag is a networked synchonized \nmirror representation of the localFlag.  The SAIA PG5 Online Debugger can be partially used with the local node.\n\n.. code-block:: python\n\n    from digimat.saia import SAIANode\n\n    node=SAIANode(253)\n\n    while node.isRunning():\n        try:\n            #\u00a0time.sleep(3.0)\n\n            #\u00a0using integrated node.sleep() will \n            # handle CTRL-C and propagate node.stop()\n            node.sleep(3.0)\n\n            node.dump()\n        except:\n            break\n\n    # node.stop()\n\n\nOpen your SAIA Debugger on this node, and try reading/writing some items. You can also use clear request with i,o,f and r items.\n\n\nDocumentation\n-------------\n\nTo be continued. Writing in progress ;) don't know if this is useful for someone.",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "http://www.digimat.ch",
    "keywords": "",
    "license": "PSF",
    "maintainer": "",
    "maintainer_email": "",
    "name": "digimat.saia",
    "platform": "",
    "project_url": "https://pypi.org/project/digimat.saia/",
    "release_url": "https://pypi.org/project/digimat.saia/0.0.27/",
    "requires_dist": [],
    "requires_python": "",
    "summary": "Digimat Saia EtherSBus (partial) client+server implementation",
    "version": "0.0.27"
  },
  "releases": {
    "0.0.26": [
      {
        "comment_text": "",
        "digests": {
          "md5": "290dc81c6a723c41402ebb1568075253",
          "sha256": "cc83e37b51e4f39acb78c016149ffc1d5ff86fcf1b4a55cf19e6863e0d3aee7e"
        },
        "downloads": 0,
        "filename": "digimat.saia-0.0.26.tar.gz",
        "has_sig": false,
        "md5_digest": "290dc81c6a723c41402ebb1568075253",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 30766,
        "upload_time": "2017-08-15T07:23:14",
        "url": "https://files.pythonhosted.org/packages/12/f0/6c70b16e611cf768303f4ce67cea6debf52ea7435ccb4db7c0512102ecb8/digimat.saia-0.0.26.tar.gz"
      }
    ],
    "0.0.27": [
      {
        "comment_text": "",
        "digests": {
          "md5": "8c4a49ba94d2dde6183e6aee38a62e94",
          "sha256": "30d9075b32186d604726e34f4107d410cdd692a170d53be76d5b098a14047ed7"
        },
        "downloads": 0,
        "filename": "digimat.saia-0.0.27.tar.gz",
        "has_sig": false,
        "md5_digest": "8c4a49ba94d2dde6183e6aee38a62e94",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 30919,
        "upload_time": "2017-08-15T12:50:37",
        "url": "https://files.pythonhosted.org/packages/01/82/e6979da38b133c80f81c13325a1913738bb68b1196dc3606c7855951d4d0/digimat.saia-0.0.27.tar.gz"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "8c4a49ba94d2dde6183e6aee38a62e94",
        "sha256": "30d9075b32186d604726e34f4107d410cdd692a170d53be76d5b098a14047ed7"
      },
      "downloads": 0,
      "filename": "digimat.saia-0.0.27.tar.gz",
      "has_sig": false,
      "md5_digest": "8c4a49ba94d2dde6183e6aee38a62e94",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 30919,
      "upload_time": "2017-08-15T12:50:37",
      "url": "https://files.pythonhosted.org/packages/01/82/e6979da38b133c80f81c13325a1913738bb68b1196dc3606c7855951d4d0/digimat.saia-0.0.27.tar.gz"
    }
  ]
}