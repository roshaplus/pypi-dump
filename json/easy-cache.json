{
  "info": {
    "author": "Oleg Churkin",
    "author_email": "bahusoff@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Environment :: Web Environment",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python",
      "Programming Language :: Python :: 2.7",
      "Programming Language :: Python :: 3.5",
      "Programming Language :: Python :: 3.6",
      "Topic :: Software Development :: Libraries :: Python Modules"
    ],
    "description": "Easy caching decorators\n=======================\n\n|Build Status|\n\nThis package is intended to simplify caching and invalidation process in\npython-based (primarily) web applications. It's possible to cache\nexecution results of functions; *instance*, *class* and *static*\nmethods; properties. Cache keys may be constructed in various different\nways and may depend on any number of parameters.\n\nThe package supports tag-based cache invalidation and better works with\nDjango, however any other frameworks can be used \u2013 see examples below.\n\nRequirements\n============\n\nLibrary was tested in the following environments:\n\n-  Python 2.7, 3.5, 3.6\n-  Django 1.8, 1.9, 1.10\n\nFeel free to try it in yours, but it's not guaranteed it will work.\nSubmit an issue if you think it should.\n\nInstallation\n============\n\n::\n\n    pip install easy_cache\n\nIntroduction\n============\n\nDifferent ways to cache something\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code:: python\n\n    # classic way\n    from django.core.cache import cache\n\n    def time_consuming_operation(n):\n        \"\"\"Calculate sum of number from 1 to provided n\"\"\"\n        cache_key = 'time_consuming_operation_{}'.format(n)\n        result = cache.get(cache_key, None)\n\n        if result is None:\n            # not found in cache\n            result = sum(range(n + 1))\n            # cache result for one hour\n            cache.set(cache_key, result, 3600)\n\n        return result\n\n    def invalidate_cache(n):\n        cache.delete('time_consuming_operation_{}'.format(n))\n\nNow let's take a look how ``easy_cache`` can help:\n\n.. code:: python\n\n    # easy way\n    from easy_cache import ecached\n\n    @ecached('time_consuming_operation_{n}', 3600)\n    def time_consuming_operation(n):\n        return sum(range(n + 1))\n\n    def invalidate_cache(n):\n        time_consuming_operation.invalidate_cache_by_key(n)\n\nHeart of the package is two decorators with the similar parameters:\n\necached\n~~~~~~~\n\nShould be used to decorate any callable and cache returned result.\n\nParameters:\n\n-  ``cache_key`` \u2013 cache key generator, default value is ``None`` so the\n   key will be composed automatically based on function name, namespace\n   and passed parameters. Also supports the following parameter types:\n-  **string** \u2013 may contain `Python advanced string formatting\n   syntax <https://docs.python.org/2/library/string.html#formatstrings>`__,\n   later this value will be formatted with dict of parameters provided\n   to decorated function, see examples below.\n-  **sequence of strings** \u2013 each string must be function parameter\n   name.\n-  **callable** \u2013 used to generate cache key, decorated function\n   parameters will be passed to this callable and returned value will be\n   used. Also one additional signature is available: ``callable(meta)``,\n   where ``meta`` is dict-like object with some additional attributes \u2013\n   see below.\n\n-  ``timeout`` \u2013 value will be cached with provided timeout, basically\n   it should be number of seconds, however it depends on cache backend\n   type. Default value is ``DEFAULT_VALUE`` \u2013 internal constant means\n   that actually no value is provided to cache backend and thus backend\n   should decide what timeout to use. Callable is also supported.\n-  ``tags`` \u2013 sequence of strings or callable. Should provide or return\n   list of tags added to cached value, so cache may be invalidated later\n   with any tag name. Tag may support advanced string formatting syntax.\n   See ``cache_key`` docs and examples for more details.\n-  ``prefix`` \u2013 this parameter works both: as regular tag and also as\n   cache key prefix, as usual advanced string formatting and callable\n   are supported here.\n-  ``cache_alias`` \u2013 cache backend alias name, it can also be `Django\n   cache backend alias\n   name <https://docs.djangoproject.com/en/1.10/ref/settings/#std:setting-CACHES>`__.\n-  ``cache_instance`` \u2013 cache backend instance may be provided directly\n   via this parameter.\n\necached\\_property\n~~~~~~~~~~~~~~~~~\n\nShould be used to create so-called cached properties, has signature\nexactly the same as for ``ecached``.\n\nSimple examples\n===============\n\nCode examples is the best way to show the power of this package.\n\nDecorators can be simply used with default parameters only\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code:: python\n\n    from easy_cache import ecached, create_cache_key\n\n    # default parameters\n    # cache key will be generated automatically:\n    #\n    # <__module__>.<__class__>.<function name> + function parameters converted to strings,\n    #\n    # so be careful when using complex objects, it's\n    # better to write custom cache key generator in such cases.\n    #\n    # timeout will be default for specified cache backend\n    # \"default\" cache backend will be used if you use Django\n    @ecached()\n    def time_consuming_operation(*args, **kwargs):\n        pass\n\n    # simple static cache key and cache timeout 100 seconds\n    @ecached('time_consuming_operation', 100)\n    def time_consuming_operation():\n        pass\n\n    # cache key with advanced string formatting syntax\n    @ecached('key:{kwargs[param1]}:{kwargs[param2]}:{args[0]}')\n    def time_consuming_operation(*args, **kwargs):\n        pass\n\n    # use specific cache alias, see \"caches framework\" below\n    from functools import partial\n\n    memcached = partial(ecached, cache_alias='memcached')\n\n    # equivalent to cache_key='{a}:{b}'\n    @memcached(['a', 'b'], timeout=600)\n    def time_consuming_operation(a, b, c='default'):\n        pass\n\nUsing custom cache key generators\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code:: python\n\n    # working with parameters provided to cached function\n    # cache key generator must have the same signature as decorated function\n    def custom_cache_key(self, a, b, c, d):\n        return create_cache_key(self.id, a, d)\n\n    # working with `meta` object\n    def custom_cache_key_meta(meta):\n        return '{}:{}:{}'.format(meta['self'].id, meta['a'], meta['d'])\n\n    # or equivalent\n    from easy_cache import meta_accepted\n\n    @meta_accepted\n    def custom_cache_key_meta(parameter_with_any_name):\n        meta = parameter_with_any_name\n        return '{}:{}:{}'.format(meta['self'].id, meta['a'], meta['d'])\n\n\n    class A(object):\n        id = 1\n\n        @ecached(custom_cache_key)\n        def time_consuming_operation(self, a, b, c=10, d=20):\n            pass\n\n        @ecached(custom_cache_key_meta)\n        def time_consuming_opeartion(self, a, b, c=10, d=20):\n            pass\n\nHow to cache ``staticmethod`` and ``classmethod`` correctly\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code:: python\n\n    # ecached decorator always comes topmost\n    class B(object):\n\n        # cache only for each different year\n        @ecached(lambda start_date: 'get_list:{}'.format(start_date.year))\n        @staticmethod\n        def get_list_by_date(start_date):\n            pass\n\n        CONST = 'abc'\n\n        @ecached('info_cache:{cls.CONST}', 3600, cache_alias='redis_cache')\n        @classmethod\n        def get_info(cls):\n            pass\n\nMetaCallable object description\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nMeta object has the following parameters:\n\n-  ``args`` \u2013 tuple with positional arguments provided to decorated\n   function\n-  ``kwargs`` \u2013 dictionary with keyword arguments provided to decorated\n   function\n-  ``returned_value`` \u2013 value returned from decorated function,\n   available only when meta object is handled in ``tags`` or ``prefix``\n   generators. You have to check ``has_returned_value`` property before\n   using this parameter:\n\n``python  def generate_cache_key(meta):      if meta.has_returned_value:          # ... do something with meta.returned_value ...``\n\n-  ``call_args`` - dictionary with all positional and keyword arguments\n   provided to decorated function, you may also access them via\n   ``__getitem__`` dict interface, e. g. ``meta['param1']``.\n-  ``function`` - decorated callable\n-  ``scope`` - object to which decorated callable is attached, ``None``\n   otherwise. Usually it's an instance or a class.\n\nTags invalidation and cached properties\n=======================================\n\nMore complex examples introducing Django models and effective tags\nusage. Check code comments and doc-strings for detailed description.\n\n.. code:: python\n\n    from django.db import models\n    from easy_cache import ecached, ecached_property, create_cache_key\n\n\n    class Book(models.Model):\n        title = models.CharField(max_length=250)\n\n        def __unicode__(self):\n            return self.title\n\n\n    class User(models.Model):\n        name = models.CharField(max_length=100)\n        state = models.CharField(\n            max_length=15,\n            choices=(('active', 'active'), ('deleted', 'deleted')),\n        )\n        friends = models.ManyToManyField('self', symmetrical=True)\n        favorite_books = models.ManyToManyField('Book')\n\n        def __unicode__(self):\n            return self.name\n\n        @ecached('users_by_state:{state}', 60, ['users_by_states'])\n        @classmethod\n        def get_users_by_state(cls, state):\n            \"\"\"\n                Caches user list by provided state parameter: there will be separate\n                cached value for every different state parameter. Note that `ecached`\n                decorator always comes topmost.\n\n                To invalidate concrete cached state call the following method\n                with required `state`, e.g.:\n                >> User.get_users_by_state.invalidate_cache_by_key('active')\n                or\n                >> User.get_users_by_state.invalidate_cache_by_key(state='active')\n\n                If you'd like to invalidate all caches for all states call:\n                >> User.get_users_by_state.invalidate_cache_by_tags('users_by_states')\n\n                `invalidate_cache_by_tags` supports both string and list parameter types.\n            \"\"\"\n            return cls.objects.filter(state=state)\n\n        @ecached_property('user_friends_count:{self.id}', timeout=3600)\n        def friends_count(self):\n            \"\"\"\n                Caches friends count of each user for 1 hour.\n\n                Call the following method, to invalidate cache:\n                >> User.friends_count.invalidate_cache_by_key(user)\n                or\n                >> type(self).friends_count.invalidate_cache_by_key(user)\n                or\n                >> self.__class__.friends_count.invalidate_cache_by_key(user)\n\n                Where `user` is desired User instance to invalidate friends count of.\n                Note that class object is used here instead of the instance.\n            \"\"\"\n            return self.friends.count()\n\n        @staticmethod\n        def get_books_tags(meta):\n            \"\"\"\n                Add one tag for every book in function response\n            \"\"\"\n            if not meta.has_returned_value:\n                return []\n\n            favorite_books = meta.returned_value\n            # yes, it may occupy a lot of cache keys\n            return [create_cache_key('book', book.pk) for book in favorite_books]\n\n        @ecached('user_favorite_books:{self.id}', 600, get_books_tags)\n        def get_favorite_books(self):\n            \"\"\"\n                Caches list of related books by user id. So in code you will use:\n\n                >> favorite_books = request.user.get_favorite_books() # cached for user\n\n                You may want to invalidate this cache in two cases:\n\n                1. User adds new book to favorites:\n                    >> User.get_favorite_books.invalidate_cache_by_key(user)\n                    or\n                    >> User.get_favorite_books.invalidate_cache_by_key(self=user)\n                    or\n                    >> from easy_cache import invalidate_cache_key, create_cache_key\n                    >> invalidate_cache_key(create_cache_key('user_favorite_books', user.id))\n                    or\n                    >> invalidate_cache_key('user_favorite_books:{}'.format(user.id))\n\n                2. Some information about favorite book was changed, e.g. its title:\n                    >> from easy_cache import invalidate_cache_tags, create_tag_cache_key\n                    >> tag_cache_key = create_tag_cache_key('book', changed_book_id)\n                    >> User.get_favorite_books.invalidate_cache_by_tags(tag_cache_key)\n                    or\n                    >> invalidate_cache_tags(tag_cache_key)\n            \"\"\"\n            return self.favorite_books.filter(user=self)\n\nPrefix usage\n============\n\nCommonly ``prefix`` is used to invalidate all cache-keys in one\nnamespace, e. g.:\n\n.. code:: python\n\n    from functools import partial\n\n    class Shop(models.Model):\n        single_shop_cache = partial(ecached, prefix='shop:{self.id}')\n\n        @single_shop_cache('goods_list')\n        def get_all_goods_list(self):\n            return [...]\n\n        @single_shop_cache('prices_list')\n        def get_all_prices_list(self):\n            return [...]\n\n\n    # if you have `shop` object you are able to use the following invalidation\n    # strategies:\n\n    # Invalidate cached list of goods for concrete shop\n    Shop.get_all_goods_list.invalidate_cache_by_key(shop)\n\n    # Invalidate cached list of prices for concrete shop\n    Shop.get_all_prices_list.invalidate_cache_by_key(shop)\n\n    # Invalidate all cached items for concrete shop\n    Shop.get_all_goods_list.invalidate_cache_by_prefix(shop)\n    # or\n    Shop.get_all_prices_list.invalidate_cache_by_prefix(shop)\n    # or\n    from easy_cache import invalidate_cache_prefix\n    invalidate_cache_prefix('shop:{self.id}'.format(self=shop))\n\nInvalidation summary\n====================\n\nThere are two ways to invalidate cache objects: use ivalidation methods\nbound to decorated function and separate functions-invalidators.\n\n.. code:: python\n\n    <decorated>.invalidate_cache_by_key(*args, **kwargs)\n    <decorated>.invalidate_cache_by_tags(tags=(), *args, **kwargs)\n    <decorated>.invalidate_cache_by_prefix(*args, **kwargs)\n\n    # <decorated> should be used with class instance if it is used in class namespace:\n    class A:\n        @ecached()\n        def method(self):\n            pass\n\n        @ecached_property()\n        def obj_property(self):\n            pass\n\n    A.method.invalidate_cache_by_key()\n    # or\n    A().method.invalidate_cache_by_key()\n    # only one variant is possible for a property\n    A.obj_property.invalidate_cache_by_key()\n\n    # and\n    from easy_cache import (\n        invalidate_cache_key,\n        invalidate_cache_tags,\n        invalidate_cache_prefix,\n        create_cache_key,\n    )\n\n    # Note that `cache_instance` and `cache_alias` may be passed\n    # to the following invalidators\n    invalidate_cache_key(cache_key)\n    invalidate_cache_tags(tags)\n    invalidate_cache_prefix(prefix)\n\nHere ``tags`` can be as string (single tag) or list of tags. Bound\nmethods should be provided with parameters if they are used in cache\nkey/tag/prefix:\n\n.. code:: python\n\n\n    @ecached('key:{a}:value:{c}', tags=['tag:{a}'], prefix='pre:{b}', cache_alias='memcached')\n    def time_consuming_operation(a, b, c=100):\n        pass\n\n    time_consuming_operation.invalidate_cache_by_key(a=1, c=11)\n    time_consuming_operation.invalidate_cache_by_tags(a=10)\n    time_consuming_operation.invalidate_cache_by_prefix(b=2)\n\n    # or using `create_cache_key` helper\n    invalidate_cache_key(\n        create_cache_key('key', 1, 'value', 11), cache_alias='memcached'\n    )\n    invalidate_cache_tags(create_cache_key('tag', 10), cache_alias='memcached')\n    invalidate_cache_prefix('pre:{}'.format(2), cache_alias='memcached')\n\nInternal caches framework\n=========================\n\nEasy-cache uses build-in Django cache framework by default, so you can\nchoose what cache storage to use on every decorated function, e.g.:\n\n.. code:: python\n\n    # Django settings\n    CACHES={\n        'local_memory': {\n            'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',\n            'LOCATION': 'locmem',\n            'KEY_PREFIX': 'custom_prefix',\n        },\n        'memcached': {\n            'BACKEND': 'django.core.cache.backends.memcached.MemcachedCache',\n            'LOCATION': '127.0.0.1:11211',\n            'KEY_PREFIX': 'memcached',\n        }\n    }\n\n    # then in somewhere code\n    @ecached(..., cache_alias='memcached')\n    # or\n    @ecached(..., cache_alias='local_memory')\n    # or even\n    from django.core.cache import caches\n    another_cache = caches['another_cache']\n    @ecached(..., cache_instance=another_cache)\n\nHowever if you don't use Django, there is cache framework build into\neasy-cache package, it may be used in the same fashion as Django caches:\n\n.. code:: python\n\n    # Custom cache instance class must implement AbstractCacheInstance interface:\n    from easy_cache.abc import AbstractCacheInstance\n    from easy_cache.core import DEFAULT_TIMEOUT, NOT_FOUND\n\n    class CustomCache(AbstractCacheInstance):\n\n        def get(self, key, default=NOT_FOUND):\n            ...\n\n        def get_many(self, keys):\n            ...\n\n        def set(self, key, value, timeout=DEFAULT_TIMEOUT):\n            ...\n\n        def set_many(self, data_dict, timeout=DEFAULT_TIMEOUT):\n            ...\n\n        def delete(self, key):\n            ...\n\n    from easy_cache import caches\n\n    custom_cache = CustomCache()\n    caches['new_cache'] = custom_cache\n    caches.set_default(CustomCacheDefault())\n\n    # and then\n    @ecached(..., cache_alias='new_cache')\n    # or\n    @ecached(..., cache_instance=custom_cache)\n    # will use `default` alias\n    @ecached(...)\n\nThere is already implemented redis cache instance class, based on\n`redis-py client <https://pypi.python.org/pypi/redis>`__:\n\n.. code:: python\n\n    from redis import StrictRedis\n    from easy_cache.contrib.redis_cache import RedisCacheInstance\n    from easy_cache import caches\n\n    redis_cache = RedisCacheInstance(StrictRedis(host='...', port='...'))\n    caches.set_default(redis_cache)\n\n    # will use `default` alias\n    @ecached(...)\n\nDynamic timeout example\n=======================\n\nYou may need to provide cache timeout dynamically depending on function\nparameters:\n\n.. code:: python\n\n    def dynamic_timeout(group):\n        if group == 'admins':\n            timeout = 10\n        else:\n            timeout = 100\n        return timeout\n\n    @ecached('key:{group}', timeout=dynamic_timeout)\n    def get_users_by_group(group):\n        ...\n\nDevelopment and contribution\n============================\n\nLive instances of Redis and Memcached are required for few tests to\npass, so it's recommended to use docker to setup necessary environment:\n\n.. code:: shell\n\n    > docker-machine ip default\n    [IP] <- your DOCKER_HOST ip address\n\n    > docker container create --name=easy_cache-redis -p 6379:6379 redis:latest\n    > docker container start easy_cache-redis\n\n    export EASY_CACHE_REDIS_HOST=[IP]:6379\n\n    > docker container create --name=easy_cache-memcached -p 11211:11211 memcached:latest\n    > docker container start easy_cache-memcached\n\n    export EASY_CACHE_MEMCACHED_HOST=[IP]:11211\n\n    # to enable debug logs\n    # export EASY_CACHE_DEBUG=\"yes\"\n\n    # install package localy\n    pip install -e .[tests]\n\n    # run tests with pytest or tox\n    pytest\n    tox\n\nPerformance and overhead\n========================\n\nBenchmarking may be executed with ``tox`` command and it shows that\ndecorators give about 4% of overhead in worst case and about 1-2%\noverhead on the average.\n\nIf you don't use tags or prefix you will get one cache request for\n``get`` and one request for ``set`` if result not found in cache,\notherwise two consecutive requests will be made: ``get`` and\n``get_many`` to receive actual value from cache and validate its tags\n(prefix). Then one ``set_many`` request will be performed to save a data\nto cache storage.\n\n.. |Build Status| image:: https://travis-ci.org/Bahus/easy_cache.svg?branch=master\n   :target: https://travis-ci.org/Bahus/easy_cache\n",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "https://github.com/Bahus/easy_cache",
    "keywords": "cache",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "easy-cache",
    "platform": "Platform Independent",
    "project_url": "https://pypi.org/project/easy-cache/",
    "release_url": "https://pypi.org/project/easy-cache/0.5.0/",
    "requires_python": "",
    "summary": "Useful cache decorators for methods and properties",
    "version": "0.5.0"
  },
  "releases": {
    "0.0.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "44e3eb5d25248ceb78e2dcd94beeaea0",
          "sha256": "3ef1c1e110c6debc45f1f64eb32e177d9a8883b4d35a797c68dfd3fceb74ac69"
        },
        "downloads": 621,
        "filename": "easy-cache-0.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "44e3eb5d25248ceb78e2dcd94beeaea0",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 16711,
        "upload_time": "2015-08-26T22:15:51",
        "url": "https://files.pythonhosted.org/packages/c0/d3/7a6d31933703b72685dc6bf9903b96ff64011030edb0c0375003db073f4c/easy-cache-0.0.1.tar.gz"
      }
    ],
    "0.1.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "0796d5bcaf291075874fca512a14b812",
          "sha256": "c7b354f62b7e6125b79c5308f43adab1b0be526e3b557621cd0833a4c799ef24"
        },
        "downloads": 1169,
        "filename": "easy-cache-0.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "0796d5bcaf291075874fca512a14b812",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 16743,
        "upload_time": "2015-08-27T07:19:33",
        "url": "https://files.pythonhosted.org/packages/0d/c0/31ae14731ce53a3d0db807722fe814474717f34af570e47dbe90a362b8d2/easy-cache-0.1.0.tar.gz"
      }
    ],
    "0.2.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "4dd666d8c07b75d2244bb5206aca99b1",
          "sha256": "d30b9f18bf3700b4cbf9bbb9fe42896e5a1b6a39a97a69864555c67fc107ebaf"
        },
        "downloads": 7938,
        "filename": "easy-cache-0.2.0.tar.gz",
        "has_sig": false,
        "md5_digest": "4dd666d8c07b75d2244bb5206aca99b1",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 18888,
        "upload_time": "2015-09-07T21:59:13",
        "url": "https://files.pythonhosted.org/packages/74/2d/9bc0438311b0b691cc8350b6aa93a03552f27c08c1415faaddf92fb5bd04/easy-cache-0.2.0.tar.gz"
      }
    ],
    "0.2.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "3d3280b9605d1780b69ad73183cdb382",
          "sha256": "fe6246ce6b90f2dcd7d9fb20bbb36c124204cd310d6a959615436e01a996f50a"
        },
        "downloads": 39310,
        "filename": "easy-cache-0.2.1.tar.gz",
        "has_sig": false,
        "md5_digest": "3d3280b9605d1780b69ad73183cdb382",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 20167,
        "upload_time": "2015-09-20T21:51:55",
        "url": "https://files.pythonhosted.org/packages/4d/3b/c9d049ec309e47ba42f329d2441108f568d5b10ddc74565dea5ac6c0520f/easy-cache-0.2.1.tar.gz"
      }
    ],
    "0.3.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "7e57d4651f846c0f1fa71f0fe671f53a",
          "sha256": "9ac0e9cc93c59fa9c94abc316b445b280aeaa8871902b993cbc07c1ee3dbae3e"
        },
        "downloads": 419,
        "filename": "easy-cache-0.3.0.tar.gz",
        "has_sig": false,
        "md5_digest": "7e57d4651f846c0f1fa71f0fe671f53a",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 20955,
        "upload_time": "2016-01-18T21:04:12",
        "url": "https://files.pythonhosted.org/packages/01/98/658f75e7178e70809fba0bd87b1be7af11384d35d24eca75b97a6f3e4070/easy-cache-0.3.0.tar.gz"
      }
    ],
    "0.5.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "324fdc2b992ed690958eb2f812e0fbf4",
          "sha256": "83878958a9ea9691cd89de0174a750ea150ebdffe4da42eb63c19eb558904481"
        },
        "downloads": 0,
        "filename": "easy-cache-0.5.0.tar.gz",
        "has_sig": false,
        "md5_digest": "324fdc2b992ed690958eb2f812e0fbf4",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 32620,
        "upload_time": "2017-05-02T19:43:11",
        "url": "https://files.pythonhosted.org/packages/8a/fd/bb9335eb2377141b78eac0200a49f0bbadaebbfdd069a0d2a5512f10f264/easy-cache-0.5.0.tar.gz"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "324fdc2b992ed690958eb2f812e0fbf4",
        "sha256": "83878958a9ea9691cd89de0174a750ea150ebdffe4da42eb63c19eb558904481"
      },
      "downloads": 0,
      "filename": "easy-cache-0.5.0.tar.gz",
      "has_sig": false,
      "md5_digest": "324fdc2b992ed690958eb2f812e0fbf4",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 32620,
      "upload_time": "2017-05-02T19:43:11",
      "url": "https://files.pythonhosted.org/packages/8a/fd/bb9335eb2377141b78eac0200a49f0bbadaebbfdd069a0d2a5512f10f264/easy-cache-0.5.0.tar.gz"
    }
  ]
}