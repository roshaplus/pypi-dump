{
  "info": {
    "author": "Zope Foundation and Contributors",
    "author_email": "zope-dev@zope.org",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Environment :: Web Environment",
      "Framework :: Zope3",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: Zope Public License",
      "Natural Language :: English",
      "Operating System :: OS Independent",
      "Programming Language :: Python",
      "Programming Language :: Python :: 2",
      "Programming Language :: Python :: 2.6",
      "Programming Language :: Python :: 2.7",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.3",
      "Programming Language :: Python :: 3.4",
      "Programming Language :: Python :: Implementation :: CPython",
      "Programming Language :: Python :: Implementation :: PyPy",
      "Topic :: Internet :: WWW/HTTP"
    ],
    "description": "``zope.contentprovider`` README\n===============================\n\nThis package provides a framework to develop componentized Web GUI\napplications. Instead of describing the content of a page using a single\ntemplate or static system of templates and METAL macros, content provider\nobjects are dynamically looked up based on the setup/configuration of the\napplication.\n\n\nContent Providers\n=================\n\n.. contents::\n\nMotivation and Design Goals\n---------------------------\n\nBefore diving into the features of this package let me take up a few bytes of\ntext to explain the use cases that drove us to develop this package (also\nothers) and how the API documented below fulfills/solves those use cases. When\nwe started developing Zope 3, it was from a desire to decentralize\nfunctionality and thus the complexity of the Python code. And we were\nsuccessful! The component architecture is a marvelous piece of software that\nhopefully will allow us to build scalable solutions for a very long\ntime. However, when it comes to user interface design, in this case\nspecifically HTML pages, we have failed to provide the features and patterns\nof assembeling a page from configured components.\n\nLooking up views for a particular content component and a request just simply\ndoes not work by itself. The content inside the page is still monolithic. One\nattempt to solve this problem are METAL macros, which allow you to insert\nother TAL snippets into your main template. But macros have two shortcomings.\nFor one there is a \"hard-coded\" one-to-one mapping between a slot and the\nmacro that fills that slot, which makes it impossible to register several\nmacros for a given location. The second problem is that macros are not views\nin their own right; thus they cannot provide functionality that is independent\nof the main template's view.\n\nA second approach to modular UI design are rendering pipes. Rendering pipes\nhave the great advantage that they can reach all regions of the page during\nevery step of the rendering process. For example, if we have a widget in the\nmiddle of the page that requires some additional Javascript, then it is easy\nfor a rendering unit to insert the Javascript file link in the HTML header of\nthe page. This type of use case is very hard to solve using page\ntemplates. However, pipes are not the answer to componentized user interface,\nsince they cannot simply deal with registering random content for a given page\nregion. In fact, I propose that pipelines are orthogonal to content providers,\nthe concept introducted below. A pipeline framework could easily use\nfunctionality provided by this and other packages to provide component-driven\nUI design.\n\nSo our goal is clear: Bring the pluggability of the component architecture\ninto page templates and user interface design. Zope is commonly known to\nreinvent the wheel, develop its own terminology and misuse other's terms. For\nexample, the Plone community has a very different understanding of what a\n\"portlet\" is compared to the commonly accepted meaning in the corporate world,\nwhich derives its definition from JSR 168. Therefore an additional use case of\nthe design of this package was to stick with common terms and use them in\ntheir original meaning -- well, given a little extra twist.\n\nThe most basic user interface component in the Web application Java world is\nthe \"content provider\" [1]_. A content provider is simply responsible for\nproviding HTML content for a page. This is equivalent to a view that does not\nprovide a full page, but just a snippet, much like widgets or macros. Once\nthere is a way to configure those content providers, we need a way to\ninsert them into our page templates. In our implementation this is\naccomplished using a new TALES namespace that allows to insert content\nproviders by name. But how, you might wonder, does this provide a\ncomponentized user interface? On the Zope 3 level, each content provider is\nregistered as a presentation component discriminated by the context, request\nand view it will appear in. Thus different content providers will be picked\nfor different configurations.\n\nOkay, that's pretty much everything there is to say about content\nproviders. What, we are done? Hold on, what about defining regions of pages\nand filling them configured UI snippets. The short answer is: See the\n``zope.viewlet`` pacakge. But let me also give you the long answer. This and\nthe other pacakges were developed using real world use cases. While doing\nthis, we noticed that not every project would need, for example, all the\nfeatures of a portlet, but would still profit from lower-level features. Thus\nwe decided to declare clear boundaries of functionality and providing each\nlevel in a different package. This particualr package is only meant to provide\nthe interface between the content provider world and page templates.\n\n.. [1] Note that this is a bit different from the role named content provider,\n       which refers to a service that provides content; the content provider\n       we are talking about here are the software components the service would\n       provide to an application.\n\n\nContent Providers\n-----------------\n\nContent Provider is a term from the Java world that refers to components that\ncan provide HTML content. It means nothing more! How the content is found and\nreturned is totally up to the implementation. The Zope 3 touch to the concept\nis that content providers are multi-adapters that are looked up by the\ncontext, request (and thus the layer/skin), and view they are displayed in.\n\nThe second important concept of content providers are their two-phase\nrendering design. In the first phase the state of the content provider is\nprepared and, if applicable, any data the provider is responsible for is\nupdated.\n\n  >>> from zope.contentprovider import interfaces\n\nSo let's create a simple content provider:\n\n  >>> import zope.interface\n  >>> import zope.component\n  >>> from zope.publisher.interfaces import browser\n\n  >>> @zope.interface.implementer(interfaces.IContentProvider)\n  ... @zope.component.adapter(zope.interface.Interface,\n  ...                         browser.IDefaultBrowserLayer,\n  ...                         zope.interface.Interface)\n  ... class MessageBox(object):\n  ...     message = u'My Message'\n  ...\n  ...     def __init__(self, context, request, view):\n  ...         self.__parent__ = view\n  ...\n  ...     def update(self):\n  ...         pass\n  ...\n  ...     def render(self):\n  ...         return u'<div class=\"box\">%s</div>' %self.message\n  ...\n  ...     def __repr__(self):\n  ...         return '<MessageBox object at %x>' % id(self)\n\nThe ``update()`` method is executed during phase one. Since no state needs to\nbe calculated and no data is modified by this simple content provider, it is\nan empty implementation. The ``render()`` method implements phase 2 of the\nprocess. We can now instantiate the content provider (manually) and render it:\n\n  >>> box = MessageBox(None, None, None)\n  >>> box.render()\n  u'<div class=\"box\">My Message</div>'\n\nSince our content provider did not require the context, request or view to\ncreate its HTML content, we were able to pass trivial dummy values into the\nconstructor. Also note that the provider must have a parent (using the\n``__parent__`` attribute) specified at all times. The parent must be the view\nthe provider appears in.\n\nI agree, this functionally does not seem very useful now. The constructor and\nthe ``update()`` method seem useless and the returned content is totally\nstatic. However, we implemented a contract for content providers that other\ncode can rely on. Content providers are (commonly) instantiated using the\ncontext, request and view they appear in and are required to always generate\nits HTML using those three components.\n\n\nTwo-Phased Content Providers\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nLet's now have a look at a content provider that actively uses the two-phase\nrendering process. The simpler scenario is the case where the content provider\nupdates a content component without affecting anything else. So let's create a\ncontent component to be updated,\n\n  >>> class Article(object):\n  ...     title = u'initial'\n  >>> article = Article()\n\nand the content provider that is updating the title:\n\n  >>> @zope.interface.implementer(interfaces.IContentProvider)\n  ... @zope.component.adapter(zope.interface.Interface,\n  ...                         browser.IDefaultBrowserLayer,\n  ...                         zope.interface.Interface)\n  ... class ChangeTitle(object):\n  ...     fieldName = 'ChangeTitle.title'\n  ...\n  ...     def __init__(self, context, request, view):\n  ...         self.__parent__ = view\n  ...         self.context, self.request = context, request\n  ...\n  ...     def update(self):\n  ...         if self.fieldName in self.request:\n  ...             self.context.title = self.request[self.fieldName]\n  ...\n  ...     def render(self):\n  ...         return u'<input name=\"%s\" value=\"%s\" />' % (self.fieldName,\n  ...                                                     self.context.title)\n\nUsing a request, let's now instantiate the content provider and go through the\ntwo-phase rendering process:\n\n  >>> from zope.publisher.browser import TestRequest\n  >>> request = TestRequest()\n  >>> changer = ChangeTitle(article, request, None)\n  >>> changer.update()\n  >>> changer.render()\n  u'<input name=\"ChangeTitle.title\" value=\"initial\" />'\n\nLet's now enter a new title and render the provider:\n\n  >>> request = TestRequest(form={'ChangeTitle.title': u'new title'})\n  >>> changer = ChangeTitle(article, request, None)\n  >>> changer.update()\n  >>> changer.render()\n  u'<input name=\"ChangeTitle.title\" value=\"new title\" />'\n  >>> article.title\n  u'new title'\n\nSo this was easy. Let's now look at a case where one content provider's update\ninfluences the content of another. Let's say we have a content provider that\ndisplays the article's title:\n\n  >>> @zope.interface.implementer(interfaces.IContentProvider)\n  ... @zope.component.adapter(zope.interface.Interface,\n  ...                         browser.IDefaultBrowserLayer,\n  ...                         zope.interface.Interface)\n  ... class ViewTitle(object):\n  ...\n  ...     def __init__(self, context, request, view):\n  ...         self.context, self.__parent__ = context, view\n  ...\n  ...     def update(self):\n  ...         pass\n  ...\n  ...     def render(self):\n  ...         return u'<h1>Title: %s</h1>' % self.context.title\n\nLet's now say that the `ShowTitle` content provider is shown on a page\n*before* the `ChangeTitle` content provider. If we do the full rendering\nprocess for each provider in sequence, we get the wrong result:\n\n  >>> request = TestRequest(form={'ChangeTitle.title': u'newer title'})\n\n  >>> viewer = ViewTitle(article, request, None)\n  >>> viewer.update()\n  >>> viewer.render()\n  u'<h1>Title: new title</h1>'\n\n  >>> changer = ChangeTitle(article, request, None)\n  >>> changer.update()\n  >>> changer.render()\n  u'<input name=\"ChangeTitle.title\" value=\"newer title\" />'\n\nSo the correct way of doing this is to first complete phase 1 (update) for all\nproviders, before executing phase 2 (render):\n\n  >>> request = TestRequest(form={'ChangeTitle.title': u'newest title'})\n\n  >>> viewer = ViewTitle(article, request, None)\n  >>> changer = ChangeTitle(article, request, None)\n\n  >>> viewer.update()\n  >>> changer.update()\n\n  >>> viewer.render()\n  u'<h1>Title: newest title</h1>'\n\n  >>> changer.render()\n  u'<input name=\"ChangeTitle.title\" value=\"newest title\" />'\n\n\n``UpdateNotCalled`` Errors\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nSince calling ``update()`` before any other method that mutates the provider\nor any other data is so important to the correct functioning of the API, the\ndeveloper has the choice to raise the ``UpdateNotCalled`` error, if any method\nis called before ``update()`` (with exception of the constructor):\n\n  >>> @zope.interface.implementer(interfaces.IContentProvider)\n  ... @zope.component.adapter(zope.interface.Interface,\n  ...                         browser.IDefaultBrowserLayer,\n  ...                         zope.interface.Interface)\n  ... class InfoBox(object):\n  ...\n  ...     def __init__(self, context, request, view):\n  ...         self.__parent__ = view\n  ...         self.__updated = False\n  ...\n  ...     def update(self):\n  ...         self.__updated = True\n  ...\n  ...     def render(self):\n  ...         if not self.__updated:\n  ...             raise interfaces.UpdateNotCalled\n  ...         return u'<div>Some information</div>'\n\n  >>> info = InfoBox(None, None, None)\n\n  >>> info.render()\n  Traceback (most recent call last):\n  ...\n  UpdateNotCalled: ``update()`` was not called yet.\n\n  >>> info.update()\n\n  >>> info.render()\n  u'<div>Some information</div>'\n\n\nThe TALES ``provider`` Expression\n---------------------------------\n\nThe ``provider`` expression will look up the name of the content provider,\ncall it and return the HTML content. The first step, however, will be to\nregister our content provider with the component architecture:\n\n  >>> zope.component.provideAdapter(MessageBox, name='mypage.MessageBox')\n\nThe content provider must be registered by name, since the TALES expression\nuses the name to look up the provider at run time.\n\nLet's now create a view using a page template:\n\n  >>> import os, tempfile\n  >>> temp_dir = tempfile.mkdtemp()\n  >>> templateFileName = os.path.join(temp_dir, 'template.pt')\n  >>> with open(templateFileName, 'w') as file:\n  ...     _ = file.write('''\n  ... <html>\n  ...   <body>\n  ...     <h1>My Web Page</h1>\n  ...     <div class=\"left-column\">\n  ...       <tal:block replace=\"structure provider:mypage.MessageBox\" />\n  ...     </div>\n  ...     <div class=\"main\">\n  ...       Content here\n  ...     </div>\n  ...   </body>\n  ... </html>\n  ... ''')\n\nAs you can see, we exprect the ``provider`` expression to simply look up the\ncontent provider and insert the HTML content at this place.\n\nNext we register the template as a view (browser page) for all objects:\n\n  >>> from zope.browserpage.simpleviewclass import SimpleViewClass\n  >>> FrontPage = SimpleViewClass(templateFileName, name='main.html')\n\n  >>> zope.component.provideAdapter(\n  ...     FrontPage,\n  ...     (zope.interface.Interface, browser.IDefaultBrowserLayer),\n  ...     zope.interface.Interface,\n  ...     name='main.html')\n\nLet's create a content object that can be viewed:\n\n  >>> @zope.interface.implementer(zope.interface.Interface)\n  ... class Content(object):\n  ...     pass\n\n  >>> content = Content()\n\nFinally we look up the view and render it. Note that a\nBeforeUpdateEvent is fired - this event should always be fired before\nany contentprovider is updated.\n\n  >>> from zope.publisher.browser import TestRequest\n  >>> events = []\n  >>> zope.component.provideHandler(events.append, (None, ))\n  >>> request = TestRequest()\n\n  >>> view = zope.component.getMultiAdapter((content, request),\n  ...                                       name='main.html')\n  >>> print(view().strip())\n  <html>\n    <body>\n      <h1>My Web Page</h1>\n      <div class=\"left-column\">\n        <div class=\"box\">My Message</div>\n      </div>\n      <div class=\"main\">\n        Content here\n      </div>\n    </body>\n  </html>\n\n  >>> events\n  [<zope.contentprovider.interfaces.BeforeUpdateEvent object at ...>]\n\nThe event holds the provider and the request.\n\n  >>> events[0].request\n  <zope.publisher.browser.TestRequest instance URL=http://127.0.0.1>\n  >>> events[0].object\n  <MessageBox object at ...>\n\nFailure to lookup a Content Provider\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf the name is not found, an error is raised. To demonstrate this behavior\nlet's create another template:\n\n  >>> errorFileName = os.path.join(temp_dir, 'error.pt')\n  >>> with open(errorFileName, 'w') as file:\n  ...     _ = file.write('''\n  ... <html>\n  ...   <body>\n  ...     <tal:block replace=\"structure provider:mypage.UnknownName\" />\n  ...   </body>\n  ... </html>\n  ... ''')\n\n  >>> ErrorPage = SimpleViewClass(errorFileName, name='error.html')\n  >>> zope.component.provideAdapter(\n  ...     ErrorPage,\n  ...     (zope.interface.Interface, browser.IDefaultBrowserLayer),\n  ...     zope.interface.Interface,\n  ...     name='main.html')\n\n  >>> errorview = zope.component.getMultiAdapter((content, request),\n  ...                                            name='main.html')\n  >>> print(errorview())\n  Traceback (most recent call last):\n  ...\n  ContentProviderLookupError: mypage.UnknownName\n\n\nAdditional Data from TAL\n~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe ``provider`` expression allows also for transferring data from the TAL\ncontext into the content provider. This is accomplished by having the content\nprovider implement an interface that specifies the attributes and provides\n``ITALNamespaceData``:\n\n  >>> import zope.schema\n  >>> class IMessageText(zope.interface.Interface):\n  ...     message = zope.schema.Text(title=u'Text of the message box')\n\n  >>> zope.interface.directlyProvides(IMessageText,\n  ...                                 interfaces.ITALNamespaceData)\n\nNow the message box can receive its text from the TAL environment:\n\n  >>> @zope.interface.implementer(IMessageText)\n  ... class DynamicMessageBox(MessageBox):\n  ...     pass\n\n  >>> zope.component.provideAdapter(\n  ...     DynamicMessageBox, provides=interfaces.IContentProvider,\n  ...     name='mypage.DynamicMessageBox')\n\nWe are now updating our original template to provide the message text:\n\n  >>> with open(templateFileName, 'w') as file:\n  ...     _ = file.write('''\n  ... <html>\n  ...   <body>\n  ...     <h1>My Web Page</h1>\n  ...     <div class=\"left-column\">\n  ...       <tal:block define=\"message string:Hello World!\"\n  ...                  replace=\"structure provider:mypage.DynamicMessageBox\" />\n  ...       <tal:block define=\"message string:Hello World again!\"\n  ...                  replace=\"structure provider:mypage.DynamicMessageBox\" />\n  ...     </div>\n  ...     <div class=\"main\">\n  ...       Content here\n  ...     </div>\n  ...   </body>\n  ... </html>\n  ... ''')\n\nNow we should get two message boxes with different text:\n\n  >>> print(view().strip())\n  <html>\n    <body>\n      <h1>My Web Page</h1>\n      <div class=\"left-column\">\n        <div class=\"box\">Hello World!</div>\n        <div class=\"box\">Hello World again!</div>\n      </div>\n      <div class=\"main\">\n        Content here\n      </div>\n    </body>\n  </html>\n\nFinally, a content provider can also implement several ``ITALNamespaceData``:\n\n  >>> class IMessageType(zope.interface.Interface):\n  ...     type = zope.schema.TextLine(title=u'The type of the message box')\n\n  >>> zope.interface.directlyProvides(IMessageType,\n  ...                                 interfaces.ITALNamespaceData)\n\nWe'll change our message box content provider implementation a bit, so the new\ninformation is used:\n\n  >>> @zope.interface.implementer(IMessageType)\n  ... class BetterDynamicMessageBox(DynamicMessageBox):\n  ...     type = None\n  ...\n  ...     def render(self):\n  ...         return u'<div class=\"box,%s\">%s</div>' %(self.type, self.message)\n\n  >>> zope.component.provideAdapter(\n  ...     BetterDynamicMessageBox, provides=interfaces.IContentProvider,\n  ...     name='mypage.MessageBox')\n\nOf course, we also have to make our tempalte a little bit more dynamic as\nwell:\n\n  >>> with open(templateFileName, 'w') as file:\n  ...     _ = file.write('''\n  ... <html>\n  ...   <body>\n  ...     <h1>My Web Page</h1>\n  ...     <div class=\"left-column\">\n  ...       <tal:block define=\"message string:Hello World!;\n  ...                          type string:error\"\n  ...                  replace=\"structure provider:mypage.MessageBox\" />\n  ...       <tal:block define=\"message string:Hello World again!;\n  ...                          type string:warning\"\n  ...                  replace=\"structure provider:mypage.MessageBox\" />\n  ...     </div>\n  ...     <div class=\"main\">\n  ...       Content here\n  ...     </div>\n  ...   </body>\n  ... </html>\n  ... ''')\n\nNow we should get two message boxes with different text and types:\n\n  >>> print(view().strip())\n  <html>\n    <body>\n      <h1>My Web Page</h1>\n      <div class=\"left-column\">\n        <div class=\"box,error\">Hello World!</div>\n        <div class=\"box,warning\">Hello World again!</div>\n      </div>\n      <div class=\"main\">\n        Content here\n      </div>\n    </body>\n  </html>\n\n\nBase class\n----------\n\nThe ``zope.contentprovider.provider`` module provides an useful base\nclass for implementing content providers. It has all boilerplate code\nand it's only required to override the ``render`` method to make it\nwork:\n\n  >>> from zope.contentprovider.provider import ContentProviderBase\n  >>> class MyProvider(ContentProviderBase):\n  ...     def render(self, *args, **kwargs):\n  ...         return 'Hi there'\n\n  >>> provider = MyProvider(None, None, None)\n  >>> interfaces.IContentProvider.providedBy(provider)\n  True\n\n  >>> provider.update()\n  >>> print(provider.render())\n  Hi there\n\nNote, that it can't be used as is, without providing the ``render`` method:\n\n  >>> bad = ContentProviderBase(None, None, None)\n  >>> bad.update()\n  >>> print(bad.render())\n  Traceback (most recent call last):\n  ...\n  NotImplementedError: ``render`` method must be implemented by subclass\n\nYou can add the update logic into the ``update`` method as with any content\nprovider and you can implement more complex rendering patterns, based on\ntemplates, using this ContentProviderBase class as a base.\n\n\nYou might also want to look at the ``zope.viewlet`` package for a more\nfeatureful API.\n\nLet's remove all temporary data we created during this README.\n\n  >>> import shutil\n  >>> shutil.rmtree(temp_dir)\n\n\n=======\nCHANGES\n=======\n\n\n4.0.0 (2014-12-24)\n------------------\n\n- Add support for PyPy and PyPy3.\n\n- Add support for Python 3.4.\n\n- Add support for testing on Travis.\n\n\n4.0.0a1 (2013-02-22)\n--------------------\n\n- Add Python 3.3 support.\n\n- Replace deprecated ``zope.component.adapts`` usage with equivalent\n  ``zope.component.adapter`` decorator.\n\n- Replace deprecated ``zope.interface.implements`` usage with equivalent\n  ``zope.interface.implementer`` decorator.\n\n- Drop support for Python 2.4 and 2.5.\n\n\n3.7.2 (2010-05-25)\n------------------\n\n- Fix unit tests broken under Python 2.4 by the switch to the standard\n  library ``doctest`` module.\n\n\n3.7.1 (2010-04-30)\n------------------\n\n- Prefer the standard library's ``doctest`` module to the one from\n  ``zope.testing.``\n\n\n3.7 (2010-04-27)\n----------------\n\n- Since ``tales:expressiontype`` is now in ``zope.browserpage``, update\n  conditional ZCML accordingly so it doesn't depend on the presence of\n  ``zope.app.pagetemplate`` anymore.\n\n\n3.6.1 (2009-12-23)\n------------------\n\n- Ensure that our ``configure.zcml`` can be loaded without requiring further\n  dependencies. It uses a ``tales:expressiontype`` directive defined in\n  ``zope.app.pagetemplate.`` We keep that dependency optional, as not all\n  consumers of this package use ZCML to configure the expression type.\n\n\n3.6.0 (2009-12-22)\n------------------\n\n- Update test dependency to use ``zope.browserpage``.\n\n\n3.5.0 (2009-03-18)\n------------------\n\n- Add very simple, but useful base class for implementing content\n  providers, see ``zope.contentprovider.provider.ContentProviderBase``.\n\n- Remove unneeded testing dependencies. We only need ``zope.testing`` and\n  ``zope.app.pagetemplate``.\n\n- Remove zcml slug and old zpkg-related files.\n\n- Add setuptools dependency to setup.py.\n\n- Clean up package's description and documentation a bit. Remove\n  duplicate text in README.\n\n- Change mailing list address to zope-dev at zope.org instead of\n  retired one.\n\n- Change ``cheeseshop`` to ``pypi`` in the package url.\n\n\n3.4.0 (2007-10-02)\n------------------\n\n- Initial release independent of the main Zope tree.",
    "docs_url": null,
    "download_url": "UNKNOWN",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "http://pypi.python.org/pypi/zope.contentprovider",
    "keywords": "zope3 content provider",
    "license": "ZPL 2.1",
    "maintainer": null,
    "maintainer_email": null,
    "name": "zope.contentprovider",
    "platform": "UNKNOWN",
    "project_url": "https://pypi.org/project/zope.contentprovider/",
    "release_url": "https://pypi.org/project/zope.contentprovider/4.0.0/",
    "requires_python": null,
    "summary": "Content Provider Framework for Zope Templates",
    "version": "4.0.0"
  },
  "releases": {
    "3.4.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "aeede0d985cc521994979cf8c150e37b",
          "sha256": "13a38bf759e1bf6744a29d0b59f6a8a131456add2d3a7b0c8f570fed61431a64"
        },
        "downloads": 24902,
        "filename": "zope.contentprovider-3.4.0.tar.gz",
        "has_sig": false,
        "md5_digest": "aeede0d985cc521994979cf8c150e37b",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 22960,
        "upload_time": "2007-10-02T05:28:28",
        "url": "https://files.pythonhosted.org/packages/ce/a4/f804f2785a83834b9b078ffa97346732f03918a2949d1b7ae9734326fe1a/zope.contentprovider-3.4.0.tar.gz"
      }
    ],
    "3.5.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "6afc263e8132840dcc577cde4299e7e7",
          "sha256": "090ffd27dbe47726e2a0f89111b5f484df424ab91397d644798072d88d3d710e"
        },
        "downloads": 39248,
        "filename": "zope.contentprovider-3.5.0.tar.gz",
        "has_sig": false,
        "md5_digest": "6afc263e8132840dcc577cde4299e7e7",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 20145,
        "upload_time": "2009-03-17T22:08:50",
        "url": "https://files.pythonhosted.org/packages/1f/5d/b92ca0e4170d40d56269048b0088d2ea968a553bf5f846c9b8492de692ad/zope.contentprovider-3.5.0.tar.gz"
      }
    ],
    "3.6.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "64dc8b70b46363d51e8d60f2e3eae9a6",
          "sha256": "4c679de039eb04cdf32245c6d3f8a104e66fa6717c4f29753d1cee84c0ad807e"
        },
        "downloads": 2541,
        "filename": "zope.contentprovider-3.6.0.zip",
        "has_sig": false,
        "md5_digest": "64dc8b70b46363d51e8d60f2e3eae9a6",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 33022,
        "upload_time": "2009-12-22T23:10:46",
        "url": "https://files.pythonhosted.org/packages/1c/fc/41edfe1f1a14f6f3118c1ca7bc8fc422f103a4a880a9499e26a85c8a6368/zope.contentprovider-3.6.0.zip"
      }
    ],
    "3.6.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "d64115175fb9a56437c94c541b8be553",
          "sha256": "d8c13b979ca60561831599e5d6999b8270f97cf4590604b0fb3f142578fbb387"
        },
        "downloads": 9967,
        "filename": "zope.contentprovider-3.6.1.zip",
        "has_sig": false,
        "md5_digest": "d64115175fb9a56437c94c541b8be553",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 33439,
        "upload_time": "2009-12-23T14:11:39",
        "url": "https://files.pythonhosted.org/packages/91/20/a15cfb64f7632a29da870c07a8e1d73f526c00f1b85241885ab62181e7a4/zope.contentprovider-3.6.1.zip"
      }
    ],
    "3.7": [
      {
        "comment_text": "",
        "digests": {
          "md5": "fe9491259c468c6e55c0bf6efd644e1b",
          "sha256": "74a28a546c3c920a1068fc3d151928d9877a32806adc61149474d69ea79485c9"
        },
        "downloads": 2606,
        "filename": "zope.contentprovider-3.7.tar.gz",
        "has_sig": false,
        "md5_digest": "fe9491259c468c6e55c0bf6efd644e1b",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 24811,
        "upload_time": "2010-04-27T18:48:05",
        "url": "https://files.pythonhosted.org/packages/7d/6d/63aaca0c8c889c8d536bcdbe1ea3522ad34b710089ba0cf0ee7115e3e7eb/zope.contentprovider-3.7.tar.gz"
      }
    ],
    "3.7.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "79c324a674cae1445112bc746b38dfda",
          "sha256": "74c0f070073ac2cd178df3479502d52fcb04971bf20c79b559ded0e9e076d58c"
        },
        "downloads": 2976,
        "filename": "zope.contentprovider-3.7.1.zip",
        "has_sig": false,
        "md5_digest": "79c324a674cae1445112bc746b38dfda",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 34471,
        "upload_time": "2010-04-30T22:48:55",
        "url": "https://files.pythonhosted.org/packages/2b/14/a2002aa94ecd01b55f81674b00d3f3f13991838e645ecfcc2d1deae95159/zope.contentprovider-3.7.1.zip"
      }
    ],
    "3.7.2": [
      {
        "comment_text": "",
        "digests": {
          "md5": "1bb2132551175c0123f17939a793f812",
          "sha256": "672fbb3922974b1c23bad605e020c10ff5ca31c44abf45ac9cd08cbbecab3432"
        },
        "downloads": 137677,
        "filename": "zope.contentprovider-3.7.2.tar.gz",
        "has_sig": false,
        "md5_digest": "1bb2132551175c0123f17939a793f812",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 26596,
        "upload_time": "2010-05-25T16:10:13",
        "url": "https://files.pythonhosted.org/packages/ec/e1/0e7f0cdf92b5824617732371a1a6a0969f1a53fcfebdc6ae29f48cd2176d/zope.contentprovider-3.7.2.tar.gz"
      }
    ],
    "4.0.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "2c5ba23a74b4f2fd5bd2ee5fcb67ad9f",
          "sha256": "70b6ea795f84ac31d5056885c32d734a27379046d3507b7bab610c9165a2e886"
        },
        "downloads": 8221,
        "filename": "zope.contentprovider-4.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "2c5ba23a74b4f2fd5bd2ee5fcb67ad9f",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 29503,
        "upload_time": "2014-12-24T17:19:50",
        "url": "https://files.pythonhosted.org/packages/e7/13/506c03568f6f3572f3dcd61cbf7835257e067e4eb0bab61daf1b9c49c814/zope.contentprovider-4.0.0.tar.gz"
      }
    ],
    "4.0.0a1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "09b478f9a3957bd2d63a264a543f2595",
          "sha256": "4160adacd9f601802f238282794103b3ba199fb6e9436e638d75f41d10d48a43"
        },
        "downloads": 12524,
        "filename": "zope.contentprovider-4.0.0a1.zip",
        "has_sig": false,
        "md5_digest": "09b478f9a3957bd2d63a264a543f2595",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 37899,
        "upload_time": "2013-02-22T22:45:19",
        "url": "https://files.pythonhosted.org/packages/e1/37/ca6ade5c841b8c7d8a2249d3dffa0addf8ec21a4fe156ad4addc6cc30e9e/zope.contentprovider-4.0.0a1.zip"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "2c5ba23a74b4f2fd5bd2ee5fcb67ad9f",
        "sha256": "70b6ea795f84ac31d5056885c32d734a27379046d3507b7bab610c9165a2e886"
      },
      "downloads": 8221,
      "filename": "zope.contentprovider-4.0.0.tar.gz",
      "has_sig": false,
      "md5_digest": "2c5ba23a74b4f2fd5bd2ee5fcb67ad9f",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 29503,
      "upload_time": "2014-12-24T17:19:50",
      "url": "https://files.pythonhosted.org/packages/e7/13/506c03568f6f3572f3dcd61cbf7835257e067e4eb0bab61daf1b9c49c814/zope.contentprovider-4.0.0.tar.gz"
    }
  ]
}