{
  "info": {
    "author": "Zope Foundation and Contributors",
    "author_email": "zope-dev@zope.org",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Environment :: Web Environment",
      "Framework :: Zope3",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: Zope Public License",
      "Natural Language :: English",
      "Operating System :: OS Independent",
      "Programming Language :: Python",
      "Programming Language :: Python :: 2",
      "Programming Language :: Python :: 2.7",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.4",
      "Programming Language :: Python :: 3.5",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: Implementation :: CPython",
      "Programming Language :: Python :: Implementation :: PyPy",
      "Topic :: Internet :: WWW/HTTP"
    ],
    "description": "``zope.mimetype``\n=================\n\n.. image:: https://img.shields.io/pypi/v/zope.mimetype.svg\n        :target: https://pypi.python.org/pypi/zope.mimetype/\n        :alt: Latest release\n\n.. image:: https://img.shields.io/pypi/pyversions/zope.mimetype.svg\n        :target: https://pypi.org/project/zope.mimetype/\n        :alt: Supported Python versions\n\n.. image:: https://travis-ci.org/zopefoundation/zope.mimetype.svg?branch=master\n        :target: https://travis-ci.org/zopefoundation/zope.mimetype\n\n.. image:: https://coveralls.io/repos/github/zopefoundation/zope.mimetype/badge.svg?branch=master\n        :target: https://coveralls.io/github/zopefoundation/zope.mimetype?branch=master\n\nThis package provides a way to work with MIME content types.  There\nare several interfaces defined here, many of which are used primarily\nto look things up based on different bits of information.\n\n\nThe Zope MIME Infrastructure\n============================\n\nThis package provides a way to work with MIME content types.  There\nare several interfaces defined here, many of which are used primarily\nto look things up based on different bits of information.\n\nThe basic idea behind this is that content objects should provide an\ninterface based on the actual content type they implement.  For\nexample, objects that represent text/xml or application/xml documents\nshould be marked mark with the `IContentTypeXml` interface.  This can\nallow additional views to be registered based on the content type, or\nsubscribers may be registered to perform other actions based on the\ncontent type.\n\nOne aspect of the content type that's important for all documents is\nthat the content type interface determines whether the object data is\ninterpreted as an encoded text document.  Encoded text documents, in\nparticular, can be decoded to obtain a single Unicode string.  The\ncontent type intefaces for encoded text must derive from\n`IContentTypeEncoded`.  (All content type interfaces derive from\n`IContentType` and directly provide `IContentTypeInterface`.)\n\nThe default configuration provides direct support for a variety of\ncommon document types found in office environments.\n\nSupported lookups\n-----------------\n\nSeveral different queries are supported by this package:\n\n- Given a MIME type expressed as a string, the associated interface,\n  if any, can be retrieved using::\n\n    # `mimeType` is the MIME type as a string\n    interface = queryUtility(IContentTypeInterface, mimeType)\n\n- Given a charset name, the associated `ICodec` instance can be\n  retrieved using::\n\n    # `charsetName` is the charset name as a string\n    codec = queryUtility(ICharsetCodec, charsetName)\n\n- Given a codec, the preferred charset name can be retrieved using::\n\n    # `codec` is an `ICodec` instance:\n    charsetName = getUtility(ICodecPreferredCharset, codec.name).name\n\n- Given any combination of a suggested file name, file data, and\n  content type header, a guess at a reasonable MIME type can be made\n  using::\n\n    # `filename` is a suggested file name, or None\n    # `data` is uploaded data, or None\n    # `content_type` is a Content-Type header value, or None\n    #\n    mimeType = getUtility(IMimeTypeGetter)(\n        name=filename, data=data, content_type=content_type)\n\n- Given any combination of a suggested file name, file data, and\n  content type header, a guess at a reasonable charset name can be\n  made using::\n\n    # `filename` is a suggested file name, or None\n    # `data` is uploaded data, or None\n    # `content_type` is a Content-Type header value, or None\n    #\n    charsetName = getUtility(ICharsetGetter)(\n        name=filename, data=data, content_type=content_type)\n\n\nRetrieving Content Type Information\n===================================\n\nMIME Types\n----------\n\nWe'll start by initializing the interfaces and registrations for the\ncontent type interfaces.  This is normally done via ZCML.\n\n    >>> from zope.mimetype import mtypes\n    >>> mtypes.setup()\n\nA utility is used to retrieve MIME types.\n\n    >>> from zope import component\n    >>> from zope.mimetype import typegetter\n    >>> from zope.mimetype.interfaces import IMimeTypeGetter\n    >>> component.provideUtility(typegetter.smartMimeTypeGuesser,\n    ...                          provides=IMimeTypeGetter)\n    >>> mime_getter = component.getUtility(IMimeTypeGetter)\n\nTo map a particular file name, file contents, and content type to a MIME type.\n\n    >>> mime_getter(name='file.txt', data='A text file.',\n    ...             content_type='text/plain')\n    'text/plain'\n\nIn the default implementation if not enough information is given to discern a\nMIME type, None is returned.\n\n    >>> mime_getter() is None\n    True\n\nCharacter Sets\n--------------\n\nA utility is also used to retrieve character sets (charsets).\n\n    >>> from zope.mimetype.interfaces import ICharsetGetter\n    >>> component.provideUtility(typegetter.charsetGetter,\n    ...                          provides=ICharsetGetter)\n    >>> charset_getter = component.getUtility(ICharsetGetter)\n\nTo map a particular file name, file contents, and content type to a charset.\n\n    >>> charset_getter(name='file.txt', data='This is a text file.',\n    ...                content_type='text/plain;charset=ascii')\n    'ascii'\n\nIn the default implementation if not enough information is given to discern a\ncharset, None is returned.\n\n    >>> charset_getter() is None\n    True\n\nFinding Interfaces\n------------------\n\nGiven a MIME type we need to be able to find the appropriate interface.\n\n    >>> from zope.mimetype.interfaces import IContentTypeInterface\n    >>> component.getUtility(IContentTypeInterface, name=u'text/plain')\n    <InterfaceClass zope.mimetype.mtypes.IContentTypeTextPlain>\n\nIt is also possible to enumerate all content type interfaces.\n\n    >>> utilities = list(component.getUtilitiesFor(IContentTypeInterface))\n\nIf you want to find an interface from a MIME string, you can use the\nutilityies.\n\n    >>> component.getUtility(IContentTypeInterface, name='text/plain')\n    <InterfaceClass zope.mimetype.mtypes.IContentTypeTextPlain>\n\n\nCodec handling\n==============\n\nWe can create codecs programatically. Codecs are registered as\nutilities for ICodec with the name of their python codec.\n\n   >>> from zope import component\n   >>> from zope.mimetype.interfaces import ICodec\n   >>> from zope.mimetype.codec import addCodec\n   >>> sorted(component.getUtilitiesFor(ICodec))\n   []\n   >>> addCodec('iso8859-1', 'Western (ISO-8859-1)')\n   >>> codec = component.getUtility(ICodec, name='iso8859-1')\n   >>> codec\n   <zope.mimetype.codec.Codec ...>\n   >>> codec.name\n   'iso8859-1'\n   >>> addCodec('utf-8', 'Unicode (UTF-8)')\n   >>> codec2 = component.getUtility(ICodec, name='utf-8')\n\nWe can programmatically add charsets to a given codec. This registers\neach charset as a named utility for ICharset. It also registers the codec\nas a utility for ICharsetCodec with the name of the charset.\n\n   >>> from zope.mimetype.codec import addCharset\n   >>> from zope.mimetype.interfaces import ICharset, ICharsetCodec\n   >>> sorted(component.getUtilitiesFor(ICharset))\n   []\n   >>> sorted(component.getUtilitiesFor(ICharsetCodec))\n   []\n   >>> addCharset(codec.name, 'latin1')\n   >>> charset = component.getUtility(ICharset, name='latin1')\n   >>> charset\n   <zope.mimetype.codec.Charset ...>\n   >>> charset.name\n   'latin1'\n   >>> component.getUtility(ICharsetCodec, name='latin1') is codec\n   True\n\nWhen adding a charset we can state that we want that charset to be the\npreferred charset for its codec.\n\n   >>> addCharset(codec.name, 'iso8859-1', preferred=True)\n   >>> addCharset(codec2.name, 'utf-8', preferred=True)\n\nA codec can have at most one preferred charset.\n\n   >>> addCharset(codec.name, 'test', preferred=True)\n   Traceback (most recent call last):\n   ...\n   ValueError: Codec already has a preferred charset.\n\nPreferred charsets are registered as utilities for\nICodecPreferredCharset under the name of the python codec.\n\n   >>> from zope.mimetype.interfaces import ICodecPreferredCharset\n   >>> preferred = component.getUtility(ICodecPreferredCharset, name='iso8859-1')\n   >>> preferred\n   <zope.mimetype.codec.Charset ...>\n   >>> preferred.name\n   'iso8859-1'\n   >>> sorted(component.getUtilitiesFor(ICodecPreferredCharset))\n   [(u'iso8859-1', <zope.mimetype.codec.Charset ...>),\n    (u'utf-8', <zope.mimetype.codec.Charset ...>)]\n\nWe can look up a codec by the name of its charset:\n\n   >>> component.getUtility(ICharsetCodec, name='latin1') is codec\n   True\n   >>> component.getUtility(ICharsetCodec, name='utf-8') is codec2\n   True\n\nOr we can look up all codecs:\n\n   >>> sorted(component.getUtilitiesFor(ICharsetCodec))\n   [(u'iso8859-1', <zope.mimetype.codec.Codec ...>),\n    (u'latin1', <zope.mimetype.codec.Codec ...>),\n    (u'test', <zope.mimetype.codec.Codec ...>),\n    (u'utf-8', <zope.mimetype.codec.Codec ...>)]\n\n\n\nConstraint Functions for Interfaces\n===================================\n\nThe `zope.mimetype.interfaces` module defines interfaces that use some\nhelper functions to define constraints on the accepted data.  These\nhelpers are used to determine whether values conform to the what's\nallowed for parts of a MIME type specification and other parts of a\nContent-Type header as specified in RFC 2045.\n\nSingle Token\n------------\n\nThe first is the simplest:  the `tokenConstraint()` function returns\n`True` if the ASCII string it is passed conforms to the `token`\nproduction in section 5.1 of the RFC.  Let's import the function::\n\n  >>> from zope.mimetype.interfaces import tokenConstraint\n\nTypical token are the major and minor parts of the MIME type and the\nparameter names for the Content-Type header.  The function should\nreturn `True` for these values::\n\n  >>> tokenConstraint(\"text\")\n  True\n  >>> tokenConstraint(\"plain\")\n  True\n  >>> tokenConstraint(\"charset\")\n  True\n\nThe function should also return `True` for unusual but otherwise\nnormal token that may be used in some situations::\n\n  >>> tokenConstraint(\"not-your-fathers-token\")\n  True\n\nIt must also allow extension tokens and vendor-specific tokens::\n\n  >>> tokenConstraint(\"x-magic\")\n  True\n\n  >>> tokenConstraint(\"vnd.zope.special-data\")\n  True\n\nSince we expect input handlers to normalize values to lower case,\nupper case text is not allowed::\n\n  >>> tokenConstraint(\"Text\")\n  False\n\nNon-ASCII text is also not allowed::\n\n  >>> tokenConstraint(\"\\x80\")\n  False\n  >>> tokenConstraint(\"\\xC8\")\n  False\n  >>> tokenConstraint(\"\\xFF\")\n  False\n\nNote that lots of characters are allowed in tokens, and there are no\nconstraints that the token \"look like\" something a person would want\nto read::\n\n  >>> tokenConstraint(\".-.-.-.\")\n  True\n\nOther characters are disallowed, however, including all forms of\nwhitespace::\n\n  >>> tokenConstraint(\"foo bar\")\n  False\n  >>> tokenConstraint(\"foo\\tbar\")\n  False\n  >>> tokenConstraint(\"foo\\nbar\")\n  False\n  >>> tokenConstraint(\"foo\\rbar\")\n  False\n  >>> tokenConstraint(\"foo\\x7Fbar\")\n  False\n\nWhitespace before or after the token is not accepted either::\n\n  >>> tokenConstraint(\" text\")\n  False\n  >>> tokenConstraint(\"plain \")\n  False\n\nOther disallowed characters are defined in the `tspecials` production\nfrom the RFC (also in section 5.1)::\n\n  >>> tokenConstraint(\"(\")\n  False\n  >>> tokenConstraint(\")\")\n  False\n  >>> tokenConstraint(\"<\")\n  False\n  >>> tokenConstraint(\">\")\n  False\n  >>> tokenConstraint(\"@\")\n  False\n  >>> tokenConstraint(\",\")\n  False\n  >>> tokenConstraint(\";\")\n  False\n  >>> tokenConstraint(\":\")\n  False\n  >>> tokenConstraint(\"\\\\\")\n  False\n  >>> tokenConstraint('\"')\n  False\n  >>> tokenConstraint(\"/\")\n  False\n  >>> tokenConstraint(\"[\")\n  False\n  >>> tokenConstraint(\"]\")\n  False\n  >>> tokenConstraint(\"?\")\n  False\n  >>> tokenConstraint(\"=\")\n  False\n\nA token must contain at least one character, so `tokenConstraint()`\nreturns false for an empty string::\n\n  >>> tokenConstraint(\"\")\n  False\n\n\nMIME Type\n---------\n\nA MIME type is specified using two tokens separated by a slash;\nwhitespace between the tokens and the slash must be normalized away in\nthe input handler.\n\nThe `mimeTypeConstraint()` function is available to test a normalized\nMIME type value; let's import that function now::\n\n  >>> from zope.mimetype.interfaces import mimeTypeConstraint\n\nLet's test some common MIME types to make sure the function isn't\nobviously insane::\n\n  >>> mimeTypeConstraint(\"text/plain\")\n  True\n  >>> mimeTypeConstraint(\"application/xml\")\n  True\n  >>> mimeTypeConstraint(\"image/svg+xml\")\n  True\n\nIf parts of the MIME type are missing, it isn't accepted::\n\n  >>> mimeTypeConstraint(\"text\")\n  False\n  >>> mimeTypeConstraint(\"text/\")\n  False\n  >>> mimeTypeConstraint(\"/plain\")\n  False\n\nAs for individual tokens, whitespace is not allowed::\n\n  >>> mimeTypeConstraint(\"foo bar/plain\")\n  False\n  >>> mimeTypeConstraint(\"text/foo bar\")\n  False\n\nWhitespace is not accepted around the slash either::\n\n  >>> mimeTypeConstraint(\"text /plain\")\n  False\n  >>> mimeTypeConstraint(\"text/ plain\")\n  False\n\nSurrounding whitespace is also not accepted::\n\n  >>> mimeTypeConstraint(\" text/plain\")\n  False\n  >>> mimeTypeConstraint(\"text/plain \")\n  False\n\n\nMinimal IContentInfo Implementation\n===================================\n\nThe `zope.mimetype.contentinfo` module provides a minimal\n`IContentInfo` implementation that adds no information to what's\nprovided by a content object.  This represents the most conservative\ncontent-type policy that might be useful.\n\nLet's take a look at how this operates by creating a couple of\nconcrete content-type interfaces::\n\n  >>> from zope.mimetype import interfaces\n\n  >>> class ITextPlain(interfaces.IContentTypeEncoded):\n  ...     \"\"\"text/plain\"\"\"\n\n  >>> class IApplicationOctetStream(interfaces.IContentType):\n  ...     \"\"\"application/octet-stream\"\"\"\n\nNow, we'll create a minimal content object that provide the necessary\ninformation::\n\n  >>> import zope.interface\n\n  >>> @zope.interface.implementer(interfaces.IContentTypeAware)\n  ... class Content(object):\n  ...     def __init__(self, mimeType, charset=None):\n  ...         self.mimeType = mimeType\n  ...         self.parameters = {}\n  ...         if charset:\n  ...             self.parameters[\"charset\"] = charset\n\nWe can now create examples of both encoded and non-encoded content::\n\n  >>> encoded = Content(\"text/plain\", \"utf-8\")\n  >>> zope.interface.alsoProvides(encoded, ITextPlain)\n\n  >>> unencoded = Content(\"application/octet-stream\")\n  >>> zope.interface.alsoProvides(unencoded, IApplicationOctetStream)\n\nThe minimal IContentInfo implementation only exposes the information\navailable to it from the base content object.  Let's take a look at\nthe unencoded content first::\n\n  >>> from zope.mimetype import contentinfo\n  >>> ci = contentinfo.ContentInfo(unencoded)\n  >>> ci.effectiveMimeType\n  'application/octet-stream'\n  >>> ci.effectiveParameters\n  {}\n  >>> ci.contentType\n  'application/octet-stream'\n\nFor unencoded content, there is never a codec::\n\n  >>> print(ci.getCodec())\n  None\n\nIt is also disallowed to try decoding such content::\n\n  >>> ci.decode(\"foo\")\n  Traceback (most recent call last):\n  ...\n  ValueError: no matching codec found\n\nAttemping to decode data using an uncoded object causes an exception\nto be raised::\n\n  >>> print(ci.decode(\"data\"))\n  Traceback (most recent call last):\n  ...\n  ValueError: no matching codec found\n\nIf we try this with encoded data, we get somewhat different behavior::\n\n  >>> ci = contentinfo.ContentInfo(encoded)\n  >>> ci.effectiveMimeType\n  'text/plain'\n  >>> ci.effectiveParameters\n  {'charset': 'utf-8'}\n  >>> ci.contentType\n  'text/plain;charset=utf-8'\n\nThe `getCodec()` and `decode()` methods can be used to handle encoded\ndata using the encoding indicated by the ``charset`` parameter.  Let's\nstore some UTF-8 data in a variable::\n\n  >>> utf8_data = b\"\\xAB\\xBB\".decode(\"iso-8859-1\").encode(\"utf-8\")\n  >>> utf8_data\n  '\\xc2\\xab\\xc2\\xbb'\n\nWe want to be able to decode the data using the `IContentInfo`\nobject.  Let's try getting the corresponding `ICodec` object using\n`getCodec()`::\n\n  >>> codec = ci.getCodec()\n  Traceback (most recent call last):\n  ...\n  ValueError: unsupported charset: 'utf-8'\n\nSo, we can't proceed without some further preparation.  What we need\nis to register an `ICharset` for UTF-8.  The `ICharset` will need a\nreference (by name) to a `ICodec` for UTF-8.  So let's create those\nobjects and register them::\n\n  >>> import codecs\n  >>> from zope.mimetype.i18n import _\n\n  >>> @zope.interface.implementer(interfaces.ICodec)\n  ... class Utf8Codec(object):\n  ...\n  ...     name = \"utf-8\"\n  ...     title = _(\"UTF-8\")\n  ...\n  ...     def __init__(self):\n  ...         ( self.encode,\n  ...           self.decode,\n  ...           self.reader,\n  ...           self.writer\n  ...           ) = codecs.lookup(self.name)\n\n  >>> utf8_codec = Utf8Codec()\n\n  >>> @zope.interface.implementer(interfaces.ICharset)\n  ... class Utf8Charset(object):\n  ...\n  ...     name = utf8_codec.name\n  ...     encoding = name\n\n  >>> utf8_charset = Utf8Charset()\n\n  >>> import zope.component\n\n  >>> zope.component.provideUtility(\n  ...     utf8_codec, interfaces.ICodec, utf8_codec.name)\n  >>> zope.component.provideUtility(\n  ...     utf8_charset, interfaces.ICharset, utf8_charset.name)\n\nNow that that's been initialized, let's try getting the codec again::\n\n  >>> codec = ci.getCodec()\n  >>> codec.name\n  'utf-8'\n\n  >>> codec.decode(utf8_data)\n  (u'\\xab\\xbb', 4)\n\nWe can now check that the `decode()` method of the `IContentInfo` will\ndecode the entire data, returning the Unicode representation of the\ntext::\n\n  >>> ci.decode(utf8_data)\n  u'\\xab\\xbb'\n\nAnother possibilty, of course, is that you have content that you know\nis encoded text of some sort, but you don't actually know what\nencoding it's in::\n\n  >>> encoded2 = Content(\"text/plain\")\n  >>> zope.interface.alsoProvides(encoded2, ITextPlain)\n\n  >>> ci = contentinfo.ContentInfo(encoded2)\n  >>> ci.effectiveMimeType\n  'text/plain'\n  >>> ci.effectiveParameters\n  {}\n  >>> ci.contentType\n  'text/plain'\n\n  >>> ci.getCodec()\n  Traceback (most recent call last):\n  ...\n  ValueError: charset not known\n\nIt's also possible that the initial content type information for an\nobject is incorrect for some reason.  If the browser provides a\ncontent type of \"text/plain; charset=utf-8\", the content will be seen\nas encoded.  A user correcting this content type using UI elements\ncan cause the content to be considered un-encoded.  At this point,\nthere should no longer be a charset parameter to the content type, and\nthe content info object should reflect this, though the previous\nencoding information will be retained in case the content type should\nbe changed to an encoded type in the future.\n\nLet's see how this behavior will be exhibited in this API.  We'll\nstart by creating some encoded content::\n\n  >>> content = Content(\"text/plain\", \"utf-8\")\n  >>> zope.interface.alsoProvides(content, ITextPlain)\n\nWe can see that the encoding information is included in the effective\nMIME type information provided by the content-info object::\n\n  >>> ci = contentinfo.ContentInfo(content)\n  >>> ci.effectiveMimeType\n  'text/plain'\n  >>> ci.effectiveParameters\n  {'charset': 'utf-8'}\n\nWe now change the content type information for the object::\n\n  >>> ifaces = zope.interface.directlyProvidedBy(content)\n  >>> ifaces -= ITextPlain\n  >>> ifaces += IApplicationOctetStream\n  >>> zope.interface.directlyProvides(content, *ifaces)\n  >>> content.mimeType = 'application/octet-stream'\n\nAt this point, a content type object would provide different\ninformation::\n\n  >>> ci = contentinfo.ContentInfo(content)\n  >>> ci.effectiveMimeType\n  'application/octet-stream'\n  >>> ci.effectiveParameters\n  {}\n\nThe underlying content type parameters still contain the original\nencoding information, however::\n\n  >>> content.parameters\n  {'charset': 'utf-8'}\n\n\nEvents and content-type changes\n===============================\n\nThe `IContentTypeChangedEvent` is fired whenever an object's\n`IContentTypeInterface` is changed.  This includes the cases when a\ncontent type interface is applied to an object that doesn't have one,\nand when the content type interface is removed from an object.\n\nLet's start the demonstration by defining a subscriber for the event\nthat simply prints out the information from the event object::\n\n  >>> def handler(event):\n  ...     print(\"changed content type interface:\")\n  ...     print(\"  from:\", event.oldContentType)\n  ...     print(\"    to:\", event.newContentType)\n\nWe'll also define a simple content object::\n\n  >>> import zope.interface\n\n  >>> class IContent(zope.interface.Interface):\n  ...     pass\n\n  >>> @zope.interface.implementer(IContent)\n  ... class Content(object):\n  ...     def __str__(self):\n  ...         return \"<MyContent>\"\n\n  >>> obj = Content()\n\nWe'll also need a couple of content type interfaces::\n\n  >>> from zope.mimetype import interfaces\n\n  >>> class ITextPlain(interfaces.IContentTypeEncoded):\n  ...     \"\"\"text/plain\"\"\"\n  >>> ITextPlain.setTaggedValue(\"mimeTypes\", [\"text/plain\"])\n  >>> ITextPlain.setTaggedValue(\"extensions\", [\".txt\"])\n  >>> zope.interface.directlyProvides(\n  ...     ITextPlain, interfaces.IContentTypeInterface)\n\n  >>> class IOctetStream(interfaces.IContentType):\n  ...     \"\"\"application/octet-stream\"\"\"\n  >>> IOctetStream.setTaggedValue(\"mimeTypes\", [\"application/octet-stream\"])\n  >>> IOctetStream.setTaggedValue(\"extensions\", [\".bin\"])\n  >>> zope.interface.directlyProvides(\n  ...     IOctetStream, interfaces.IContentTypeInterface)\n\nLet's register our subscriber::\n\n  >>> import zope.component\n  >>> import zope.component.interfaces\n  >>> zope.component.provideHandler(\n  ...     handler,\n  ...     (zope.component.interfaces.IObjectEvent,))\n\nChanging the content type interface on an object is handled by the\n`zope.mimetype.event.changeContentType()` function.  Let's import that\nmodule and demonstrate that the expected event is fired\nappropriately::\n\n  >>> from zope.mimetype import event\n\nSince the object currently has no content type interface, \"removing\"\nthe interface does not affect the object and the event is not fired::\n\n  >>> event.changeContentType(obj, None)\n\nSetting a content type interface on an object that doesn't have one\nwill cause the event to be fired, with the `.oldContentType` attribute\non the event set to `None`::\n\n  >>> event.changeContentType(obj, ITextPlain)\n  changed content type interface:\n    from: None\n      to: <InterfaceClass __builtin__.ITextPlain>\n\nCalling the `changeContentType()` function again with the same \"new\"\ncontent type interface causes no change, so the event is not fired\nagain::\n\n  >>> event.changeContentType(obj, ITextPlain)\n\nProviding a new interface does cause the event to be fired again::\n\n  >>> event.changeContentType(obj, IOctetStream)\n  changed content type interface:\n    from: <InterfaceClass __builtin__.ITextPlain>\n      to: <InterfaceClass __builtin__.IOctetStream>\n\nSimilarly, removing the content type interface triggers the event as\nwell::\n\n  >>> event.changeContentType(obj, None)\n  changed content type interface:\n    from: <InterfaceClass __builtin__.IOctetStream>\n      to: None\n\n\nMIME type and character set extraction\n======================================\n\nThe `zope.mimetype.typegetter` module provides a selection of MIME\ntype extractors and charset extractors.  These may be used to\ndetermine what the MIME type and character set for uploaded data\nshould be.\n\nThese two interfaces represent the site policy regarding interpreting\nupload data in the face of missing or inaccurate input.\n\nLet's go ahead and import the module::\n\n  >>> from zope.mimetype import typegetter\n\nMIME types\n----------\n\nThere are a number of interesting MIME-type extractors:\n\n`mimeTypeGetter()`\n  A minimal extractor that never attempts to guess.\n\n`mimeTypeGuesser()`\n  An extractor that tries to guess the content type based on the name\n  and data if the input contains no content type information.\n\n`smartMimeTypeGuesser()`\n  An extractor that checks the content for a variety of constructs to\n  try and refine the results of the `mimeTypeGuesser()`.  This is able\n  to do things like check for XHTML that's labelled as HTML in upload\n  data.\n\n\n`mimeTypeGetter()`\n~~~~~~~~~~~~~~~~~~\n\nWe'll start with the simplest, which does no content-based guessing at\nall, but uses the information provided by the browser directly.  If\nthe browser did not provide any content-type information, or if it\ncannot be parsed, the extractor simply asserts a \"safe\" MIME type of\napplication/octet-stream.  (The rationale for selecting this type is\nthat since there's really nothing productive that can be done with it\nother than download it, it's impossible to mis-interpret the data.)\n\nWhen there's no information at all about the content, the extractor\nreturns None::\n\n  >>> print(typegetter.mimeTypeGetter())\n  None\n\nProviding only the upload filename or data, or both, still produces\nNone, since no guessing is being done::\n\n  >>> print(typegetter.mimeTypeGetter(name=\"file.html\"))\n  None\n\n  >>> print(typegetter.mimeTypeGetter(data=b\"<html>...</html>\"))\n  None\n\n  >>> print(typegetter.mimeTypeGetter(\n  ...     name=\"file.html\", data=b\"<html>...</html>\"))\n  None\n\nIf a content type header is available for the input, that is used\nsince that represents explicit input from outside the application\nserver.  The major and minor parts of the content type are extracted\nand returned as a single string::\n\n  >>> typegetter.mimeTypeGetter(content_type=\"text/plain\")\n  'text/plain'\n\n  >>> typegetter.mimeTypeGetter(content_type=\"text/plain; charset=utf-8\")\n  'text/plain'\n\nIf the content-type information is provided but malformed (not in\nconformance with RFC 2822), it is ignored, since the intent cannot be\nreliably guessed::\n\n  >>> print(typegetter.mimeTypeGetter(content_type=\"foo bar\"))\n  None\n\nThis combines with ignoring the other values that may be provided as\nexpected::\n\n  >>> print(typegetter.mimeTypeGetter(\n  ...     name=\"file.html\", data=b\"<html>...</html>\", content_type=\"foo bar\"))\n  None\n\n\n`mimeTypeGuesser()`\n~~~~~~~~~~~~~~~~~~~\n\nA more elaborate extractor that tries to work around completely\nmissing information can be found as the `mimeTypeGuesser()` function.\nThis function will only guess if there is no usable content type\ninformation in the input.  This extractor can be thought of as having\nthe following pseudo-code::\n\n  def mimeTypeGuesser(name=None, data=None, content_type=None):\n      type = mimeTypeGetter(name=name, data=data, content_type=content_type)\n      if type is None:\n          type = guess the content type\n      return type\n\nLet's see how this affects the results we saw earlier.  When there's\nno input to use, we still get None::\n\n  >>> print(typegetter.mimeTypeGuesser())\n  None\n\nProviding only the upload filename or data, or both, now produces a\nnon-None guess for common content types::\n\n  >>> typegetter.mimeTypeGuesser(name=\"file.html\")\n  'text/html'\n\n  >>> typegetter.mimeTypeGuesser(data=b\"<html>...</html>\")\n  'text/html'\n\n  >>> typegetter.mimeTypeGuesser(name=\"file.html\", data=b\"<html>...</html>\")\n  'text/html'\n\nNote that if the filename and data provided separately produce\ndifferent MIME types, the result of providing both will be one of\nthose types, but which is unspecified::\n\n  >>> mt_1 = typegetter.mimeTypeGuesser(name=\"file.html\")\n  >>> mt_1\n  'text/html'\n\n  >>> mt_2 = typegetter.mimeTypeGuesser(data=b\"<?xml version='1.0'?>...\")\n  >>> mt_2\n  'text/xml'\n\n  >>> mt = typegetter.mimeTypeGuesser(\n  ...     data=b\"<?xml version='1.0'?>...\", name=\"file.html\")\n  >>> mt in (mt_1, mt_2)\n  True\n\nIf a content type header is available for the input, that is used in\nthe same way as for the `mimeTypeGetter()` function::\n\n  >>> typegetter.mimeTypeGuesser(content_type=\"text/plain\")\n  'text/plain'\n\n  >>> typegetter.mimeTypeGuesser(content_type=\"text/plain; charset=utf-8\")\n  'text/plain'\n\nIf the content-type information is provided but malformed, it is\nignored::\n\n  >>> print(typegetter.mimeTypeGetter(content_type=\"foo bar\"))\n  None\n\nWhen combined with values for the filename or content data, those are\nstill used to provide reasonable guesses for the content type::\n\n  >>> typegetter.mimeTypeGuesser(name=\"file.html\", content_type=\"foo bar\")\n  'text/html'\n\n  >>> typegetter.mimeTypeGuesser(\n  ...     data=b\"<html>...</html>\", content_type=\"foo bar\")\n  'text/html'\n\nInformation from a parsable content-type is still used even if a guess\nfrom the data or filename would provide a different or more-refined\nresult::\n\n  >>> typegetter.mimeTypeGuesser(\n  ...     data=b\"GIF89a...\", content_type=\"application/octet-stream\")\n  'application/octet-stream'\n\n\n`smartMimeTypeGuesser()`\n~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe `smartMimeTypeGuesser()` function applies more knowledge to the\nprocess of determining the MIME-type to use.  Essentially, it takes\nthe result of the `mimeTypeGuesser()` function and attempts to refine\nthe content-type based on various heuristics.\n\nWe still see the basic behavior that no input produces None::\n\n  >>> print(typegetter.smartMimeTypeGuesser())\n  None\n\nAn unparsable content-type is still ignored::\n\n  >>> print(typegetter.smartMimeTypeGuesser(content_type=\"foo bar\"))\n  None\n\nThe interpretation of uploaded data will be different in at least some\ninteresting cases.  For instance, the `mimeTypeGuesser()` function\nprovides these results for some XHTML input data::\n\n  >>> typegetter.mimeTypeGuesser(\n  ...     data=b\"<?xml version='1.0' encoding='utf-8'?><html>...</html>\",\n  ...     name=\"file.html\")\n  'text/html'\n\nThe smart extractor is able to refine this into more usable data::\n\n  >>> typegetter.smartMimeTypeGuesser(\n  ...     data=b\"<?xml version='1.0' encoding='utf-8'?>...\",\n  ...     name=\"file.html\")\n  'application/xhtml+xml'\n\nIn this case, the smart extractor has refined the information\ndetermined from the filename using information from the uploaded\ndata.  The specific approach taken by the extractor is not part of the\ninterface, however.\n\n\n`charsetGetter()`\n~~~~~~~~~~~~~~~~~\n\nIf you're interested in the character set of textual data, you can use\nthe `charsetGetter` function (which can also be registered as the\n`ICharsetGetter` utility):\n\nThe simplest case is when the character set is already specified in the\ncontent type.\n\n  >>> typegetter.charsetGetter(content_type='text/plain; charset=mambo-42')\n  'mambo-42'\n\nNote that the charset name is lowercased, because all the default ICharset\nand ICharsetCodec utilities are registered for lowercase names.\n\n  >>> typegetter.charsetGetter(content_type='text/plain; charset=UTF-8')\n  'utf-8'\n\nIf it isn't, `charsetGetter` can try to guess by looking at actual data\n\n  >>> typegetter.charsetGetter(content_type='text/plain', data=b'just text')\n  'ascii'\n\n  >>> typegetter.charsetGetter(content_type='text/plain', data=b'\\xe2\\x98\\xba')\n  'utf-8'\n\n  >>> import codecs\n  >>> typegetter.charsetGetter(data=codecs.BOM_UTF16_BE + b'\\x12\\x34')\n  'utf-16be'\n\n  >>> typegetter.charsetGetter(data=codecs.BOM_UTF16_LE + b'\\x12\\x34')\n  'utf-16le'\n\nIf the character set cannot be determined, `charsetGetter` returns None.\n\n  >>> typegetter.charsetGetter(content_type='text/plain', data=b'\\xff')\n  >>> typegetter.charsetGetter()\n\n\nSource for MIME type interfaces\n===============================\n\nSome sample interfaces have been created in the zope.mimetype.tests\nmodule for use in this test.  Let's import them::\n\n  >>> from zope.mimetype.tests import (\n  ...     ISampleContentTypeOne, ISampleContentTypeTwo)\n\nThe source should only include `IContentTypeInterface` interfaces that\nhave been registered.  Let's register one of these two interfaces so\nwe can test this::\n\n  >>> import zope.component\n  >>> from zope.mimetype.interfaces import IContentTypeInterface\n\n  >>> zope.component.provideUtility(\n  ...     ISampleContentTypeOne, IContentTypeInterface, name=\"type/one\")\n\n  >>> zope.component.provideUtility(\n  ...     ISampleContentTypeOne, IContentTypeInterface, name=\"type/two\")\n\nWe should see that these interfaces are included in the source::\n\n  >>> from zope.mimetype import source\n\n  >>> s = source.ContentTypeSource()\n\n  >>> ISampleContentTypeOne in s\n  True\n  >>> ISampleContentTypeTwo in s\n  False\n\nInterfaces that do not implement the `IContentTypeInterface` are not\nincluded in the source::\n\n  >>> import zope.interface\n  >>> class ISomethingElse(zope.interface.Interface):\n  ...    \"\"\"This isn't a content type interface.\"\"\"\n\n  >>> ISomethingElse in s\n  False\n\nThe source is iterable, so we can get a list of the values::\n\n  >>> values = list(s)\n\n  >>> len(values)\n  1\n  >>> values[0] is ISampleContentTypeOne\n  True\n\nWe can get terms for the allowed values::\n\n  >>> terms = source.ContentTypeTerms(s, None)\n  >>> t = terms.getTerm(ISampleContentTypeOne)\n  >>> terms.getValue(t.token) is ISampleContentTypeOne\n  True\n\nInterfaces that are not in the source cause an error when a term is\nrequested::\n\n  >>> terms.getTerm(ISomethingElse)\n  Traceback (most recent call last):\n  ...\n  LookupError: value is not an element in the source\n\nThe term provides a token based on the module name of the interface::\n\n  >>> t.token\n  'zope.mimetype.tests.ISampleContentTypeOne'\n\nThe term also provides the title based on the \"title\" tagged value\nfrom the interface::\n\n  >>> t.title\n  u'Type One'\n\nEach interface provides a list of MIME types with which the interface\nis associated.  The term object provides access to this list::\n\n  >>> t.mimeTypes\n  ['type/one', 'type/foo']\n\nA list of common extensions for files of this type is also available,\nthough it may be empty::\n\n  >>> t.extensions\n  []\n\nThe term's value, of course, is the interface passed in::\n\n  >>> t.value is ISampleContentTypeOne\n  True\n\nThis extended term API is defined by the `IContentTypeTerm`\ninterface::\n\n  >>> from zope.mimetype.interfaces import IContentTypeTerm\n  >>> IContentTypeTerm.providedBy(t)\n  True\n\nThe value can also be retrieved using the `getValue()` method::\n\n  >>> iface = terms.getValue('zope.mimetype.tests.ISampleContentTypeOne')\n  >>> iface is ISampleContentTypeOne\n  True\n\nAttempting to retrieve an interface that isn't in the source using the\nterms object generates a LookupError::\n\n  >>> terms.getValue('zope.mimetype.tests.ISampleContentTypeTwo')\n  Traceback (most recent call last):\n  ...\n  LookupError: token does not represent an element in the source\n\nAttempting to look up a junk token also generates an error::\n\n  >>> terms.getValue('just.some.dotted.name.that.does.not.exist')\n  Traceback (most recent call last):\n  ...\n  LookupError: could not import module for token\n\n\nTranslatableSourceSelectWidget\n==============================\n\nTranslatableSourceSelectWidget is a SourceSelectWidget that translates\nand sorts the choices.\n\nWe will borrow the boring set up code from the SourceSelectWidget test\n(source.txt in zope.formlib).\n\n    >>> import zope.interface\n    >>> import zope.component\n    >>> import zope.schema\n    >>> import zope.schema.interfaces\n\n    >>> @zope.interface.implementer(zope.schema.interfaces.IIterableSource)\n    ... class SourceList(list):\n    ...     pass\n\n    >>> import base64, binascii\n    >>> import zope.publisher.interfaces.browser\n    >>> from zope.browser.interfaces import ITerms\n    >>> from zope.schema.vocabulary import SimpleTerm\n    >>> @zope.interface.implementer(ITerms)\n    ... class ListTerms:\n    ...\n    ...     def __init__(self, source, request):\n    ...         pass # We don't actually need the source or the request :)\n    ...\n    ...     def getTerm(self, value):\n    ...         title = value.decode() if isinstance(value, bytes) else value\n    ...         try:\n    ...             token = base64.b64encode(title.encode()).strip().decode()\n    ...         except binascii.Error:\n    ...             raise LookupError(token)\n    ...         return SimpleTerm(value, token=token, title=title)\n    ...\n    ...     def getValue(self, token):\n    ...         return token.decode('base64')\n\n    >>> zope.component.provideAdapter(\n    ...     ListTerms,\n    ...     (SourceList, zope.publisher.interfaces.browser.IBrowserRequest))\n\n    >>> dog = zope.schema.Choice(\n    ...    __name__ = 'dog',\n    ...    title=u\"Dogs\",\n    ...    source=SourceList(['spot', 'bowser', 'prince', 'duchess', 'lassie']),\n    ...    )\n    >>> dog = dog.bind(object())\n\nNow that we have a field and a working source, we can construct and render\na widget.\n\n    >>> from zope.mimetype.widget import TranslatableSourceSelectWidget\n    >>> from zope.publisher.browser import TestRequest\n    >>> request = TestRequest()\n    >>> widget = TranslatableSourceSelectWidget(\n    ...     dog, dog.source, request)\n\n    >>> print(widget())\n    <div>\n    <div class=\"value\">\n    <select id=\"field.dog\" name=\"field.dog\" size=\"5\" >\n    <option value=\"Ym93c2Vy\">bowser</option>\n    <option value=\"ZHVjaGVzcw==\">duchess</option>\n    <option value=\"bGFzc2ll\">lassie</option>\n    <option value=\"cHJpbmNl\">prince</option>\n    <option value=\"c3BvdA==\">spot</option>\n    </select>\n    </div>\n    <input name=\"field.dog-empty-marker\" type=\"hidden\" value=\"1\" />\n    </div>\n\nNote that the options are ordered alphabetically.\n\nIf the field is not required, we will also see a special choice labeled\n\"(nothing selected)\" at the top of the list\n\n    >>> dog.required = False\n    >>> print(widget())\n    <div>\n    <div class=\"value\">\n    <select id=\"field.dog\" name=\"field.dog\" size=\"5\" >\n    <option selected=\"selected\" value=\"\">(nothing selected)</option>\n    <option value=\"Ym93c2Vy\">bowser</option>\n    <option value=\"ZHVjaGVzcw==\">duchess</option>\n    <option value=\"bGFzc2ll\">lassie</option>\n    <option value=\"cHJpbmNl\">prince</option>\n    <option value=\"c3BvdA==\">spot</option>\n    </select>\n    </div>\n    <input name=\"field.dog-empty-marker\" type=\"hidden\" value=\"1\" />\n    </div>\n\n\nThe utils module contains various helpers for working with data goverened\nby MIME content type information, as found in the HTTP Content-Type header:\nmime types and character sets.\n\nThe decode function takes a string and an IANA character set name and\nreturns a unicode object decoded from the string, using the codec associated\nwith the character set name.  Errors will generally arise from the unicode\nconversion rather than the mapping of character set to codec, and will be\nLookupErrors (the character set did not cleanly convert to a codec that\nPython knows about) or UnicodeDecodeErrors (the string included characters\nthat were not in the range of the codec associated with the character set).\n\n    >>> original = b'This is an o with a slash through it: \\xb8.'\n    >>> charset = 'Latin-7' # Baltic Rim or iso-8859-13\n    >>> from zope.mimetype import utils\n    >>> utils.decode(original, charset)\n    u'This is an o with a slash through it: \\xf8.'\n    >>> utils.decode(original, 'foo bar baz')\n    Traceback (most recent call last):\n    ...\n    LookupError: unknown encoding: foo bar baz\n    >>> utils.decode(original, 'iso-ir-6') # alias for ASCII\n    ... # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n    ...\n    UnicodeDecodeError: 'ascii' codec can't decode...\n\n\nChanges\n=======\n\n2.3.1 (2018-01-09)\n------------------\n\n- Only try to register the browser stuff in the ZCA when `zope.formlib` is\n  available as it breaks otherwise.\n\n\n2.3.0 (2017-09-28)\n------------------\n\n- Drop support for Python 3.3.\n\n- Move the dependencies on ``zope.browser``, ``zope.publisher`` and\n  ``zope.formlib`` (only needed to use the ``source`` and ``widget``\n  modules) into a new ``browser`` extra.\n  See `PR 8 <https://github.com/zopefoundation/zope.mimetype/pull/8>`_.\n\n2.2.0 (2017-04-24)\n------------------\n\n- Fix `issue 6 <https://github.com/zopefoundation/zope.mimetype/issues/6>`_:\n  ``typegetter.smartMimeTypeGuesser`` would raise ``TypeError`` on Python 3\n  when the data was ``bytes`` and the ``content_type`` was ``text/html``.\n\n- Add support for Python 3.6.\n\n\n2.1.0 (2016-08-09)\n------------------\n\n- Add support for Python 3.5.\n\n- Drop support for Python 2.6.\n\n- Fix configuring the package via its included ZCML on Python 3.\n\n2.0.0 (2014-12-24)\n--------------------\n\n- Add support for PyPy and PyPy3.\n\n- Add support for Python 3.4.\n\n- Restore the ability to write ``from zope.mimetype import types``.\n\n- Make ``configure.zcml`` respect the renaming of the ``types`` module\n  so that it can be loaded.\n\n\n2.0.0a1 (2013-02-27)\n--------------------\n\n- Add support for Python 3.3.\n\n- Replace deprecated ``zope.component.adapts`` usage with equivalent\n  ``zope.component.adapter`` decorator.\n\n- Replace deprecated ``zope.interface.implements`` usage with equivalent\n  ``zope.interface.implementer`` decorator.\n\n- Rename ``zope.mimetype.types`` to ``zope.mimetype.mtypes``.\n\n- Drop support for Python 2.4 and 2.5.\n\n\n1.3.1 (2010-11-10)\n------------------\n\n- No longer dependg on ``zope.app.form`` in ``configure.zcml`` by using\n  ``zope.formlib`` instead, where the needed interfaces are living now.\n\n1.3.0 (2010-06-26)\n------------------\n\n- Add testing dependency on ``zope.component[test]``.\n\n- Use zope.formlib instead of zope.app.form.browser for select widget.\n\n- Conform to repository policy.\n\n1.2.0 (2009-12-26)\n------------------\n\n- Convert functional tests to unit tests and get rid of all extra test\n  dependencies as a result.\n\n- Use the ITerms interface from zope.browser.\n\n- Declare missing dependencies, resolved direct dependency on\n  zope.app.publisher.\n\n- Import content-type parser from ``zope.contenttype``, adding a dependency on\n  that package.\n\n1.1.2 (2009-05-22)\n------------------\n\n- No longer depend on ``zope.app.component``.\n\n1.1.1 (2009-04-03)\n------------------\n\n- Fix wrong package version (version ``1.1.0`` was released as ``0.4.0`` at\n  `pypi` but as ``1.1dev`` at `download.zope.org/distribution`)\n\n- Fix author email and home page address.\n\n1.1.0 (2007-11-01)\n------------------\n\n- Package data update.\n\n- First public release.\n\n1.0.0 (2007-??-??)\n------------------\n\n- Initial release.\n\n\n",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "https://github.com/zopefoundation/zope.mimetype",
    "keywords": "file content mimetype",
    "license": "ZPL 2.1",
    "maintainer": "",
    "maintainer_email": "",
    "name": "zope.mimetype",
    "platform": "",
    "project_url": "https://pypi.org/project/zope.mimetype/",
    "release_url": "https://pypi.org/project/zope.mimetype/2.3.1/",
    "requires_dist": [
      "zope.testrunner; extra == 'test'",
      "zope.testing; extra == 'test'",
      "zope.publisher; extra == 'test'",
      "zope.formlib (>=4.0); extra == 'test'",
      "zope.browserresource; extra == 'test'",
      "zope.browser; extra == 'test'",
      "zope.publisher; extra == 'browser'",
      "zope.formlib (>=4.0); extra == 'browser'",
      "zope.browserresource; extra == 'browser'",
      "zope.browser; extra == 'browser'",
      "zope.security",
      "zope.schema",
      "zope.interface",
      "zope.i18nmessageid",
      "zope.i18n",
      "zope.event",
      "zope.contenttype (>=3.5)",
      "zope.configuration",
      "zope.component",
      "setuptools"
    ],
    "requires_python": "",
    "summary": "A simple package for working with MIME content types",
    "version": "2.3.1"
  },
  "releases": {
    "0.3.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "fd1ea4ce240745a86ecc65e8d88aa4ba",
          "sha256": "5f596658e63c9ccd3b473351bead48a2544a9ce0d2ffab59ba10f1802ad50b35"
        },
        "downloads": -1,
        "filename": "zope.mimetype-0.3.0.tar.gz",
        "has_sig": false,
        "md5_digest": "fd1ea4ce240745a86ecc65e8d88aa4ba",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 65000,
        "upload_time": "2007-11-02T03:08:42",
        "url": "https://files.pythonhosted.org/packages/8e/d4/bb80eb6a991d42c8f9345583f4a1666bc93fb183d100e34026e397c97337/zope.mimetype-0.3.0.tar.gz"
      }
    ],
    "1.1.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "a3a50ca07a98f842b85c5f3d15299e8c",
          "sha256": "7865700bf938a212a9224d0fc274e39bc9792424c021f65dd4afa455bef78517"
        },
        "downloads": -1,
        "filename": "zope.mimetype-1.1.1.tar.gz",
        "has_sig": false,
        "md5_digest": "a3a50ca07a98f842b85c5f3d15299e8c",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 66853,
        "upload_time": "2009-04-03T21:30:09",
        "url": "https://files.pythonhosted.org/packages/d0/fc/ad219ca46f4ed0a3a33f9744cae4d0e201645797dd109e0591ad0c625111/zope.mimetype-1.1.1.tar.gz"
      }
    ],
    "1.1.2": [
      {
        "comment_text": "",
        "digests": {
          "md5": "29e53ffb29f4c02da3eae83f3aa82070",
          "sha256": "cd333546d1ea121c3e8cec3157b05a7bbf54ad2fc9a27950f1e8e66f334375ef"
        },
        "downloads": -1,
        "filename": "zope.mimetype-1.1.2.tar.gz",
        "has_sig": false,
        "md5_digest": "29e53ffb29f4c02da3eae83f3aa82070",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 67397,
        "upload_time": "2009-05-22T23:11:36",
        "url": "https://files.pythonhosted.org/packages/e0/bc/abb6d873d4389e92b49f46ebc74440b253fd6f6c2f9373def768df22fbab/zope.mimetype-1.1.2.tar.gz"
      }
    ],
    "1.2.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "fe4a0dd0822423aa6da9a9b78bda9fac",
          "sha256": "7f11c44605e15cc757e77639804137702ad86f3ccd76a5a09e1580f92d9deb9b"
        },
        "downloads": -1,
        "filename": "zope.mimetype-1.2.0.zip",
        "has_sig": false,
        "md5_digest": "fe4a0dd0822423aa6da9a9b78bda9fac",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 86319,
        "upload_time": "2009-12-26T18:31:18",
        "url": "https://files.pythonhosted.org/packages/bc/fe/5ed378b0ff9967a06cfbe867af0cfa295255837b80226e39f6ace24b5d13/zope.mimetype-1.2.0.zip"
      }
    ],
    "1.3.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "9431af14b54327a8d21e3f827a021b71",
          "sha256": "e03215a17057fb26512330f6a33957b13a830e1fb9bcf9ec4b3376614225ed4b"
        },
        "downloads": -1,
        "filename": "zope.mimetype-1.3.0.zip",
        "has_sig": false,
        "md5_digest": "9431af14b54327a8d21e3f827a021b71",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 88651,
        "upload_time": "2010-06-26T10:30:33",
        "url": "https://files.pythonhosted.org/packages/ac/e3/58d3ea7c6c146db00d5e9bda2996793a70793d32f7d0ef8ce47fb820a498/zope.mimetype-1.3.0.zip"
      }
    ],
    "1.3.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "c865758c896707287f86ba603f06a84b",
          "sha256": "bc24e25cb50d4f61e53f6a245f021c60289447dbcac56bf1ec14a3d207faad23"
        },
        "downloads": -1,
        "filename": "zope.mimetype-1.3.1.tar.gz",
        "has_sig": false,
        "md5_digest": "c865758c896707287f86ba603f06a84b",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 67704,
        "upload_time": "2010-11-10T21:06:29",
        "url": "https://files.pythonhosted.org/packages/7e/5c/2e922331f2891e33bc0492916f6c003f9d4a05d51cd45620cd815f5d525e/zope.mimetype-1.3.1.tar.gz"
      }
    ],
    "2.0.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "8f94843ea606189b58e8e1565e95c54d",
          "sha256": "167d1dd8a439b9ecf838c93c746551432d991777c5409e1af22bff0557d3fa71"
        },
        "downloads": -1,
        "filename": "zope.mimetype-2.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "8f94843ea606189b58e8e1565e95c54d",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 69682,
        "upload_time": "2014-12-24T19:50:09",
        "url": "https://files.pythonhosted.org/packages/1a/c4/eb988ec0306e47649ccf8b76c4b4b025d708b4e604f64afab26ca07ed211/zope.mimetype-2.0.0.tar.gz"
      }
    ],
    "2.0.0a1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "bc0ce91cb6beb715144580975bf91b1a",
          "sha256": "c82239bb9cabb3e9ad24466577855cc82d6ab315ed8df24ae2d8ccff12c4de78"
        },
        "downloads": -1,
        "filename": "zope.mimetype-2.0.0a1.zip",
        "has_sig": false,
        "md5_digest": "bc0ce91cb6beb715144580975bf91b1a",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 89863,
        "upload_time": "2013-02-28T04:29:57",
        "url": "https://files.pythonhosted.org/packages/30/46/012bd948000814b970f1a9ef6ed773cebbc4901952630ec630f4f3127453/zope.mimetype-2.0.0a1.zip"
      }
    ],
    "2.1.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "a62c30b9fe81741297b55a4db172ca82",
          "sha256": "654ce00f5bcfe8b66c8ab1b0ffc986fa74887d967d33fca0598c94ba2fa70c88"
        },
        "downloads": -1,
        "filename": "zope.mimetype-2.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "a62c30b9fe81741297b55a4db172ca82",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 71883,
        "upload_time": "2016-08-09T05:59:37",
        "url": "https://files.pythonhosted.org/packages/ba/a6/b7c9ddee9ace56cb19c00d7ac09e6b5a85b0701858fa49ba192b2c69dee6/zope.mimetype-2.1.0.tar.gz"
      }
    ],
    "2.2.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "a899f8ac0dc8a73a14b462a051c41b71",
          "sha256": "457b8fd4d341dce0f541ba1c506d26e39fddfce68df7ac80c8cb44d5c7e0b8ea"
        },
        "downloads": -1,
        "filename": "zope.mimetype-2.2.0.tar.gz",
        "has_sig": true,
        "md5_digest": "a899f8ac0dc8a73a14b462a051c41b71",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 71635,
        "upload_time": "2017-04-24T15:14:23",
        "url": "https://files.pythonhosted.org/packages/b2/c5/f090afd8f97b60dbea3d7386f3c482f329a02daab4813159ed4b8dff7316/zope.mimetype-2.2.0.tar.gz"
      }
    ],
    "2.3.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "d9cc272f7a2816ff0926578a2b1559da",
          "sha256": "6a5813f505a539656ad5600b4af4f46e5713a5266c7d6d174c4d798829a03b95"
        },
        "downloads": -1,
        "filename": "zope.mimetype-2.3.0-py2.py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "d9cc272f7a2816ff0926578a2b1559da",
        "packagetype": "bdist_wheel",
        "python_version": "py2.py3",
        "size": 84593,
        "upload_time": "2017-09-28T18:57:14",
        "url": "https://files.pythonhosted.org/packages/e4/7c/ebace654a4a68ace1533295d344d6b43772e2c0d46afe4eda16d6ce145d2/zope.mimetype-2.3.0-py2.py3-none-any.whl"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "b4ae4dad636513f1a13684fd98f33e6d",
          "sha256": "bf2ff74390e9288c9b6733fe7b0be07f77323d89ffd185511a44c04b1492c795"
        },
        "downloads": -1,
        "filename": "zope.mimetype-2.3.0.tar.gz",
        "has_sig": false,
        "md5_digest": "b4ae4dad636513f1a13684fd98f33e6d",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 73276,
        "upload_time": "2017-09-28T18:57:17",
        "url": "https://files.pythonhosted.org/packages/c8/d3/ecc3789a639d4784d303b67e7124e58a557efdbddf177dadf5145c967d5b/zope.mimetype-2.3.0.tar.gz"
      }
    ],
    "2.3.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "10751ae075cdeb794bbd632be4afbf62",
          "sha256": "366aa5a418f694a0fe5fd362d142fe0a4a078e45658bd2156589a69c4c34093c"
        },
        "downloads": -1,
        "filename": "zope.mimetype-2.3.1-py2.py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "10751ae075cdeb794bbd632be4afbf62",
        "packagetype": "bdist_wheel",
        "python_version": "py2.py3",
        "size": 84756,
        "upload_time": "2018-01-09T07:25:33",
        "url": "https://files.pythonhosted.org/packages/62/48/df2cf44fac8d4448ff8d4429b7aedb2fce0330561678d6ec513c3f7ad9ac/zope.mimetype-2.3.1-py2.py3-none-any.whl"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "e571848293a0a7ef0ac1ae7970e29b0e",
          "sha256": "f8bad7a9d59e7d31c3694ef42e76d2b421ccb8611f45058c43bdc87cec41df49"
        },
        "downloads": -1,
        "filename": "zope.mimetype-2.3.1.tar.gz",
        "has_sig": false,
        "md5_digest": "e571848293a0a7ef0ac1ae7970e29b0e",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 73531,
        "upload_time": "2018-01-09T07:25:34",
        "url": "https://files.pythonhosted.org/packages/59/f3/c5b89d8bd1e7ed8fcb4d3fd381b3264a1f0ae150bfb9afd6eb348098287a/zope.mimetype-2.3.1.tar.gz"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "10751ae075cdeb794bbd632be4afbf62",
        "sha256": "366aa5a418f694a0fe5fd362d142fe0a4a078e45658bd2156589a69c4c34093c"
      },
      "downloads": -1,
      "filename": "zope.mimetype-2.3.1-py2.py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "10751ae075cdeb794bbd632be4afbf62",
      "packagetype": "bdist_wheel",
      "python_version": "py2.py3",
      "size": 84756,
      "upload_time": "2018-01-09T07:25:33",
      "url": "https://files.pythonhosted.org/packages/62/48/df2cf44fac8d4448ff8d4429b7aedb2fce0330561678d6ec513c3f7ad9ac/zope.mimetype-2.3.1-py2.py3-none-any.whl"
    },
    {
      "comment_text": "",
      "digests": {
        "md5": "e571848293a0a7ef0ac1ae7970e29b0e",
        "sha256": "f8bad7a9d59e7d31c3694ef42e76d2b421ccb8611f45058c43bdc87cec41df49"
      },
      "downloads": -1,
      "filename": "zope.mimetype-2.3.1.tar.gz",
      "has_sig": false,
      "md5_digest": "e571848293a0a7ef0ac1ae7970e29b0e",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 73531,
      "upload_time": "2018-01-09T07:25:34",
      "url": "https://files.pythonhosted.org/packages/59/f3/c5b89d8bd1e7ed8fcb4d3fd381b3264a1f0ae150bfb9afd6eb348098287a/zope.mimetype-2.3.1.tar.gz"
    }
  ]
}