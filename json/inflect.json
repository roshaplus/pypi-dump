{
  "info": {
    "author": "Alex Gronholm",
    "author_email": "alex.gronholm@nextday.fi",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 3 - Alpha",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: GNU Affero General Public License v3",
      "Natural Language :: English",
      "Operating System :: OS Independent",
      "Programming Language :: Python",
      "Programming Language :: Python :: 2.6",
      "Programming Language :: Python :: 2.7",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.2",
      "Programming Language :: Python :: 3.3",
      "Topic :: Software Development :: Libraries :: Python Modules",
      "Topic :: Text Processing :: Linguistic"
    ],
    "description": "==========\ninflect.py\n==========\n\nNAME\n====\n\ninflect.py - Correctly generate plurals, singular nouns, ordinals, indefinite articles; convert numbers to words.\n\nVERSION\n=======\n\nThis document describes version 0.2.4 of inflect.py\n\nINSTALLATION\n============\n\n``pip install -e git+https://github.com/pwdyson/inflect.py#egg=inflect``\n\nSYNOPSIS\n========\n\n::\n\n import inflect\n p = inflect.engine()\n\n # METHODS:\n\n # plural plural_noun plural_verb plural_adj singular_noun no num\n # compare compare_nouns compare_nouns compare_adjs\n # a an\n # present_participle\n # ordinal number_to_words\n # join\n # inflect classical gender\n # defnoun defverb defadj defa defan\n\n\n # UNCONDITIONALLY FORM THE PLURAL\n\n      print(\"The plural of \", word, \" is \", p.plural(word))\n\n\n # CONDITIONALLY FORM THE PLURAL\n\n      print(\"I saw\", cat_count, p.plural(\"cat\",cat_count))\n\n\n # FORM PLURALS FOR SPECIFIC PARTS OF SPEECH\n\n      print(p.plural_noun(\"I\",N1), p.plural_verb(\"saw\",N1), p.plural_adj(\"my\",N2), \\)\n            p.plural_noun(\"saw\",N2)\n\n\n # FORM THE SINGULAR OF PLURAL NOUNS\n\n      print(\"The singular of \", word, \" is \", p.singular_noun(word))\n\n # SELECT THE GENDER OF SINGULAR PRONOUNS\n\n      print(p.singular_noun('they')  # 'it')\n      p.gender('f')\n      print(p.singular_noun('they')  # 'she')\n\n\n # DEAL WITH \"0/1/N\" -> \"no/1/N\" TRANSLATION:\n\n      print(\"There \", p.plural_verb(\"was\",errors), p.no(\" error\",errors))\n\n\n # USE DEFAULT COUNTS:\n\n      print(p.num(N1,\"\"), p.plural(\"I\"), p.plural_verb(\" saw\"), p.num(N2), p.plural_noun(\" saw\"))\n      print(\"There \", p.num(errors,''), p.plural_verb(\"was\"), p.no(\" error\"))\n\n\n # COMPARE TWO WORDS \"NUMBER-INSENSITIVELY\":\n\n      print(\"same\\n\"      if p.compare(word1, word2))\n      print(\"same noun\\n\" if p.compare_nouns(word1, word2))\n      print(\"same verb\\n\" if p.compare_verbs(word1, word2))\n      print(\"same adj.\\n\" if p.compare_adjs(word1, word2))\n\n\n # ADD CORRECT \"a\" OR \"an\" FOR A GIVEN WORD:\n\n      print(\"Did you want \", p.a(thing), \" or \", p.an(idea))\n\n\n # CONVERT NUMERALS INTO ORDINALS (i.e. 1->1st, 2->2nd, 3->3rd, etc.)\n\n      print(\"It was\", p.ordinal(position), \" from the left\\n\")\n\n # CONVERT NUMERALS TO WORDS (i.e. 1->\"one\", 101->\"one hundred and one\", etc.)\n # RETURNS A SINGLE STRING...\n\n    words = p.number_to_words(1234)      # \"one thousand, two hundred and thirty-four\"\n    words = p.number_to_words(p.ordinal(1234)) # \"one thousand, two hundred and thirty-fourth\"\n\n\n # GET BACK A LIST OF STRINGS, ONE FOR EACH \"CHUNK\"...\n\n    words = p.number_to_words(1234, getlist=True)    # (\"one thousand\",\"two hundred and thirty-four\")\n\n\n # OPTIONAL PARAMETERS CHANGE TRANSLATION:\n\n    words = p.number_to_words(12345, group=1)\n    # \"one, two, three, four, five\"\n\n    words = p.number_to_words(12345, group=2)\n    # \"twelve, thirty-four, five\"\n\n    words = p.number_to_words(12345, group=3)\n    # \"one twenty-three, forty-five\"\n\n    words = p.number_to_words(1234, andword='')\n    # \"one thousand, two hundred thirty-four\"\n\n    words = p.number_to_words(1234, andword=', plus')\n    # \"one thousand, two hundred, plus thirty-four\" #TODO: I get no comma before plus: check perl\n\n    words = p.number_to_words(555_1202, group=1, zero='oh')\n    # \"five, five, five, one, two, oh, two\"\n\n    words = p.number_to_words(555_1202, group=1, one='unity')\n    # \"five, five, five, unity, two, oh, two\"\n\n    words = p.number_to_words(123.456, group=1, decimal='mark')\n    # \"one two three mark four five six\"  #TODO: DOCBUG: perl gives commas here as do I\n\n # LITERAL STYLE ONLY NAMES NUMBERS LESS THAN A CERTAIN THRESHOLD...\n\n    words = p.number_to_words(   9, threshold=10);    # \"nine\"\n    words = p.number_to_words(  10, threshold=10);    # \"ten\"\n    words = p.number_to_words(  11, threshold=10);    # \"11\"\n    words = p.number_to_words(1000, threshold=10);    # \"1,000\"\n\n # JOIN WORDS INTO A LIST:\n\n    mylist = join((\"apple\", \"banana\", \"carrot\"))\n        # \"apple, banana, and carrot\"\n\n    mylist = join((\"apple\", \"banana\"))\n        # \"apple and banana\"\n\n    mylist = join((\"apple\", \"banana\", \"carrot\"), final_sep=\"\")\n        # \"apple, banana and carrot\"\n\n\n # REQUIRE \"CLASSICAL\" PLURALS (EG: \"focus\"->\"foci\", \"cherub\"->\"cherubim\")\n\n      p.classical()               # USE ALL CLASSICAL PLURALS\n\n      p.classical(all=True)       # USE ALL CLASSICAL PLURALS\n      p.classical(all=False)      # SWITCH OFF CLASSICAL MODE\n\n      p.classical(zero=True)      #  \"no error\" INSTEAD OF \"no errors\"\n      p.classical(zero=False)     #  \"no errors\" INSTEAD OF \"no error\" \n\n      p.classical(herd=True)      #  \"2 buffalo\" INSTEAD OF \"2 buffalos\"\n      p.classical(herd=False)     #  \"2 buffalos\" INSTEAD OF \"2 buffalo\"\n\n      p.classical(persons=True)   # \"2 chairpersons\" INSTEAD OF \"2 chairpeople\"\n      p.classical(persons=False)  # \"2 chairpeople\" INSTEAD OF \"2 chairpersons\"\n\n      p.classical(ancient=True)   # \"2 formulae\" INSTEAD OF \"2 formulas\"\n      p.classical(ancient=False)  # \"2 formulas\" INSTEAD OF \"2 formulae\"\n\n\n\n # INTERPOLATE \"plural()\", \"plural_noun()\", \"plural_verb()\", \"plural_adj()\", \"singular_noun()\",\n # a()\", \"an()\", \"num()\" AND \"ordinal()\" WITHIN STRINGS:\n\n      print(p.inflect(\"The plural of {0} is plural({0})\".format(word)))\n      print(p.inflect(\"The singular of {0} is singular_noun({0})\".format(word)))\n      print(p.inflect(\"I saw {0} plural(\"cat\",{0})\".format(cat_count)))\n      print(p.inflect(\"plural(I,{0}) plural_verb(saw,{0}) plural(a,{1}) plural_noun(saw,{1})\".format(N1, N2)))\n      print(p.inflect(\"num({0},)plural(I) plural_verb(saw) num({1},)plural(a) plural_noun(saw)\".format(N1, N2)))\n      print(p.inflect(\"I saw num({0}) plural(\"cat\")\\nnum()\".format(cat_count)))\n      print(p.inflect(\"There plural_verb(was,{0}) no(error,{0})\".format(errors)))\n      print(p.inflect(\"There num({0},) plural_verb(was) no(error)\".format(errors)))\n      print(p.inflect(\"Did you want a({0}) or an({1})\".format(thing, idea)))\n      print(p.inflect(\"It was ordinal({0}) from the left\".format(position)))\n\n\n # ADD USER-DEFINED INFLECTIONS (OVERRIDING INBUILT RULES):\n\n      p.defnoun( \"VAX\", \"VAXen\" )  # SINGULAR => PLURAL\n\n      p.defverb( \"will\" , \"shall\",  # 1ST PERSON SINGULAR => PLURAL\n                \"will\" , \"will\",   # 2ND PERSON SINGULAR => PLURAL\n                \"will\" , \"will\")   # 3RD PERSON SINGULAR => PLURAL\n\n      p.defadj(  \"hir\"  , \"their\")  # SINGULAR => PLURAL\n\n      p.defa(\"h\")        # \"AY HALWAYS SEZ 'HAITCH'!\"\n\n      p.defan(   \"horrendous.*\" )    # \"AN HORRENDOUS AFFECTATION\"\n\n\nDESCRIPTION\n===========\n\nThe methods of the class ``engine`` in module ``inflect.py`` provide plural\ninflections, singular noun inflections, \"a\"/\"an\" selection for English words,\nand manipulation of numbers as words.\n\nPlural forms of all nouns, most verbs, and some adjectives are\nprovided. Where appropriate, \"classical\" variants (for example: \"brother\" ->\n\"brethren\", \"dogma\" -> \"dogmata\", etc.) are also provided.\n\nSingle forms of nouns are also provided. The gender of singular pronouns\ncan be chosen (for example \"they\" -> \"it\" or \"she\" or \"he\" or \"they\"). \n\nPronunciation-based \"a\"/\"an\" selection is provided for all English\nwords, and most initialisms.\n\nIt is also possible to inflect numerals (1,2,3) to ordinals (1st, 2nd, 3rd)\nand to english words (\"one\", \"two\", \"three\").\n\nIn generating these inflections, ``inflect.py`` follows the Oxford\nEnglish Dictionary and the guidelines in Fowler's Modern English\nUsage, preferring the former where the two disagree.\n\nThe module is built around standard British spelling, but is designed\nto cope with common American variants as well. Slang, jargon, and\nother English dialects are *not* explicitly catered for.\n\nWhere two or more inflected forms exist for a single word (typically a\n\"classical\" form and a \"modern\" form), ``inflect.py`` prefers the\nmore common form (typically the \"modern\" one), unless \"classical\"\nprocessing has been specified\n(see `MODERN VS CLASSICAL INFLECTIONS`).\n\nFORMING PLURALS AND SINGULARS\n=============================\n\nInflecting Plurals and Singulars\n--------------------------------\n\nAll of the ``plural...`` plural inflection methods take the word to be\ninflected as their first argument and return the corresponding inflection.\nNote that all such methods expect the *singular* form of the word. The\nresults of passing a plural form are undefined (and unlikely to be correct).\nSimilarly, the ``si...`` singular inflection method expects the *plural*\nform of the word.\n\nThe ``plural...`` methods also take an optional second argument,\nwhich indicates the grammatical \"number\" of the word (or of another word\nwith which the word being inflected must agree). If the \"number\" argument is\nsupplied and is not ``1`` (or ``\"one\"`` or ``\"a\"``, or some other adjective that\nimplies the singular), the plural form of the word is returned. If the\n\"number\" argument *does* indicate singularity, the (uninflected) word\nitself is returned. If the number argument is omitted, the plural form\nis returned unconditionally.\n\nThe ``si...`` method takes a second argument in a similar fashion. If it is\nsome form of the number ``1``, or is omitted, the singular form is returned.\nOtherwise the plural is returned unaltered.\n\n\nThe various methods of ``inflect.engine`` are:\n\n\n\n``plural_noun(word, count=None)``\n\n The method ``plural_noun()`` takes a *singular* English noun or\n pronoun and returns its plural. Pronouns in the nominative (\"I\" ->\n \"we\") and accusative (\"me\" -> \"us\") cases are handled, as are\n possessive pronouns (\"mine\" -> \"ours\").\n\n\n``plural_verb(word, count=None)``\n\n The method ``plural_verb()`` takes the *singular* form of a\n conjugated verb (that is, one which is already in the correct \"person\"\n and \"mood\") and returns the corresponding plural conjugation.\n\n\n``plural_adj(word, count=None)``\n\n The method ``plural_adj()`` takes the *singular* form of\n certain types of adjectives and returns the corresponding plural form.\n Adjectives that are correctly handled include: \"numerical\" adjectives\n (\"a\" -> \"some\"), demonstrative adjectives (\"this\" -> \"these\", \"that\" ->\n \"those\"), and possessives (\"my\" -> \"our\", \"cat's\" -> \"cats'\", \"child's\"\n -> \"childrens'\", etc.)\n\n\n``plural(word, count=None)``\n\n The method ``plural()`` takes a *singular* English noun,\n pronoun, verb, or adjective and returns its plural form. Where a word\n has more than one inflection depending on its part of speech (for\n example, the noun \"thought\" inflects to \"thoughts\", the verb \"thought\"\n to \"thought\"), the (singular) noun sense is preferred to the (singular)\n verb sense.\n\n Hence ``plural(\"knife\")`` will return \"knives\" (\"knife\" having been treated\n as a singular noun), whereas ``plural(\"knifes\")`` will return \"knife\"\n (\"knifes\" having been treated as a 3rd person singular verb).\n\n The inherent ambiguity of such cases suggests that,\n where the part of speech is known, ``plural_noun``, ``plural_verb``, and\n ``plural_adj`` should be used in preference to ``plural``.\n\n\n``singular_noun(word, count=None)``\n\n The method ``singular_noun()`` takes a *plural* English noun or\n pronoun and returns its singular. Pronouns in the nominative (\"we\" ->\n \"I\") and accusative (\"us\" -> \"me\") cases are handled, as are\n possessive pronouns (\"ours\" -> \"mine\"). When third person\n singular pronouns are returned they take the neuter gender by default\n (\"they\" -> \"it\"), not (\"they\"-> \"she\") nor (\"they\" -> \"he\"). This can be\n changed with ``gender()``.\n\nNote that all these methods ignore any whitespace surrounding the\nword being inflected, but preserve that whitespace when the result is\nreturned. For example, ``plural(\" cat  \")`` returns \" cats  \".\n\n\n``gender(genderletter)``\n\n The third person plural pronoun takes the same form for the female, male and\n neuter (e.g. \"they\"). The singular however, depends upon gender (e.g. \"she\",\n \"he\", \"it\" and \"they\" -- \"they\" being the gender neutral form.) By default\n ``singular_noun`` returns the neuter form, however, the gender can be selected with\n the ``gender`` method. Pass the first letter of the gender to\n ``gender`` to return the f(eminine), m(asculine), n(euter) or t(hey)\n form of the singular. e.g.\n gender('f') followed by singular_noun('themselves') returns 'herself'.\n\nNumbered plurals\n----------------\n\nThe ``plural...`` methods return only the inflected word, not the count that\nwas used to inflect it. Thus, in order to produce \"I saw 3 ducks\", it\nis necessary to use::\n\n    print(\"I saw\", N, p.plural_noun(animal,N))\n\nSince the usual purpose of producing a plural is to make it agree with\na preceding count, inflect.py provides a method\n(``no(word, count)``) which, given a word and a(n optional) count, returns the\ncount followed by the correctly inflected word. Hence the previous\nexample can be rewritten::\n\n    print(\"I saw \", p.no(animal,N))\n\nIn addition, if the count is zero (or some other term which implies\nzero, such as ``\"zero\"``, ``\"nil\"``, etc.) the count is replaced by the\nword \"no\". Hence, if ``N`` had the value zero, the previous example\nwould print(the somewhat more elegant::)\n\n    I saw no animals\n\nrather than::\n\n    I saw 0 animals\n\nNote that the name of the method is a pun: the method\nreturns either a number (a *No.*) or a ``\"no\"``, in front of the\ninflected word.\n\n\nReducing the number of counts required\n--------------------------------------\n\nIn some contexts, the need to supply an explicit count to the various\n``plural...`` methods makes for tiresome repetition. For example::\n\n    print(plural_adj(\"This\",errors), plural_noun(\" error\",errors), \\)\n          plural_verb(\" was\",errors), \" fatal.\"\n\ninflect.py therefore provides a method\n(``num(count=None, show=None)``) which may be used to set a persistent \"default number\"\nvalue. If such a value is set, it is subsequently used whenever an\noptional second \"number\" argument is omitted. The default value thus set \ncan subsequently be removed by calling ``num()`` with no arguments.\nHence we could rewrite the previous example::\n\n    p.num(errors)\n    print(p.plural_adj(\"This\"), p.plural_noun(\" error\"), p.plural_verb(\" was\"), \"fatal.\")\n    p.num()\n\nNormally, ``num()`` returns its first argument, so that it may also\nbe \"inlined\" in contexts like::\n\n    print(p.num(errors), p.plural_noun(\" error\"), p.plural_verb(\" was\"), \" detected.\")\n    if severity > 1:\n        print(p.plural_adj(\"This\"), p.plural_noun(\" error\"), p.plural_verb(\" was\"), \"fatal.\")\n\nHowever, in certain contexts (see `INTERPOLATING INFLECTIONS IN STRINGS`)\nit is preferable that ``num()`` return an empty string. Hence ``num()``\nprovides an optional second argument. If that argument is supplied (that is, if\nit is defined) and evaluates to false, ``num`` returns an empty string\ninstead of its first argument. For example::\n\n    print(p.num(errors,0), p.no(\"error\"), p.plural_verb(\" was\"), \" detected.\")\n    if severity > 1:\n        print(p.plural_adj(\"This\"), p.plural_noun(\" error\"), p.plural_verb(\" was\"), \"fatal.\")\n\n\n\nNumber-insensitive equality\n---------------------------\n\ninflect.py also provides a solution to the problem\nof comparing words of differing plurality through the methods\n``compare(word1, word2)``, ``compare_nouns(word1, word2)``,\n``compare_verbs(word1, word2)``, and ``compare_adjs(word1, word2)``.\nEach  of these methods takes two strings, and  compares them\nusing the corresponding plural-inflection method (``plural()``, ``plural_noun()``,\n``plural_verb()``, and ``plural_adj()`` respectively).\n\nThe comparison returns true if:\n\n- the strings are equal, or\n- one string is equal to a plural form of the other, or\n- the strings are two different plural forms of the one word.\n\n\nHence all of the following return true::\n\n    p.compare(\"index\",\"index\")      # RETURNS \"eq\"\n    p.compare(\"index\",\"indexes\")    # RETURNS \"s:p\"\n    p.compare(\"index\",\"indices\")    # RETURNS \"s:p\"\n    p.compare(\"indexes\",\"index\")    # RETURNS \"p:s\"\n    p.compare(\"indices\",\"index\")    # RETURNS \"p:s\"\n    p.compare(\"indices\",\"indexes\")  # RETURNS \"p:p\"\n    p.compare(\"indexes\",\"indices\")  # RETURNS \"p:p\"\n    p.compare(\"indices\",\"indices\")  # RETURNS \"eq\"\n\nAs indicated by the comments in the previous example, the actual value\nreturned by the various ``compare`` methods encodes which of the\nthree equality rules succeeded: \"eq\" is returned if the strings were\nidentical, \"s:p\" if the strings were singular and plural respectively,\n\"p:s\" for plural and singular, and \"p:p\" for two distinct plurals.\nInequality is indicated by returning an empty string.\n\nIt should be noted that two distinct singular words which happen to take\nthe same plural form are *not* considered equal, nor are cases where\none (singular) word's plural is the other (plural) word's singular.\nHence all of the following return false::\n\n    p.compare(\"base\",\"basis\")       # ALTHOUGH BOTH -> \"bases\"\n    p.compare(\"syrinx\",\"syringe\")   # ALTHOUGH BOTH -> \"syringes\"\n    p.compare(\"she\",\"he\")           # ALTHOUGH BOTH -> \"they\"\n\n    p.compare(\"opus\",\"operas\")      # ALTHOUGH \"opus\" -> \"opera\" -> \"operas\"\n    p.compare(\"taxi\",\"taxes\")       # ALTHOUGH \"taxi\" -> \"taxis\" -> \"taxes\"\n\nNote too that, although the comparison is \"number-insensitive\" it is *not*\ncase-insensitive (that is, ``plural(\"time\",\"Times\")`` returns false. To obtain\nboth number and case insensitivity, use the ``lower()`` method on both strings\n(that is, ``plural(\"time\".lower(), \"Times\".lower())`` returns true).\n\n\nOTHER VERB FORMS\n================\n\nPresent participles\n-------------------\n\n``inflect.py`` also provides the ``present_participle`` method,\nwhich can take a 3rd person singular verb and\ncorrectly inflect it to its present participle::\n\n    p.present_participle(\"runs\")   # \"running\"\n    p.present_participle(\"loves\")  # \"loving\"\n    p.present_participle(\"eats\")   # \"eating\"\n    p.present_participle(\"bats\")   # \"batting\"\n    p.present_participle(\"spies\")  # \"spying\"\n\n\nPROVIDING INDEFINITE ARTICLES\n=============================\n\nSelecting indefinite articles\n-----------------------------\n\ninflect.py provides two methods (``a(word, count=None)`` and\n``an(word, count=None)``) which will correctly prepend the appropriate indefinite\narticle to a word, depending on its pronunciation. For example::\n\n    p.a(\"cat\")        # -> \"a cat\"\n    p.an(\"cat\")       # -> \"a cat\"\n    p.a(\"euphemism\")      # -> \"a euphemism\"\n    p.a(\"Euler number\")   # -> \"an Euler number\"\n    p.a(\"hour\")       # -> \"an hour\"\n    p.a(\"houri\")      # -> \"a houri\"\n\nThe two methods are *identical* in function and may be used\ninterchangeably. The only reason that two versions are provided is to\nenhance the readability of code such as::\n\n    print(\"That is \", an(errortype), \" error)\n    print(\"That is \", a(fataltype), \" fatal error)\n\nNote that in both cases the actual article provided depends *only* on\nthe pronunciation of the first argument, *not* on the name of the\nmethod.\n\n``a()`` and ``an()`` will ignore any indefinite article that already\nexists at the start of the string. Thus::\n\n    half_arked = [\n        \"a elephant\",\n        \"a giraffe\",\n        \"an ewe\",\n        \"a orangutan\",\n    ]\n\n    for txt in half_arked:\n        print(p.a(txt))\n\n    # prints:\n    #     an elephant\n    #     a giraffe\n    #     a ewe\n    #     an orangutan\n\n\n``a()`` and ``an()`` both take an optional second argument. As with the\n``plural...`` methods, this second argument is a \"number\" specifier. If\nits value is ``1`` (or some other value implying singularity), ``a()`` and\n``an()`` insert \"a\" or \"an\" as appropriate. If the number specifier \nimplies plurality, (``a()`` and ``an()`` insert the actual second argument instead.\nFor example::\n\n    p.a(\"cat\",1)      # -> \"a cat\"\n    p.a(\"cat\",2)      # -> \"2 cat\"\n    p.a(\"cat\",\"one\")      # -> \"one cat\"\n    p.a(\"cat\",\"no\")       # -> \"no cat\"\n\nNote that, as implied by the previous examples, ``a()`` and\n``an()`` both assume that their job is merely to provide the correct\nqualifier for a word (that is: \"a\", \"an\", or the specified count).\nIn other words, they assume that the word they are given has\nalready been correctly inflected for plurality. Hence, if ``N`` \nhas the value 2, then::\n\n      print(p.a(\"cat\",N))\n\nprints \"2 cat\", instead of \"2 cats\". The correct approach is to use::\n\n      print(p.a(p.plural(\"cat\",N),N))\n\nor, better still::\n\n      print(p.no(\"cat\",N))\n\nNote too that, like the various ``plural...`` methods, whenever ``a()``\nand ``an()`` are called with only one argument they are subject to the\neffects of any preceding call to ``num()``. Hence, another possible\nsolution is::\n\n      p.num(N)\n      print(p.a(p.plural(\"cat\")))\n\n\nIndefinite articles and initialisms\n-----------------------------------\n\n\"Initialisms\" (sometimes inaccurately called \"acronyms\") are terms which\nhave been formed from the initial letters of words in a phrase (for\nexample, \"NATO\", \"NBL\", \"S.O.S.\", \"SCUBA\", etc.)\n\nSuch terms present a particular challenge when selecting between \"a\"\nand \"an\", since they are sometimes pronounced as if they were a single\nword (\"nay-tow\", \"sku-ba\") and sometimes as a series of letter names\n(\"en-eff-ell\", \"ess-oh-ess\").\n\n``a()`` and ``an()`` cope with this dichotomy using a series of inbuilt\nrules, which may be summarized as:\n\n\n\n If the word starts with a single letter, followed by a period or dash\n (for example, \"R.I.P.\", \"C.O.D.\", \"e-mail\", \"X-ray\", \"T-square\"), then\n choose the appropriate article for the *sound* of the first letter\n (\"an R.I.P.\", \"a C.O.D.\", \"an e-mail\", \"an X-ray\", \"a T-square\").\n\n\n If the first two letters of the word are capitals,\n consonants, and do not appear at the start of any known English word,\n (for example, \"LCD\", \"XML\", \"YWCA\"), then once again choose \"a\" or\n \"an\" depending on the *sound* of the first letter (\"an LCD\", \"an\n XML\", \"a YWCA\").\n\n\n Otherwise, assume the string is a capitalized word or a\n pronounceable initialism (for example, \"LED\", \"OPEC\", \"FAQ\", \"UNESCO\"), and\n therefore takes \"a\" or \"an\" according to the (apparent) pronunciation of\n the entire word (\"a LED\", \"an OPEC\", \"a FAQ\", \"a UNESCO\").\n\n\nNote that rules 1 and 3 together imply that the presence or absence of\npunctuation may change the selection of indefinite article for a\nparticular initialism (for example, \"a FAQ\" but \"an F.A.Q.\").\n\n\nIndefinite articles and \"soft H's\"\n----------------------------------\n\nWords beginning in the letter 'H' present another type of difficulty\nwhen selecting a suitable indefinite article. In a few such words\n(for example, \"hour\", \"honour\", \"heir\") the 'H' is not voiced at\nall, and so such words inflect with \"an\". The remaining cases\n(\"voiced H's\") may be divided into two categories:\n\"hard H's\" (such as \"hangman\", \"holograph\", \"hat\", etc.) and\n\"soft H's\" (such as \"hysterical\", \"horrendous\", \"holy\", etc.)\n\nHard H's always take \"a\" as their indefinite article, and soft\nH's normally do so as well. But *some* English speakers prefer\n\"an\" for soft H's (although the practice is now generally considered an\naffectation, rather than a legitimate grammatical alternative).\n\nAt present, the ``a()`` and ``an()`` methods ignore soft H's and use\n\"a\" for any voiced 'H'. The author would, however, welcome feedback on\nthis decision (envisaging a possible future \"soft H\" mode).\n\n\nINFLECTING ORDINALS\n===================\n\nOccasionally it is useful to present an integer value as an ordinal\nrather than as a numeral. For example::\n\n    Enter password (1st attempt): ********\n    Enter password (2nd attempt): *********\n    Enter password (3rd attempt): *********\n    No 4th attempt. Access denied.\n\nTo this end, inflect.py provides the ``ordinal()`` method.\n``ordinal()`` takes a single argument and forms its ordinal equivalent.\nIf the argument isn't a numerical integer, it just adds \"-th\".\n\n\nCONVERTING NUMBERS TO WORDS\n===========================\n\nThe method ``number_to_words`` takes a number (cardinal or ordinal)\nand returns an English representation of that number.\n\n::\n\n    word = p.number_to_words(1234567)\n\nputs the string::\n\n    \"one million, two hundred and thirty-four thousand, five hundred and sixty-seven\"\n\ninto ``words``.\n\nA list can be return where each comma-separated chunk is returned as a separate element.\nHence::\n\n    words = p.number_to_words(1234567, wantlist=True)\n\nputs the list::\n\n    [\"one million\",\n     \"two hundred and thirty-four thousand\",\n     \"five hundred and sixty-seven\"]\n\ninto ``words``.\n\nNon-digits (apart from an optional leading plus or minus sign,\nany decimal points, and ordinal suffixes -- see below) are silently\nignored, so the following all produce identical results::\n\n        p.number_to_words(5551202)\n        p.number_to_words(5_551_202)\n        p.number_to_words(\"5,551,202\")\n        p.number_to_words(\"555-1202\")\n\nThat last case is a little awkward since it's almost certainly a phone number,\nand \"five million, five hundred and fifty-one thousand, two hundred and two\"\nprobably isn't what's wanted.\n\nTo overcome this, ``number_to_words()`` takes an optional argument, 'group',\nwhich changes how numbers are translated. The argument must be a\npositive integer less than four, which indicated how the digits of the\nnumber are to be grouped. If the argument is ``1``, then each digit is\ntranslated separately. If the argument is ``2``, pairs of digits\n(starting from the *left*) are grouped together. If the argument is\n``3``, triples of numbers (again, from the *left*) are grouped. Hence::\n\n        p.number_to_words(\"555-1202\", group=1)\n\nreturns ``\"five, five, five, one, two, zero, two\"``, whilst::\n\n        p.number_to_words(\"555-1202\", group=2)\n\nreturns ``\"fifty-five, fifty-one, twenty, two\"``, and::\n\n        p.number_to_words(\"555-1202\", group=3)\n\nreturns ``\"five fifty-five, one twenty, two\"``.\n\nPhone numbers are often written in words as\n``\"five..five..five..one..two..zero..two\"``, which is also easy to\nachieve::\n\n        join '..', p.number_to_words(\"555-1202\", group=>1)\n\n``number_to_words`` also handles decimal fractions. Hence::\n\n        p.number_to_words(\"1.2345\")\n\nreturns ``\"one point two three four five\"`` in a scalar context\nand ``(\"one\",\"point\",\"two\",\"three\",\"four\",\"five\")``) in an array context.\nExponent form (``\"1.234e56\"``) is not yet handled.\n\nMultiple decimal points are only translated in one of the \"grouping\" modes.\nHence::\n\n        p.number_to_words(101.202.303)\n\nreturns ``\"one hundred and one point two zero two three zero three\"``,\nwhereas::\n\n        p.number_to_words(101.202.303, group=1)\n\nreturns ``\"one zero one point two zero two point three zero three\"``.\n\nThe digit ``'0'`` is unusual in that in may be translated to English as \"zero\",\n\"oh\", or \"nought\". To cater for this diversity, ``number_to_words`` may be passed\na named argument, 'zero', which may be set to\nthe desired translation of ``'0'``. For example::\n\n        print(join \"..\", p.number_to_words(\"555-1202\", group=3, zero='oh'))\n\nprints ``\"five..five..five..one..two..oh..two\"``.\nBy default, zero is rendered as \"zero\".\n\nLikewise, the digit ``'1'`` may be rendered as \"one\" or \"a/an\" (or very\noccasionally other variants), depending on the context. So there is a\n``'one'`` argument as well::\n\n        for num in [3,2,1,0]:\n              print(p.number_to_words(num, one='a solitary', zero='no more'),)\n              p.plural(\" bottle of beer on the wall\", num)\n\n        # prints:\n        #     three bottles of beer on the wall\n        #     two bottles of beer on the wall\n        #     a solitary bottle of beer on the wall\n        #     no more bottles of beer on the wall\n\nCare is needed if the word \"a/an\" is to be used as a ``'one'`` value.\nUnless the next word is known in advance, it's almost always necessary\nto use the ``A`` function as well::\n\n\n        for word in [\"cat aardvark ewe hour\".split()]:\n            print(p.a(\"{0} {1}\".format(p.number_to_words(1, one='a'), word)))\n\n    # prints:\n    #     a cat\n    #     an aardvark\n    #     a ewe\n    #     an hour\n\nAnother major regional variation in number translation is the use of\n\"and\" in certain contexts. The named argument 'and'\nallows the programmer to specify how \"and\" should be handled. Hence::\n\n        print(scalar p.number_to_words(\"765\", andword=''))\n\nprints \"seven hundred sixty-five\", instead of \"seven hundred and sixty-five\".\nBy default, the \"and\" is included.\n\nThe translation of the decimal point is also subject to variation\n(with \"point\", \"dot\", and \"decimal\" being the favorites).\nThe named argument 'decimal' allows the\nprogrammer to how the decimal point should be rendered. Hence::\n\n        print(scalar p.number_to_words(\"666.124.64.101\", group=3, decimal='dot'))\n\nprints \"six sixty-six, dot, one twenty-four, dot, sixty-four, dot, one zero one\"\nBy default, the decimal point is rendered as \"point\".\n\n``number_to_words`` also handles the ordinal forms of numbers. So::\n\n        print(p.number_to_words('1st'))\n        print(p.number_to_words('3rd'))\n        print(p.number_to_words('202nd'))\n        print(p.number_to_words('1000000th'))\n\nprints::\n\n        first\n        third\n        two hundred and twenty-second\n        one millionth\n\nTwo common idioms in this regard are::\n\n        print(p.number_to_words(ordinal(number)))\n\nand::\n\n        print(p.ordinal(p.number_to_words(number)))\n\nThese are identical in effect, except when ``number`` contains a decimal::\n\n        number = 99.09\n        print(p.number_to_words(p.ordinal(number));    # ninety-ninth point zero nine)\n        print(p.ordinal(p.number_to_words(number));    # ninety-nine point zero ninth)\n\nUse whichever you feel is most appropriate.\n\n\nCONVERTING LISTS OF WORDS TO PHRASES\n====================================\n\nWhen creating a list of words, commas are used between adjacent items,\nexcept if the items contain commas, in which case semicolons are used.\nBut if there are less than two items, the commas/semicolons are omitted\nentirely. The final item also has a conjunction (usually \"and\" or \"or\")\nbefore it. And although it's technically incorrect (and sometimes\nmisleading), some people prefer to omit the comma before that final\nconjunction, even when there are more than two items.\n\nThat's complicated enough to warrant its own method: ``join()``.\nThis method expects a tuple of words, possibly with one or more\noptions. It returns a string that joins the list\ntogether in the normal English usage. For example::\n\n    print(\"You chose \", p.join(selected_items))\n    # You chose barley soup, roast beef, and Yorkshire pudding\n\n    print(\"You chose \", p.join(selected_items, final_sep=>\"\"))\n    # You chose barley soup, roast beef and Yorkshire pudding\n\n    print(\"Please chose \", p.join(side_orders, conj=>\"or\"))\n    # Please chose salad, vegetables, or ice-cream\n\nThe available options are::\n\n    Option named    Specifies                Default value\n\n    conj            Final conjunction        \"and\"\n    sep             Inter-item separator     \",\"\n    last_sep        Final separator          value of 'sep' option\n    sep_spaced      Space follows sep        True\n    conj_spaced     Spaces around conj       True\n\n\nINTERPOLATING INFLECTIONS IN STRINGS\n====================================\n\nBy far the commonest use of the inflection methods is to\nproduce message strings for various purposes. For example::\n\n        print(p.num(errors), p.plural_noun(\" error\"), p.plural_verb(\" was\"), \" detected.\")\n        if severity > 1:\n            print(p.plural_adj(\"This\"), p.plural_noun(\" error\"), p.plural_verb(\" was\"), \"fatal.\")\n\nUnfortunately the need to separate each method call detracts\nsignificantly from the readability of the resulting code. To ameliorate\nthis problem, inflect.py provides a string-interpolating\nmethod (``inflect(txt)``), which recognizes calls to the various inflection\nmethods within a string and interpolates them appropriately.\n\nUsing ``inflect`` the previous example could be rewritten::\n\n        print(p.inflect(\"num({0}) plural_noun(error) plural_verb(was) detected.\".format(errors)))\n        if severity > 1:\n            print(p.inflect(\"plural_adj(This) plural_noun(error) plural_verb(was) fatal.\"))\n\nNote that ``inflect`` also correctly handles calls to the ``num()`` method\n(whether interpolated or antecedent). The ``inflect()`` method has\na related extra feature, in that it *automatically* cancels any \"default\nnumber\" value before it returns its interpolated string. This means that\ncalls to ``num()`` which are embedded in an ``inflect()``-interpolated\nstring do not \"escape\" and interfere with subsequent inflections.\n\n\nMODERN VS CLASSICAL INFLECTIONS\n===============================\n\nCertain words, mainly of Latin or Ancient Greek origin, can form\nplurals either using the standard English \"-s\" suffix, or with \ntheir original Latin or Greek inflections. For example::\n\n        p.plural(\"stigma\")            # -> \"stigmas\" or \"stigmata\"\n        p.plural(\"torus\")             # -> \"toruses\" or \"tori\"\n        p.plural(\"index\")             # -> \"indexes\" or \"indices\"\n        p.plural(\"millennium\")        # -> \"millenniums\" or \"millennia\"\n        p.plural(\"ganglion\")          # -> \"ganglions\" or \"ganglia\"\n        p.plural(\"octopus\")           # -> \"octopuses\" or \"octopodes\"\n\n\ninflect.py caters to such words by providing an\n\"alternate state\" of inflection known as \"classical mode\".\nBy default, words are inflected using their contemporary English\nplurals, but if classical mode is invoked, the more traditional \nplural forms are returned instead.\n\nThe method ``classical()`` controls this feature.\nIf ``classical()`` is called with no arguments, it unconditionally\ninvokes classical mode. If it is called with a single argument, it\nturns all classical inflects on or off (depending on whether the argument is\ntrue or false). If called with two or more arguments, those arguments \nspecify which aspects of classical behaviour are to be used.\n\nThus::\n\n        p.classical()                # SWITCH ON CLASSICAL MODE\n        print(p.plural(\"formula\")        # -> \"formulae\")\n\n        p.classical(all=False)               # SWITCH OFF CLASSICAL MODE\n        print(p.plural(\"formula\")        # -> \"formulas\")\n\n        p.classical(cmode=True)           # CLASSICAL MODE IFF cmode\n        print(p.plural(\"formula\")        # -> \"formulae\" (IF cmode))\n                                     # -> \"formulas\" (OTHERWISE)\n\n        p.classical(herd=True)          # SWITCH ON CLASSICAL MODE FOR \"HERD\" NOUNS\n        print(p.plural(\"wilderbeest\")    # -> \"wilderbeest\")\n\n        p.classical(names=True)         # SWITCH ON CLASSICAL MODE FOR NAMES\n        print(p.plural(\"sally\")          # -> \"sallies\")\n        print(p.plural(\"Sally\")          # -> \"Sallys\")\n\nNote however that ``classical()`` has no effect on the inflection of words which\nare now fully assimilated. Hence::\n\n        p.plural(\"forum\")             # ALWAYS -> \"forums\"\n        p.plural(\"criterion\")         # ALWAYS -> \"criteria\"\n\nLEI assumes that a capitalized word is a person's name. So it forms the\nplural according to the rules for names (which is that you don't\ninflect, you just add -s or -es). You can choose to turn that behaviour\noff (it's on by the default, even when the module isn't in classical\nmode) by calling `` classical(names=0) ``\n\nUSER-DEFINED INFLECTIONS\n========================\n\nAdding plurals at run-time\n--------------------------\n\ninflect.py provides five methods which allow\nthe programmer to override the module's behaviour for specific cases:\n\n\n``defnoun(singular, plural)``\n\n The ``defnoun`` method takes a pair of string arguments: the singular and the\n plural forms of the noun being specified. The singular form \n specifies a pattern to be interpolated (as ``m/^(?:$first_arg)$/i``).\n Any noun matching this pattern is then replaced by the string in the\n second argument. The second argument specifies a string which is\n interpolated after the match succeeds, and is then used as the plural\n form. For example::\n\n      defnoun( 'cow'        , 'kine')\n      defnoun( '(.+i)o'     , '$1i')\n      defnoun( 'spam(mer)?' , '\\\\$\\\\%\\\\@#\\\\$\\\\@#!!')\n\n Note that both arguments should usually be specified in single quotes,\n so that they are not interpolated when they are specified, but later (when\n words are compared to them). As indicated by the last example, care\n also needs to be taken with certain characters in the second argument,\n to ensure that they are not unintentionally interpolated during comparison.\n\n The second argument string may also specify a second variant of the plural\n form, to be used when \"classical\" plurals have been requested. The beginning\n of the second variant is marked by a '|' character::\n\n      defnoun( 'cow'        , 'cows|kine')\n      defnoun( '(.+i)o'     , '$1os|$1i')\n      defnoun( 'spam(mer)?' , '\\\\$\\\\%\\\\@#\\\\$\\\\@#!!|varmints')\n\n If no classical variant is given, the specified plural form is used in\n both normal and \"classical\" modes.\n\n\n..\n   #TODO: check that the following paragraph is implemented\n\n If the second argument is ``None`` instead of a string, then the\n current user definition for the first argument is removed, and the\n standard plural inflection(s) restored.\n\n\n Note that in all cases, later plural definitions for a particular\n singular form replace earlier definitions of the same form. For example::\n\n      # FIRST, HIDE THE MODERN FORM....\n      defnoun( 'aviatrix' , 'aviatrices')\n\n      # LATER, HIDE THE CLASSICAL FORM...\n      defnoun( 'aviatrix' , 'aviatrixes')\n\n      # FINALLY, RESTORE THE DEFAULT BEHAVIOUR...\n      defnoun( 'aviatrix' , undef)\n\n\n Special care is also required when defining general patterns and\n associated specific exceptions: put the more specific cases *after*\n the general pattern. For example::\n\n      defnoun( '(.+)us' , '$1i')      # EVERY \"-us\" TO \"-i\"\n      defnoun( 'bus'    , 'buses')    # EXCEPT FOR \"bus\"\n\n This \"try-most-recently-defined-first\" approach to matching\n user-defined words is also used by ``defverb``, ``defa`` and ``defan``.\n\n\n``defverb(s1, p1, s2, p2, s3, p3)``\n\n The ``defverb`` method takes three pairs of string arguments (that is, six\n arguments in total), specifying the singular and plural forms of the three\n \"persons\" of verb. As with ``defnoun``, the singular forms are specifications of\n run-time-interpolated patterns, whilst the plural forms are specifications of\n (up to two) run-time-interpolated strings::\n\n       defverb('am'       , 'are',\n                'are'      , 'are|art\",\n                'is'       , 'are')\n\n       defverb('have'     , 'have',\n                'have'     , 'have\",\n                'ha(s|th)' , 'have')\n\n Note that as with ``defnoun``, modern/classical variants of plurals\n may be separately specified, subsequent definitions replace previous\n ones, and ``None``'ed plural forms revert to the standard behaviour.\n\n\n``defadj(singular, plural)``\n\n The ``defadj`` method takes a pair of string arguments, which specify\n the singular and plural forms of the adjective being defined.\n As with ``defnoun`` and ``defadj``, the singular forms are specifications of\n run-time-interpolated patterns, whilst the plural forms are specifications of\n (up to two) run-time-interpolated strings::\n\n       defadj( 'this'     , 'these')\n       defadj( 'red'      , 'red|gules')\n\n As previously, modern/classical variants of plurals\n may be separately specified, subsequent definitions replace previous\n ones, and ``None``'ed plural forms revert to the standard behaviour.\n\n\n``defa(pattern)`` and ``defan(pattern)``\n\n The ``defa`` and ``defan`` methods each take a single argument, which\n specifies a pattern. If a word passed to ``a()`` or ``an()`` matches this\n pattern, it will be prefixed (unconditionally) with the corresponding indefinite\n article. For example::\n\n      defa( 'error')\n      defa( 'in.+')\n\n      defan('mistake')\n      defan('error')\n\n As with the other ``def_...`` methods, such redefinitions are sequential\n in effect so that, after the above example, \"error\" will be inflected with \"an\".\n\n\nThe ``<$HOME/.inflectrc`` file\n------------------------------\n\nTHIS HAS NOT BEEN IMPLEMENTED IN THE PYTHON VERSION YET\n\nWhen it is imported, inflect.py executes (as Perl code)\nthe contents of any file named ``.inflectrc`` which it finds in the\nin the directory where ``Lingua/EN/Inflect.pm`` is installed,\nor in the current home directory (``$ENV{HOME}``), or in both.\nNote that the code is executed within the inflect.py\nnamespace.\n\nHence the user or the local Perl guru can make appropriate calls to\n``defnoun``, ``defverb``, etc. in one of these ``.inflectrc`` files, to\npermanently and universally modify the behaviour of the module. For example\n\n      > cat /usr/local/lib/perl5/Text/Inflect/.inflectrc\n\n      defnoun  \"UNIX\"  => \"UN*X|UNICES\"\n\n      defverb  \"teco\"  => \"teco\",      # LITERALLY: \"to edit with TECO\"\n                \"teco\"  => \"teco\",\n                \"tecos\" => \"teco\"\n\n      defa     \"Euler.*\";              # \"Yewler\" TURNS IN HIS GRAVE\n\n\nNote that calls to the ``def_...`` methods from within a program\nwill take precedence over the contents of the home directory\nF<.inflectrc> file, which in turn takes precedence over the system-wide\nF<.inflectrc> file.\n\n\nDIAGNOSTICS\n===========\n\nTHIS HAS NOT BEEN IMPLEMENTED IN THE PYTHON VERSION YET\n\nOn loading, if the Perl code in a ``.inflectrc`` file is invalid\n(syntactically or otherwise), an appropriate fatal error is issued.\nA common problem is not ending the file with something that\nevaluates to true (as the five ``def_...`` methods do).\n\nUsing the five ``def_...`` methods directly in a program may also\nresult in fatal diagnostics, if a (singular) pattern or an interpolated\n(plural) string is somehow invalid.\n\nSpecific diagnostics related to user-defined inflections are:\n\n\n``\"Bad user-defined singular pattern:\\t %s\"``\n\n The singular form of a user-defined noun or verb\n (as defined by a call to ``defnoun``, ``defverb``, ``defadj``,\n ``defa`` or ``defan``) is not a valid Perl regular expression. The\n actual Perl error message is also given.\n\n``\"Bad user-defined plural string: '%s'\"``\n\n The plural form(s) of a user-defined noun or verb\n (as defined by a call to ``defnoun``, ``defverb`` or ``defadj``)\n is not a valid Perl interpolated string (usually because it \n interpolates some undefined variable).\n\n``\"Bad .inflectrc file (%s): %s\"``\n\n Some other problem occurred in loading the named local \n or global F<.inflectrc> file. The Perl error message (including\n the line number) is also given.\n\n\nThere are *no* diagnosable run-time error conditions for the actual\ninflection methods, except ``number_to_words`` and hence no run-time\ndiagnostics. If the inflection methods are unable to form a plural\nvia a user-definition or an inbuilt rule, they just \"guess\" the\ncommonest English inflection: adding \"-s\" for nouns, removing \"-s\" for\nverbs, and no inflection for adjectives.\n\n``inflect.py`` can raise the following execeptions:\n\n``BadChunkingOptionError``\n\n The optional argument to ``number_to_words()`` wasn't 1, 2 or 3.\n\n``NumOutOfRangeError``\n\n ``number_to_words()`` was passed a number larger than\n 999,999,999,999,999,999,999,999,999,999,999,999 (that is: nine hundred\n and ninety-nine decillion, nine hundred and ninety-nine nonillion, nine\n hundred and ninety-nine octillion, nine hundred and ninety-nine\n septillion, nine hundred and ninety-nine sextillion, nine hundred and\n ninety-nine quintillion, nine hundred and ninety-nine quadrillion, nine\n hundred and ninety-nine trillion, nine hundred and ninety-nine billion,\n nine hundred and ninety-nine million, nine hundred and ninety-nine\n thousand, nine hundred and ninety-nine :-) \n\n The problem is that ``number_to_words`` doesn't know any\n words for number components bigger than \"decillion\".\n\n\n..\n   #TODO expand these\n\n``UnknownClassicalModeError``\n\n``BadNumValueError``\n\n``BadUserDefinedPatternError``\n\n``BadRcFileError``\n\n\nOTHER ISSUES\n============\n\n2nd Person precedence\n---------------------\n\nIf a verb has identical 1st and 2nd person singular forms, but\ndifferent 1st and 2nd person plural forms, then when its plural is\nconstructed, the 2nd person plural form is always preferred.\n\nThe author is not currently aware of any such verbs in English, but is\nnot quite arrogant enough to assume *ipso facto* that none exist.\n\n\nNominative precedence\n---------------------\n\nThe singular pronoun \"it\" presents a special problem because its plural form\ncan vary, depending on its \"case\". For example::\n\n        It ate my homework       ->  They ate my homework\n        It ate it                ->  They ate them\n        I fed my homework to it  ->  I fed my homework to them\n\nAs a consequence of this ambiguity, ``plural()`` or ``plural_noun`` have been implemented\nso that they always return the *nominative* plural (that is, \"they\").\n\nHowever, when asked for the plural of an unambiguously *accusative*\n\"it\" (namely, ``plural(\"to it\")``, ``plural_noun(\"from it\")``, ``plural(\"with it\")``,\netc.), both methods will correctly return the accusative plural\n(\"to them\", \"from them\", \"with them\", etc.)\n\n\nThe plurality of zero\n---------------------\n\nThe rules governing the choice between::\n\n      There were no errors.\n\nand\n\n::\n\n      There was no error.\n\nare complex and often depend more on *intent* rather than *content*.\nHence it is infeasible to specify such rules algorithmically.\n\nTherefore, inflect.py contents itself with the following compromise: If\nthe governing number is zero, inflections always return the plural form\nunless the appropriate \"classical\" inflection is in effect, in which case the\nsingular form is always returned.\n\nThus, the sequence::\n\n      p.num(0)\n      print(p.inflect(\"There plural(was) no(choice)\"))\n\nproduces \"There were no choices\", whereas::\n\n      p.classical(zero=True)\n      p.num(0)\n      print(p.inflect(\"There plural(was) no(choice)\"))\n\nit will print(\"There was no choice\".)\n\n\nHomographs with heterogeneous plurals\n-------------------------------------\n\nAnother context in which intent (and not content) sometimes determines\nplurality is where two distinct meanings of a word require different\nplurals. For example::\n\n      Three basses were stolen from the band's equipment trailer.\n      Three bass were stolen from the band's aquarium.\n\n      I put the mice next to the cheese.\n      I put the mouses next to the computers.\n\n      Several thoughts about leaving crossed my mind.\n      Several thought about leaving across my lawn.\n\ninflect.py handles such words in two ways:\n\n\n- If both meanings of the word are the *same* part of speech (for\n  example, \"bass\" is a noun in both sentences above), then one meaning\n  is chosen as the \"usual\" meaning, and only that meaning's plural is\n  ever returned by any of the inflection methods.\n\n- If each meaning of the word is a different part of speech (for\n  example, \"thought\" is both a noun and a verb), then the noun's\n  plural is returned by ``plural()`` and ``plural_noun()`` and the verb's plural is\n  returned only by ``plural_verb()``.\n\n\nSuch contexts are, fortunately, uncommon (particularly\n\"same-part-of-speech\" examples). An informal study of nearly 600\n\"difficult plurals\" indicates that ``plural()`` can be relied upon to \"get\nit right\" about 98% of the time (although, of course, ichthyophilic\nguitarists or cyber-behaviouralists may experience higher rates of\nconfusion).\n\nIf the choice of a particular \"usual inflection\" is considered\ninappropriate, it can always be reversed with a preliminary call\nto the corresponding ``def_...`` method.\n\nNOTE\n====\n\nThere will be no further correspondence on:\n\n\"octopi\".\n\n Despite the populist pandering of certain New World dictionaries, the\n plural is \"octopuses\" or (for the pendantic classicist) \"octopodes\". The\n suffix \"-pus\" is Greek, not Latin, so the plural is \"-podes\", not \"pi\".\n\n\n\"virus\".\n\n Had no plural in Latin (possibly because it was a mass noun).\n The only plural is the Anglicized \"viruses\".\n\n\nAUTHORS\n=======\n\nThorben Kr\u00fcger (github@benthor.name)\n* established Python 3 compatibility\n\nPaul Dyson (pwdyson@yahoo.com)\n* converted code from Perl to Python\n* added singular_noun functionality\n\nOriginal Perl version of the code and documentation:\nDamian Conway (damian@conway.org),\nMatthew Persico (ORD inflection)\n\n\nBUGS AND IRRITATIONS\n====================\n\nThe endless inconsistencies of English.\n\n(*Please* report words for which the correct plural or\nindefinite article is not formed, so that the reliability\nof inflect.py can be improved.)\n\n\n\nCOPYRIGHT\n=========\n\n    Copyright (C) 2010 Paul Dyson\n\n    Based upon the Perl module Lingua::EN::Inflect by Damian Conway.\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n    The original Perl module Lingua::EN::Inflect by Damian Conway is \n    available from http://search.cpan.org/~dconway/\n\n    This module can be downloaded at http://pypi.python.org/pypi/inflect\n\n    This module can be installed via ``easy_install inflect``\n\n    Repository available at http://github.com/pwdyson/inflect.py",
    "docs_url": null,
    "download_url": null,
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "http://pypi.python.org/pypi/inflect",
    "keywords": "plural,inflect,participle",
    "license": null,
    "maintainer": null,
    "maintainer_email": null,
    "name": "inflect",
    "platform": "UNKNOWN",
    "project_url": "https://pypi.org/project/inflect/",
    "release_url": "https://pypi.org/project/inflect/0.2.5/",
    "requires_python": null,
    "summary": "Correctly generate plurals, singular nouns, ordinals, indefinite articles; convert numbers to words",
    "version": "0.2.5"
  },
  "releases": {
    "0.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "8bcd0300b26c155fb6b6c9557b8676d1",
          "sha256": "7d10357c072ece635e88ec6b493269fa0727821be3d34577159efb4037c20876"
        },
        "downloads": 3169,
        "filename": "inflect-0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "8bcd0300b26c155fb6b6c9557b8676d1",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 48744,
        "upload_time": "2010-06-14T02:25:09",
        "url": "https://files.pythonhosted.org/packages/3b/d2/a660a731626cdac2fafed3b8f131e05dc65a2a96bca9d17720479cf2c958/inflect-0.1.tar.gz"
      }
    ],
    "0.1.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "d5c743b31be1ed0572d6686e2249e38e",
          "sha256": "d953575117744d90c5836620e7fa885a5702d935f231f4b7680cc3a59ad95c38"
        },
        "downloads": 2803,
        "filename": "inflect-0.1.1.tar.gz",
        "has_sig": false,
        "md5_digest": "d5c743b31be1ed0572d6686e2249e38e",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 80451,
        "upload_time": "2010-06-17T05:47:34",
        "url": "https://files.pythonhosted.org/packages/b6/6b/4a48f8525bb88a49588c98f6b223866ab62a769346cda81a530d121b2d81/inflect-0.1.1.tar.gz"
      }
    ],
    "0.1.2": [
      {
        "comment_text": "",
        "digests": {
          "md5": "710786f019fb487bb3a3748eda589e90",
          "sha256": "d4e4351b56b940aef7c069333126f2aa14a68a161de0466419076d3be062ce26"
        },
        "downloads": 2777,
        "filename": "inflect-0.1.2.tar.gz",
        "has_sig": false,
        "md5_digest": "710786f019fb487bb3a3748eda589e90",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 66533,
        "upload_time": "2010-06-21T03:10:24",
        "url": "https://files.pythonhosted.org/packages/e2/f0/106e6d942efa5980a8c0062caa20788df3909f20dffe23d6bc30b1d2db8c/inflect-0.1.2.tar.gz"
      }
    ],
    "0.1.3": [
      {
        "comment_text": "",
        "digests": {
          "md5": "8d41a2e53026f4c343511523b4d60c58",
          "sha256": "8728816d477078b088e23cd74f9ca97bccebdc8ba0ed4c4262f1f567f7bf7220"
        },
        "downloads": 2789,
        "filename": "inflect-0.1.3.tar.gz",
        "has_sig": false,
        "md5_digest": "8d41a2e53026f4c343511523b4d60c58",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 66863,
        "upload_time": "2010-06-21T14:45:52",
        "url": "https://files.pythonhosted.org/packages/44/f5/a8d8cc197c38bf21fd0761ca6a48509ab7961622fcbc42f4885356070f45/inflect-0.1.3.tar.gz"
      }
    ],
    "0.1.4": [
      {
        "comment_text": "",
        "digests": {
          "md5": "418389cc59eb1352fbce29f0711be4a9",
          "sha256": "d1bd918fbd58b2fac5e09ed2004237cb403b5b7366d7ca3b067933ad30b83e0a"
        },
        "downloads": 2910,
        "filename": "inflect-0.1.4.tar.gz",
        "has_sig": false,
        "md5_digest": "418389cc59eb1352fbce29f0711be4a9",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 68131,
        "upload_time": "2010-06-24T14:17:43",
        "url": "https://files.pythonhosted.org/packages/01/6b/2f1fbaf1d7f729d407a77bcf12bbc895ef4a77725b9d2027ff02821b29b1/inflect-0.1.4.tar.gz"
      }
    ],
    "0.1.5": [
      {
        "comment_text": "",
        "digests": {
          "md5": "75c8082b202d6a751d0f815e8c6b20c6",
          "sha256": "79bff53163dd8658d3fb2e1798967c69afb07d45fc5bdbbe9b6ab41cb8429637"
        },
        "downloads": 2771,
        "filename": "inflect-0.1.5.tar.gz",
        "has_sig": false,
        "md5_digest": "75c8082b202d6a751d0f815e8c6b20c6",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 68041,
        "upload_time": "2010-06-26T14:14:05",
        "url": "https://files.pythonhosted.org/packages/a1/1e/f0220686fb36e4dfd84b0871add4855a480c64f156c3d2d569cc049c0211/inflect-0.1.5.tar.gz"
      }
    ],
    "0.1.6": [
      {
        "comment_text": "",
        "digests": {
          "md5": "6058d8ce3438537be9a58f46d0e04e73",
          "sha256": "289b93f2dafda339c10a253e86f66c02f45843e8292e995ac843bec6f85cb03a"
        },
        "downloads": 2786,
        "filename": "inflect-0.1.6.tar.gz",
        "has_sig": false,
        "md5_digest": "6058d8ce3438537be9a58f46d0e04e73",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 83825,
        "upload_time": "2010-07-03T15:48:50",
        "url": "https://files.pythonhosted.org/packages/d6/80/fec06e115acff422f898854a99607771a604753d2489db8a1000b35e7a76/inflect-0.1.6.tar.gz"
      }
    ],
    "0.1.7": [
      {
        "comment_text": "",
        "digests": {
          "md5": "e8616667f478e5bf9f2094a62210f5d4",
          "sha256": "d2e73f94e7093f402ee0663ea789dfa3de6c17dff818b179248168c690cb6398"
        },
        "downloads": 2752,
        "filename": "inflect-0.1.7.tar.gz",
        "has_sig": false,
        "md5_digest": "e8616667f478e5bf9f2094a62210f5d4",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 85761,
        "upload_time": "2010-07-09T12:55:24",
        "url": "https://files.pythonhosted.org/packages/c8/f3/044e692504986564feb4307edcb18bbe93c7ddecd73a34a136acb80d8147/inflect-0.1.7.tar.gz"
      }
    ],
    "0.1.8": [
      {
        "comment_text": "",
        "digests": {
          "md5": "12c7738d595b716a8527e34e4b93188d",
          "sha256": "d4e0ca18b7191a311710ad7c0706201a718caa5ad3d57aed9642b8cd87d603b0"
        },
        "downloads": 2967,
        "filename": "inflect-0.1.8.tar.gz",
        "has_sig": false,
        "md5_digest": "12c7738d595b716a8527e34e4b93188d",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 89323,
        "upload_time": "2010-07-10T15:13:06",
        "url": "https://files.pythonhosted.org/packages/e9/4a/c297ef4043fe2fc662450e96530103d70b512ceb58421714e95b2df02d2b/inflect-0.1.8.tar.gz"
      }
    ],
    "0.2.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "b148f2a74282a960676d16ea896b0034",
          "sha256": "1da998ebdf09b3ef3be1f288bb8b3d598ea217888abf64fa6d1773176f026b56"
        },
        "downloads": 2778,
        "filename": "inflect-0.2.0.tar.gz",
        "has_sig": false,
        "md5_digest": "b148f2a74282a960676d16ea896b0034",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 90693,
        "upload_time": "2010-08-07T01:27:39",
        "url": "https://files.pythonhosted.org/packages/86/18/d9e2b200ba98263bddf1c30e5650935c1e72df77f312af405033e999ffa6/inflect-0.2.0.tar.gz"
      }
    ],
    "0.2.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "b34bec6cec8d976844b5d295acf0aa3d",
          "sha256": "8290bb78a02a11854619f342b6d8308a75068382b6e97fdb55ca337cc90b5223"
        },
        "downloads": 11080,
        "filename": "inflect-0.2.1.tar.gz",
        "has_sig": false,
        "md5_digest": "b34bec6cec8d976844b5d295acf0aa3d",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 90697,
        "upload_time": "2010-08-31T13:09:40",
        "url": "https://files.pythonhosted.org/packages/aa/7b/1fbc94a1ada7c192cc71d133c6eb78d132b8a69afc0f7694fd6ebc5643ab/inflect-0.2.1.tar.gz"
      }
    ],
    "0.2.3": [
      {
        "comment_text": "",
        "digests": {
          "md5": "83dcb28aa4d8e6bae52e506a0f3c4ddc",
          "sha256": "c0dba116c6c0a8b80f9d10f3adf029e673d8be1b1b32a56a0d49fc70b94e1de0"
        },
        "downloads": 23284,
        "filename": "inflect-0.2.3.zip",
        "has_sig": false,
        "md5_digest": "83dcb28aa4d8e6bae52e506a0f3c4ddc",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 97640,
        "upload_time": "2012-06-10T23:14:28",
        "url": "https://files.pythonhosted.org/packages/60/be/d5c29660b0575b16b553c68f1935b0943ea42680efcb01b63e7ae68bf3ed/inflect-0.2.3.zip"
      }
    ],
    "0.2.4": [
      {
        "comment_text": "",
        "digests": {
          "md5": "fc2d807b600c4e959e993690ffa573bc",
          "sha256": "be63ed78f8da783be74cb02ae261e1f9cf4ea2c60cbf2f91862e1429c7011c89"
        },
        "downloads": 324429,
        "filename": "inflect-0.2.4.tar.gz",
        "has_sig": false,
        "md5_digest": "fc2d807b600c4e959e993690ffa573bc",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 91344,
        "upload_time": "2013-06-09T07:11:37",
        "url": "https://files.pythonhosted.org/packages/46/da/33ee1aec598d8202bd0b6c77565e776be9db0782545b3a64f3cc272e6135/inflect-0.2.4.tar.gz"
      }
    ],
    "0.2.5": [
      {
        "comment_text": "",
        "digests": {
          "md5": "453c5662f13ca3d192d79385d3c07486",
          "sha256": "0e2358f4f46a54cca3d77b983fa3708b02dc83acd8d28466a67e88b72e5c1b34"
        },
        "downloads": 238932,
        "filename": "inflect-0.2.5-py2.py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "453c5662f13ca3d192d79385d3c07486",
        "packagetype": "bdist_wheel",
        "python_version": "py2.py3",
        "size": 58988,
        "upload_time": "2015-01-09T21:01:53",
        "url": "https://files.pythonhosted.org/packages/66/15/2d176749884cbeda0c92e0d09e1303ff53a973eb3c6bb2136803b9d962c9/inflect-0.2.5-py2.py3-none-any.whl"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "ca9ecb838687253eedc6c81f59c656a7",
          "sha256": "2014c8dcb2114ebae2941ba3f0fbd98a02c846792a7b72f2da31eb9aa431a818"
        },
        "downloads": 38173,
        "filename": "inflect-0.2.5.tar.gz",
        "has_sig": false,
        "md5_digest": "ca9ecb838687253eedc6c81f59c656a7",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 109756,
        "upload_time": "2015-01-09T21:02:02",
        "url": "https://files.pythonhosted.org/packages/e1/5d/478a8e9d8b7cc004a36b75369f9caf1c23cd7ba0b97af146b516c49923d9/inflect-0.2.5.tar.gz"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "453c5662f13ca3d192d79385d3c07486",
        "sha256": "0e2358f4f46a54cca3d77b983fa3708b02dc83acd8d28466a67e88b72e5c1b34"
      },
      "downloads": 238932,
      "filename": "inflect-0.2.5-py2.py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "453c5662f13ca3d192d79385d3c07486",
      "packagetype": "bdist_wheel",
      "python_version": "py2.py3",
      "size": 58988,
      "upload_time": "2015-01-09T21:01:53",
      "url": "https://files.pythonhosted.org/packages/66/15/2d176749884cbeda0c92e0d09e1303ff53a973eb3c6bb2136803b9d962c9/inflect-0.2.5-py2.py3-none-any.whl"
    },
    {
      "comment_text": "",
      "digests": {
        "md5": "ca9ecb838687253eedc6c81f59c656a7",
        "sha256": "2014c8dcb2114ebae2941ba3f0fbd98a02c846792a7b72f2da31eb9aa431a818"
      },
      "downloads": 38173,
      "filename": "inflect-0.2.5.tar.gz",
      "has_sig": false,
      "md5_digest": "ca9ecb838687253eedc6c81f59c656a7",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 109756,
      "upload_time": "2015-01-09T21:02:02",
      "url": "https://files.pythonhosted.org/packages/e1/5d/478a8e9d8b7cc004a36b75369f9caf1c23cd7ba0b97af146b516c49923d9/inflect-0.2.5.tar.gz"
    }
  ]
}