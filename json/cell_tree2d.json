{
  "info": {
    "author": "Jay Hennen",
    "author_email": "jay.hennen@noaa.gov",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 2 - Pre-Alpha",
      "Intended Audience :: Developers",
      "Intended Audience :: Science/Research",
      "License :: Public Domain",
      "Operating System :: OS Independent",
      "Programming Language :: C++",
      "Programming Language :: Cython",
      "Programming Language :: Python :: 2 :: Only",
      "Programming Language :: Python :: Implementation :: CPython",
      "Topic :: Scientific/Engineering",
      "Topic :: Scientific/Engineering :: Visualization",
      "Topic :: Utilities"
    ],
    "description": "========\ncell_tree2d\n========\n\nA module that provides the CellTree data structure as described by Garth and Joy in their 2010 paper  \nhttp://graphics.cs.ucdavis.edu/~joy/NSF-IIS-0916289/Papers/GarthTVCG2011.pdf  \n\nThis implementation is 2D specific and includes some additions useful to answering one question: \n_\"What is the index of the polygon that contains this point?\"_\n\n========\nAlgorithm Notes\n========\n\nThere are two major benefits to this algorithm over other types of BVHs. First is that overlaps in volumes\nbounded by nodes do not create duplicates, decreasing the memory footprint. Secondly, the tree is balanced\nby splitting a node along the plane that minimizes a cost function that 'weighs' each half. The result is\na tree with no duplicates and that becomes increasingly balanced as the number of buckets used when building\nthe tree increases (though this linearly increases build time).\n\nThis is a 2D version of the algorithm that is oriented towards maximum lookup speed and immediate answer\nchecking. The basic CellTree does not hold enough information to give conclusive point-in-polygon answers; \nthe best it can do is provide the (short) list of cells that contain the point. Since a point can be within\nthe bounds of two different leaves, and it is very possible both children of a parent node will need to be \nsearched, implementing immediate point-in-polygon checks on each cell as they are encountered is highly\nbeneficial, as an early success will avoid all further tree traversal.\n\n======== \nUsage Notes\n========\n\nThe tree needs certain information to be built:  \n1. 'verts' - A 2xV numpy array containing x/y coordinates of the V vertices   \n2. 'faces' - A PxN numpy array containing N arrays of P indices of vertices that describe one 'face' or polygon of degree P  \n3. 'num_buckets' - The # of buckets desired. Must be >= 2 The default is 4. Values higher than 8 begin to provide diminishing returns.  \n4. 'cells\\_per\\_leaf' - The # of polygons per leaf node. The default is 2. Using 1 is possible, but doubles memory footprint for only slightly.\nfaster lookup. If memory is a concern, this value can be increased, but lookup performance will quickly be impacted  \n\nIMPORTANT: 'verts' and 'faces' MUST describe a _properly formed_ unstructed grid. Assume that degenerate (0 area) or\noverlapping polygons WILL cause a build failure. If the construction of the tree causes a segfault, this is probably\nthe cause.",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "https://github.com/NOAA-ORR-ERD",
    "keywords": "",
    "license": "Public Domain",
    "maintainer": "",
    "maintainer_email": "",
    "name": "cell_tree2d",
    "platform": "UNKNOWN",
    "project_url": "https://pypi.org/project/cell_tree2d/",
    "release_url": "https://pypi.org/project/cell_tree2d/0.1.1/",
    "requires_python": "",
    "summary": "Python wrappers around Cell-Tree 2D spatial index",
    "version": "0.1.1"
  },
  "releases": {
    "0.1.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "06f95190c341e9fc6963dbd40274ef98",
          "sha256": "c7c7514cf5ffd53c13118d35730568b00150f4d565a6023bf0d3eae68c72051d"
        },
        "downloads": 535,
        "filename": "cell_tree2d-0.1.1-1.zip",
        "has_sig": false,
        "md5_digest": "06f95190c341e9fc6963dbd40274ef98",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 123951,
        "upload_time": "2016-02-26T22:17:55",
        "url": "https://files.pythonhosted.org/packages/c7/f4/58e09e363189e4a6fafbb67157ccf2784d90fddfa0e9766eb2a8be4fc3e8/cell_tree2d-0.1.1-1.zip"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "06f95190c341e9fc6963dbd40274ef98",
        "sha256": "c7c7514cf5ffd53c13118d35730568b00150f4d565a6023bf0d3eae68c72051d"
      },
      "downloads": 535,
      "filename": "cell_tree2d-0.1.1-1.zip",
      "has_sig": false,
      "md5_digest": "06f95190c341e9fc6963dbd40274ef98",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 123951,
      "upload_time": "2016-02-26T22:17:55",
      "url": "https://files.pythonhosted.org/packages/c7/f4/58e09e363189e4a6fafbb67157ccf2784d90fddfa0e9766eb2a8be4fc3e8/cell_tree2d-0.1.1-1.zip"
    }
  ]
}