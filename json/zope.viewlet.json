{
  "info": {
    "author": "Zope Foundation and Contributors",
    "author_email": "zope-dev@zope.org",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Environment :: Web Environment",
      "Framework :: Zope3",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: Zope Public License",
      "Natural Language :: English",
      "Operating System :: OS Independent",
      "Programming Language :: Python",
      "Programming Language :: Python :: 2",
      "Programming Language :: Python :: 2.6",
      "Programming Language :: Python :: 2.7",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.3",
      "Programming Language :: Python :: 3.4",
      "Programming Language :: Python :: Implementation :: CPython",
      "Programming Language :: Python :: Implementation :: PyPy",
      "Topic :: Internet :: WWW/HTTP"
    ],
    "description": "``zope.viewlet`` README\n=======================\n\nViewlets provide a generic framework for building pluggable user interfaces.\n\n\nDetailed Documentation\n**********************\n\n\n\n=============================\nViewlets and Viewlet Managers\n=============================\n\nLet's start with some motivation. Using content providers allows us to insert\none piece of HTML content. In most Web development, however, you are often\ninterested in defining some sort of region and then allow developers to\nregister content for those regions.\n\n  >>> from zope.viewlet import interfaces\n\n\nDesign Notes\n------------\n\nAs mentioned above, besides inserting snippets of HTML at places, we more\nfrequently want to define a region in our page and allow specialized content\nproviders to be inserted based on configuration. Those specialized content\nproviders are known as viewlets and are only available inside viewlet\nmanagers, which are just a more complex example of content providers.\n\nUnfortunately, the Java world does not implement this layer separately. The\nviewlet manager is most similar to a Java \"channel\", but we decided against\nusing this name, since it is very generic and not very meaningful. The viewlet\nhas no Java counterpart, since Java does not implement content providers using\na component architecture and thus does not register content providers\nspecifically for viewlet managers, which I believe makes the Java\nimplementation less useful as a generic concept. In fact, the main design\ngoal in the Java world is the implementation of reusable and shareable\nportlets. The scope for Zope 3 is larger, since we want to provide a generic\nframework for building pluggable user interfaces.\n\n\nThe Viewlet Manager\n-------------------\n\nIn this implementation of viewlets, those regions are just content providers\ncalled viewlet managers that manage a special type of content providers known\nas viewlets. Every viewlet manager handles the viewlets registered for it:\n\n  >>> class ILeftColumn(interfaces.IViewletManager):\n  ...     \"\"\"Viewlet manager located in the left column.\"\"\"\n\nYou can then create a viewlet manager using this interface now:\n\n  >>> from zope.viewlet import manager\n  >>> LeftColumn = manager.ViewletManager('left', ILeftColumn)\n\nNow we have to instantiate it:\n\n  >>> import zope.interface\n  >>> @zope.interface.implementer(zope.interface.Interface)\n  ... class Content(object):\n  ...     pass\n  >>> content = Content()\n\n  >>> from zope.publisher.browser import TestRequest\n  >>> request = TestRequest()\n\n  >>> from zope.publisher.interfaces.browser import IBrowserView\n  >>> @zope.interface.implementer(IBrowserView)\n  ... class View(object):\n  ...     def __init__(self, context, request):\n  ...         pass\n  >>> view = View(content, request)\n\n  >>> leftColumn = LeftColumn(content, request, view)\n\nSo initially nothing gets rendered:\n\n  >>> leftColumn.update()\n  >>> leftColumn.render()\n  u''\n\nBut now we register some viewlets for the manager\n\n  >>> import zope.component\n  >>> from zope.publisher.interfaces.browser import IDefaultBrowserLayer\n\n  >>> @zope.interface.implementer(interfaces.IViewlet)\n  ... class WeatherBox(object):\n  ...\n  ...     def __init__(self, context, request, view, manager):\n  ...         self.__parent__ = view\n  ...\n  ...     def update(self):\n  ...         pass\n  ...\n  ...     def render(self):\n  ...         return u'<div class=\"box\">It is sunny today!</div>'\n  ...\n  ...     def __repr__(self):\n  ...         return '<WeatherBox object at %x>' % id(self)\n\n  >>> # Create a security checker for viewlets.\n  >>> from zope.security.checker import NamesChecker, defineChecker\n  >>> viewletChecker = NamesChecker(('update', 'render'))\n  >>> defineChecker(WeatherBox, viewletChecker)\n\n  >>> zope.component.provideAdapter(\n  ...     WeatherBox,\n  ...     (zope.interface.Interface, IDefaultBrowserLayer,\n  ...     IBrowserView, ILeftColumn),\n  ...     interfaces.IViewlet, name='weather')\n\n  >>> from zope.location.interfaces import ILocation\n  >>> @zope.interface.implementer(interfaces.IViewlet,\n  ...         ILocation)\n  ... class SportBox(object):\n  ...\n  ...     def __init__(self, context, request, view, manager):\n  ...         self.__parent__ = view\n  ...\n  ...     def update(self):\n  ...         pass\n  ...\n  ...     def render(self):\n  ...         return u'<div class=\"box\">Patriots (23) : Steelers (7)</div>'\n\n  >>> defineChecker(SportBox, viewletChecker)\n\n  >>> zope.component.provideAdapter(\n  ...     SportBox,\n  ...     (zope.interface.Interface, IDefaultBrowserLayer,\n  ...      IBrowserView, ILeftColumn),\n  ...     interfaces.IViewlet, name='sport')\n\nand thus the left column is filled. Note that also events get fired\nbefore viewlets are updated. We register a simple handler to\ndemonstrate this behaviour.\n\n  >>> from zope.contentprovider.interfaces import IBeforeUpdateEvent\n  >>> events = []\n  >>> def handler(ev):\n  ...     events.append(ev)\n  >>> zope.component.provideHandler(handler, (IBeforeUpdateEvent,))\n  >>> leftColumn.update()\n  >>> sorted([(ev, ev.object.__class__.__name__) for ev in events],\n  ...        key=lambda x: x[1])\n  [(<zope.contentprovider.interfaces.BeforeUpdateEvent...>, 'SportBox'),\n   (<zope.contentprovider.interfaces.BeforeUpdateEvent...>, 'WeatherBox')]\n\n  >>> print(leftColumn.render())\n  <div class=\"box\">Patriots (23) : Steelers (7)</div>\n  <div class=\"box\">It is sunny today!</div>\n\nBut this is of course pretty lame, since there is no way of specifying how the\nviewlets are put together. But we have a solution. The second argument of the\n``ViewletManager()`` function is a template in which we can specify how the\nviewlets are put together:\n\n  >>> import os, tempfile\n  >>> temp_dir = tempfile.mkdtemp()\n  >>> leftColTemplate = os.path.join(temp_dir, 'leftCol.pt')\n  >>> with open(leftColTemplate, 'w') as file:\n  ...     _ = file.write('''\n  ... <div class=\"left-column\">\n  ...   <tal:block repeat=\"viewlet options/viewlets\"\n  ...              replace=\"structure viewlet/render\" />\n  ... </div>\n  ... ''')\n\n  >>> LeftColumn = manager.ViewletManager('left', ILeftColumn,\n  ...                                     template=leftColTemplate)\n  >>> leftColumn = LeftColumn(content, request, view)\n\nTODO: Fix this silly thing; viewlets should be directly available.\n\nAs you can see, the viewlet manager provides a global ``options/viewlets``\nvariable that is an iterable of all the available viewlets in the correct\norder:\n\n  >>> leftColumn.update()\n  >>> print(leftColumn.render().strip())\n  <div class=\"left-column\">\n    <div class=\"box\">Patriots (23) : Steelers (7)</div>\n    <div class=\"box\">It is sunny today!</div>\n  </div>\n\nIf a viewlet provides ILocation the ``__name__`` attribute of the\nviewlet is set to the name under which the viewlet is registered.\n\n  >>> [getattr(viewlet, '__name__', None) for viewlet in leftColumn.viewlets]\n  [u'sport', None]\n\n\nYou can also lookup the viewlets directly for management purposes:\n\n  >>> leftColumn['weather']\n  <WeatherBox ...>\n  >>> leftColumn.get('weather')\n  <WeatherBox ...>\n\nThe viewlet manager also provides the __contains__ method defined in\nIReadMapping:\n\n  >>> 'weather' in leftColumn\n  True\n\n  >>> 'unknown' in leftColumn\n  False\n\nIf the viewlet is not found, then the expected behavior is provided:\n\n  >>> leftColumn['stock']\n  Traceback (most recent call last):\n  ...\n  ComponentLookupError: No provider with name `stock` found.\n\n  >>> leftColumn.get('stock') is None\n  True\n\nCustomizing the default Viewlet Manager\n---------------------------------------\n\nOne important feature of any viewlet manager is to be able to filter and sort\nthe viewlets it is displaying. The default viewlet manager that we have been\nusing in the tests above, supports filtering by access availability and\nsorting via the viewlet's ``__cmp__()`` method (default). You can easily\noverride this default policy by providing a base viewlet manager class.\n\nIn our case we will manage the viewlets using a global list:\n\n  >>> shown = ['weather', 'sport']\n\nThe viewlet manager base class now uses this list:\n\n  >>> class ListViewletManager(object):\n  ...\n  ...     def filter(self, viewlets):\n  ...         viewlets = super(ListViewletManager, self).filter(viewlets)\n  ...         return [(name, viewlet)\n  ...                 for name, viewlet in viewlets\n  ...                 if name in shown]\n  ...\n  ...     def sort(self, viewlets):\n  ...         viewlets = dict(viewlets)\n  ...         return [(name, viewlets[name]) for name in shown]\n\nLet's now create a new viewlet manager:\n\n  >>> LeftColumn = manager.ViewletManager(\n  ...     'left', ILeftColumn, bases=(ListViewletManager,),\n  ...     template=leftColTemplate)\n  >>> leftColumn = LeftColumn(content, request, view)\n\nSo we get the weather box first and the sport box second:\n\n  >>> leftColumn.update()\n  >>> print(leftColumn.render().strip())\n  <div class=\"left-column\">\n    <div class=\"box\">It is sunny today!</div>\n    <div class=\"box\">Patriots (23) : Steelers (7)</div>\n  </div>\n\nNow let's change the order...\n\n  >>> shown.reverse()\n\nand the order should switch as well:\n\n  >>> leftColumn.update()\n  >>> print(leftColumn.render().strip())\n  <div class=\"left-column\">\n    <div class=\"box\">Patriots (23) : Steelers (7)</div>\n    <div class=\"box\">It is sunny today!</div>\n  </div>\n\nOf course, we also can remove a shown viewlet:\n\n  >>> weather = shown.pop()\n  >>> leftColumn.update()\n  >>> print(leftColumn.render().strip())\n  <div class=\"left-column\">\n    <div class=\"box\">Patriots (23) : Steelers (7)</div>\n  </div>\n\n\nWeightOrderedViewletManager\n---------------------------\n\nThe weight ordered viewlet manager offers ordering viewlets by a additional\nweight argument. Viewlets which doesn't provide a weight attribute will get\na weight of 0 (zero).\n\nLet's define a new column:\n\n  >>> class IWeightedColumn(interfaces.IViewletManager):\n  ...     \"\"\"Column with weighted viewlet manager.\"\"\"\n\nFirst register a template for the weight ordered viewlet manager:\n\n  >>> weightedColTemplate = os.path.join(temp_dir, 'weightedColTemplate.pt')\n  >>> with open(weightedColTemplate, 'w') as file:\n  ...     _ = file.write('''\n  ... <div class=\"weighted-column\">\n  ...   <tal:block repeat=\"viewlet options/viewlets\"\n  ...              replace=\"structure viewlet/render\" />\n  ... </div>\n  ... ''')\n\nAnd create a new weight ordered viewlet manager:\n\n  >>> from zope.viewlet.manager import WeightOrderedViewletManager\n  >>> WeightedColumn = manager.ViewletManager(\n  ...     'left', IWeightedColumn, bases=(WeightOrderedViewletManager,),\n  ...     template=weightedColTemplate)\n  >>> weightedColumn = WeightedColumn(content, request, view)\n\nLet's create some viewlets:\n\n  >>> from zope.viewlet import viewlet\n  >>> class FirstViewlet(viewlet.ViewletBase):\n  ...\n  ...     weight = 1\n  ...\n  ...     def render(self):\n  ...         return u'<div>first</div>'\n\n  >>> class SecondViewlet(viewlet.ViewletBase):\n  ...\n  ...     weight = 2\n  ...\n  ...     def render(self):\n  ...         return u'<div>second</div>'\n\n  >>> class ThirdViewlet(viewlet.ViewletBase):\n  ...\n  ...     weight = 3\n  ...\n  ...     def render(self):\n  ...         return u'<div>third</div>'\n\n  >>> class UnWeightedViewlet(viewlet.ViewletBase):\n  ...\n  ...     def render(self):\n  ...         return u'<div>unweighted</div>'\n\n  >>> defineChecker(FirstViewlet, viewletChecker)\n  >>> defineChecker(SecondViewlet, viewletChecker)\n  >>> defineChecker(ThirdViewlet, viewletChecker)\n  >>> defineChecker(UnWeightedViewlet, viewletChecker)\n\n  >>> zope.component.provideAdapter(\n  ...     ThirdViewlet,\n  ...     (zope.interface.Interface, IDefaultBrowserLayer,\n  ...      IBrowserView, IWeightedColumn),\n  ...     interfaces.IViewlet, name='third')\n\n  >>> zope.component.provideAdapter(\n  ...     FirstViewlet,\n  ...     (zope.interface.Interface, IDefaultBrowserLayer,\n  ...      IBrowserView, IWeightedColumn),\n  ...     interfaces.IViewlet, name='first')\n\n  >>> zope.component.provideAdapter(\n  ...     SecondViewlet,\n  ...     (zope.interface.Interface, IDefaultBrowserLayer,\n  ...      IBrowserView, IWeightedColumn),\n  ...     interfaces.IViewlet, name='second')\n\n  >>> zope.component.provideAdapter(\n  ...     UnWeightedViewlet,\n  ...     (zope.interface.Interface, IDefaultBrowserLayer,\n  ...      IBrowserView, IWeightedColumn),\n  ...     interfaces.IViewlet, name='unweighted')\n\nAnd check the order:\n\n  >>> weightedColumn.update()\n  >>> print(weightedColumn.render().strip())\n  <div class=\"weighted-column\">\n    <div>unweighted</div>\n    <div>first</div>\n    <div>second</div>\n    <div>third</div>\n  </div>\n\n\nConditionalViewletManager\n-------------------------\n\nThe conditional ordered viewlet manager offers ordering viewlets by a\nadditional weight argument and filters by the available attribute if a\nsupported by the viewlet. Viewlets which doesn't provide a available attribute\nwill not get skipped. The default weight value for viewlets which doesn't\nprovide a weight attribute is 0 (zero).\n\nLet's define a new column:\n\n  >>> class IConditionalColumn(interfaces.IViewletManager):\n  ...     \"\"\"Column with weighted viewlet manager.\"\"\"\n\nFirst register a template for the weight ordered viewlet manager:\n\n  >>> conditionalColTemplate = os.path.join(temp_dir,\n  ...     'conditionalColTemplate.pt')\n  >>> with open(conditionalColTemplate, 'w') as file:\n  ...     _ = file.write('''\n  ... <div class=\"conditional-column\">\n  ...   <tal:block repeat=\"viewlet options/viewlets\"\n  ...              replace=\"structure viewlet/render\" />\n  ... </div>\n  ... ''')\n\nAnd create a new conditional viewlet manager:\n\n  >>> from zope.viewlet.manager import ConditionalViewletManager\n  >>> ConditionalColumn = manager.ViewletManager(\n  ...     'left', IConditionalColumn, bases=(ConditionalViewletManager,),\n  ...     template=conditionalColTemplate)\n  >>> conditionalColumn = ConditionalColumn(content, request, view)\n\nLet's create some viewlets. We also use the previous viewlets supporting no\nweight and or no available attribute:\n\n  >>> from zope.viewlet import viewlet\n  >>> class AvailableViewlet(viewlet.ViewletBase):\n  ...\n  ...     weight = 4\n  ...\n  ...     available = True\n  ...\n  ...     def render(self):\n  ...         return u'<div>available</div>'\n\n  >>> class UnAvailableViewlet(viewlet.ViewletBase):\n  ...\n  ...     weight = 5\n  ...\n  ...     available = False\n  ...\n  ...     def render(self):\n  ...         return u'<div>not available</div>'\n\n  >>> defineChecker(AvailableViewlet, viewletChecker)\n  >>> defineChecker(UnAvailableViewlet, viewletChecker)\n\n  >>> zope.component.provideAdapter(\n  ...     ThirdViewlet,\n  ...     (zope.interface.Interface, IDefaultBrowserLayer,\n  ...      IBrowserView, IConditionalColumn),\n  ...     interfaces.IViewlet, name='third')\n\n  >>> zope.component.provideAdapter(\n  ...     FirstViewlet,\n  ...     (zope.interface.Interface, IDefaultBrowserLayer,\n  ...      IBrowserView, IConditionalColumn),\n  ...     interfaces.IViewlet, name='first')\n\n  >>> zope.component.provideAdapter(\n  ...     SecondViewlet,\n  ...     (zope.interface.Interface, IDefaultBrowserLayer,\n  ...      IBrowserView, IConditionalColumn),\n  ...     interfaces.IViewlet, name='second')\n\n  >>> zope.component.provideAdapter(\n  ...     UnWeightedViewlet,\n  ...     (zope.interface.Interface, IDefaultBrowserLayer,\n  ...      IBrowserView, IConditionalColumn),\n  ...     interfaces.IViewlet, name='unweighted')\n\n  >>> zope.component.provideAdapter(\n  ...     AvailableViewlet,\n  ...     (zope.interface.Interface, IDefaultBrowserLayer,\n  ...      IBrowserView, IConditionalColumn),\n  ...     interfaces.IViewlet, name='available')\n\n  >>> zope.component.provideAdapter(\n  ...     UnAvailableViewlet,\n  ...     (zope.interface.Interface, IDefaultBrowserLayer,\n  ...      IBrowserView, IConditionalColumn),\n  ...     interfaces.IViewlet, name='unavailable')\n\nAnd check the order:\n\n  >>> conditionalColumn.update()\n  >>> print(conditionalColumn.render().strip())\n  <div class=\"conditional-column\">\n    <div>unweighted</div>\n    <div>first</div>\n    <div>second</div>\n    <div>third</div>\n    <div>available</div>\n  </div>\n\n\nViewlet Base Classes\n--------------------\n\nTo make the creation of viewlets simpler, a set of useful base classes and\nhelper functions are provided.\n\nThe first class is a base class that simply defines the constructor:\n\n  >>> base = viewlet.ViewletBase('context', 'request', 'view', 'manager')\n  >>> base.context\n  'context'\n  >>> base.request\n  'request'\n  >>> base.__parent__\n  'view'\n  >>> base.manager\n  'manager'\n\nBut a default ``render()`` method implementation is not provided:\n\n  >>> base.render()\n  Traceback (most recent call last):\n  ...\n  NotImplementedError: `render` method must be implemented by subclass.\n\nIf you have already an existing class that produces the HTML content in some\nmethod, then the ``SimpleAttributeViewlet`` might be for you, since it can be\nused to convert any class quickly into a viewlet:\n\n  >>> class FooViewlet(viewlet.SimpleAttributeViewlet):\n  ...     __page_attribute__ = 'foo'\n  ...\n  ...     def foo(self):\n  ...         return 'output'\n\nThe `__page_attribute__` attribute provides the name of the function to call for\nrendering.\n\n  >>> foo = FooViewlet('context', 'request', 'view', 'manager')\n  >>> foo.foo()\n  'output'\n  >>> foo.render()\n  'output'\n\nIf you specify `render` as the attribute an error is raised to prevent\ninfinite recursion:\n\n  >>> foo.__page_attribute__ = 'render'\n  >>> foo.render()\n  Traceback (most recent call last):\n  ...\n  AttributeError: render\n\nThe same is true if the specified attribute does not exist:\n\n  >>> foo.__page_attribute__ = 'bar'\n  >>> foo.render()\n  Traceback (most recent call last):\n  ...\n  AttributeError: 'FooViewlet' object has no attribute 'bar'\n\nTo create simple template-based viewlets you can use the\n``SimpleViewletClass()`` function. This function is very similar to its view\nequivalent and is used by the ZCML directives to create viewlets. The result\nof this function call will be a fully functional viewlet class. Let's start by\nsimply specifying a template only:\n\n  >>> template = os.path.join(temp_dir, 'demoTemplate.pt')\n  >>> with open(template, 'w') as file:\n  ...     _ = file.write('''<div>contents</div>''')\n\n  >>> Demo = viewlet.SimpleViewletClass(template)\n  >>> print(Demo(content, request, view, manager).render())\n  <div>contents</div>\n\nNow let's additionally specify a class that can provide additional features:\n\n  >>> class MyViewlet(object):\n  ...     myAttribute = 8\n\n  >>> Demo = viewlet.SimpleViewletClass(template, bases=(MyViewlet,))\n  >>> MyViewlet in Demo.__bases__\n  True\n  >>> Demo(content, request, view, manager).myAttribute\n  8\n\nThe final important feature is the ability to pass in further attributes to\nthe class:\n\n  >>> Demo = viewlet.SimpleViewletClass(\n  ...     template, attributes={'here': 'now', 'lucky': 3})\n  >>> demo = Demo(content, request, view, manager)\n  >>> demo.here\n  'now'\n  >>> demo.lucky\n  3\n\nAs for all views, they must provide a name that can also be passed to the\nfunction:\n\n  >>> Demo = viewlet.SimpleViewletClass(template, name='demoViewlet')\n  >>> demo = Demo(content, request, view, manager)\n  >>> demo.__name__\n  'demoViewlet'\n\nIn addition to the the generic viewlet code above, the package comes with two\nviewlet base classes and helper functions for inserting CSS and Javascript\nlinks into HTML headers, since those two are so very common. I am only going\nto demonstrate the helper functions here, since those demonstrations will\nfully demonstrate the functionality of the base classes as well.\n\nThe viewlet will look up the resource it was given and tries to produce the\nabsolute URL for it:\n\n  >>> class JSResource(object):\n  ...     def __init__(self, request):\n  ...         self.request = request\n  ...\n  ...     def __call__(self):\n  ...         return '/@@/resource.js'\n\n  >>> zope.component.provideAdapter(\n  ...     JSResource,\n  ...     (IDefaultBrowserLayer,),\n  ...     zope.interface.Interface, name='resource.js')\n\n  >>> JSViewlet = viewlet.JavaScriptViewlet('resource.js')\n  >>> print(JSViewlet(content, request, view, manager).render().strip())\n  <script type=\"text/javascript\" src=\"/@@/resource.js\"></script>\n\n\nThere is also a javascript viewlet base class which knows how to render more\nthen one javascript resource file:\n\n  >>> class JSSecondResource(object):\n  ...     def __init__(self, request):\n  ...         self.request = request\n  ...\n  ...     def __call__(self):\n  ...         return '/@@/second-resource.js'\n\n  >>> zope.component.provideAdapter(\n  ...     JSSecondResource,\n  ...     (IDefaultBrowserLayer,),\n  ...     zope.interface.Interface, name='second-resource.js')\n\n  >>> JSBundleViewlet = viewlet.JavaScriptBundleViewlet(('resource.js',\n  ...                                                    'second-resource.js'))\n  >>> print(JSBundleViewlet(content, request, view, manager).render().strip())\n  <script type=\"text/javascript\"\n          src=\"/@@/resource.js\"> </script>\n  <script type=\"text/javascript\"\n          src=\"/@@/second-resource.js\"> </script>\n\n\nThe same works for the CSS resource viewlet:\n\n  >>> class CSSResource(object):\n  ...     def __init__(self, request):\n  ...         self.request = request\n  ...\n  ...     def __call__(self):\n  ...         return '/@@/resource.css'\n\n  >>> zope.component.provideAdapter(\n  ...     CSSResource,\n  ...     (IDefaultBrowserLayer,),\n  ...     zope.interface.Interface, name='resource.css')\n\n  >>> CSSViewlet = viewlet.CSSViewlet('resource.css')\n  >>> print(CSSViewlet(content, request, view, manager).render().strip())\n  <link type=\"text/css\" rel=\"stylesheet\"\n        href=\"/@@/resource.css\" media=\"all\" />\n\nYou can also change the media type and the rel attribute:\n\n  >>> CSSViewlet = viewlet.CSSViewlet('resource.css', media='print', rel='css')\n  >>> print(CSSViewlet(content, request, view, manager).render().strip())\n  <link type=\"text/css\" rel=\"css\" href=\"/@@/resource.css\"\n        media=\"print\" />\n\nThere is also a bundle viewlet for CSS links:\n\n  >>> class CSSPrintResource(object):\n  ...     def __init__(self, request):\n  ...         self.request = request\n  ...\n  ...     def __call__(self):\n  ...         return '/@@/print-resource.css'\n\n  >>> zope.component.provideAdapter(\n  ...     CSSPrintResource,\n  ...     (IDefaultBrowserLayer,),\n  ...     zope.interface.Interface, name='print-resource.css')\n\n  >>> items = []\n  >>> items.append({'path':'resource.css', 'rel':'stylesheet', 'media':'all'})\n  >>> items.append({'path':'print-resource.css', 'media':'print'})\n  >>> CSSBundleViewlet = viewlet.CSSBundleViewlet(items)\n  >>> print(CSSBundleViewlet(content, request, view, manager).render().strip())\n  <link type=\"text/css\" rel=\"stylesheet\"\n        href=\"/@@/resource.css\" media=\"all\" />\n  <link type=\"text/css\" rel=\"stylesheet\"\n        href=\"/@@/print-resource.css\" media=\"print\" />\n\n\nA Complex Example\n-----------------\n\nThe Data\n~~~~~~~~\n\nSo far we have only demonstrated simple (maybe overly trivial) use cases of\nthe viewlet system. In the following example, we are going to develop a\ngeneric contents view for files. The step is to create a file component:\n\n  >>> class IFile(zope.interface.Interface):\n  ...     data = zope.interface.Attribute('Data of file.')\n\n  >>> @zope.interface.implementer(IFile)\n  ... class File(object):\n  ...     def __init__(self, data=''):\n  ...         self.__name__ = ''\n  ...         self.data = data\n\nSince we want to also provide the size of a file, here a simple implementation\nof the ``ISized`` interface:\n\n  >>> from zope import size\n  >>> @zope.interface.implementer(size.interfaces.ISized)\n  ... @zope.component.adapter(IFile)\n  ... class FileSized(object):\n  ...\n  ...     def __init__(self, file):\n  ...         self.file = file\n  ...\n  ...     def sizeForSorting(self):\n  ...         return 'byte', len(self.file.data)\n  ...\n  ...     def sizeForDisplay(self):\n  ...         return '%i bytes' %len(self.file.data)\n\n  >>> zope.component.provideAdapter(FileSized)\n\nWe also need a container to which we can add files:\n\n  >>> class Container(dict):\n  ...     def __setitem__(self, name, value):\n  ...         value.__name__ = name\n  ...         super(Container, self).__setitem__(name, value)\n\nHere is some sample data:\n\n  >>> container = Container()\n  >>> container['test.txt'] = File('Hello World!')\n  >>> container['mypage.html'] = File('<html><body>Hello World!</body></html>')\n  >>> container['data.xml'] = File('<message>Hello World!</message>')\n\n\nThe View\n~~~~~~~~\n\nThe contents view of the container should iterate through the container and\nrepresent the files in a table:\n\n  >>> contentsTemplate = os.path.join(temp_dir, 'contents.pt')\n  >>> with open(contentsTemplate, 'w') as file:\n  ...     _ = file.write('''\n  ... <html>\n  ...   <body>\n  ...     <h1>Contents</h1>\n  ...     <div tal:content=\"structure provider:contents\" />\n  ...   </body>\n  ... </html>\n  ... ''')\n\n  >>> from zope.browserpage.simpleviewclass import SimpleViewClass\n  >>> Contents = SimpleViewClass(contentsTemplate, name='contents.html')\n\n\nThe Viewlet Manager\n~~~~~~~~~~~~~~~~~~~\n\nNow we have to write our own viewlet manager. In this case we cannot use the\ndefault implementation, since the viewlets will be looked up for each\ndifferent item:\n\n  >>> shownColumns = []\n\n  >>> @zope.interface.implementer(interfaces.IViewletManager)\n  ... class ContentsViewletManager(object):\n  ...     index = None\n  ...\n  ...     def __init__(self, context, request, view):\n  ...         self.context = context\n  ...         self.request = request\n  ...         self.__parent__ = view\n  ...\n  ...     def update(self):\n  ...         rows = []\n  ...         for name, value in sorted(self.context.items()):\n  ...             rows.append(\n  ...                 [zope.component.getMultiAdapter(\n  ...                     (value, self.request, self.__parent__, self),\n  ...                     interfaces.IViewlet, name=colname)\n  ...                  for colname in shownColumns])\n  ...             [entry.update() for entry in rows[-1]]\n  ...         self.rows = rows\n  ...\n  ...     def render(self, *args, **kw):\n  ...         return self.index(*args, **kw)\n\nNow we need a template to produce the contents table:\n\n  >>> tableTemplate = os.path.join(temp_dir, 'table.pt')\n  >>> with open(tableTemplate, 'w') as file:\n  ...     _ = file.write('''\n  ... <table>\n  ...   <tr tal:repeat=\"row view/rows\">\n  ...     <td tal:repeat=\"column row\">\n  ...       <tal:block replace=\"structure column/render\" />\n  ...     </td>\n  ...   </tr>\n  ... </table>\n  ... ''')\n\nFrom the two pieces above, we can generate the final viewlet manager class and\nregister it (it's a bit tedious, I know):\n\n  >>> from zope.browserpage import ViewPageTemplateFile\n  >>> ContentsViewletManager = type(\n  ...     'ContentsViewletManager', (ContentsViewletManager,),\n  ...     {'index': ViewPageTemplateFile(tableTemplate)})\n\n  >>> zope.component.provideAdapter(\n  ...     ContentsViewletManager,\n  ...     (Container, IDefaultBrowserLayer, zope.interface.Interface),\n  ...     interfaces.IViewletManager, name='contents')\n\nSince we have not defined any viewlets yet, the table is totally empty:\n\n  >>> contents = Contents(container, request)\n  >>> print(contents().strip())\n  <html>\n    <body>\n      <h1>Contents</h1>\n      <div>\n        <table>\n          <tr>\n          </tr>\n          <tr>\n          </tr>\n          <tr>\n          </tr>\n        </table>\n      </div>\n    </body>\n  </html>\n\n\nThe Viewlets and the Final Result\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nNow let's create a first viewlet for the manager...\n\n  >>> class NameViewlet(object):\n  ...\n  ...     def __init__(self, context, request, view, manager):\n  ...         self.__parent__ = view\n  ...         self.context = context\n  ...\n  ...     def update(self):\n  ...         pass\n  ...\n  ...     def render(self):\n  ...         return self.context.__name__\n\nand register it:\n\n  >>> zope.component.provideAdapter(\n  ...     NameViewlet,\n  ...     (IFile, IDefaultBrowserLayer,\n  ...      zope.interface.Interface, interfaces.IViewletManager),\n  ...     interfaces.IViewlet, name='name')\n\nNote how you register the viewlet on ``IFile`` and not on the container. Now\nwe should be able to see the name for each file in the container:\n\n  >>> print(contents().strip())\n  <html>\n    <body>\n      <h1>Contents</h1>\n      <div>\n        <table>\n          <tr>\n          </tr>\n          <tr>\n          </tr>\n          <tr>\n          </tr>\n        </table>\n      </div>\n    </body>\n  </html>\n\nWaaa, nothing there! What happened? Well, we have to tell our user preferences\nthat we want to see the name as a column in the table:\n\n  >>> shownColumns = ['name']\n\n  >>> print(contents().strip())\n  <html>\n    <body>\n      <h1>Contents</h1>\n      <div>\n        <table>\n          <tr>\n            <td>\n              data.xml\n            </td>\n          </tr>\n          <tr>\n            <td>\n              mypage.html\n            </td>\n          </tr>\n          <tr>\n            <td>\n              test.txt\n            </td>\n          </tr>\n        </table>\n      </div>\n    </body>\n  </html>\n\nLet's now write a second viewlet that will display the size of the object for\nus:\n\n  >>> class SizeViewlet(object):\n  ...\n  ...     def __init__(self, context, request, view, manager):\n  ...         self.__parent__ = view\n  ...         self.context = context\n  ...\n  ...     def update(self):\n  ...         pass\n  ...\n  ...     def render(self):\n  ...         return size.interfaces.ISized(self.context).sizeForDisplay()\n\n  >>> zope.component.provideAdapter(\n  ...     SizeViewlet,\n  ...     (IFile, IDefaultBrowserLayer,\n  ...      zope.interface.Interface, interfaces.IViewletManager),\n  ...     interfaces.IViewlet, name='size')\n\nAfter we added it to the list of shown columns,\n\n  >>> shownColumns = ['name', 'size']\n\nwe can see an entry for it:\n\n  >>> print(contents().strip())\n  <html>\n    <body>\n      <h1>Contents</h1>\n      <div>\n        <table>\n          <tr>\n            <td>\n              data.xml\n            </td>\n            <td>\n              31 bytes\n            </td>\n          </tr>\n          <tr>\n            <td>\n              mypage.html\n            </td>\n            <td>\n              38 bytes\n            </td>\n          </tr>\n          <tr>\n            <td>\n              test.txt\n            </td>\n            <td>\n              12 bytes\n            </td>\n          </tr>\n        </table>\n      </div>\n    </body>\n  </html>\n\nIf we switch the two columns around,\n\n  >>> shownColumns = ['size', 'name']\n\nthe result will be\n\n  >>> print(contents().strip())\n  <html>\n    <body>\n      <h1>Contents</h1>\n      <div>\n        <table>\n          <tr>\n            <td>\n              31 bytes\n            </td>\n            <td>\n              data.xml\n            </td>\n          </tr>\n          <tr>\n            <td>\n              38 bytes\n            </td>\n            <td>\n              mypage.html\n            </td>\n          </tr>\n          <tr>\n            <td>\n              12 bytes\n            </td>\n            <td>\n              test.txt\n            </td>\n          </tr>\n        </table>\n      </div>\n    </body>\n  </html>\n\n\nSupporting Sorting\n~~~~~~~~~~~~~~~~~~\n\nOftentimes you also want to batch and sort the entries in a table. Since those\ntwo features are not part of the view logic, they should be treated with\nindependent components. In this example, we are going to only implement\nsorting using a simple utility:\n\n  >>> class ISorter(zope.interface.Interface):\n  ...\n  ...     def sort(values):\n  ...         \"\"\"Sort the values.\"\"\"\n\n  >>> @zope.interface.implementer(ISorter)\n  ... class SortByName(object):\n  ...\n  ...     def sort(self, values):\n  ...         return sorted(values, key=lambda x: x.__name__)\n\n  >>> zope.component.provideUtility(SortByName(), name='name')\n\n  >>> @zope.interface.implementer(ISorter)\n  ... class SortBySize(object):\n  ...\n  ...     def sort(self, values):\n  ...         return sorted(\n  ...             values,\n  ...             key=lambda x: size.interfaces.ISized(x).sizeForSorting())\n\n  >>> zope.component.provideUtility(SortBySize(), name='size')\n\nNote that we decided to give the sorter utilities the same name as the\ncorresponding viewlet. This convention will make our implementation of the\nviewlet manager much simpler:\n\n  >>> sortByColumn = ''\n\n  >>> @zope.interface.implementer(interfaces.IViewletManager)\n  ... class SortedContentsViewletManager(object):\n  ...     index = None\n  ...\n  ...     def __init__(self, context, request, view):\n  ...         self.context = context\n  ...         self.request = request\n  ...         self.__parent__ = view\n  ...\n  ...     def update(self):\n  ...         values = self.context.values()\n  ...\n  ...         if sortByColumn:\n  ...            sorter = zope.component.queryUtility(ISorter, sortByColumn)\n  ...            if sorter:\n  ...                values = sorter.sort(values)\n  ...\n  ...         rows = []\n  ...         for value in values:\n  ...             rows.append(\n  ...                 [zope.component.getMultiAdapter(\n  ...                     (value, self.request, self.__parent__, self),\n  ...                     interfaces.IViewlet, name=colname)\n  ...                  for colname in shownColumns])\n  ...             [entry.update() for entry in rows[-1]]\n  ...         self.rows = rows\n  ...\n  ...     def render(self, *args, **kw):\n  ...         return self.index(*args, **kw)\n\nAs you can see, the concern of sorting is cleanly separated from generating\nthe view code. In MVC terms that means that the controller (sort) is logically\nseparated from the view (viewlets). Let's now do the registration dance for\nthe new viewlet manager. We simply override the existing registration:\n\n  >>> SortedContentsViewletManager = type(\n  ...     'SortedContentsViewletManager', (SortedContentsViewletManager,),\n  ...     {'index': ViewPageTemplateFile(tableTemplate)})\n\n  >>> zope.component.provideAdapter(\n  ...     SortedContentsViewletManager,\n  ...     (Container, IDefaultBrowserLayer, zope.interface.Interface),\n  ...     interfaces.IViewletManager, name='contents')\n\nFinally we sort the contents by name:\n\n  >>> shownColumns = ['name', 'size']\n  >>> sortByColumn = 'name'\n\n  >>> print(contents().strip())\n  <html>\n    <body>\n      <h1>Contents</h1>\n      <div>\n        <table>\n          <tr>\n            <td>\n              data.xml\n            </td>\n            <td>\n              31 bytes\n            </td>\n          </tr>\n          <tr>\n            <td>\n              mypage.html\n            </td>\n            <td>\n              38 bytes\n            </td>\n          </tr>\n          <tr>\n            <td>\n              test.txt\n            </td>\n            <td>\n              12 bytes\n            </td>\n          </tr>\n        </table>\n      </div>\n    </body>\n  </html>\n\nNow let's sort by size:\n\n  >>> sortByColumn = 'size'\n\n  >>> print(contents().strip())\n  <html>\n    <body>\n      <h1>Contents</h1>\n      <div>\n        <table>\n          <tr>\n            <td>\n              test.txt\n            </td>\n            <td>\n              12 bytes\n            </td>\n          </tr>\n          <tr>\n            <td>\n              data.xml\n            </td>\n            <td>\n              31 bytes\n            </td>\n          </tr>\n          <tr>\n            <td>\n              mypage.html\n            </td>\n            <td>\n              38 bytes\n            </td>\n          </tr>\n        </table>\n      </div>\n    </body>\n  </html>\n\nThat's it! As you can see, in a few steps we have built a pretty flexible\ncontents view with selectable columns and sorting. However, there is a lot of\nroom for extending this example:\n\n- Table Header: The table header cell for each column should be a different\n  type of viewlet, but registered under the same name. The column header\n  viewlet also adapts the container not the item. The header column should\n  also be able to control the sorting.\n\n- Batching: A simple implementation of batching should work very similar to\n  the sorting feature. Of course, efficient implementations should somehow\n  combine batching and sorting more effectively.\n\n- Sorting in ascending and descending order: Currently, you can only sort from\n  the smallest to the highest value; however, this limitation is almost\n  superficial and can easily be removed by making the sorters a bit more\n  flexible.\n\n- Further Columns: For a real application, you would want to implement other\n  columns, of course. You would also probably want some sort of fallback for\n  the case that a viewlet is not found for a particular container item and\n  column.\n\n\nCleanup\n-------\n\n  >>> import shutil\n  >>> shutil.rmtree(temp_dir)\n\n\n================================\nThe ``viewletManager`` Directive\n================================\n\nThe ``viewletManager`` directive allows you to quickly register a new viewlet\nmanager without worrying about the details of the ``adapter``\ndirective. Before we can use the directives, we have to register their\nhandlers by executing the package's meta configuration:\n\n  >>> from zope.configuration import xmlconfig\n  >>> context = xmlconfig.string('''\n  ... <configure i18n_domain=\"zope\">\n  ...   <include package=\"zope.viewlet\" file=\"meta.zcml\" />\n  ... </configure>\n  ... ''')\n\nNow we can register a viewlet manager:\n\n  >>> context = xmlconfig.string('''\n  ... <configure xmlns=\"http://namespaces.zope.org/browser\" i18n_domain=\"zope\">\n  ...   <viewletManager\n  ...       name=\"defaultmanager\"\n  ...       permission=\"zope.Public\"\n  ...       />\n  ... </configure>\n  ... ''', context=context)\n\nLet's make sure the directive has really issued a sensible adapter\nregistration; to do that, we create some dummy content, request and view\nobjects:\n\n  >>> import zope.interface\n  >>> @zope.interface.implementer(zope.interface.Interface)\n  ... class Content(object):\n  ...     pass\n  >>> content = Content()\n\n  >>> from zope.publisher.browser import TestRequest\n  >>> request = TestRequest()\n\n  >>> from zope.publisher.browser import BrowserView\n  >>> view = BrowserView(content, request)\n\nNow let's lookup the manager. This particular registration is pretty boring:\n\n  >>> import zope.component\n  >>> from zope.viewlet import interfaces\n  >>> manager = zope.component.getMultiAdapter(\n  ...     (content, request, view),\n  ...     interfaces.IViewletManager, name='defaultmanager')\n\n  >>> manager\n  <zope.viewlet.manager.<ViewletManager providing IViewletManager> object ...>\n  >>> interfaces.IViewletManager.providedBy(manager)\n  True\n  >>> manager.template is None\n  True\n  >>> manager.update()\n  >>> manager.render()\n  u''\n\nHowever, this registration is not very useful, since we did specify a specific\nviewlet manager interface, a specific content interface, specific view or\nspecific layer. This means that all viewlets registered will be found.\n\nThe first step to effectively using the viewlet manager directive is to define\na special viewlet manager interface:\n\n  >>> class ILeftColumn(interfaces.IViewletManager):\n  ...     \"\"\"Left column of my page.\"\"\"\n\nNow we can register register a manager providing this interface:\n\n  >>> context = xmlconfig.string('''\n  ... <configure xmlns=\"http://namespaces.zope.org/browser\" i18n_domain=\"zope\">\n  ...   <viewletManager\n  ...       name=\"leftcolumn\"\n  ...       permission=\"zope.Public\"\n  ...       provides=\"zope.viewlet.directives.ILeftColumn\"\n  ...       />\n  ... </configure>\n  ... ''', context=context)\n\n  >>> manager = zope.component.getMultiAdapter(\n  ...     (content, request, view), ILeftColumn, name='leftcolumn')\n\n  >>> manager\n  <zope.viewlet.manager.<ViewletManager providing ILeftColumn> object ...>\n  >>> ILeftColumn.providedBy(manager)\n  True\n  >>> manager.template is None\n  True\n  >>> manager.update()\n  >>> manager.render()\n  u''\n\nNext let's see what happens, if we specify a template for the viewlet manager:\n\n  >>> import os, tempfile\n  >>> temp_dir = tempfile.mkdtemp()\n\n  >>> leftColumnTemplate = os.path.join(temp_dir, 'leftcolumn.pt')\n  >>> with open(leftColumnTemplate, 'w') as file:\n  ...     _ = file.write('''\n  ... <div class=\"column\">\n  ...    <div class=\"entry\"\n  ...         tal:repeat=\"viewlet options/viewlets\"\n  ...         tal:content=\"structure viewlet\" />\n  ... </div>\n  ... ''')\n\n  >>> context = xmlconfig.string('''\n  ... <configure xmlns=\"http://namespaces.zope.org/browser\" i18n_domain=\"zope\">\n  ...   <viewletManager\n  ...       name=\"leftcolumn\"\n  ...       permission=\"zope.Public\"\n  ...       provides=\"zope.viewlet.directives.ILeftColumn\"\n  ...       template=\"%s\"\n  ...       />\n  ... </configure>\n  ... ''' %leftColumnTemplate, context=context)\n\n  >>> manager = zope.component.getMultiAdapter(\n  ...     (content, request, view), ILeftColumn, name='leftcolumn')\n\n  >>> manager\n  <zope.viewlet.manager.<ViewletManager providing ILeftColumn> object ...>\n  >>> ILeftColumn.providedBy(manager)\n  True\n  >>> manager.template\n  <BoundPageTemplateFile of ...<ViewletManager providing ILeftColumn>  ...>>\n  >>> manager.update()\n  >>> print(manager.render().strip())\n  <div class=\"column\">\n  </div>\n\nAdditionally you can specify a class that will serve as a base to the default\nviewlet manager or be a viewlet manager in its own right. In our case we will\nprovide a custom implementation of the ``sort()`` method, which will sort by a\nweight attribute in the viewlet:\n\n  >>> class WeightBasedSorting(object):\n  ...     def sort(self, viewlets):\n  ...         return sorted(viewlets, key=lambda x: getattr(x[1], 'weight', 0))\n\n  >>> context = xmlconfig.string('''\n  ... <configure xmlns=\"http://namespaces.zope.org/browser\" i18n_domain=\"zope\">\n  ...   <viewletManager\n  ...       name=\"leftcolumn\"\n  ...       permission=\"zope.Public\"\n  ...       provides=\"zope.viewlet.directives.ILeftColumn\"\n  ...       template=\"%s\"\n  ...       class=\"zope.viewlet.directives.WeightBasedSorting\"\n  ...       />\n  ... </configure>\n  ... ''' %leftColumnTemplate, context=context)\n\n  >>> manager = zope.component.getMultiAdapter(\n  ...     (content, request, view), ILeftColumn, name='leftcolumn')\n\n  >>> manager\n  <zope.viewlet.manager.<ViewletManager providing ILeftColumn> object ...>\n  >>> manager.__class__.__bases__\n  (<class 'zope.viewlet.directives.WeightBasedSorting'>,\n   <class 'zope.viewlet.manager.ViewletManagerBase'>)\n  >>> ILeftColumn.providedBy(manager)\n  True\n  >>> manager.template\n  <BoundPageTemplateFile of ...<ViewletManager providing ILeftColumn>  ...>>\n  >>> manager.update()\n  >>> print(manager.render().strip())\n  <div class=\"column\">\n  </div>\n\nFinally, if a non-existent template is specified, an error is raised:\n\n  >>> context = xmlconfig.string('''\n  ... <configure xmlns=\"http://namespaces.zope.org/browser\" i18n_domain=\"zope\">\n  ...   <viewletManager\n  ...       name=\"leftcolumn\"\n  ...       permission=\"zope.Public\"\n  ...       template=\"foo.pt\"\n  ...       />\n  ... </configure>\n  ... ''', context=context)\n  Traceback (most recent call last):\n  ...\n  ZopeXMLConfigurationError: File \"<string>\", line 3.2-7.8\n      ConfigurationError: ('No such file', '...foo.pt')\n\n\n=========================\nThe ``viewlet`` Directive\n=========================\n\nNow that we have a viewlet manager, we have to register some viewlets for\nit. The ``viewlet`` directive is similar to the ``viewletManager`` directive,\nexcept that the viewlet is also registered for a particular manager interface,\nas seen below:\n\n  >>> weatherTemplate = os.path.join(temp_dir, 'weather.pt')\n  >>> with open(weatherTemplate, 'w') as file:\n  ...     _ = file.write('''\n  ... <div>sunny</div>\n  ... ''')\n\n  >>> context = xmlconfig.string('''\n  ... <configure xmlns=\"http://namespaces.zope.org/browser\" i18n_domain=\"zope\">\n  ...   <viewlet\n  ...       name=\"weather\"\n  ...       manager=\"zope.viewlet.directives.ILeftColumn\"\n  ...       template=\"%s\"\n  ...       permission=\"zope.Public\"\n  ...       extra_string_attributes=\"can be specified\"\n  ...       />\n  ... </configure>\n  ... ''' % weatherTemplate, context=context)\n\nIf we look into the adapter registry, we will find the viewlet:\n\n  >>> viewlet = zope.component.getMultiAdapter(\n  ...     (content, request, view, manager), interfaces.IViewlet,\n  ...     name='weather')\n  >>> viewlet.render().strip()\n  u'<div>sunny</div>'\n  >>> viewlet.extra_string_attributes\n  u'can be specified'\n\nThe manager now also gives us the output of the one and only viewlet:\n\n  >>> manager.update()\n  >>> print(manager.render().strip())\n  <div class=\"column\">\n    <div class=\"entry\">\n      <div>sunny</div>\n    </div>\n  </div>\n\nLet's now ensure that we can also specify a viewlet class:\n\n  >>> class Weather(object):\n  ...     weight = 0\n\n  >>> context = xmlconfig.string('''\n  ... <configure xmlns=\"http://namespaces.zope.org/browser\" i18n_domain=\"zope\">\n  ...   <viewlet\n  ...       name=\"weather2\"\n  ...       for=\"*\"\n  ...       manager=\"zope.viewlet.directives.ILeftColumn\"\n  ...       template=\"%s\"\n  ...       class=\"zope.viewlet.directives.Weather\"\n  ...       permission=\"zope.Public\"\n  ...       />\n  ... </configure>\n  ... ''' % weatherTemplate, context=context)\n\n  >>> viewlet = zope.component.getMultiAdapter(\n  ...     (content, request, view, manager), interfaces.IViewlet,\n  ...     name='weather2')\n  >>> viewlet().strip()\n  u'<div>sunny</div>'\n\nOkay, so the template-driven cases work. But just specifying a class should\nalso work:\n\n  >>> class Sport(object):\n  ...     weight = 0\n  ...     def __call__(self):\n  ...         return u'Red Sox vs. White Sox'\n\n  >>> context = xmlconfig.string('''\n  ... <configure xmlns=\"http://namespaces.zope.org/browser\" i18n_domain=\"zope\">\n  ...   <viewlet\n  ...       name=\"sport\"\n  ...       for=\"*\"\n  ...       manager=\"zope.viewlet.directives.ILeftColumn\"\n  ...       class=\"zope.viewlet.directives.Sport\"\n  ...       permission=\"zope.Public\"\n  ...       />\n  ... </configure>\n  ... ''', context=context)\n\n  >>> viewlet = zope.component.getMultiAdapter(\n  ...     (content, request, view, manager), interfaces.IViewlet, name='sport')\n  >>> viewlet()\n  u'Red Sox vs. White Sox'\n\nIt should also be possible to specify an alternative attribute of the class to\nbe rendered upon calling the viewlet:\n\n  >>> class Stock(object):\n  ...     weight = 0\n  ...     def getStockTicker(self):\n  ...         return u'SRC $5.19'\n\n  >>> context = xmlconfig.string('''\n  ... <configure xmlns=\"http://namespaces.zope.org/browser\" i18n_domain=\"zope\">\n  ...   <viewlet\n  ...       name=\"stock\"\n  ...       for=\"*\"\n  ...       manager=\"zope.viewlet.directives.ILeftColumn\"\n  ...       class=\"zope.viewlet.directives.Stock\"\n  ...       attribute=\"getStockTicker\"\n  ...       permission=\"zope.Public\"\n  ...       />\n  ... </configure>\n  ... ''', context=context)\n\n  >>> viewlet = zope.component.getMultiAdapter(\n  ...     (content, request, view, manager), interfaces.IViewlet,\n  ...     name='stock')\n  >>> viewlet.render()\n  u'SRC $5.19'\n\nA final feature the ``viewlet`` directive is that it supports the\nspecification of any number of keyword arguments:\n\n  >>> context = xmlconfig.string('''\n  ... <configure xmlns=\"http://namespaces.zope.org/browser\" i18n_domain=\"zope\">\n  ...   <viewlet\n  ...       name=\"stock2\"\n  ...       permission=\"zope.Public\"\n  ...       class=\"zope.viewlet.directives.Stock\"\n  ...       weight=\"8\"\n  ...       />\n  ... </configure>\n  ... ''', context=context)\n\n  >>> viewlet = zope.component.getMultiAdapter(\n  ...     (content, request, view, manager), interfaces.IViewlet,\n  ...     name='stock2')\n  >>> viewlet.weight\n  u'8'\n\n\nError Scenarios\n---------------\n\nNeither the class or template have been specified:\n\n  >>> context = xmlconfig.string('''\n  ... <configure xmlns=\"http://namespaces.zope.org/browser\" i18n_domain=\"zope\">\n  ...   <viewlet\n  ...       name=\"testviewlet\"\n  ...       manager=\"zope.viewlet.directives.ILeftColumn\"\n  ...       permission=\"zope.Public\"\n  ...       />\n  ... </configure>\n  ... ''', context=context)\n  Traceback (most recent call last):\n  ...\n  ZopeXMLConfigurationError: File \"<string>\", line 3.2-7.8\n      ConfigurationError: Must specify a class or template\n\nThe specified attribute is not ``__call__``, but also a template has been\nspecified:\n\n  >>> context = xmlconfig.string('''\n  ... <configure xmlns=\"http://namespaces.zope.org/browser\" i18n_domain=\"zope\">\n  ...   <viewlet\n  ...       name=\"testviewlet\"\n  ...       manager=\"zope.viewlet.directives.ILeftColumn\"\n  ...       template=\"test_viewlet.pt\"\n  ...       attribute=\"faux\"\n  ...       permission=\"zope.Public\"\n  ...       />\n  ... </configure>\n  ... ''', context=context)\n  Traceback (most recent call last):\n  ...\n  ZopeXMLConfigurationError: File \"<string>\", line 3.2-9.8\n      ConfigurationError: Attribute and template cannot be used together.\n\nNow, we are not specifying a template, but a class that does not have the\nspecified attribute:\n\n  >>> context = xmlconfig.string('''\n  ... <configure xmlns=\"http://namespaces.zope.org/browser\" i18n_domain=\"zope\">\n  ...   <viewlet\n  ...       name=\"testviewlet\"\n  ...       manager=\"zope.viewlet.directives.ILeftColumn\"\n  ...       class=\"zope.viewlet.directives.Sport\"\n  ...       attribute=\"faux\"\n  ...       permission=\"zope.Public\"\n  ...       />\n  ... </configure>\n  ... ''', context=context)\n  Traceback (most recent call last):\n  ...\n  ZopeXMLConfigurationError: File \"<string>\", line 3.2-9.8\n    ConfigurationError: The provided class doesn't have the specified attribute\n\n\nCleanup\n-------\n\n  >>> import shutil\n  >>> shutil.rmtree(temp_dir)\n\n\nChanges\n=======\n\n4.0.0 (2014-12-24)\n------------------\n\n- Add support for PyPy and PyPy3.\n\n- Add support for Python 3.4.\n\n- Add support for testing on Travis.\n\n\n4.0.0a1 (2013-02-24)\n--------------------\n\n- Add support for Python 3.3.\n\n- Replace deprecated ``zope.component.adapts`` usage with equivalent\n  ``zope.component.adapter`` decorator.\n\n- Replace deprecated ``zope.interface.implements`` usage with equivalent\n  ``zope.interface.implementer`` decorator.\n\n- Drop support for Python 2.4 and 2.5.\n\n\n3.7.2 (2010-05-25)\n------------------\n\n- Fix unit tests broken under Python 2.4 by the switch to the standard\n  library ``doctest`` module.\n\n\n3.7.1 (2010-04-30)\n------------------\n\n- Remove use of 'zope.testing.doctest' in favor of stdlib's 'doctest.\n\n- Fix dubious quoting in metadirectives.py. Closes\n  https://bugs.launchpad.net/zope2/+bug/143774.\n\n\n3.7.0 (2009-12-22)\n------------------\n\n- Depend on ``zope.browserpage`` in favor of ``zope.app.pagetemplate``.\n\n\n3.6.1 (2009-08-29)\n------------------\n\n- Fix unit tests in README.txt.\n\n\n3.6.0 (2009-08-02)\n------------------\n\n- Optimize the the script tag for the JS viewlet. This makes YSlow happy.\n\n- Remove ZCML slugs and old zpkg-related files.\n\n- Drop all testing dependncies except ``zope.testing``.\n\n\n3.5.0 (2009-01-26)\n------------------\n\n- Remove the dependency on ``zope.app.publisher`` by moving four simple helper\n  functions into this package and making the interface for describing the\n  ZCML content provider directive explicit.\n\n- Typo fix in CSSViewlet docstring.\n\n\n3.4.2 (2008-01-24)\n------------------\n\n- Re-release of 3.4.1 because of brown bag release.\n\n\n3.4.1 (2008-01-21)\n------------------\n\n- Implement missing ``__contains__`` method in IViewletManager\n\n- Implement additional viewlet managers offering weight ordered sorting\n\n- Implement additional viewlet managers offering conditional filtering\n\n\n3.4.1a (2007-4-22)\n------------------\n\n- Add a missing ',' behind ``zope.i18nmessageid``.\n\n- Recreate the ``README.txt`` removing everything except for the overview.\n\n\n3.4.0 (2007-10-10)\n------------------\n\n- Initial release independent of the main Zope tree.",
    "docs_url": null,
    "download_url": "UNKNOWN",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "http://pypi.python.org/pypi/zope.viewlet",
    "keywords": "zope web html ui viewlet pattern",
    "license": "ZPL 2.1",
    "maintainer": null,
    "maintainer_email": null,
    "name": "zope.viewlet",
    "platform": "UNKNOWN",
    "project_url": "https://pypi.org/project/zope.viewlet/",
    "release_url": "https://pypi.org/project/zope.viewlet/4.0.0/",
    "requires_python": null,
    "summary": "Zope Viewlets",
    "version": "4.0.0"
  },
  "releases": {
    "3.4.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "864f937b3e9d0422c7ba29e4e814ad0b",
          "sha256": "3aaf172b52b29dd0bb191e90990ff0ed7757b099aa58b6b1e0429aeb51e02182"
        },
        "downloads": 6325,
        "filename": "zope.viewlet-3.4.0.tar.gz",
        "has_sig": false,
        "md5_digest": "864f937b3e9d0422c7ba29e4e814ad0b",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 37209,
        "upload_time": "2007-10-11T04:04:47",
        "url": "https://files.pythonhosted.org/packages/b8/28/2835e820e81003ac34235e0a67753f5eb8129ef994104b8a96ee693433f3/zope.viewlet-3.4.0.tar.gz"
      }
    ],
    "3.4.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "0963e33ac17e9d9ed9c711a8dbaf33a4",
          "sha256": "5c0ec5beda14538015266cb80e58d987c01dc220e8b2db938d2f77f66dae5215"
        },
        "downloads": 3842,
        "filename": "zope.viewlet-3.4.1.tar.gz",
        "has_sig": false,
        "md5_digest": "0963e33ac17e9d9ed9c711a8dbaf33a4",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 42430,
        "upload_time": "2008-01-21T02:35:56",
        "url": "https://files.pythonhosted.org/packages/de/d4/17cd61c64cc7938f8c2e5ab555d1edf6288214135845e9cf20791a82f717/zope.viewlet-3.4.1.tar.gz"
      }
    ],
    "3.4.2": [
      {
        "comment_text": "",
        "digests": {
          "md5": "576ae490bc3053ed547d93e6c8fc2b70",
          "sha256": "1fff96639ddea590e058dfb431b916bb3afcf765f8a24724c2fa318aefed3202"
        },
        "downloads": 16836,
        "filename": "zope.viewlet-3.4.2.tar.gz",
        "has_sig": false,
        "md5_digest": "576ae490bc3053ed547d93e6c8fc2b70",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 42395,
        "upload_time": "2008-01-24T13:52:30",
        "url": "https://files.pythonhosted.org/packages/da/d3/297c6ed86d4e0ea0862aea1653a41045ed6b1ef96468b8cd1559df5a47d7/zope.viewlet-3.4.2.tar.gz"
      }
    ],
    "3.4dev-r73054": [
      {
        "comment_text": "",
        "digests": {
          "md5": "04edba76d334d1a2dd45ca55cdee111b",
          "sha256": "8fa66d1479cb7250a3cee7f549de152afa1c84084f993d5f79630d710ed2add2"
        },
        "downloads": 2936,
        "filename": "zope.viewlet-3.4dev_r73054-py2.4.egg",
        "has_sig": false,
        "md5_digest": "04edba76d334d1a2dd45ca55cdee111b",
        "packagetype": "bdist_egg",
        "python_version": "2.4",
        "size": 37428,
        "upload_time": "2007-03-21T05:15:36",
        "url": "https://files.pythonhosted.org/packages/61/ad/78b62461c310b3cfbe379a5274e27e0de12c2f886c7bcfb69c7ed8c627f4/zope.viewlet-3.4dev_r73054-py2.4.egg"
      }
    ],
    "3.4dev-r73833": [
      {
        "comment_text": "",
        "digests": {
          "md5": "bee55ce62cb743e86d2d109a5bc6800d",
          "sha256": "7428af11d6b7feb01fd4900d9f7d5c7dc7fcd269c59e6cfd63ee732f9726b975"
        },
        "downloads": 2729,
        "filename": "zope.viewlet-3.4dev-r73833.tar.gz",
        "has_sig": false,
        "md5_digest": "bee55ce62cb743e86d2d109a5bc6800d",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 18190,
        "upload_time": "2007-04-18T06:45:14",
        "url": "https://files.pythonhosted.org/packages/e2/42/c3a95173fda4c9238d5cc90898a80c277fc8578715634cf5f80e230a7239/zope.viewlet-3.4dev-r73833.tar.gz"
      }
    ],
    "3.5.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "03a40fb9118193aea836a518698e6120",
          "sha256": "ac2af7347a70e42fa465b0962fda12abe3c3c344bb7544db9c32ca884e897a59"
        },
        "downloads": 10572,
        "filename": "zope.viewlet-3.5.0.zip",
        "has_sig": true,
        "md5_digest": "03a40fb9118193aea836a518698e6120",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 55189,
        "upload_time": "2009-01-26T20:14:34",
        "url": "https://files.pythonhosted.org/packages/82/0e/5205766f2d4591cf7a0bfb686ebf639fb8d3ae1362e7efd479fee57941bc/zope.viewlet-3.5.0.zip"
      }
    ],
    "3.6.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "49d95cac467835f39fae875c955ad1ef",
          "sha256": "f5357e15ef64b17216f94aec45e721e26f2f680d76c77205cbb2114ef2fc3a7b"
        },
        "downloads": 2901,
        "filename": "zope.viewlet-3.6.0.tar.gz",
        "has_sig": false,
        "md5_digest": "49d95cac467835f39fae875c955ad1ef",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 41352,
        "upload_time": "2009-08-02T07:33:29",
        "url": "https://files.pythonhosted.org/packages/a2/e5/90b23a4d37820b54f2725aad45bbf74ee3461b86f59bcbd3f038bab9d4e0/zope.viewlet-3.6.0.tar.gz"
      }
    ],
    "3.6.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "ead48dcc8403aac285ac4d3caaa4fda3",
          "sha256": "041d022dd624e4a3962e7cf2d50db21c02ce8389e4035f3242ef13a08cc66645"
        },
        "downloads": 33951,
        "filename": "zope.viewlet-3.6.1.zip",
        "has_sig": true,
        "md5_digest": "ead48dcc8403aac285ac4d3caaa4fda3",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 54494,
        "upload_time": "2009-08-29T01:01:52",
        "url": "https://files.pythonhosted.org/packages/57/79/af432f41197539db4e44b228d6f0f8908d4a1da92ff391af206be3151034/zope.viewlet-3.6.1.zip"
      }
    ],
    "3.7.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "ce2a5b38ae8cbb299a085e816f6e0615",
          "sha256": "da13cc5d4fd19b3799ad75e3fb274e5efd44eb985deef666c16da0366a5645a5"
        },
        "downloads": 9718,
        "filename": "zope.viewlet-3.7.0.zip",
        "has_sig": false,
        "md5_digest": "ce2a5b38ae8cbb299a085e816f6e0615",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 54676,
        "upload_time": "2009-12-22T20:00:32",
        "url": "https://files.pythonhosted.org/packages/b4/f2/2ac2d2235cbb7a3669bd72e27094a25a8974d4064998c471b8882a42fea3/zope.viewlet-3.7.0.zip"
      }
    ],
    "3.7.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "8c86ae1b026eafcb6ee85e3a1daba384",
          "sha256": "08f897d4c83228065f677f9335815ab63c4f677bb8b76e469590fbbea52ad128"
        },
        "downloads": 2908,
        "filename": "zope.viewlet-3.7.1.zip",
        "has_sig": false,
        "md5_digest": "8c86ae1b026eafcb6ee85e3a1daba384",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 55918,
        "upload_time": "2010-05-01T00:24:56",
        "url": "https://files.pythonhosted.org/packages/d8/f7/94e7ff56971b5f0245ace6ca50022b7936aee0438c348eaa3a2578c82bc3/zope.viewlet-3.7.1.zip"
      }
    ],
    "3.7.2": [
      {
        "comment_text": "",
        "digests": {
          "md5": "367e03096df57e2f9b74fff43f7901f9",
          "sha256": "4fe3d24f9cc7a70f4e774b923df6688538ff2164cde34f74981ed773ef60b2d7"
        },
        "downloads": 131723,
        "filename": "zope.viewlet-3.7.2.tar.gz",
        "has_sig": false,
        "md5_digest": "367e03096df57e2f9b74fff43f7901f9",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 45828,
        "upload_time": "2010-05-25T16:03:51",
        "url": "https://files.pythonhosted.org/packages/8a/d4/3a466dbe7b7ac67e481b155addfc1ce8534417942b7da2ed7afec1cbcb9f/zope.viewlet-3.7.2.tar.gz"
      }
    ],
    "4.0.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "7fdd09d550f8b8ec34d572e6376d1c7f",
          "sha256": "df785bf0fca1bc24d1da3d8624b1ce6ef7d06e82961ffa680689e2f6c4873700"
        },
        "downloads": 0,
        "filename": "zope.viewlet-4.0.0-py2.py3-none-any.whl",
        "has_sig": true,
        "md5_digest": "7fdd09d550f8b8ec34d572e6376d1c7f",
        "packagetype": "bdist_wheel",
        "python_version": "py2.py3",
        "size": 51402,
        "upload_time": "2017-06-13T20:43:36",
        "url": "https://files.pythonhosted.org/packages/78/f8/e6dca434924ed55ae6cfe1131434a8f940157f916d40b1ee0d0300e72ccf/zope.viewlet-4.0.0-py2.py3-none-any.whl"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "04645812a22fbc1b1e8ccd02290afaab",
          "sha256": "af0df6fe3602e7730d3dd241f6add4f354a221f9f216606ba5b190a66cc04433"
        },
        "downloads": 6731,
        "filename": "zope.viewlet-4.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "04645812a22fbc1b1e8ccd02290afaab",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 47804,
        "upload_time": "2014-12-24T23:28:54",
        "url": "https://files.pythonhosted.org/packages/cb/f3/e26f2a282ac0159b08d211fb7990d1789731a7d3791fb4bdfb1e44c2fbbf/zope.viewlet-4.0.0.tar.gz"
      }
    ],
    "4.0.0a1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "6b6b541df2d36069588e519054dae14f",
          "sha256": "f5554fe1a594f026df5403ce1ea82a0db99842fecd7bc8ba6ae96e87049e72b9"
        },
        "downloads": 11553,
        "filename": "zope.viewlet-4.0.0a1.zip",
        "has_sig": false,
        "md5_digest": "6b6b541df2d36069588e519054dae14f",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 59157,
        "upload_time": "2013-02-24T22:58:48",
        "url": "https://files.pythonhosted.org/packages/a9/30/f82177c9d0047a2237a971d0e729d5c36b41896c3ebed3b8a285146f3e2e/zope.viewlet-4.0.0a1.zip"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "7fdd09d550f8b8ec34d572e6376d1c7f",
        "sha256": "df785bf0fca1bc24d1da3d8624b1ce6ef7d06e82961ffa680689e2f6c4873700"
      },
      "downloads": 0,
      "filename": "zope.viewlet-4.0.0-py2.py3-none-any.whl",
      "has_sig": true,
      "md5_digest": "7fdd09d550f8b8ec34d572e6376d1c7f",
      "packagetype": "bdist_wheel",
      "python_version": "py2.py3",
      "size": 51402,
      "upload_time": "2017-06-13T20:43:36",
      "url": "https://files.pythonhosted.org/packages/78/f8/e6dca434924ed55ae6cfe1131434a8f940157f916d40b1ee0d0300e72ccf/zope.viewlet-4.0.0-py2.py3-none-any.whl"
    },
    {
      "comment_text": "",
      "digests": {
        "md5": "04645812a22fbc1b1e8ccd02290afaab",
        "sha256": "af0df6fe3602e7730d3dd241f6add4f354a221f9f216606ba5b190a66cc04433"
      },
      "downloads": 6731,
      "filename": "zope.viewlet-4.0.0.tar.gz",
      "has_sig": false,
      "md5_digest": "04645812a22fbc1b1e8ccd02290afaab",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 47804,
      "upload_time": "2014-12-24T23:28:54",
      "url": "https://files.pythonhosted.org/packages/cb/f3/e26f2a282ac0159b08d211fb7990d1789731a7d3791fb4bdfb1e44c2fbbf/zope.viewlet-4.0.0.tar.gz"
    }
  ]
}