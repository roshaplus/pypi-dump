{
  "info": {
    "author": "Rohit Kumar, Kyle Lahnakoski",
    "author_email": "rohitkumar.a255@gmail.com, kyle@lahnakoski.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 4 - Beta",
      "License :: OSI Approved :: Mozilla Public License 2.0 (MPL 2.0)",
      "Topic :: Software Development :: Libraries",
      "Topic :: Software Development :: Libraries :: Python Modules"
    ],
    "description": "jx-sqlite\n=========\n\nJSON query expressions using SQLite\n\nOverview\n--------\n\nAn attempt to store JSON documents in SQLite so that they are accessible\nvia SQL. The hope is this will serve a basis for a general\ndocument-relational map (DRM), and leverage the database's query\noptimizer.\n\nStatus\n------\n\nIt looks like many tests already pass, but those are the easy ones. The\ndifficult tests, testing queries into nested arrays, remain to be\nsolved. Hopefully, there will be a GSOC project to refactor and finish\nthis work.\n\nThe tests fail because what I have written does not handle the most\ninteresting, and most important features: We want to query nested object\narrays as if they were just another table. This is important for two\nreasons;\n\n1. Inner objects ``{\"a\":{\"b\":0}}`` are a shortcut for nested arrays\n   ``{\"a\":[{\"b\":0}]}``, plus\n2. Schemas can be expanded from one-to-one to one-to-many\n   ``{\"a\":[{\"b\":0}, {\"b\":1}]}``.\n\nRunning tests\n-------------\n\n::\n\n    export PYTHONPATH=.\n    python -m unittest discover -v -s tests\n\nDesign\n------\n\nNomenclature\n~~~~~~~~~~~~\n\n-  **Nested Object** - An object in an array\n-  **Inner Object** - A child object, no arrays\n\nThis nomenclature is different than most documentation that talks about\nJSON documents: Other documentation will use the word *nested* to refer\nto either sub-structure ambiguously.\n\nOverloading property types\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nA distinction between databases and document stores is the ability to\nstore different primitive types at the same property. To overcome this,\nwe markup the columns of the database with the type. Let's put two\nobjects into the ``example`` table:\n\n::\n\n    {\"a\": 1}\n    {\"a\": \"hello\"}\n\nWe markup the columns with ``$``\\ +typename, with the hope we avoid\nnamespace collisions.\n\n``example``\n~~~~~~~~~~~\n\n\\| \\_id \\| a.\\ :math:`integer | a.`\\ string \\|\n\\|-----\\|------------\\|-----------\\| \\| 0 \\| 1 \\| null \\| \\| 1 \\| null\n\\| \"hello\" \\|\n\nWe add an ``_id`` column as a UID, so we can distinguish documents.\n\nThe good thing about adding the type to the name is we can store\nprimitive values:\n\n::\n\n    \"hello world\"\n\n\\| \\_id \\| a.\\ :math:`integer | a.`\\ string \\| $string \\|\n\\|-----\\|------------\\|-----------\\|---------------\\| \\| 2 \\| null \\|\nnull \\| \"hello world\" \\|\n\nInner objects\n~~~~~~~~~~~~~\n\nLimiting ourselves to inner objects, with no arrays, we can store them\nin the database so that each column represents a *path* to a literal\nvalue\n\n::\n\n    {\"a\": {\"b\": 1, \"c\": \"test\"}}\n\nthere are only two leaves in this tree of documents:\n\n``example``\n~~~~~~~~~~~\n\n\\| \\_id \\| a.b.\\ :math:`integer | a.c.`\\ string \\|\n\\|-----\\|--------------\\|-------------\\| \\| 3 \\| 1 \\| \"test\" \\|\n\nWhen we encounter objects with different structures, we can perform\nschema expansion\n\n::\n\n    {\"a\": {\"b\": {\"d\": 3}}}\n\nwe do this by adding columns to the table so we can store the new leaf\nvalues\n\n``example``\n~~~~~~~~~~~\n\n\\| \\_id \\| a.b.\\ :math:`integer | a.c.`\\ string \\| a.b.d.$integer \\|\n\\|-----\\|--------------\\|-------------\\|----------------\\| \\| 4 \\| null\n\\| null \\| 3 \\|\n\nNested Objects\n~~~~~~~~~~~~~~\n\nWhen it comes to nesting objects, a new table will be required\n\n::\n\n    {\"a\": [{\"b\": 4}, {\"b\":5}]}\n\nOur fact table has no primitive values\n\n``example``\n~~~~~~~~~~~\n\n\\| \\_id \\| a.b.\\ :math:`integer | a.c.`\\ string \\| a.b.d.$integer \\|\n\\|-----\\|--------------\\|-------------\\|----------------\\| \\| 5 \\| null\n\\| null \\| null \\|\n\nOur nested documents are stored in a new table, called ``example.a``\n\n``example.a``\n~~~~~~~~~~~~~\n\n| \\_id \\| \\_order \\| \\_parent \\| b.integer \\|\n| --- \\| ------ \\| ------- \\| --------- \\|\n| \u00a06 \\| 0 \\| 5 \\| 4 \\|\n| \u00a07 \\| 1 \\| 5 \\| 5 \\|\n\nChild tables have a ``_id`` column, plus two others: ``_order`` so we\ncan reconstruct the original JSON and ``_parent`` which is used to refer\nto the immediate parent of the array.\n\nMore Design Docs\n----------------\n\n-  `Snowflake <https://github.com/mozilla/jx-sqlite/blob/master/docs/Perspective.md>`__\n-  `JSON in\n   Database <https://github.com/mozilla/jx-sqlite/blob/master/docs/JSON%20in%20Database.md>`__\n\nOpen problems\n-------------\n\n**Do we copy the ``a.*`` columns from the ``example`` table to our new\nchild table?** As I see it, there are two possible answers:\n\n1. **Do not copy** - If there is just one nested document, or it is an\n   inner object, then it will fit in a single row of the parent, and\n   reduce the number of rows returned when querying. The query\n   complexity increases because we must consider the case of inner\n   objects and the case of nested objects.\n2. **Copy** - Effectively move the columns to the new child table: This\n   will simplify the queries because each path is realized in only one\n   table but may be more expensive because every inner object will\n   demand an SQL-join, it may be expensive to perform the alter table.\n\n**How to handle arrays of arrays?** I have not seen many examples in the\nwild yet. Usually, arrays of arrays represent a multidimensional array,\nwhere the number of elements in every array is the same. Maybe we can\nreject JSON that does not conform to a multidimensional interpretation.",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "https://github.com/mozilla/jx-sqlite",
    "keywords": "",
    "license": "MPL 2.0",
    "maintainer": "",
    "maintainer_email": "",
    "name": "jx-sqlite",
    "platform": "",
    "project_url": "https://pypi.org/project/jx-sqlite/",
    "release_url": "https://pypi.org/project/jx-sqlite/0.9.17206/",
    "requires_dist": [],
    "requires_python": "",
    "summary": "JSON query expressions using SQLite",
    "version": "0.9.17206"
  },
  "releases": {
    "0.9.17206": [
      {
        "comment_text": "",
        "digests": {
          "md5": "77cf52ae2cc3984500d38fcb2a179adb",
          "sha256": "3127161a15485dfc4bb2ebde6b24ed700d1c1e3159718db44d254c074df64df0"
        },
        "downloads": 0,
        "filename": "jx-sqlite-0.9.17206.zip",
        "has_sig": false,
        "md5_digest": "77cf52ae2cc3984500d38fcb2a179adb",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 215609,
        "upload_time": "2017-08-01T13:05:52",
        "url": "https://files.pythonhosted.org/packages/d7/0c/1842bc6b3b2ece5003bf0bddda170a8746e90b84b0172bea25da66328f4f/jx-sqlite-0.9.17206.zip"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "77cf52ae2cc3984500d38fcb2a179adb",
        "sha256": "3127161a15485dfc4bb2ebde6b24ed700d1c1e3159718db44d254c074df64df0"
      },
      "downloads": 0,
      "filename": "jx-sqlite-0.9.17206.zip",
      "has_sig": false,
      "md5_digest": "77cf52ae2cc3984500d38fcb2a179adb",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 215609,
      "upload_time": "2017-08-01T13:05:52",
      "url": "https://files.pythonhosted.org/packages/d7/0c/1842bc6b3b2ece5003bf0bddda170a8746e90b84b0172bea25da66328f4f/jx-sqlite-0.9.17206.zip"
    }
  ]
}