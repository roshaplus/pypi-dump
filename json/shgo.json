{
  "info": {
    "author": "Stefan Endres",
    "author_email": "stefan.c.endres@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 3 - Alpha",
      "Intended Audience :: Developers",
      "Intended Audience :: Science/Research",
      "License :: OSI Approved :: MIT License",
      "Programming Language :: Python :: 2.7",
      "Programming Language :: Python :: 3.5",
      "Programming Language :: Python :: 3.6",
      "Topic :: Scientific/Engineering",
      "Topic :: Scientific/Engineering :: Mathematics"
    ],
    "description": ".. image:: https://travis-ci.org/Stefan-Endres/shgo.svg?branch=master\n    :target: https://travis-ci.org/Stefan-Endres/shgo\n\n.. image:: https://coveralls.io/repos/Stefan-Endres/shgo/badge.png?branch=master\n    :target: https://coveralls.io/r/Stefan-Endres/shgo?branch=master\n\nDescription\n-----------\n\nFinds the global minimum of a function using simplicial homology global\noptimisation. Appropriate for solving general purpose NLP and blackbox\noptimisation problems to global optimality (low dimensional problems).\nThe general form of an optimisation problem is given by:\n\n::\n\n    minimize f(x) subject to\n\n    g_i(x) >= 0,  i = 1,...,m\n    h_j(x)  = 0,  j = 1,...,p\n\nwhere x is a vector of one or more variables. ``f(x)`` is the objective\nfunction ``R^n -> R`` ``g_i(x)`` are the inequality constraints.\n``h_j(x)`` are the equality constrains.\n\n\nInstallation\n------------\n.. code::\n\n    pip install shgo\n\n\nExamples\n--------\n\nFirst consider the problem of minimizing the Rosenbrock function. This\nfunction is implemented in ``rosen`` in ``scipy.optimize``\n\n.. code:: python\n\n    >>> from scipy.optimize import rosen\n    >>> from shgo import shgo\n    >>> bounds = [(0,2), (0, 2), (0, 2), (0, 2), (0, 2)]\n    >>> result = shgo(rosen, bounds)\n    >>> result.x, result.fun\n    (array([ 1.,  1.,  1.,  1.,  1.]), 2.9203923741900809e-18)\n\nNote that bounds determine the dimensionality of the objective function\nand is therefore a required input, however you can specify empty bounds\nusing ``None`` or objects like numpy.inf which will be converted to\nlarge float numbers.\n\n.. code:: python\n\n    >>> bounds = [(None, None), ]*4\n    >>> result = shgo(rosen, bounds)\n    >>> result.x\n    array([ 0.99999851,  0.99999704,  0.99999411,  0.9999882 ])\n\nNext we consider the Eggholder function, a problem with several local\nminima and one global minimum. We will demonstrate the use of arguments\nand the capabilities of shgo.\n(https://en.wikipedia.org/wiki/Test\\_functions\\_for\\_optimization)\n\n.. code:: python\n\n    >>> from shgo import shgo\n    >>> import numpy as np\n    >>> def eggholder(x):\n    ...     return (-(x[1] + 47.0)\n    ...             * np.sin(np.sqrt(abs(x[0]/2.0 + (x[1] + 47.0))))\n    ...             - x[0] * np.sin(np.sqrt(abs(x[0] - (x[1] + 47.0))))\n    ...             )\n    ...\n    >>> bounds = [(-512, 512), (-512, 512)]\n\nshgo has two built-in low discrepancy sampling sequences. First we will\ninput 30 initial sampling points of the Sobol sequence\n\n.. code:: python\n\n    >>> result = shgo(eggholder, bounds, n=30, sampling_method='sobol')\n    >>> result.x, result.fun\n    (array([ 512.    ,  404.23180542]), -959.64066272085051)\n\n``shgo`` also has a return for any other local minima that was found,\nthese can be called using:\n\n.. code:: python\n\n    >>> result.xl\n    array([[ 512., 404.23180542], [ 283.07593402, -487.12566542], [-294.66820039, -462.01964031], [-105.87688985,  423.15324143], [-242.97923629,  274.38032063], [-506.25823477, 6.3131022 ], [-408.71981195, -156.10117154], [150.23210485,  301.31378508], [91.00922754, -391.28375925], [ 202.8966344, -269.38042147], [361.66625957, -106.96490692], [-219.40615102, -244.06022436], [ 151.59603137, -100.61082677]])\n    >>> result.funl\n    array([-959.64066272, -718.16745962, -704.80659592, -565.99778097, -559.78685655, -557.36868733, -507.87385942, -493.9605115, -426.48799655, -421.15571437, -419.31194957, -410.98477763, -202.53912972])\n\nThese results are useful in applications where there are many global\nminima and the values of other global minima are desired or where the\nlocal minima can provide insight into the system such are for example\nmorphologies in physical chemistry [5]\n\nNow suppose we want to find a larger number of local minima, this can be\naccomplished for example by increasing the amount of sampling points or\nthe number of iterations. We'll increase the number of sampling points\nto 60 and the number of iterations to 3 increased from the default 100\nfor a total of 60 x 3 = 180 initial sampling points.\n\n.. code:: python\n\n    >>> result_2 = shgo(eggholder, bounds, n=60, iters=3, sampling_method='sobol')\n    >>> len(result.xl), len(result_2.xl)\n    (13, 33)\n\nNote that there is a difference between specifying arguments for ex.\n``n=180, iters=1`` and ``n=60, iters=3``. In the first case the\npromising points contained in the minimiser pool is processed only once.\nIn the latter case it is processed every 60 sampling points for a total\nof 3 times.\n\nTo demonstrate solving problems with non-linear constraints consider the\nfollowing example from Hock and Schittkowski problem 73 (cattle-feed)\n[4]:\n\n::\n\n    minimize: f = 24.55 * x_1 + 26.75 * x_2 + 39 * x_3 + 40.50 * x_4\n\n    subject to: 2.3 * x_1 + 5.6 * x_2 + 11.1 * x_3 + 1.3 * x_4 - 5      >= 0,\n\n                12 * x_1 + 11.9 * x_2 + 41.8 * x_3 + 52.1 * x_4 - 21\n                    -1.645 * sqrt(0.28 * x_1**2 + 0.19 * x_2**2 +\n                                  20.5 * x_3**2 + 0.62 * x_4**2)        >= 0,\n\n                x_1 + x_2 + x_3 + x_4 - 1                               == 0,\n\n                1 >= x_i >= 0 for all i\n\nApprox. Answer [4]: f([0.6355216, -0.12e-11, 0.3127019, 0.05177655]) =\n29.894378\n\n.. code:: python\n\n        >>> from scipy.optimize import shgo\n        >>> import numpy as np\n        >>> def f(x):  # (cattle-feed)\n        ...     return 24.55*x[0] + 26.75*x[1] + 39*x[2] + 40.50*x[3]\n        ...\n        >>> def g1(x):\n        ...     return 2.3*x[0] + 5.6*x[1] + 11.1*x[2] + 1.3*x[3] - 5  # >=0\n        ...\n        >>> def g2(x):\n        ...     return (12*x[0] + 11.9*x[1] +41.8*x[2] + 52.1*x[3] - 21\n        ...             - 1.645 * np.sqrt(0.28*x[0]**2 + 0.19*x[1]**2\n        ...                             + 20.5*x[2]**2 + 0.62*x[3]**2)\n        ...             ) # >=0\n        ...\n        >>> def h1(x):\n        ...     return x[0] + x[1] + x[2] + x[3] - 1  # == 0\n        ...\n        >>> cons = ({'type': 'ineq', 'fun': g1},\n        ...         {'type': 'ineq', 'fun': g2},\n        ...         {'type': 'eq', 'fun': h1})\n        >>> bounds = [(0, 1.0),]*4\n        >>> res = shgo(f, bounds, iters=2, constraints=cons)\n        >>> res\n             fun: 29.894378159142136\n            funl: array([ 29.89437816])\n         message: 'Optimization terminated successfully.'\n            nfev: 119\n             nit: 2\n           nlfev: 40\n           nljev: 0\n         success: True\n               x: array([  6.35521569e-01,   1.13700270e-13,   3.12701881e-01,\n                 5.17765506e-02])\n              xl: array([[  6.35521569e-01,   1.13700270e-13,   3.12701881e-01,\n                  5.17765506e-02]])\n        >>> g1(res.x), g2(res.x), h1(res.x)\n        (-5.0626169922907138e-14, -2.9594104944408173e-12, 0.0)\n\n\nParameters\n----------\n\n::\n\n    func : callable\n\nThe objective function to be minimized. Must be in the form\n``f(x, *args)``, where ``x`` is the argument in the form of a 1-D array\nand ``args`` is a tuple of any additional fixed parameters needed to\ncompletely specify the function.\n\n--------------\n\n::\n\n    bounds : sequence\n\nBounds for variables. ``(min, max)`` pairs for each element in ``x``,\ndefining the lower and upper bounds for the optimizing argument of\n``func``. It is required to have ``len(bounds) == len(x)``.\n``len(bounds)`` is used to determine the number of parameters in ``x``.\nUse ``None`` for one of min or max when there is no bound in that\ndirection. By default bounds are ``(None, None)``.\n\n--------------\n\n::\n\n    args : tuple, optional\n\nAny additional fixed parameters needed to completely specify the\nobjective function.\n\n--------------\n\n::\n\n    constraints : dict or sequence of dict, optional\n\nConstraints definition. Function(s) R^n in the form g(x) <= 0 applied as\ng : R^n -> R^m h(x) == 0 applied as h : R^n -> R^p\n\nEach constraint is defined in a dictionary with fields:\n\n::\n\n    * type : str\n        Constraint type: 'eq' for equality, 'ineq' for inequality.\n    * fun : callable\n        The function defining the constraint.\n    * jac : callable, optional\n        The Jacobian of `fun` (only for SLSQP).\n    * args : sequence, optional\n        Extra arguments to be passed to the function and Jacobian.\n\nEquality constraint means that the constraint function result is to be\nzero whereas inequality means that it is to be non-negative. Note that\nCOBYLA only supports inequality constraints.\n\nNOTE: Only the COBYLA and SLSQP local minimize methods currently support\nconstraint arguments. If the ``constraints`` sequence used in the local\noptimization problem is not defined in ``minimizer_kwargs`` and a\nconstrained method is used then the global ``constraints`` will be used.\n(Defining a ``constraints`` sequence in ``minimizer_kwargs`` means that\n``constraints`` will not be added so if equality constraints and so\nforth need to be added then the inequality functions in ``constraints``\nneed to be added to ``minimizer_kwargs`` too).\n\n--------------\n\n::\n\n    n : int, optional\n\nNumber of sampling points used in the construction of the simplicial\ncomplex. Note that this argument is only used for ``sobol`` and other\narbitrary sampling\\_methods.\n\n--------------\n\n::\n\n    iters : int, optional\n\nNumber of iterations used in the construction of the simplicial complex.\n\n--------------\n\n::\n\n    callback : callable, optional\n\nCalled after each iteration, as ``callback(xk)``, where ``xk`` is the\ncurrent parameter vector.\n\n--------------\n\n::\n\n    minimizer_kwargs : dict, optional\n\nExtra keyword arguments to be passed to the minimizer\n``scipy.optimize.minimize`` Some important options could be:\n\n::\n\n    * method : str\n        The minimization method (e.g. ``SLSQP``)\n    * args : tuple\n        Extra arguments passed to the objective function (``func``) and\n        its derivatives (Jacobian, Hessian).\n\n    options : {ftol: 1e-12}\n\n--------------\n\n::\n\n    options : dict, optional\n\nA dictionary of solver options. Many of the options specified for the\nglobal routine are also passed to the scipy.optimize.minimize routine.\nThe options that are also passed to the local routine are marked with an\n(L)\n\nStopping criteria, the algorithm will terminate if any of the specified\ncriteria are met. However, the default algorithm does not require any to\nbe specified:\n\n::\n\n    * maxfev : int (L)\n        Maximum number of function evaluations in the feasible domain.\n        (Note only methods that support this option will terminate\n        the routine at precisely exact specified value. Otherwise the\n        criterion will only terminate during a global iteration)\n    * f_min\n        Specify the minimum objective function value, if it is known.\n    * f_tol : float\n        Precision goal for the value of f in the stopping\n        criterion. Note that the global routine will also\n        terminate if a sampling point in the global routine is\n        within this tolerance.\n    * maxiter : int\n        Maximum number of iterations to perform.\n    * maxev : int\n        Maximum number of sampling evaluations to perform (includes\n        searching in infeasible points).\n    * maxtime : float\n        Maximum processing runtime allowed\n    * maxhgrd : int\n        Maximum homology group rank differential. The homology group of the\n        objective function is calculated (approximately) during every\n        iteration. The rank of this group has a one-to-one correspondence\n        with the number of locally convex subdomains in the objective\n        function (after adequate sampling points each of these subdomains\n        contain a unique global minima). If the difference in the hgr is 0\n        between iterations for ``maxhgrd`` specified iterations the\n        algorithm will terminate.\n\nObjective function knowledge:\n\n::\n\n    * symmetry : bool\n       Specify True if the objective function contains symmetric variables.\n       The search space (and therfore performance) is decreased by O(n!).\n\nAlgorithm settings:\n\n::\n\n    * minimize_every_iter : bool\n        If True then promising global sampling points will be passed to a\n        local minimisation routine every iteration. If False then only the\n        final minimiser pool will be run.\n    * local_iter : int\n        Only evaluate a few of the best minimiser pool candiates every\n        iteration. If False all potential points are passed to the local\n        minimsation routine.\n    * infty_constraints: bool\n        If True then any sampling points generated which are outside will\n        the feasible domain will be saved and given an objective function\n        value of numpy.inf. If False then these points will be discarded.\n        Using this functionality could lead to higher performance with\n        respect to function evaluations before the global minimum is found,\n        specifying False will use less memory at the cost of a slight\n        decrease in performance.\n\nFeedback:\n\n::\n\n    * disp : bool (L)\n        Set to True to print convergence messages.\n\n--------------\n\n::\n\n    sampling_method : str or function, optional\n\nCurrent built in sampling method options are ``sobol`` and\n``simplicial``. The default ``simplicial`` uses less memory and provides\nthe theoretical guarantee of convergence to the global minimum in finite\ntime. The ``sobol`` method is faster in terms of sampling point\ngeneration at the cost of higher memory resources and the loss of\nguaranteed convergence. It is more appropriate for most \"easier\"\nproblems where the convergence is relatively fast. User defined sampling\nfunctions must accept two arguments of ``n`` sampling points of\ndimension ``dim`` per call and output an array of s ampling points with\nshape ``n x dim``. See SHGO.sampling\\_sobol for an example function.\n\nReturns\n-------\n\n::\n\n    res : OptimizeResult\n\nThe optimization result represented as a ``OptimizeResult`` object.\nImportant attributes are: ``x`` the solution array corresponding to the\nglobal minimum, ``fun`` the function output at the global solution,\n``xl`` an ordered list of local minima solutions, ``funl`` the function\noutput at the corresponding local solutions, ``success`` a Boolean flag\nindicating if the optimizer exited successfully, ``message`` which\ndescribes the cause of the termination, ``nfev`` the total number of\nobjective function evaluations including the sampling calls, ``nlfev``\nthe total number of objective function evaluations culminating from all\nlocal search optimisations, ``nit`` number of iterations performed by\nthe global routine.\n\nNotes\n-----\n\nGlobal optimisation using simplicial homology global optimisation [1].\nAppropriate for solving general purpose NLP and blackbox optimisation\nproblems to global optimality (low dimensional problems).\n\nIn general, the optimisation problems are of the form:\n\n::\n\n    minimize f(x) subject to\n\n    g_i(x) >= 0,  i = 1,...,m\n    h_j(x)  = 0,  j = 1,...,p\n\nwhere x is a vector of one or more variables. ``f(x)`` is the objective\nfunction ``R^n -> R`` ``g_i(x)`` are the inequality constraints.\n``h_j(x)`` are the equality constrains.\n\nOptionally, the lower and upper bounds for each element in x can also be\nspecified using the ``bounds`` argument.\n\nWhile most of the theoretical advantages of shgo are only proven for\nwhen ``f(x)`` is a Lipschitz smooth function. The algorithm is also\nproven to converge to the global optimum for the more general case where\n``f(x)`` is non-continuous, non-convex and non-smooth iff the default\nsampling method is used [1].\n\nThe local search method may be specified using the ``minimizer_kwargs``\nparameter which is inputted to ``scipy.optimize.minimize``. By default\nthe ``SLSQP`` method is used. In general it is recommended to use the\n``SLSQP`` or ``COBYLA`` local minimization if inequality constraints are\ndefined for the problem since the other methods do not use constraints.\n\nThe ``sobol`` method points are generated using the Sobol (1967) [2]\nsequence. The primitive polynomials and various sets of initial\ndirection numbers for generating Sobol sequences is provided by [3] by\nFrances Kuo and Stephen Joe. The original program sobol.cc (MIT) is\navailable and described at http://web.maths.unsw.edu.au/~fkuo/sobol/\ntranslated to Python 3 by Carl Sandrock 2016-03-31.\n\nReferences\n----------\n\n1. Endres, SC (2017) \"A simplicial homology algorithm for Lipschitz\n   optimisation\".\n\n2. Sobol, IM (1967) \"The distribution of points in a cube and the\n   approximate evaluation of integrals\", USSR Comput. Math. Math. Phys.\n   7, 86-112.\n\n3. Joe, SW and Kuo, FY (2008) \"Constructing Sobol sequences with better\n   two-dimensional projections\", SIAM J. Sci. Comput. 30, 2635-2654.\n\n4. Hoch, W and Schittkowski, K (1981) \"Test examples for nonlinear\n   programming codes\", Lecture Notes in Economics and mathematical\n   Systems, 187. Springer-Verlag, New York.\n   http://www.ai7.uni-bayreuth.de/test\\_problem\\_coll.pdf\n\n5. Wales, DJ (2015) \"Perspective: Insight into reaction coordinates and\n   dynamics from the potential energy landscape\", Journal of Chemical\n   Physics, 142(13), 2015.\n\n.. |Build Status| image:: https://travis-ci.org/Stefan-Endres/shgo.svg?branch=master\n   :target: https://travis-ci.org/Stefan-Endres/shgo\n.. |Build Status| image:: https://coveralls.io/repos/Stefan-Endres/shgo/badge.png?branch=master\n   :target: https://coveralls.io/r/Stefan-Endres/shgo?branch=master\n\n\n",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "https://github.com/stefan-endres/shgo",
    "keywords": "optimization",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "shgo",
    "platform": "",
    "project_url": "https://pypi.org/project/shgo/",
    "release_url": "https://pypi.org/project/shgo/0.3.4/",
    "requires_dist": [
      "numpy",
      "scipy"
    ],
    "requires_python": "",
    "summary": "Simplicial homology global optimisation",
    "version": "0.3.4"
  },
  "releases": {
    "0.3.3": [
      {
        "comment_text": "",
        "digests": {
          "md5": "6d02ea6182be25aa7a79a4bdd90c0905",
          "sha256": "d676cd1ad34c2b885d337b5dfe83298d765308d38f31e63818af292f4956d3a2"
        },
        "downloads": -1,
        "filename": "shgo-0.3.3-py2.py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "6d02ea6182be25aa7a79a4bdd90c0905",
        "packagetype": "bdist_wheel",
        "python_version": "py2.py3",
        "size": 44083,
        "upload_time": "2017-10-17T15:11:55",
        "url": "https://files.pythonhosted.org/packages/8d/d6/7fc7ac3cc9685a8832772f97c2faff7e20028280b2bf21471a33f6e6d590/shgo-0.3.3-py2.py3-none-any.whl"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "6e075b299eab2750ca3d32098a9992d4",
          "sha256": "6e412e8aeff86fa0e8c5cb0929c9560f5f32b9dee9ff66536415b69d3b1fcce9"
        },
        "downloads": -1,
        "filename": "shgo-0.3.3.tar.gz",
        "has_sig": false,
        "md5_digest": "6e075b299eab2750ca3d32098a9992d4",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 47200,
        "upload_time": "2017-10-17T15:11:57",
        "url": "https://files.pythonhosted.org/packages/89/46/ecf5eb4e8ab44d730dff8ffeba4cf1f47d731cd0c4234b3e12541d865bd4/shgo-0.3.3.tar.gz"
      }
    ],
    "0.3.4": [
      {
        "comment_text": "",
        "digests": {
          "md5": "9fac4c1bdb715749c992084814ab4fe4",
          "sha256": "3a0ac74138f9c5dfa224cbb172226abea9f50e7c96d469350dcb8b5e78e3cfd3"
        },
        "downloads": -1,
        "filename": "shgo-0.3.4-py2.py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "9fac4c1bdb715749c992084814ab4fe4",
        "packagetype": "bdist_wheel",
        "python_version": "py2.py3",
        "size": 56648,
        "upload_time": "2017-10-18T07:53:44",
        "url": "https://files.pythonhosted.org/packages/13/b2/ee1e87a5a29c0ecc22a8128f55ab291cbdf1e3be4c8e938b340a554d7fb1/shgo-0.3.4-py2.py3-none-any.whl"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "6485a425b6db342a1bbcf67ef77203d4",
          "sha256": "efc3d355fad9f2b7bd6d07c61ec1da1c6cac3d2547e9687ade59b71dea3d1889"
        },
        "downloads": -1,
        "filename": "shgo-0.3.4-py3.6.egg",
        "has_sig": false,
        "md5_digest": "6485a425b6db342a1bbcf67ef77203d4",
        "packagetype": "bdist_egg",
        "python_version": "3.6",
        "size": 98434,
        "upload_time": "2017-10-18T07:53:48",
        "url": "https://files.pythonhosted.org/packages/f8/03/6cd5cfe047e6771f2573710b61d88d2d6af86764b96f56c365b2b6dcbe31/shgo-0.3.4-py3.6.egg"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "64dfa90c2604f7a2f50b7ebc8e32d407",
          "sha256": "8626bf14b06922e4380ad5a26f17a16bf6db5681b6e7d2659865dd99e6a2f6ff"
        },
        "downloads": -1,
        "filename": "shgo-0.3.4.tar.gz",
        "has_sig": false,
        "md5_digest": "64dfa90c2604f7a2f50b7ebc8e32d407",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 52042,
        "upload_time": "2017-10-18T07:53:49",
        "url": "https://files.pythonhosted.org/packages/f9/0d/aaa491c7f9e4c286692fe0525b12b1706ebd2acd5a5950b93ea180315a15/shgo-0.3.4.tar.gz"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "9fac4c1bdb715749c992084814ab4fe4",
        "sha256": "3a0ac74138f9c5dfa224cbb172226abea9f50e7c96d469350dcb8b5e78e3cfd3"
      },
      "downloads": -1,
      "filename": "shgo-0.3.4-py2.py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "9fac4c1bdb715749c992084814ab4fe4",
      "packagetype": "bdist_wheel",
      "python_version": "py2.py3",
      "size": 56648,
      "upload_time": "2017-10-18T07:53:44",
      "url": "https://files.pythonhosted.org/packages/13/b2/ee1e87a5a29c0ecc22a8128f55ab291cbdf1e3be4c8e938b340a554d7fb1/shgo-0.3.4-py2.py3-none-any.whl"
    },
    {
      "comment_text": "",
      "digests": {
        "md5": "6485a425b6db342a1bbcf67ef77203d4",
        "sha256": "efc3d355fad9f2b7bd6d07c61ec1da1c6cac3d2547e9687ade59b71dea3d1889"
      },
      "downloads": -1,
      "filename": "shgo-0.3.4-py3.6.egg",
      "has_sig": false,
      "md5_digest": "6485a425b6db342a1bbcf67ef77203d4",
      "packagetype": "bdist_egg",
      "python_version": "3.6",
      "size": 98434,
      "upload_time": "2017-10-18T07:53:48",
      "url": "https://files.pythonhosted.org/packages/f8/03/6cd5cfe047e6771f2573710b61d88d2d6af86764b96f56c365b2b6dcbe31/shgo-0.3.4-py3.6.egg"
    },
    {
      "comment_text": "",
      "digests": {
        "md5": "64dfa90c2604f7a2f50b7ebc8e32d407",
        "sha256": "8626bf14b06922e4380ad5a26f17a16bf6db5681b6e7d2659865dd99e6a2f6ff"
      },
      "downloads": -1,
      "filename": "shgo-0.3.4.tar.gz",
      "has_sig": false,
      "md5_digest": "64dfa90c2604f7a2f50b7ebc8e32d407",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 52042,
      "upload_time": "2017-10-18T07:53:49",
      "url": "https://files.pythonhosted.org/packages/f9/0d/aaa491c7f9e4c286692fe0525b12b1706ebd2acd5a5950b93ea180315a15/shgo-0.3.4.tar.gz"
    }
  ]
}