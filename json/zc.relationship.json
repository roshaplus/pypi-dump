{
  "info": {
    "author": "Zope Project",
    "author_email": "zope3-dev@zope.org",
    "bugtrack_url": null,
    "classifiers": [],
    "description": "=======\nCHANGES\n=======\n\n1.1\n===\n\n(supports Zope 3.4/Zope 2.11/ZODB 3.8)\n\n1.1.1\n-----\n\n- Add support for both ZODB 3.7 and ZODB 3.8 via a small import location\n  monkey patch.\n\n- Fix name errors caught by pyflakes.\n\n1.1.0\n-----\n\n- adjust to BTrees changes in ZODB 3.8 (thanks Juergen Kartnaller)\n\n- converted buildout to rely exclusively on eggs  \n\n1.0\n===\n\n(supports Zope 3.3/Zope 2.10/ZODB 3.7)\n\n1.0.2\n-----\n\n- Incorporated tests and bug fixes to relationship containers from\n  Markus Kemmerling:\n\n  * ManyToOneRelationship instantiation was broken\n  \n  * The `findRelationships` method misbehaved if both, `source` and `target`,\n    are not None, but `bool(target)` evaluated to False.\n    \n  * ISourceRelationship and ITargetRelationship had errors.\n\n1.0.1\n-----\n\n(supports Zope 3.3/Zope 2.10/ZODB 3.7)\n\n- Incorporated test and bug fix from Gabriel Shaar:\n\n  if the target parameter is a container with no objects, then\n  `shared.AbstractContainer.isLinked` resolves to False in a bool context and\n  tokenization fails.  `target and tokenize({'target': target})` returns the\n  target instead of the result of the tokenize function.\n\n- Made README.txt tests pass on hopefully wider set of machines (this was a\n  test improvement; the relationship index did not have the fragility).\n  Reported by Gabriel Shaar.\n\n1.0\n---\n\n(supports Zope 3.3/Zope 2.10/ZODB 3.7)\n\nInitial release\n\n========\nOverview\n========\n\nThe Relationship package currently contains two main types of components: a\nrelationship index, and some relationship containers.  Both are designed for\nuse within the ZODB.  They share the model that relationships are full-fledged\nobjects that are indexed for optimized searches.  They also share the ability\nto perform optimized intransitive and transitive relationship searches, and\nto support arbitrary filter searches on relationship tokens.\n\nThe index is a very generic component that can be used to optimize searches\nfor N-ary relationships, can be used standalone or within a catalog, can be\nused with pluggable token generation schemes, and generally tries to provide\na relatively policy-free tool.  It is expected to be used primarily as an\nengine for more specialized and constrained tools and APIs.\n\nThe relationship containers use the index to manage two-way\nrelationships, using a derived mapping interface.  It is a reasonable\nexample of the index in standalone use.\n\nThis document describes the relationship index.  See container.txt for\ndocumentation of the relationship container.\n\n=====\nIndex\n=====\n\nThe index interface searches for object and relationship tokens. To use a\nrelationship index, you need to have interface attributes, or methods callable\nwith no arguments, that are treated as relationship pointers.  The pointers\nmay be a collection of items or a single item.\n\nTo exercise the index, we'll come up with a somewhat complex relationship to\nindex. Let's say we are modeling a generic set-up like SUBJECT\nRELATIONSHIPTYPE OBJECT in CONTEXT.  This could let you let users define\nrelationship types, then index them on the fly.  The context can be something\nlike a project, so we could say\n\n\"Fred\" \"has the role of\" \"Project Manager\" on the \"zope.org redesign project\".\n\nMapped to the parts of the relationship object, that's\n\n[\"Fred\" (SUBJECT)] [\"has the role of\" (RELATIONSHIPTYPE)]\n[\"Project Manager\" (OBJECT)] on the [\"zope.org redesign project\" (CONTEXT)].\n\nWithout the context, you can still do interesting things like\n\n[\"Ygritte\" (SUBJECT)] [\"manages\" (RELATIONSHIPTYPE)] [\"Uther\" (OBJECT)]\n\nSo let's define a basic interface without the context, and then an extended\ninterface with the context.\n\n    >>> from zope import interface\n    >>> class IRelationship(interface.Interface):\n    ...     subjects = interface.Attribute(\n    ...         'The sources of the relationship; the subject of the sentence')\n    ...     relationshiptype = interface.Attribute(\n    ...         '''unicode: the single relationship type of this relationship;\n    ...         usually contains the verb of the sentence.''')\n    ...     objects = interface.Attribute(\n    ...         '''the targets of the relationship; usually a direct or\n    ...         indirect object in the sentence''')\n    ...\n    >>> class IContextAwareRelationship(IRelationship):\n    ...     def getContext():\n    ...         '''return a context for the relationship'''\n    ...\n\nNow we'll create an index.  To do that, we must minimally pass in an iterable\ndescribing the indexed values.  Each item in the iterable must either be an\ninterface element (a zope.interface.Attribute or zope.interface.Method\nassociated with an interface, typically obtained using a spelling like\n`IRelationship['subjects']`) or a dict.  Each dict must have at least one key:\n'element', which is the interface element to be indexed.  It then can contain\nother keys to override the default indexing behavior for the element.\n\nThe element's __name__ will be used to refer to this element in queries, unless\nthe dict has a 'name' key, which must be a non-empty string.\n\nThe element is assumed to be a single value, unless the dict has a 'multiple'\nkey with a value equivalent True.  In our example, \"subjects\" and \"objects\" are\npotentially multiple values, while \"relationshiptype\" and \"getContext\" are\nsingle values.\n\nBy default, the values for the element will be tokenized and resolved using an\nintid utility, and stored in a BTrees.IFBTree.  This is a good choice if you\nwant to make object tokens easily mergable with typical Zope 3 catalog\nresults.  If you need different behavior for any element, you can specify\nthree keys per dict:\n\n- 'dump', the tokenizer, a callable taking (obj, index, cache) and returning a\n  token;\n\n- 'load' the token resolver, a callable taking (token, index, cache) to return\n  the object which the token represents; and\n\n- 'btree', the btree module to use to store and process the tokens, such as\n  BTrees.OOBTree.\n\nIf you provide a custom 'dump' you will almost certainly need to provide a\ncustom 'load'; and if your tokens are not integers then you will need to\nspecify a different 'btree' (either BTrees.OOBTree or BTrees.OIBTree, as of\nthis writing).\n\nThe tokenizing function ('dump') *must* return homogenous, immutable tokens:\nthat is, any given tokenizer should only return tokens that sort\nunambiguously, across Python versions, which usually mean that they are all of\nthe same type.  For instance, a tokenizer should only return ints, or only\nreturn strings, or only tuples of strings, and so on.  Different tokenizers\nused for different elements in the same index may return different types. They\nalso may return the same value as the other tokenizers to mean different\nobjects: the stores are separate.\n\nIn addition to the one required argument to the class, the signature contains\nfour optional arguments.  The 'defaultTransitiveQueriesFactory' is the next,\nand allows you to specify a callable as described in\ninterfaces.ITransitiveQueriesFactory.  Without it transitive searches will\nrequire an explicit factory every time, which can be tedious.  The index\npackage provides a simple implementation that supports transitive searches\nfollowing two indexed elements (TransposingTransitiveQueriesFactory) and this\ndocument describes more complex possible transitive behaviors that can be\nmodeled.  For our example, \"subjects\" and \"objects\" are the default transitive\nfields, so if Ygritte (SUBJECT) manages Uther (OBJECT), and Uther (SUBJECT)\nmanages Emily (OBJECT), a search for all those transitively managed by Ygritte\nwill transpose Uther from OBJECT to SUBJECT and find that Uther manages Emily.\nSimilarly, to find all transitive managers of Emily, Uther will change place\nfrom SUBJECT to OBJECT in the search.\n\nThe next three arguments, 'dumpRel', 'loadRel' and 'relFamily', have\nto do with the relationship tokens.  The default values assume that you will\nbe using intid tokens for the relationships, and so 'dumpRel' and\n'loadRel' tokenize and resolve, respectively, using the intid utility; and\n'relFamily' defaults to BTrees.IFBTree.\n\nIf relationship tokens (from 'findRelationshipChains' or 'apply' or\n'findRelationshipTokenSet', or in a filter to most of the search methods) are\nto be merged with other catalog results, relationship tokens should be based\non intids, as in the default.  For instance, if some relationships are only\navailable to some users on the basis of security, and you keep an index of\nthis, then you will want to use a filter based on the relationship tokens\nviewable by the current user as kept by the catalog index.\n\nIf you are unable or unwilling to use intid relationship tokens, tokens must\nstill be homogenous and immutable as described above for indexed values tokens.\n\nThe last argument is 'deactivateSets', which defaults to False.  This is an\noptimization to try and keep relationship index searches from consuming too\nmuch of the ZODB's object cache.  It can cause inefficiency under some\nusages--if queries against the relationship index are very frequent and often\nuse the same sets, for instance--and it exposes a bug in the ZODB at the time\nof this writing (_p_deactivate on a new object that has been given an _p_oid\nbut has not yet been committed will irretrievably snuff out the object before\nit has had a chance to be committed, so if you add and query in the same\ntransaction you will have trouble).  Pass True to this argument to enable\nthis optimization.\n\nIf we had an IIntId utility registered and wanted to use the defaults, then\ninstantiation  of an index for our relationship would look like this:\n\n    >>> from zc.relationship import index\n    >>> ix = index.Index(\n    ...     ({'element': IRelationship['subjects'], 'multiple': True},\n    ...      IRelationship['relationshiptype'],\n    ...      {'element': IRelationship['objects'], 'multiple': True},\n    ...      IContextAwareRelationship['getContext']),\n    ...     index.TransposingTransitiveQueriesFactory('subjects', 'objects'))\n\nThat's the simple case.  With relatively little fuss, we have an IIndex, and a\ndefaultTransitiveQueriesFactory, implementing ITransitiveQueriesFactory, that\nswitches subjects and objects as described above.\n\n    >>> from zc.relationship import interfaces\n    >>> from zope.interface.verify import verifyObject\n    >>> verifyObject(interfaces.IIndex, ix)\n    True\n    >>> verifyObject(\n    ...     interfaces.ITransitiveQueriesFactory,\n    ...     ix.defaultTransitiveQueriesFactory)\n    True\n\nFor the purposes of a more complex example, though, we are going to exercise\nmore of the index's options--we'll use at least one of 'name', 'dump', 'load',\nand 'btree'.\n\n- 'subjects' and 'objects' will use a custom integer-based token generator.\n  They will share tokens, which will let us use the default\n  TransposingTransitiveQueriesFactory.  We can keep using the IFBTree sets,\n  because the tokens are still integers.\n\n- 'relationshiptype' will use a name 'reltype' and will just use the unicode\n  value as the token, without translation but with a registration check.\n\n- 'getContext' will use a name 'context' but will continue to use the intid\n  utility and use the names from their interface.  We will see later that\n  making transitive walks between different token sources must be handled with\n  care.\n\nWe will also use the intid utility to resolve relationship tokens.  See the\nrelationship container (and container.txt) for examples of changing the\nrelationship type, especially in keyref.py.  The example also turns on the\n'deactivateSets' optimization.\n\nHere are the methods we'll use for the 'subjects' and 'objects' tokens,\nfollowed by the methods we'll use for the 'relationshiptypes' tokens.\n\n    >>> lookup = {}\n    >>> counter = [0]\n    >>> prefix = '_z_token__'\n    >>> def dump(obj, index, cache):\n    ...     assert (interfaces.IIndex.providedBy(index) and\n    ...             isinstance(cache, dict)), (\n    ...         'did not receive correct arguments')\n    ...     token = getattr(obj, prefix, None)\n    ...     if token is None:\n    ...         token = counter[0]\n    ...         counter[0] += 1\n    ...         if counter[0] >= 2147483647:\n    ...             raise RuntimeError(\"Whoa!  That's a lot of ids!\")\n    ...         assert token not in lookup\n    ...         setattr(obj, prefix, token)\n    ...         lookup[token] = obj\n    ...     return token\n    ...\n    >>> def load(token, index, cache):\n    ...     assert (interfaces.IIndex.providedBy(index) and\n    ...             isinstance(cache, dict)), (\n    ...         'did not receive correct arguments')\n    ...     return lookup[token]\n    ...\n    >>> relTypes = []\n    >>> def relTypeDump(obj, index, cache):\n    ...     assert obj in relTypes, 'unknown relationshiptype'\n    ...     return obj\n    ...\n    >>> def relTypeLoad(token, index, cache):\n    ...     assert token in relTypes, 'unknown relationshiptype'\n    ...     return obj\n    ...\n\nNote that these implementations are completely silly if we actually cared about\nZODB-based persistence: to even make it half-acceptable we should make the\ncounter, lookup, and and relTypes persistently stored somewhere using a\nreasonable persistent data structure.  This is just a demonstration example.\n\nNow we can make an index.\n\nAs in our initial example, we are going to use the simple transitive query\nfactory defined in the index module for our default transitive behavior: when\nyou want to do transitive searches, transpose 'subjects' with 'objects' and\nkeep everything else; and if both subjects and objects are provided, don't do\nany transitive search.\n\n    >>> from BTrees import OIBTree # could also be OOBTree\n    >>> ix = index.Index(\n    ...     ({'element': IRelationship['subjects'], 'multiple': True,\n    ...       'dump': dump, 'load': load},\n    ...      {'element': IRelationship['relationshiptype'],\n    ...       'dump': relTypeDump, 'load': relTypeLoad, 'btree': OIBTree,\n    ...       'name': 'reltype'},\n    ...      {'element': IRelationship['objects'], 'multiple': True,\n    ...       'dump': dump, 'load': load},\n    ...      {'element': IContextAwareRelationship['getContext'],\n    ...       'name': 'context'}),\n    ...     index.TransposingTransitiveQueriesFactory('subjects', 'objects'))\n\nWe'll want to put the index somewhere in the system so it can find the intid\nutility.  We'll add it as a utility just as part of the example.  As long as\nthe index has a valid __parent__ that is itself connected transitively to a\nsite manager with the desired intid utility, everything should work fine, so\nno need to install it as utility.  This is just an example.\n\n    >>> from zope import interface\n    >>> sm = app.getSiteManager()\n    >>> sm['rel_index'] = ix\n    >>> import zope.component.interfaces\n    >>> registry = zope.component.interfaces.IComponentRegistry(sm)\n    >>> registry.registerUtility(ix, interfaces.IIndex)\n    >>> import transaction\n    >>> transaction.commit()\n\nNow we'll create some representative objects that we can relate, and create\nand index our first example relationship.\n\nIn the example, note that the context will only be available as an adapter to\nISpecialRelationship objects: the index tries to adapt objects to the\nappropriate interface, and considers the value to be empty if it cannot adapt.\n\n    >>> import persistent\n    >>> from zope.app.container.contained import Contained\n    >>> class Base(persistent.Persistent, Contained):\n    ...     def __init__(self, name):\n    ...         self.name = name\n    ...     def __repr__(self):\n    ...         return '<%s %r>' % (self.__class__.__name__, self.name)\n    ...\n    >>> class Person(Base): pass\n    ...\n    >>> class Role(Base): pass\n    ...\n    >>> class Project(Base): pass\n    ...\n    >>> class Company(Base): pass\n    ...\n    >>> class Relationship(persistent.Persistent, Contained):\n    ...     interface.implements(IRelationship)\n    ...     def __init__(self, subjects, relationshiptype, objects):\n    ...         self.subjects = subjects\n    ...         assert relationshiptype in relTypes\n    ...         self.relationshiptype = relationshiptype\n    ...         self.objects = objects\n    ...     def __repr__(self):\n    ...         return '<%r %s %r>' % (\n    ...             self.subjects, self.relationshiptype, self.objects)\n    ...\n    >>> class ISpecialRelationship(interface.Interface):\n    ...     pass\n    ...\n    >>> from zope import component\n    >>> class ContextRelationshipAdapter(object):\n    ...     component.adapts(ISpecialRelationship)\n    ...     interface.implements(IContextAwareRelationship)\n    ...     def __init__(self, adapted):\n    ...         self.adapted = adapted\n    ...     def getContext(self):\n    ...         return getattr(self.adapted, '_z_context__', None)\n    ...     def setContext(self, value):\n    ...         self.adapted._z_context__ = value\n    ...     def __getattr__(self, name):\n    ...         return getattr(self.adapted, name)\n    ...\n    >>> component.provideAdapter(ContextRelationshipAdapter)\n    >>> class SpecialRelationship(Relationship):\n    ...     interface.implements(ISpecialRelationship)\n    ...\n    >>> people = {}\n    >>> for p in ['Abe', 'Bran', 'Cathy', 'David', 'Emily', 'Fred', 'Gary',\n    ...           'Heather', 'Ingrid', 'Jim', 'Karyn', 'Lee', 'Mary',\n    ...           'Nancy', 'Olaf', 'Perry', 'Quince', 'Rob', 'Sam', 'Terry',\n    ...           'Uther', 'Van', 'Warren', 'Xen', 'Ygritte', 'Zane']:\n    ...     app[p] = people[p] = Person(p)\n    ...\n    >>> relTypes.extend(\n    ...     ['has the role of', 'manages', 'taught', 'commissioned'])\n    >>> roles = {}\n    >>> for r in ['Project Manager', 'Software Engineer', 'Designer',\n    ...           'Systems Administrator', 'Team Leader', 'Mascot']:\n    ...     app[r] = roles[r] = Role(r)\n    ...\n    >>> projects = {}\n    >>> for p in ['zope.org redesign', 'Zope 3 manual',\n    ...           'improved test coverage', 'Vault design and implementation']:\n    ...     app[p] = projects[p] = Project(p)\n    ...\n    >>> companies = {}\n    >>> for c in ['Ynod Corporation', 'HAL, Inc.', 'Zookd']:\n    ...     app[c] = companies[c] = Company(c)\n    ...\n\n    >>> app['fredisprojectmanager'] = rel = SpecialRelationship(\n    ...     (people['Fred'],), 'has the role of', (roles['Project Manager'],))\n    >>> IContextAwareRelationship(rel).setContext(\n    ...     projects['zope.org redesign'])\n    >>> ix.index(rel)\n    >>> transaction.commit()\n\nToken conversion\n================\n\nBefore we examine the searching features, we should quickly discuss the\ntokenizing API on the index.  All search queries must use value tokens, and\nsearch results can sometimes be value or relationship tokens.  Therefore\nconverting between tokens and real values can be important.  The index\nprovides a number of conversion methods for this purpose.\n\nArguably the most important is `tokenizeQuery`: it takes a query, in which\neach key and value are the name of an indexed value and an actual value,\nrespectively; and returns a query in which the actual values have been\nconverted to tokens.  For instance, consider the following example.  It's a\nbit hard to show the conversion reliably (we can't know what the intid tokens\nwill be, for instance) so we just show that the result's values are tokenized\nversions of the inputs.\n\n    >>> res = ix.tokenizeQuery(\n    ...     {'objects': roles['Project Manager'],\n    ...      'context': projects['zope.org redesign']})\n    >>> res['objects'] == dump(roles['Project Manager'], ix, {})\n    True\n    >>> from zope.app.intid.interfaces import IIntIds\n    >>> intids = component.getUtility(IIntIds, context=ix)\n    >>> res['context'] == intids.getId(projects['zope.org redesign'])\n    True\n\nTokenized queries can be resolved to values again using resolveQuery.\n\n    >>> sorted(ix.resolveQuery(res).items()) # doctest: +NORMALIZE_WHITESPACE\n    [('context', <Project 'zope.org redesign'>),\n     ('objects', <Role 'Project Manager'>)]\n\nOther useful conversions are `tokenizeValues`, which returns an iterable of\ntokens for the values of the given index name;\n\n    >>> examples = (people['Abe'], people['Bran'], people['Cathy'])\n    >>> res = list(ix.tokenizeValues(examples, 'subjects'))\n    >>> res == [dump(o, ix, {}) for o in examples]\n    True\n\n`resolveValueTokens`, which returns an iterable of values for the tokens of\nthe given index name;\n\n    >>> list(ix.resolveValueTokens(res, 'subjects'))\n    [<Person 'Abe'>, <Person 'Bran'>, <Person 'Cathy'>]\n\n`tokenizeRelationship`, which returns a token for the given relationship;\n\n    >>> res = ix.tokenizeRelationship(rel)\n    >>> res == intids.getId(rel)\n    True\n\n`resolveRelationshipToken`, which returns a relationship for the given token;\n\n    >>> ix.resolveRelationshipToken(res) is rel\n    True\n\n`tokenizeRelationships`, which returns an iterable of tokens for the relations\ngiven; and\n\n    >>> app['another_rel'] = another_rel = Relationship(\n    ...     (companies['Ynod Corporation'],), 'commissioned',\n    ...     (projects['Vault design and implementation'],))\n    >>> res = list(ix.tokenizeRelationships((another_rel, rel)))\n    >>> res == [intids.getId(r) for r in (another_rel, rel)]\n    True\n\n`resolveRelationshipTokens`, which returns an iterable of relations for the\ntokens given.\n\n    >>> list(ix.resolveRelationshipTokens(res)) == [another_rel, rel]\n    True\n\nBasic searching\n===============\n\nNow we move to the meat of the interface: searching.  The index interface\ndefines several searching methods:\n\n- `findValues` and `findValueTokens` ask \"to what is this related?\";\n\n- `findRelationshipChains` and `findRelationshipTokenChains` ask \"how is this\n  related?\", especially for transitive searches;\n\n- `isLinked` asks \"does a relationship like this exist?\";\n\n- `findRelationshipTokenSet` asks \"what are the intransitive relationships\n  that match my query?\" and is particularly useful for low-level usage of the\n  index data structures;\n\n- `findRelationships` asks the same question, but returns an iterable of\n  relationships rather than a set of tokens;\n\n- `findValueTokenSet` asks \"what are the value tokens for this particular\n  indexed name and this relationship token?\" and is useful for low-level\n  usage of the index data structures such as transitive query factories; and\n\n- the standard zope.index method `apply` essentially exposes the\n  `findRelationshipTokenSet` and `findValueTokens` methods via a query object\n  spelling.\n\n`findRelationshipChains` and `findRelationshipTokenChains` are paired methods,\ndoing the same work but with and without resolving the resulting tokens; and\n`findValues` and `findValueTokens` are also paired in the same way.\n\nIt is very important to note that all queries must use tokens, not actual\nobjects.  As introduced above, the index provides a method to ease that\nrequirement, in the form of a `tokenizeQuery` method that converts a dict with\nobjects to a dict with tokens.  You'll see below that we shorten our calls by\nstashing `tokenizeQuery` away in the 'q' name.\n\nWe have indexed our first example relationship--\"Fred has the role of project\nmanager in the zope.org redesign\"--so we can search for it.  We'll first look\nat `findValues` and `findValueTokens`.  Here, we ask 'who has the role of\nproject manager in the zope.org redesign?'.  We do it first with findValues\nand then with findTokenValues.\n\n    >>> q = ix.tokenizeQuery\n    >>> list(ix.findValues(\n    ...     'subjects',\n    ...     q({'reltype': 'has the role of',\n    ...       'objects': roles['Project Manager'],\n    ...       'context': projects['zope.org redesign']})))\n    [<Person 'Fred'>]\n\n    >>> [load(t, ix, {}) for t in ix.findValueTokens(\n    ...     'subjects',\n    ...     q({'reltype': 'has the role of',\n    ...       'objects': roles['Project Manager'],\n    ...       'context': projects['zope.org redesign']}))]\n    [<Person 'Fred'>]\n\nIf we want to find all the relationships for which Fred is a subject, we can\nuse `findRelationshipTokenSet`.  It, combined with `findValueTokenSet`, is\nuseful for querying the index data structures at a fairly low level, when you\nwant to use the data in a way that the other search methods don't support.\n\n`findRelationshipTokenSet`, given a single dictionary of {indexName: token},\nreturns a set (based on the btree family for relationships in the index) of\nrelationship tokens that match it, intransitively.\n\n    >>> res = ix.findRelationshipTokenSet(q({'subjects': people['Fred']}))\n    >>> res # doctest: +ELLIPSIS\n    <BTrees.IFBTree.IFTreeSet object at ...>\n    >>> [intids.getObject(t) for t in res]\n    [<(<Person 'Fred'>,) has the role of (<Role 'Project Manager'>,)>]\n\n`findRelationships` does the same thing but with resolving the relationships.\n\n    >>> list(ix.findRelationships(q({'subjects': people['Fred']})))\n    [<(<Person 'Fred'>,) has the role of (<Role 'Project Manager'>,)>]\n\n`findValueTokenSet`, given a relationship token and a value name, returns a\nset (based on the btree family for the value) of value tokens for that\nrelationship.\n\n    >>> res = ix.findValueTokenSet(list(res)[0], 'subjects')\n    >>> res # doctest: +ELLIPSIS\n    <BTrees.IFBTree.IFTreeSet object at ...>\n    >>> [load(t, ix, {}) for t in res]\n    [<Person 'Fred'>]\n\nThe apply method, part of the zope.index.interfaces.IIndexSearch interface,\ncan essentially only duplicate the `findValueTokens` and\n`findRelationshipTokenSet` search calls.  The only additional functionality\nis that the results always are IFBTree sets: if the tokens requested are not\nin an IFBTree set (on the basis of the 'btree' key during instantiation, for\ninstance) then the index raises a ValueError.  A wrapper dict specifies the\ntype of search with the key, and the value should be the arguments for the\nsearch.\n\nHere, we ask for the current known roles on the zope.org redesign.\n\n    >>> res = ix.apply({'values':\n    ...     {'resultName': 'objects', 'query':\n    ...         q({'reltype': 'has the role of',\n    ...            'context': projects['zope.org redesign']})}})\n    >>> res # doctest: +ELLIPSIS\n    IFSet([...])\n    >>> [load(t, ix, {}) for t in res]\n    [<Role 'Project Manager'>]\n\nIdeally, this would fail, because the tokens, while integers, are not actually\nmergable with a intid-based catalog results.  However, the index only complains\nif it can tell that the returning set is not an IFTreeSet or IFSet.\n\nHere, we ask for the relationships that have the 'has the role of' type.\n\n    >>> res = ix.apply({'relationships':\n    ...     q({'reltype': 'has the role of'})})\n    ... doctest: +ELLIPSIS\n    >>> res # doctest: +ELLIPSIS\n    <BTrees.IFBTree.IFTreeSet object at ...>\n    >>> [intids.getObject(t) for t in res]\n    [<(<Person 'Fred'>,) has the role of (<Role 'Project Manager'>,)>]\n\nHere, we ask for the known relationships for the zope.org redesign.  It\nwill fail, because the result cannot be expressed as an IFBTree.IFTreeSet\n\n    >>> res = ix.apply({'values':\n    ...     {'resultName': 'reltype', 'query':\n    ...         q({'context': projects['zope.org redesign']})}})\n    ... # doctest: +NORMALIZE_WHITESPACE\n    Traceback (most recent call last):\n    ...\n    ValueError: cannot fulfill `apply` interface because cannot return an\n                IFBTree-based result\n\nThe last basic search methods, `isLinked`, `findRelationshipTokenChains`, and\n`findRelationshipChains`, are most useful for transitive searches.  We\nhave not yet created any relationships that we can use transitively.  They\nstill will work with intransitive searches, so we will demonstrate them here\nas an introduction, then discuss them more below when we introduce transitive\nrelationships.\n\n`findRelationshipChains` and `findRelationshipTokenChains` let you find\ntransitive relationship paths. Right now a single relationship--a single\npoint--can't create much of a line. So first, here's a somewhat useless\nexample:\n\n    >>> [[intids.getObject(t) for t in path] for path in\n    ...  ix.findRelationshipTokenChains(\n    ...     q({'reltype': 'has the role of'}))]\n    ... # doctest: +NORMALIZE_WHITESPACE\n    [[<(<Person 'Fred'>,) has the role of (<Role 'Project Manager'>,)>]]\n\nThat's useless, because there's no chance of it being a transitive search, and\nso you might as well use findRelationshipTokenSet.  This will become more\ninteresting later on.\n\nHere's the same example with findRelationshipChains, which resolves the\nrelationship tokens itself.\n\n    >>> list(ix.findRelationshipChains(q({'reltype': 'has the role of'})))\n    ... # doctest: +NORMALIZE_WHITESPACE\n    [(<(<Person 'Fred'>,) has the role of (<Role 'Project Manager'>,)>,)]\n\n`isLinked` returns a boolean if there is at least one path that matches the\nsearch--in fact, the implementation is essentially ::\n\n    try:\n        iter(ix.findRelationshipTokenChains(...args...)).next()\n    except StopIteration:\n        return False\n    else:\n        return True\n\nSo, we can say\n\n    >>> ix.isLinked(q({'subjects': people['Fred']}))\n    True\n    >>> ix.isLinked(q({'subjects': people['Gary']}))\n    False\n    >>> ix.isLinked(q({'subjects': people['Fred'],\n    ...                'reltype': 'manages'}))\n    False\n\nThis is reasonably useful as is, to test basic assertions.  It also works with\ntransitive searches, as we will see below.\n\n\nAn even simpler example\n-----------------------\n\n(This was added to test that searching for a simple relationship works\neven when the transitive query factory is not set.)\n\nLet's create a very simple relation type, using strings as the source\nand target types:\n\n  >>> class IStringRelation(interface.Interface):\n  ...     name = interface.Attribute(\"The name of the value.\")\n  ...     value = interface.Attribute(\"The value associated with the name.\")\n\n  >>> class StringRelation(persistent.Persistent, Contained):\n  ...     interface.implements(IStringRelation)\n  ...\n  ...     def __init__(self, name, value):\n  ...         self.name = name\n  ...         self.value = value\n\n  >>> app[u\"string-relation-1\"] = StringRelation(\"name1\", \"value1\")\n  >>> app[u\"string-relation-2\"] = StringRelation(\"name2\", \"value2\")\n\n  >>> transaction.commit()\n\nWe can now create an index that uses these:\n\n  >>> from BTrees import OOBTree\n\n  >>> sx = index.Index(\n  ...     ({\"element\": IStringRelation[\"name\"],\n  ...       \"load\": None, \"dump\": None, \"btree\": OOBTree},\n  ...      {\"element\": IStringRelation[\"value\"],\n  ...       \"load\": None, \"dump\": None, \"btree\": OOBTree},\n  ...      ))\n\n  >>> app[\"sx\"] = sx\n  >>> transaction.commit()\n\nAnd we'll add the relations to the index:\n\n  >>> app[\"sx\"].index(app[\"string-relation-1\"])\n  >>> app[\"sx\"].index(app[\"string-relation-2\"])\n\nGetting a relationship back out should be very simple.  Let's look for\nall the values associates with \"name1\":\n\n  >>> query = sx.tokenizeQuery({\"name\": \"name1\"})\n  >>> list(sx.findValues(\"value\", query))\n  ['value1']\n\n\n\nSearching for empty sets\n------------------------\n\nWe've examined the most basic search capabilities.  One other feature of the\nindex and search is that one can search for relationships to an empty set, or,\nfor single-value relationships like 'reltype' and 'context' in our\nexamples, None.\n\nLet's add a relationship with a 'manages' relationshiptype, and no context; and\na relationship with a 'commissioned' relationship type, and a company context.\n\nNotice that there are two ways of adding indexes, by the way.  We have already\nseen that the index has an 'index' method that takes a relationship.  Here we\nuse 'index_doc' which is a method defined in zope.index.interfaces.IInjection\nthat requires the token to already be generated.  Since we are using intids\nto tokenize the relationships, we must add them to the ZODB app object to give\nthem the possibility of a connection.\n\n    >>> app['abeAndBran'] = rel = Relationship(\n    ...     (people['Abe'],), 'manages', (people['Bran'],))\n    >>> ix.index_doc(intids.register(rel), rel)\n    >>> app['abeAndVault'] = rel = SpecialRelationship(\n    ...     (people['Abe'],), 'commissioned',\n    ...     (projects['Vault design and implementation'],))\n    >>> IContextAwareRelationship(rel).setContext(companies['Zookd'])\n    >>> ix.index_doc(intids.register(rel), rel)\n\nNow we can search for Abe's relationship that does not have a context.  The\nNone value is always used to match both an empty set and a single `None` value.\nThe index does not support any other \"empty\" values at this time.\n\n    >>> sorted(\n    ...     repr(load(t, ix, {})) for t in ix.findValueTokens(\n    ...         'objects',\n    ...         q({'subjects': people['Abe']})))\n    [\"<Person 'Bran'>\", \"<Project 'Vault design and implementation'>\"]\n    >>> [load(t, ix, {}) for t in ix.findValueTokens(\n    ...     'objects', q({'subjects': people['Abe'], 'context': None}))]\n    [<Person 'Bran'>]\n    >>> sorted(\n    ...     repr(v) for v in ix.findValues(\n    ...         'objects',\n    ...         q({'subjects': people['Abe']})))\n    [\"<Person 'Bran'>\", \"<Project 'Vault design and implementation'>\"]\n    >>> list(ix.findValues(\n    ...     'objects', q({'subjects': people['Abe'], 'context': None})))\n    [<Person 'Bran'>]\n\nNote that the index does not currently support searching for relationships that\nhave any value, or one of a set of values.  This may be added at a later date;\nthe spelling for such queries are among the more troublesome parts.\n\nWorking with transitive searches\n================================\n\nIt's possible to do transitive searches as well.  This can let you find all\ntransitive bosses, or transitive subordinates, in our 'manages' relationship\ntype.  Let's set up some example relationships.  Using letters to represent our\npeople, we'll create three hierarchies like this::\n\n        A        JK           R\n       / \\      /  \\\n      B   C    LM   NOP     S T U\n     / \\  |     |          /| |  \\\n    D  E  F     Q         V W X   |\n    |     |                    \\--Y\n    H     G                       |\n    |                             Z\n    I\n\nThis means that, for instance, person \"A\" (\"Abe\") manages \"B\" (\"Bran\") and \"C\"\n(\"Cathy\").\n\nWe already have a relationship from Abe to Bran, so we'll only be adding the\nrest.\n\n    >>> relmap = (\n    ...     ('A', 'C'), ('B', 'D'), ('B', 'E'), ('C', 'F'),\n    ...     ('F', 'G'), ('D', 'H'), ('H', 'I'), ('JK', 'LM'), ('JK', 'NOP'),\n    ...     ('LM', 'Q'), ('R', 'STU'), ('S', 'VW'), ('T', 'X'), ('UX', 'Y'),\n    ...     ('Y', 'Z'))\n    >>> letters = dict((name[0], ob) for name, ob in people.items())\n    >>> for subs, obs in relmap:\n    ...     subs = tuple(letters[l] for l in subs)\n    ...     obs = tuple(letters[l] for l in obs)\n    ...     app['%sManages%s' % (''.join(o.name for o in subs),\n    ...                          ''.join(o.name for o in obs))] = rel = (\n    ...         Relationship(subs, 'manages', obs))\n    ...     ix.index(rel)\n    ...\n\nNow we can do both transitive and intransitive searches.  Here are a few\nexamples.\n\n    >>> [load(t, ix, {}) for t in ix.findValueTokens(\n    ...     'subjects',\n    ...     q({'objects': people['Ingrid'],\n    ...        'reltype': 'manages'}))\n    ...     ]\n    [<Person 'Heather'>, <Person 'David'>, <Person 'Bran'>, <Person 'Abe'>]\n\nHere's the same thing using findValues.\n\n    >>> list(ix.findValues(\n    ...     'subjects',\n    ...     q({'objects': people['Ingrid'],\n    ...        'reltype': 'manages'})))\n    [<Person 'Heather'>, <Person 'David'>, <Person 'Bran'>, <Person 'Abe'>]\n\nNotice that they are in order, walking away from the search start.  It also\nis breadth-first--for instance, look at the list of superiors to Zane: Xen and\nUther come before Rob and Terry.\n\n    >>> res = list(ix.findValues(\n    ...     'subjects',\n    ...     q({'objects': people['Zane'], 'reltype': 'manages'})))\n    >>> res[0]\n    <Person 'Ygritte'>\n    >>> sorted(repr(p) for p in res[1:3])\n    [\"<Person 'Uther'>\", \"<Person 'Xen'>\"]\n    >>> sorted(repr(p) for p in res[3:])\n    [\"<Person 'Rob'>\", \"<Person 'Terry'>\"]\n\nNotice that all the elements of the search are maintained as it is walked--only\nthe transposed values are changed, and the rest remain statically.  For\ninstance, notice the difference between these two results.\n\n    >>> [load(t, ix, {}) for t in ix.findValueTokens(\n    ...     'objects',\n    ...     q({'subjects': people['Cathy'], 'reltype': 'manages'}))]\n    [<Person 'Fred'>, <Person 'Gary'>]\n    >>> res = [load(t, ix, {}) for t in ix.findValueTokens(\n    ...     'objects',\n    ...     q({'subjects': people['Cathy']}))]\n    >>> res[0]\n    <Person 'Fred'>\n    >>> sorted(repr(i) for i in res[1:])\n    [\"<Person 'Gary'>\", \"<Role 'Project Manager'>\"]\n\nThe first search got what we expected for our management relationshiptype--\nwalking from Cathy, the relationshiptype was maintained, and we only got the\nGary subordinate.  The second search didn't specify the relationshiptype, so\nthe transitive search included the Role we added first (Fred has the role of\nProject Manager for the zope.org redesign).\n\nThe `maxDepth` argument allows control over how far to search.  For instance,\nif we only want to search for Bran's subordinates a maximum of two steps deep,\nwe can do so:\n\n    >>> res = [load(t, ix, {}) for t in ix.findValueTokens(\n    ...     'objects',\n    ...     q({'subjects': people['Bran']}),\n    ...     maxDepth=2)]\n    >>> sorted(repr(i) for i in res)\n    [\"<Person 'David'>\", \"<Person 'Emily'>\", \"<Person 'Heather'>\"]\n\nThe same is true for findValues.\n\n    >>> res = list(ix.findValues(\n    ...     'objects',\n    ...     q({'subjects': people['Bran']}), maxDepth=2))\n    >>> sorted(repr(i) for i in res)\n    [\"<Person 'David'>\", \"<Person 'Emily'>\", \"<Person 'Heather'>\"]\n\nA minimum depth--a number of relationships that must be traversed before\nresults are desired--can also be achieved trivially using the targetFilter\nargument described soon below.  For now, we will continue in the order of the\narguments list, so `filter` is up next.\n\nThe `filter` argument takes an object (such as a function) that provides\ninterfaces.IFilter.  As the interface lists, it receives the current chain\nof relationship tokens (\"relchain\"), the original query that started the search\n(\"query\"), the index object (\"index\"), and a dictionary that will be used\nthroughout the search and then discarded that can be used for optimizations\n(\"cache\").  It should return a boolean, which determines whether the given\nrelchain should be used at all--traversed or returned.  For instance, if\nsecurity dictates that the current user can only see certain relationships,\nthe filter could be used to make only the available relationships traversable.\nOther uses are only getting relationships that were created after a given time,\nor that have some annotation (available after resolving the token).\n\nLet's look at an example of a filter that only allows relationships in a given\nset, the way a security-based filter might work.  We'll then use it to model\na situation in which the current user can't see that Ygritte is managed by\nUther, in addition to Xen.\n\n    >>> s = set(intids.getId(r) for r in app.values()\n    ...         if IRelationship.providedBy(r))\n    >>> relset = list(\n    ...     ix.findRelationshipTokenSet(q({'subjects': people['Xen']})))\n    >>> len(relset)\n    1\n    >>> s.remove(relset[0])\n    >>> dump(people['Uther'], ix, {}) in list(\n    ...     ix.findValueTokens('subjects', q({'objects': people['Ygritte']})))\n    True\n    >>> dump(people['Uther'], ix, {}) in list(ix.findValueTokens(\n    ...     'subjects', q({'objects': people['Ygritte']}),\n    ...     filter=lambda relchain, query, index, cache: relchain[-1] in s))\n    False\n    >>> people['Uther'] in list(\n    ...     ix.findValues('subjects', q({'objects': people['Ygritte']})))\n    True\n    >>> people['Uther'] in list(ix.findValues(\n    ...     'subjects', q({'objects': people['Ygritte']}),\n    ...     filter=lambda relchain, query, index, cache: relchain[-1] in s))\n    False\n\nThe next two search arguments are the targetQuery and the targetFilter.  They\nboth are filters on the output of the search methods, while not affecting the\ntraversal/search process.  The targetQuery takes a query identical to the main\nquery, and the targetFilter takes an IFilter identical to the one used by the\n`filter` argument.  The targetFilter can do all of the work of the targetQuery,\nbut the targetQuery makes a common case--wanting to find the paths between two\nobjects, or if two objects are linked at all, for instance--convenient.\n\nWe'll skip over targetQuery for a moment (we'll return when we revisit\n`findRelationshipChains` and `isLinked`), and look at targetFilter.\ntargetFilter can be used for many tasks, such as only returning values that\nare in specially annotated relationships, or only returning values that have\ntraversed a certain hinge relationship in a two-part search, or other tasks.\nA very simply one, though, is to effectively specify a minimum traversal depth.\nHere, we find the people who are precisely two steps down from Bran, no more\nand no less.  We do it twice, once with findValueTokens and once with\nfindValues.\n\n    >>> [load(t, ix, {}) for t in ix.findValueTokens(\n    ...     'objects', q({'subjects': people['Bran']}), maxDepth=2,\n    ...     targetFilter=lambda relchain, q, i, c: len(relchain)>=2)]\n    [<Person 'Heather'>]\n    >>> list(ix.findValues(\n    ...     'objects', q({'subjects': people['Bran']}), maxDepth=2,\n    ...     targetFilter=lambda relchain, q, i, c: len(relchain)>=2))\n    [<Person 'Heather'>]\n\nHeather is the only person precisely two steps down from Bran.\n\nNotice that we specified both maxDepth and targetFilter.  We could have\nreceived the same output by specifying a targetFilter of `len(relchain)==2`\nand no maxDepth, but there is an important difference in efficiency.  maxDepth\nand filter can reduce the amount of work done by the index because they can\nstop searching after reaching the maxDepth, or failing the filter; the\ntargetFilter and targetQuery arguments simply hide the results obtained, which\ncan reduce a bit of work in the case of getValues but generally don't reduce\nany of the traversal work.\n\nThe last argument to the search methods is `transitiveQueriesFactory`.  It is\na powertool that replaces the index's default traversal factory for the\nduration of the search.  This allows custom traversal for individual searches,\nand can support a number of advanced use cases.  For instance, our index\nassumes that you want to traverse objects and sources, and that the context\nshould be constant; that may not always be the desired traversal behavior.  If\nwe had a relationship of PERSON1 TAUGHT PERSON2 (the lessons of PERSON3) then\nto find the teachers of any given person you might want to traverse PERSON1,\nbut sometimes you might want to traverse PERSON3 as well.  You can change the\nbehavior by providing a different factory.\n\nTo show this example we will need to add a few more relationships.  We will say\nthat Mary teaches Rob the lessons of Abe; Olaf teaches Zane the lessons of\nBran; Cathy teaches Bran the lessons of Lee; David teaches Abe the lessons of\nZane; and Emily teaches Mary the lessons of Ygritte.\n\nIn the diagram, left-hand lines indicate \"taught\" and right-hand lines indicate\n\"the lessons of\", so ::\n\n  E   Y\n   \\ /\n    M\n\nshould be read as \"Emily taught Mary the lessons of Ygritte\".  Here's the full\ndiagram::\n\n            C   L\n             \\ /\n          O   B\n           \\ /\n  E   Y D   Z\n   \\ /   \\ /\n    M     A\n     \\   /\n      \\ /\n       R\n\nYou can see then that the transitive path of Rob's teachers is Mary and Emily,\nbut the transitive path of Rob's lessons is Abe, Zane, Bran, and Lee.\n\nTransitive queries factories must do extra work when the transitive walk is\nacross token types.  We have used the TransposingTransitiveQueriesFactory to\nbuild our transposers before, but now we need to write a custom one that\ntranslates the tokens (ooh!  a\nTokenTranslatingTransposingTransitiveQueriesFactory!  ...maybe we won't go that\nfar...).\n\nWe will add the relationships, build the custom transitive factory, and then\nagain do the search work twice, once with findValueTokens and once with\nfindValues.\n\n    >>> for triple in ('EMY', 'MRA', 'DAZ', 'OZB', 'CBL'):\n    ...     teacher, student, source = (letters[l] for l in triple)\n    ...     rel = SpecialRelationship((teacher,), 'taught', (student,))\n    ...     app['%sTaught%sTo%s' % (\n    ...         teacher.name, source.name, student.name)] = rel\n    ...     IContextAwareRelationship(rel).setContext(source)\n    ...     ix.index_doc(intids.register(rel), rel)\n    ...\n\n    >>> def transitiveFactory(relchain, query, index, cache):\n    ...     dynamic = cache.get('dynamic')\n    ...     if dynamic is None:\n    ...         intids = cache['intids'] = component.getUtility(\n    ...             IIntIds, context=index)\n    ...         static = cache['static'] = {}\n    ...         dynamic = cache['dynamic'] = []\n    ...         names = ['objects', 'context']\n    ...         for nm, val in query.items():\n    ...             try:\n    ...                 ix = names.index(nm)\n    ...             except ValueError:\n    ...                 static[nm] = val\n    ...             else:\n    ...                 if dynamic:\n    ...                     # both were specified: no transitive search known.\n    ...                     del dynamic[:]\n    ...                     cache['intids'] = False\n    ...                     break\n    ...                 else:\n    ...                     dynamic.append(nm)\n    ...                     dynamic.append(names[not ix])\n    ...         else:\n    ...             intids = component.getUtility(IIntIds, context=index)\n    ...             if dynamic[0] == 'objects':\n    ...                 def translate(t):\n    ...                     return dump(intids.getObject(t), index, cache)\n    ...             else:\n    ...                 def translate(t):\n    ...                     return intids.register(load(t, index, cache))\n    ...             cache['translate'] = translate\n    ...     else:\n    ...         static = cache['static']\n    ...         translate = cache['translate']\n    ...     if dynamic:\n    ...         for r in index.findValueTokenSet(relchain[-1], dynamic[1]):\n    ...             res = {dynamic[0]: translate(r)}\n    ...             res.update(static)\n    ...             yield res\n\n    >>> [load(t, ix, {}) for t in ix.findValueTokens(\n    ...     'subjects',\n    ...     q({'objects': people['Rob'], 'reltype': 'taught'}))]\n    [<Person 'Mary'>, <Person 'Emily'>]\n    >>> [intids.getObject(t) for t in ix.findValueTokens(\n    ...     'context',\n    ...     q({'objects': people['Rob'], 'reltype': 'taught'}),\n    ...     transitiveQueriesFactory=transitiveFactory)]\n    [<Person 'Abe'>, <Person 'Zane'>, <Person 'Bran'>, <Person 'Lee'>]\n\n    >>> list(ix.findValues(\n    ...     'subjects',\n    ...     q({'objects': people['Rob'], 'reltype': 'taught'})))\n    [<Person 'Mary'>, <Person 'Emily'>]\n    >>> list(ix.findValues(\n    ...     'context',\n    ...     q({'objects': people['Rob'], 'reltype': 'taught'}),\n    ...     transitiveQueriesFactory=transitiveFactory))\n    [<Person 'Abe'>, <Person 'Zane'>, <Person 'Bran'>, <Person 'Lee'>]\n\ntransitiveQueryFactories can be very powerful, and we aren't finished talking\nabout them in this document: see \"Transitively mapping multiple elements\"\nbelow.\n\nWe have now discussed, or at least mentioned, all of the available search\narguments.  The `apply` method's 'values' search has the same arguments and\nfeatures as `findValues`, so it can also do these transitive tricks.  Let's\nget all of Karyn's subordinates.\n\n    >>> res = ix.apply({'values':\n    ...     {'resultName': 'objects', 'query':\n    ...         q({'reltype': 'manages',\n    ...           'subjects': people['Karyn']})}})\n    >>> res # doctest: +ELLIPSIS\n    IFSet([...])\n    >>> sorted(repr(load(t, ix, {})) for t in res)\n    ... # doctest: +NORMALIZE_WHITESPACE\n    [\"<Person 'Lee'>\", \"<Person 'Mary'>\", \"<Person 'Nancy'>\",\n     \"<Person 'Olaf'>\", \"<Person 'Perry'>\", \"<Person 'Quince'>\"]\n\nAs we return to `findRelationshipChains` and `findRelationshipTokenChains`, we\nalso return to the search argument we postponed above: targetQuery.\n\nThe `findRelationshipChains` and `findRelationshipTokenChains` can simply find\nall paths:\n\n    >>> res = [repr([intids.getObject(t) for t in path]) for path in\n    ...  ix.findRelationshipTokenChains(\n    ...     q({'reltype': 'manages', 'subjects': people['Jim']}\n    ...     ))]\n    >>> len(res)\n    3\n    >>> sorted(res[:2]) # doctest: +NORMALIZE_WHITESPACE\n    [\"[<(<Person 'Jim'>, <Person 'Karyn'>) manages\n        (<Person 'Lee'>, <Person 'Mary'>)>]\",\n     \"[<(<Person 'Jim'>, <Person 'Karyn'>) manages\n        (<Person 'Nancy'>, <Person 'Olaf'>, <Person 'Perry'>)>]\"]\n    >>> res[2] # doctest: +NORMALIZE_WHITESPACE\n    \"[<(<Person 'Jim'>, <Person 'Karyn'>) manages\n       (<Person 'Lee'>, <Person 'Mary'>)>,\n      <(<Person 'Lee'>, <Person 'Mary'>) manages\n       (<Person 'Quince'>,)>]\"\n    >>> res == [repr(list(p)) for p in\n    ...  ix.findRelationshipChains(\n    ...     q({'reltype': 'manages', 'subjects': people['Jim']}\n    ...     ))]\n    True\n\nLike `findValues`, this is a breadth-first search.\n\nIf we use a targetQuery with `findRelationshipChains`, you can find all paths\nbetween two searches. For instance, consider the paths between Rob and\nYgritte.  While a `findValues` search would only include Rob once if asked to\nsearch for supervisors, there are two paths.  These can be found with the\ntargetQuery.\n\n    >>> res = [repr([intids.getObject(t) for t in path]) for path in\n    ...  ix.findRelationshipTokenChains(\n    ...     q({'reltype': 'manages', 'subjects': people['Rob']}),\n    ...     targetQuery=q({'objects': people['Ygritte']}))]\n    >>> len(res)\n    2\n    >>> sorted(res[:2]) # doctest: +NORMALIZE_WHITESPACE\n    [\"[<(<Person 'Rob'>,) manages\n        (<Person 'Sam'>, <Person 'Terry'>, <Person 'Uther'>)>,\n       <(<Person 'Terry'>,) manages (<Person 'Xen'>,)>,\n       <(<Person 'Uther'>, <Person 'Xen'>) manages (<Person 'Ygritte'>,)>]\",\n     \"[<(<Person 'Rob'>,) manages\n        (<Person 'Sam'>, <Person 'Terry'>, <Person 'Uther'>)>,\n       <(<Person 'Uther'>, <Person 'Xen'>) manages (<Person 'Ygritte'>,)>]\"]\n\nHere's a query with no results:\n\n    >>> len(list(ix.findRelationshipTokenChains(\n    ...     q({'reltype': 'manages', 'subjects': people['Rob']}),\n    ...     targetQuery=q({'objects': companies['Zookd']}))))\n    0\n\n`isLinked` takes the same arguments as all of the other transitive-aware\nmethods.  For instance, Rob and Ygritte are transitively linked, but Abe and\nZane are not.\n\n    >>> ix.isLinked(\n    ...     q({'reltype': 'manages', 'subjects': people['Rob']}),\n    ...     targetQuery=q({'objects': people['Ygritte']}))\n    True\n    >>> ix.isLinked(\n    ...     q({'reltype': 'manages', 'subjects': people['Abe']}),\n    ...     targetQuery=q({'objects': people['Ygritte']}))\n    False\n\nDetecting cycles\n----------------\n\nSuppose we're modeling a 'king in disguise': someone high up in management also\nworks as a peon to see how his employees' lives are.  We could model this a\nnumber of ways that might make more sense than what we'll do now, but to show\ncycles at work we'll just add an additional relationship so that Abe works for\nGary.  That means that the very longest path from Ingrid up gets a lot longer--\nin theory, it's infinitely long, because of the cycle.\n\nThe index keeps track of this and stops right when the cycle happens, and right\nbefore the cycle duplicates any relationships.  It marks the chain that has\ncycle as a special kind of tuple that implements ICircularRelationshipPath.\nThe tuple has a 'cycled' attribute that contains the one or more searches\nthat would be equivalent to following the cycle (given the same transitiveMap).\n\nLet's actually look at the example we described.\n\n    >>> res = list(ix.findRelationshipTokenChains(\n    ...     q({'objects': people['Ingrid'], 'reltype': 'manages'})))\n    >>> len(res)\n    4\n    >>> len(res[3])\n    4\n    >>> interfaces.ICircularRelationshipPath.providedBy(res[3])\n    False\n    >>> rel = Relationship(\n    ...     (people['Gary'],), 'manages', (people['Abe'],))\n    >>> app['GaryManagesAbe'] = rel\n    >>> ix.index(rel)\n    >>> res = list(ix.findRelationshipTokenChains(\n    ...     q({'objects': people['Ingrid'], 'reltype': 'manages'})))\n    >>> len(res)\n    8\n    >>> len(res[7])\n    8\n    >>> interfaces.ICircularRelationshipPath.providedBy(res[7])\n    True\n    >>> [sorted(\n    ...     (nm, nm == 'objects' and load(t, ix, {}) or t)\n    ...     for nm, t in search.items()) for search in res[7].cycled]\n    ... # doctest: +NORMALIZE_WHITESPACE\n    [[('objects', <Person 'Abe'>),\n      ('reltype', 'manages')]]\n\nNotice that there is nothing special about the new relationship, by the way.\nIf we had started to look for Fred's supervisors, the cycle marker would have\nbeen given for the relationship that points back to Fred as a supervisor to\nhimself.  There's no way for the computer to know which is the \"cause\" without\nfurther help and policy.\n\nHandling cycles can be tricky.  Now imagine that we have a cycle that involves\na relationship with two objects, only one of which causes the cycle.  The other\nobject should continue to be followed.\n\nFor instance, lets have Q manage L and Y.  The link to L will be a cycle, but\nthe link to Y is not, and should be followed.  This means that only the middle\nrelationship chain will be marked as a cycle.\n\n    >>> rel = Relationship((people['Quince'],), 'manages',\n    ...                    (people['Lee'], people['Ygritte']))\n    >>> app['QuinceManagesLeeYgritte'] = rel\n    >>> ix.index_doc(intids.register(rel), rel)\n    >>> res = [p for p in ix.findRelationshipTokenChains(\n    ...     q({'reltype': 'manages', 'subjects': people['Mary']}))]\n    >>> [interfaces.ICircularRelationshipPath.providedBy(p) for p in res]\n    [False, True, False]\n    >>> [[intids.getObject(t) for t in p] for p in res]\n    ... # doctest: +NORMALIZE_WHITESPACE\n    [[<(<Person 'Lee'>, <Person 'Mary'>) manages (<Person 'Quince'>,)>],\n     [<(<Person 'Lee'>, <Person 'Mary'>) manages (<Person 'Quince'>,)>,\n      <(<Person 'Quince'>,) manages (<Person 'Lee'>, <Person 'Ygritte'>)>],\n     [<(<Person 'Lee'>, <Person 'Mary'>) manages (<Person 'Quince'>,)>,\n      <(<Person 'Quince'>,) manages (<Person 'Lee'>, <Person 'Ygritte'>)>,\n      <(<Person 'Ygritte'>,) manages (<Person 'Zane'>,)>]]\n    >>> [sorted(\n    ...     (nm, nm == 'reltype' and t or load(t, ix, {}))\n    ...     for nm, t in search.items()) for search in res[1].cycled]\n    [[('reltype', 'manages'), ('subjects', <Person 'Lee'>)]]\n\nTransitively mapping multiple elements\n--------------------------------------\n\nTransitive searches can do whatever searches the transitiveQueriesFactory\nreturns, which means that complex transitive behavior can be modeled.  For\ninstance, imagine genealogical relationships.  Let's say the basic\nrelationship is \"MALE and FEMALE had CHILDREN\".  Walking transitively to get\nancestors or descendants would need to distinguish between male children and\nfemale children in order to correctly generate the transitive search.  This\ncould be accomplished by resolving each child token and examining the object\nor, probably more efficiently, getting an indexed collection of males and\nfemales (and cacheing it in the cache dictionary for further transitive steps)\nand checking the gender by membership in the indexed collections.  Either of\nthese approaches could be performed by a transitiveQueriesFactory.  A full\nexample is left as an exercise to the reader.\n\nLies, damn lies, and statistics\n===============================\n\nThe zope.index.interfaces.IStatistics methods are implemented to provide\nminimal introspectability.  wordCount always returns 0, because words are\nirrelevant to this kind of index.  documentCount returns the number of\nrelationships indexed.\n\n    >>> ix.wordCount()\n    0\n    >>> ix.documentCount()\n    25\n\nReindexing and removing relationships\n=====================================\n\nUsing an index over an application's lifecycle usually requires changes to the\nindexed objects.  As per the zope.index interfaces, `index_doc` can reindex\nrelationships, `unindex_doc` can remove them, and `clear` can clear the entire\nindex.\n\nHere we change the zope.org project manager from Fred to Emily.\n\n    >>> [load(t, ix, {}) for t in ix.findValueTokens(\n    ...     'subjects',\n    ...     q({'reltype': 'has the role of',\n    ...       'objects': roles['Project Manager'],\n    ...       'context': projects['zope.org redesign']}))]\n    [<Person 'Fred'>]\n    >>> rel = intids.getObject(list(ix.findRelationshipTokenSet(\n    ...     q({'reltype': 'has the role of',\n    ...       'objects': roles['Project Manager'],\n    ...       'context': projects['zope.org redesign']})))[0])\n    >>> rel.subjects = (people['Emily'],)\n    >>> ix.index_doc(intids.register(rel), rel)\n    >>> q = ix.tokenizeQuery\n    >>> [load(t, ix, {}) for t in ix.findValueTokens(\n    ...     'subjects',\n    ...     q({'reltype': 'has the role of',\n    ...       'objects': roles['Project Manager'],\n    ...       'context': projects['zope.org redesign']}))]\n    [<Person 'Emily'>]\n\nHere we remove the relationship that made a cycle for Abe in the 'king in\ndisguise' scenario.\n\n    >>> res = list(ix.findRelationshipTokenChains(\n    ...     q({'objects': people['Ingrid'],\n    ...        'reltype': 'manages'})))\n    >>> len(res)\n    8\n    >>> len(res[7])\n    8\n    >>> interfaces.ICircularRelationshipPath.providedBy(res[7])\n    True\n    >>> rel = intids.getObject(list(ix.findRelationshipTokenSet(\n    ...     q({'subjects': people['Gary'], 'reltype': 'manages',\n    ...        'objects': people['Abe']})))[0])\n    >>> ix.unindex(rel) # == ix.unindex_doc(intids.getId(rel))\n    >>> ix.documentCount()\n    24\n    >>> res = list(ix.findRelationshipTokenChains(\n    ...     q({'objects': people['Ingrid'], 'reltype': 'manages'})))\n    >>> len(res)\n    4\n    >>> len(res[3])\n    4\n    >>> interfaces.ICircularRelationshipPath.providedBy(res[3])\n    False\n\nFinally we clear out the whole index.\n\n    >>> ix.clear()\n    >>> ix.documentCount()\n    0\n    >>> list(ix.findRelationshipTokenChains(\n    ...     q({'objects': people['Ingrid'], 'reltype': 'manages'})))\n    []\n    >>> [load(t, ix, {}) for t in ix.findValueTokens(\n    ...     'subjects',\n    ...     q({'reltype': 'has the role of',\n    ...       'objects': roles['Project Manager'],\n    ...       'context': projects['zope.org redesign']}))]\n    []\n\nOptimizing relationship index use\n=================================\n\nThere are three optimization opportunities built into the index.\n\n- use the cache to load and dump tokens;\n\n- don't load or dump tokens (the values themselves may be used as tokens); and\n\n- have the returned value be of the same btree family as the result family.\n\nFor some operations, particularly with hundreds or thousands of members in a\nsingle relationship value, some of these optimizations can speed up some\ncommon-case reindexing work by around 100 times.\n\nThe easiest (and perhaps least useful) optimization is that all dump\ncalls and all load calls generated by a single operation share a cache\ndictionary per call type (dump/load), per indexed relationship value.\nTherefore, for instance, we could stash an intids utility, so that we\nonly had to do a utility lookup once, and thereafter it was only a\nsingle dictionary lookup. This is what the default `generateToken` and\n`resolveToken` functions in index.py do: look at them for an example.\n\nA further optimization is to not load or dump tokens at all, but use values\nthat may be tokens.  This will be particularly useful if the tokens have\n__cmp__ (or equivalent) in C, such as built-in types like ints.  To specify\nthis behavior, you create an index with the 'load' and 'dump' values for the\nindexed attribute descriptions explicitly set to None.\n\n    >>> ix = index.Index(\n    ...     ({'element': IRelationship['subjects'], 'multiple': True,\n    ...       'dump': None, 'load': None},\n    ...      {'element': IRelationship['relationshiptype'],\n    ...       'dump': relTypeDump, 'load': relTypeLoad, 'btree': OIBTree,\n    ...       'name': 'reltype'},\n    ...      {'element': IRelationship['objects'], 'multiple': True,\n    ...       'dump': None, 'load': None},\n    ...      {'element': IContextAwareRelationship['getContext'],\n    ...       'name': 'context'}),\n    ...     index.TransposingTransitiveQueriesFactory('subjects', 'objects'))\n    ...\n    >>> sm['rel_index_2'] = ix\n    >>> app['ex_rel_1'] = rel = Relationship((1,), 'has the role of', (2,))\n    >>> ix.index(rel)\n    >>> list(ix.findValueTokens('objects', {'subjects': 1}))\n    [2]\n\nFinally, if you have single relationships that relate hundreds or thousands\nof objects, it can be a huge win if the value is a 'multiple' of the same type\nas the stored BTree for the given attribute.  The default BTree family for\nattributes is IFBTree; IOBTree is also a good choice, and may be preferrable\nfor some applications.\n\n    >>> ix = index.Index(\n    ...     ({'element': IRelationship['subjects'], 'multiple': True,\n    ...       'dump': None, 'load': None},\n    ...      {'element': IRelationship['relationshiptype'],\n    ...       'dump': relTypeDump, 'load': relTypeLoad, 'btree': OIBTree,\n    ...       'name': 'reltype'},\n    ...      {'element': IRelationship['objects'], 'multiple': True,\n    ...       'dump': None, 'load': None},\n    ...      {'element': IContextAwareRelationship['getContext'],\n    ...       'name': 'context'}),\n    ...     index.TransposingTransitiveQueriesFactory('subjects', 'objects'))\n    ...\n    >>> sm['rel_index_3'] = ix\n    >>> from BTrees import IFBTree\n    >>> app['ex_rel_2'] = rel = Relationship(\n    ...     IFBTree.IFTreeSet((1,)), 'has the role of', IFBTree.IFTreeSet((2,)))\n    >>> ix.index(rel)\n    >>> list(ix.findValueTokens('objects', {'subjects': 1}))\n    [2]\n\nRemember that BTrees (not just BTreeSets) can be used for these values:\nthe keys are used as the set members in that case.\n\n__contains__ and Unindexing\n=============================\n\nYou can test whether a relationship is in an index with __contains__.  Note\nthat this uses the actual relationship, not the relationship token.\n\n    >>> ix = index.Index(\n    ...     ({'element': IRelationship['subjects'], 'multiple': True,\n    ...       'dump': dump, 'load': load},\n    ...      {'element': IRelationship['relationshiptype'],\n    ...       'dump': relTypeDump, 'load': relTypeLoad, 'btree': OIBTree,\n    ...       'name': 'reltype'},\n    ...      {'element': IRelationship['objects'], 'multiple': True,\n    ...       'dump': dump, 'load': load},\n    ...      {'element': IContextAwareRelationship['getContext'],\n    ...       'name': 'context'}),\n    ...     index.TransposingTransitiveQueriesFactory('subjects', 'objects'))\n    >>> ix.documentCount()\n    0\n    >>> app['fredisprojectmanager'].subjects = (people['Fred'],)\n    >>> ix.index(app['fredisprojectmanager'])\n    >>> ix.index(app['another_rel'])\n    >>> ix.documentCount()\n    2\n    >>> app['fredisprojectmanager'] in ix\n    True\n    >>> list(ix.findValues(\n    ...     'subjects',\n    ...     q({'reltype': 'has the role of',\n    ...       'objects': roles['Project Manager'],\n    ...       'context': projects['zope.org redesign']})))\n    [<Person 'Fred'>]\n\n    >>> app['another_rel'] in ix\n    True\n\n    >>> app['abeAndBran'] in ix\n    False\n\nAs noted, you can unindex using unindex(relationship) or\nunindex_doc(relationship token).\n\n    >>> ix.unindex_doc(ix.tokenizeRelationship(app['fredisprojectmanager']))\n    >>> app['fredisprojectmanager'] in ix\n    False\n    >>> list(ix.findValues(\n    ...     'subjects',\n    ...     q({'reltype': 'has the role of',\n    ...       'objects': roles['Project Manager'],\n    ...       'context': projects['zope.org redesign']})))\n    []\n\n    >>> ix.unindex(app['another_rel'])\n    >>> app['another_rel'] in ix\n    False\n\nAs defined by zope.index.interfaces.IInjection, if the relationship is\nnot in the index then calling unindex_doc is a no-op; the same holds\ntrue for unindex.\n\n    >>> ix.unindex(app['abeAndBran'])\n    >>> ix.unindex_doc(ix.tokenizeRelationship(app['abeAndBran']))",
    "docs_url": null,
    "download_url": "UNKNOWN",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "UNKNOWN",
    "keywords": "zope zope3",
    "license": "ZPL 2.1",
    "maintainer": null,
    "maintainer_email": null,
    "name": "zc.relationship",
    "platform": "UNKNOWN",
    "project_url": "https://pypi.org/project/zc.relationship/",
    "release_url": "https://pypi.org/project/zc.relationship/1.1.1/",
    "requires_python": null,
    "summary": "Low-level ZODB relationship index: supports intransitive and transitive n-ary\nrelationships.  Example usage of \"relationship containers\".",
    "version": "1.1.1"
  },
  "releases": {
    "1.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "becccb21ca0245ce70022863e73a24c5",
          "sha256": "3134ad3f3bb9e6e381000f9579fab897a968c621fea8223cb47aabb40d1712fe"
        },
        "downloads": 2771,
        "filename": "zc.relationship-1.0-py2.4.egg",
        "has_sig": false,
        "md5_digest": "becccb21ca0245ce70022863e73a24c5",
        "packagetype": "bdist_egg",
        "python_version": "2.4",
        "size": 78710,
        "upload_time": "2006-12-02T03:09:03",
        "url": "https://files.pythonhosted.org/packages/09/33/aa9b22356a79bc80dd4035484b30484e93bc194162df31a7b1b96cbb8d1d/zc.relationship-1.0-py2.4.egg"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "ff8332f265a98f3713368a1d8cb8d35f",
          "sha256": "d89f3ea667df34fa8da888ae24650d4b8b280ec6b9b08342dfbd6ab63ef435c4"
        },
        "downloads": 2387,
        "filename": "zc.relationship-1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "ff8332f265a98f3713368a1d8cb8d35f",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 72957,
        "upload_time": "2006-12-02T03:09:04",
        "url": "https://files.pythonhosted.org/packages/0b/66/08f35627435603ed20178f9753a2009cee5631139d5a297939ef1b6e76f3/zc.relationship-1.0.tar.gz"
      }
    ],
    "1.0.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "756628495416bd513cfb22b4a6285c06",
          "sha256": "96a59201a08912acf5b1e2d724e008dae73ea48e2db85eb509f2e4905419a6e6"
        },
        "downloads": 2712,
        "filename": "zc.relationship-1.0.1-py2.4.egg",
        "has_sig": false,
        "md5_digest": "756628495416bd513cfb22b4a6285c06",
        "packagetype": "bdist_egg",
        "python_version": "2.4",
        "size": 78800,
        "upload_time": "2007-01-23T21:01:02",
        "url": "https://files.pythonhosted.org/packages/a4/a8/881ae7daa83c3083d60585ec2e2d660e26b30a57376c42a3f07b4eb492bf/zc.relationship-1.0.1-py2.4.egg"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "d4a47403baa55402a2c332d19e146c07",
          "sha256": "0e4dd2c9ab40080c65f3b324dca203f30f219796166b97b6c76393bc34d06946"
        },
        "downloads": 2432,
        "filename": "zc.relationship-1.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "d4a47403baa55402a2c332d19e146c07",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 73784,
        "upload_time": "2007-01-23T21:01:01",
        "url": "https://files.pythonhosted.org/packages/04/de/48b25df5a8c231a86a821cdb046aab96eab3066db04ff7bfc3ba86bbf3ac/zc.relationship-1.0.1.tar.gz"
      }
    ],
    "1.0.2": [
      {
        "comment_text": "",
        "digests": {
          "md5": "fa65abf4d6331b8c9808e3fd034eb1ae",
          "sha256": "c921af04796840e046790abfbdcf02b1f1aa21498b57a5ba4711ae1826ad53c5"
        },
        "downloads": 5017,
        "filename": "zc.relationship-1.0.2-py2.4.egg",
        "has_sig": false,
        "md5_digest": "fa65abf4d6331b8c9808e3fd034eb1ae",
        "packagetype": "bdist_egg",
        "python_version": "2.4",
        "size": 80019,
        "upload_time": "2007-07-04T15:58:22",
        "url": "https://files.pythonhosted.org/packages/d4/13/b42c02211bb8f3ba22a4ba7c357936bcdda8081c6b155ac6192e4927ca25/zc.relationship-1.0.2-py2.4.egg"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "a36d25ae362e4c88a6a5deb6dc13208d",
          "sha256": "af2d180e856ddcefd87c7c111b50be9e2b57d3b0a26b446a3fb5d55407968de4"
        },
        "downloads": 2532,
        "filename": "zc.relationship-1.0.2.tar.gz",
        "has_sig": false,
        "md5_digest": "a36d25ae362e4c88a6a5deb6dc13208d",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 74730,
        "upload_time": "2007-07-04T15:58:24",
        "url": "https://files.pythonhosted.org/packages/7b/a4/60a9cb0a5bce85bf8a7268cc74658a367f917a17688af779aa9240c249f5/zc.relationship-1.0.2.tar.gz"
      }
    ],
    "1.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "6a1544744dc8a9a9099c89a5e38632e8",
          "sha256": "3f82dd16446d889bf6c04e3789d9568b8b37c039c73956370d127582df639ec7"
        },
        "downloads": 6484,
        "filename": "zc.relationship-1.1-py2.4.egg",
        "has_sig": false,
        "md5_digest": "6a1544744dc8a9a9099c89a5e38632e8",
        "packagetype": "bdist_egg",
        "python_version": "2.4",
        "size": 80768,
        "upload_time": "2007-07-04T16:00:17",
        "url": "https://files.pythonhosted.org/packages/ec/32/b0a7e90e6cf6ed3a2f596a33fb199fd57ccc97ea64eac9308cd3fbc77e3e/zc.relationship-1.1-py2.4.egg"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "de4cf0dc8e33176ebc1c956899267f64",
          "sha256": "e039b0f7dc4407d06a2f3c1453ae901cebcb3a251571f9416a168c3996134895"
        },
        "downloads": 2391,
        "filename": "zc.relationship-1.1.tar.gz",
        "has_sig": false,
        "md5_digest": "de4cf0dc8e33176ebc1c956899267f64",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 75715,
        "upload_time": "2007-07-04T16:00:18",
        "url": "https://files.pythonhosted.org/packages/ee/83/093bc316486400159531e423f45f153dad028d3286727f99bf6784fa86a4/zc.relationship-1.1.tar.gz"
      }
    ],
    "1.1.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "b6461c8378603aceaa848294f92457e9",
          "sha256": "b39321691d35e10b9513cfe644cd7ac534dcc1fcb6e77d0fe80ed1c2a48d42f7"
        },
        "downloads": 3629,
        "filename": "zc.relationship-1.1.1.tar.gz",
        "has_sig": false,
        "md5_digest": "b6461c8378603aceaa848294f92457e9",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 76001,
        "upload_time": "2009-03-17T15:58:10",
        "url": "https://files.pythonhosted.org/packages/46/c9/dbf0dc917309ae4eebe0cafefe7dcdf65c3a7746c6fa523ff79c93ae5c89/zc.relationship-1.1.1.tar.gz"
      }
    ],
    "1.1a": [
      {
        "comment_text": "",
        "digests": {
          "md5": "b14ebe27b293eeb6d78d47d8e964984a",
          "sha256": "4df61b55df8df74d376e2d46bea7ebb8dd029969ea304f000baebf88e7ec6050"
        },
        "downloads": 3454,
        "filename": "zc.relationship-1.1a-py2.4.egg",
        "has_sig": false,
        "md5_digest": "b14ebe27b293eeb6d78d47d8e964984a",
        "packagetype": "bdist_egg",
        "python_version": "2.4",
        "size": 79139,
        "upload_time": "2007-02-06T23:18:25",
        "url": "https://files.pythonhosted.org/packages/ef/da/a490d4666ee230766d116da4c644c8caac91447b7348044bb6a353c4a037/zc.relationship-1.1a-py2.4.egg"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "3db6c87f2bc8910751c74ab03965cebd",
          "sha256": "783929e70cb2d4825d9b64524517f493ebe9914e5f3b1eb6dfdb838f734104ac"
        },
        "downloads": 2383,
        "filename": "zc.relationship-1.1a.tar.gz",
        "has_sig": false,
        "md5_digest": "3db6c87f2bc8910751c74ab03965cebd",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 74161,
        "upload_time": "2007-02-06T23:18:21",
        "url": "https://files.pythonhosted.org/packages/9d/3b/75a713a73e41f3df18c5e6a502e14b1e49de174106320bf8eba399b15b0d/zc.relationship-1.1a.tar.gz"
      }
    ],
    "2.0dev": [
      {
        "comment_text": "",
        "digests": {
          "md5": "0ea14abf2728319d7af12826e4f4c356",
          "sha256": "ef51bf51fb42396f94155a0430ca53d51f83a6d936d0cd473a1e578a98ffd7ab"
        },
        "downloads": 3695,
        "filename": "zc.relationship-2.0dev-py2.4.egg",
        "has_sig": false,
        "md5_digest": "0ea14abf2728319d7af12826e4f4c356",
        "packagetype": "bdist_egg",
        "python_version": "2.4",
        "size": 102425,
        "upload_time": "2007-07-04T16:10:08",
        "url": "https://files.pythonhosted.org/packages/9f/0b/49d327e346e424e0f8c5c131f2a2b16f5e0960f447ef29817970f91cac7d/zc.relationship-2.0dev-py2.4.egg"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "3d5f6da7c9fd326b5fae1acbba54f55e",
          "sha256": "b0059ea4b722cc8614261746c55c841a250edc4187d051d9baffce81fa9c6aae"
        },
        "downloads": 3791,
        "filename": "zc.relationship-2.0dev.tar.gz",
        "has_sig": false,
        "md5_digest": "3d5f6da7c9fd326b5fae1acbba54f55e",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 98739,
        "upload_time": "2007-07-04T16:10:10",
        "url": "https://files.pythonhosted.org/packages/a7/db/83e6205f2023597beadfa42cb1001a37a38e1bef7555d8991d3b0f0a31d4/zc.relationship-2.0dev.tar.gz"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "b6461c8378603aceaa848294f92457e9",
        "sha256": "b39321691d35e10b9513cfe644cd7ac534dcc1fcb6e77d0fe80ed1c2a48d42f7"
      },
      "downloads": 3629,
      "filename": "zc.relationship-1.1.1.tar.gz",
      "has_sig": false,
      "md5_digest": "b6461c8378603aceaa848294f92457e9",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 76001,
      "upload_time": "2009-03-17T15:58:10",
      "url": "https://files.pythonhosted.org/packages/46/c9/dbf0dc917309ae4eebe0cafefe7dcdf65c3a7746c6fa523ff79c93ae5c89/zc.relationship-1.1.1.tar.gz"
    }
  ]
}