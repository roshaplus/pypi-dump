{
  "info": {
    "author": "Luis Pedro Coelho",
    "author_email": "luis@luispedro.org",
    "bugtrack_url": null,
    "classifiers": [
      "Intended Audience :: Developers",
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python",
      "Programming Language :: Python :: 2",
      "Programming Language :: Python :: 2.7",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.3",
      "Programming Language :: Python :: 3.4",
      "Programming Language :: Python :: 3.5",
      "Programming Language :: Python :: 3.6",
      "Topic :: Software Development :: Libraries"
    ],
    "description": "# Disk-based hashtable\n\n[![Travis](https://api.travis-ci.org/luispedro/diskhash.png)](https://travis-ci.org/luispedro/diskhash)\n[![License: MIT](https://img.shields.io/badge/License-MIT-blue.svg)](https://opensource.org/licenses/MIT)\n\n\nA simple disk-based hash table.\n\nThe code is in C, wrappers are provided for Python, Haskell, and C++. The\nwrappers follow similar APIs with variations to accomodate the language\nspecificity. They all use the same underlying code, so you can open a hashtable\ncreated in C from Haskell, modify it within your Haskell code, and open the\nresult in Python (although Python's version currently only deals with integers,\nstored as longs).\n\nCross-language functionality will work best for very simple types so that you\ncan control their binary representation (64-bit integers, for example).\n\nReading does not touch the disk representation at all and, thus, can be done on\ntop of read-only files or using multiple threads. Writing or modifying values\nis, however, not thread-safe.\n\n## Examples\n\nThe following examples all create a hashtable to store longs (`int64_t`), then\nset the value associated with the key `\"key\"` to 9. In the current API, the\nmaximum size of the keys needs to be pre-specified, which is the value `15`\nbelow.\n\n### Raw C\n\n```c\n#include <stdio.h>\n#include <inttypes.h>\n#include \"diskhash.h\"\n\nint main(void) {\n    HashTableOpts opts;\n    opts.key_maxlen = 15;\n    opts.object_datalen = sizeof(int64_t);\n    char* err = NULL;\n    HashTable* ht = dht_open(\"testing.dht\", opts, O_RDWR|O_CREAT, &err);\n    if (!ht) {\n        if (!err) err = \"Unknown error\";\n        fprintf(stderr, \"Failed opening hash table: %s.\\n\", err);\n        return 1;\n    }\n    long i = 9;\n    dht_insert(ht, \"key\", &i);\n    \n    long* val = (long*) dht_lookup(ht, \"key\");\n    printf(\"Looked up value: %l\\n\", *val);\n\n    dht_free(ht);\n    return 0;\n}\n```\n\n### Haskell\n\nIn Haskell, you have different types/functions for read-write and read-only\nhashtables.\n\nRead write example:\n\n```haskell\nimport Data.DiskHash\nimport Data.Int\nmain = do\n    ht <- htOpenRW \"testing.dht\" 15\n    htInsertRW ht \"key\" (9 :: Int64)\n    val <- htLookupRW \"key\" ht\n    print val\n```\n\nRead only example (`htLookupRO` is pure in this case):\n\n```haskell\nimport Data.DiskHash\nimport Data.Int\nmain = do\n    ht <- htOpenRO \"testing.dht\" 15\n    let val :: Int64\n        val = htLookupRO \"key\" ht\n    print val\n```\n\n\n### Python\n\nPython's interface is more limited and only integers are supported as values in\nthe hash table (they are stored as 64-bit integers).\n\n```python\nimport diskhash\ntb = diskhash.Str2int(\"testing.dht\", 15)\ntb.insert(\"key\", 9)\nprint(tb.lookup(\"key\"))\n```\n\nThe Python interface is currently Python 3 only. Patches to extend it to 2.7\nare welcome, but it's not a priority.\n\n\n### C++\n\n```c++\n#include <iostream>\n#include <string>\n\n#include <diskhash.hpp>\n\nint main() {\n    const int key_maxlen = 15;\n    dht::DiskHash<uint64_t> ht(\"testing.dht\", key_maxlen, dht::DHOpenRW);\n    std::string line;\n    uint64_t ix = 0;\n    while (std::getline(std::cine, line)) {\n        if (line.length() > key_maxlen) {\n            std::cerr << \"Key too long: '\" << line << \"'. Aborting.\\n\";\n            return 2;\n        }\n        const bool inserted = ht.insert(line.c_str(), ix);\n        if (!inserted) {\n            std::cerr  << \"Found repeated key '\" << line << \"' (ignored).\\n\";\n        }\n        ++ix;\n    }\n    return 0;\n}\n```\n\n## Statibility\n\nThis is _beta_ software. It is good enough that I am using it, but the API can\nchange in the future with little warning. The binary format will be fixed once\nthere is an upload to PyPI or Stackage, but that format is versioned (the magic\nstring encodes its version, so changes can be detected).\n\n[Automated unit testing](https://travis-ci.org/luispedro/diskhash) ensures that\nbasic mistakes will not go uncaught.\n\n## Limitations\n\n- You must specify the maximum key size. This can be worked around either by\n  pre-hashing the keys (with a strong hash) or using multiple hash tables for\n  different key sizes. Neither is currently implemented in diskhash.\n\n- You cannot delete objects. This was not a necessity for my uses, so it was\n  not implemented. A simple implementation could be done by marking objects as\n  \"deleted\" in place and recompacting when the hash table size changes or with\n  an explicit `dht_gc()` call. It may also be important to add functionality to\n  shrink hashtables so as to not waste disk space.\n\nLicense: MIT\n\n",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "http://github.com/luispedro/diskhash",
    "keywords": "",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "diskhash",
    "platform": "Any",
    "project_url": "https://pypi.org/project/diskhash/",
    "release_url": "https://pypi.org/project/diskhash/0.0/",
    "requires_dist": [],
    "requires_python": "",
    "summary": "Disk-based hashtable",
    "version": "0.0"
  },
  "releases": {
    "0.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "181ebb87395ff5a6afec489edc8b6b7e",
          "sha256": "ea0dab0c1105e319bed0f9efc8a091d716bc9ae65e33463c14eaecc30f5a680d"
        },
        "downloads": 0,
        "filename": "diskhash-0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "181ebb87395ff5a6afec489edc8b6b7e",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 12366,
        "upload_time": "2017-06-26T11:52:14",
        "url": "https://files.pythonhosted.org/packages/7a/c4/1886751c936bfb5a829d2b4496276f1790996994a37ac36959b015b893c3/diskhash-0.0.tar.gz"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "181ebb87395ff5a6afec489edc8b6b7e",
        "sha256": "ea0dab0c1105e319bed0f9efc8a091d716bc9ae65e33463c14eaecc30f5a680d"
      },
      "downloads": 0,
      "filename": "diskhash-0.0.tar.gz",
      "has_sig": false,
      "md5_digest": "181ebb87395ff5a6afec489edc8b6b7e",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 12366,
      "upload_time": "2017-06-26T11:52:14",
      "url": "https://files.pythonhosted.org/packages/7a/c4/1886751c936bfb5a829d2b4496276f1790996994a37ac36959b015b893c3/diskhash-0.0.tar.gz"
    }
  ]
}