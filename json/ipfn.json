{
  "info": {
    "author": "Damien Forthommme",
    "author_email": "damien2227@hotmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 4 - Beta",
      "Intended Audience :: Science/Research",
      "License :: OSI Approved :: MIT License",
      "Programming Language :: Python :: 2.7",
      "Programming Language :: Python :: 3.5",
      "Topic :: Software Development :: Build Tools"
    ],
    "description": "ipfn\n=======================\n\nIterative proportional fitting is an algorithm used is many different fields such as economics or social sciences, to alter results in such a way that aggregates along one or several dimensions match known marginals (or aggregates along these same dimensions).\n\nThe algorithm exists in 2 versions:\n\n*   numpy version, which the fastest by far\n*   pandas version, which is much slower but easier to use than the numpy version\n\n\nThe algorithm recognizes the input variable type and and uses the appropriate version to solve the problem. To install the package:\n\n*   pip install ipfn\n\nFor more information and examples, please visit:\n\n*   `wikipedia page on ipf <https://en.wikipedia.org/wiki/Iterative_proportional_fitting>`_\n*   `slides explaining the methodology and links to specific examples <http://www.demog.berkeley.edu/~eddieh/IPFDescription/AKDOLWDIPFTWOD.pdf>`_\n*   https://github.com/Dirguis/ipfn\n\n----\n\nThe project is similar to the ipfp package available for R and tests have been run to ensure same results.\n\n----\n\nExample with the numpy version of the algorithm:\n------------------------------------------------\nPlease, follow the example below to run the package. Several additional examples in addition to the one listed below, are listed in the ipfn.py script. This example is taken from `<http://www.demog.berkeley.edu/~eddieh/IPFDescription/AKDOLWDIPFTHREED.pdf>`_\n\nFirst, let us define a matrix of N=3 dimensions, the matrix being of specific size 2*4*3 and populate that matrix with some values ::\n\n    from ipfn import *\n    import numpy as np\n    import pandas as pd\n\n    m = np.zeros((2,4,3))\n    m[0,0,0] = 1\n    m[0,0,1] = 2\n    m[0,0,2] = 1\n    m[0,1,0] = 3\n    m[0,1,1] = 5\n    m[0,1,2] = 5\n    m[0,2,0] = 6\n    m[0,2,1] = 2\n    m[0,2,2] = 2\n    m[0,3,0] = 1\n    m[0,3,1] = 7\n    m[0,3,2] = 2\n    m[1,0,0] = 5\n    m[1,0,1] = 4\n    m[1,0,2] = 2\n    m[1,1,0] = 5\n    m[1,1,1] = 5\n    m[1,1,2] = 5\n    m[1,2,0] = 3\n    m[1,2,1] = 8\n    m[1,2,2] = 7\n    m[1,3,0] = 2\n    m[1,3,1] = 7\n    m[1,3,2] = 6\n\nNow, let us define some marginals. They all have to be less than N=3 dimensions and be consistent with the dimensions of contingency table m. For example, the marginal along the first dimension will be made of 2 elements. We want the sum of elements in m for dimensions 2 and 3 to equal the marginal::\n\n    m[0,:,:].sum() == marginal[0]\n    m[1,:,:].sum() == marginal[1]\n\nThe marginals are::\n\n    xipp = np.array([52, 48])\n    xpjp = np.array([20, 30, 35, 15])\n    xppk = np.array([35, 40, 25])\n    xijp = np.array([[9, 17, 19, 7], [11, 13, 16, 8]])\n    xpjk = np.array([[7, 9, 4], [8, 12, 10], [15, 12, 8], [5, 7, 3]])\n\nI used the letter p to denote the dimension(s) being summed over\n\nDefine the aggregates list and the corresponding list of dimension to indicate the algorithm which dimension(s) to sum over for each aggregate::\n\n    aggregates = [xipp, xpjp, xppk, xijp, xpjk]\n    dimensions = [[0], [1], [2], [0, 1], [1, 2]]\n\nFinally, run the algorithm::\n\n    IPF = ipfn(m, aggregates, dimensions)\n    m = IPF.iteration()\n    print xijp[0,0]\n    print m[0, 0, :].sum()\n\n\nExample with the pandas version of the algorithm:\n------------------------------------------------\nIn the same fashion, we can run a similar example, but using a dataframe::\n\n    from ipfn import *\n    import numpy as np\n    import pandas as pd\n\n    m      = np.array([1., 2., 1., 3., 5., 5., 6., 2., 2., 1., 7., 2.,\n                   5., 4., 2., 5., 5., 5., 3., 8., 7., 2., 7., 6.], )\n    dma_l  = [501, 501, 501, 501, 501, 501, 501, 501, 501, 501, 501, 501,\n              502, 502, 502, 502, 502, 502, 502, 502, 502, 502, 502, 502]\n    size_l = [1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4,\n              1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4]\n\n    age_l  = ['20-25','30-35','40-45',\n              '20-25','30-35','40-45',\n              '20-25','30-35','40-45',\n              '20-25','30-35','40-45',\n              '20-25','30-35','40-45',\n              '20-25','30-35','40-45',\n              '20-25','30-35','40-45',\n              '20-25','30-35','40-45']\n\n    df = pd.DataFrame()\n    df['dma'] = dma_l\n    df['size'] = size_l\n    df['age'] = age_l\n    df['total'] = m\n\n    xipp = df.groupby('dma')['total'].sum()\n    xpjp = df.groupby('size')['total'].sum()\n    xppk = df.groupby('age')['total'].sum()\n    xijp = df.groupby(['dma', 'size'])['total'].sum()\n    xpjk = df.groupby(['size', 'age'])['total'].sum()\n    # xppk = df.groupby('age')['total'].sum()\n\n    xipp.loc[501] = 52\n    xipp.loc[502] = 48\n\n    xpjp.loc[1] = 20\n    xpjp.loc[2] = 30\n    xpjp.loc[3] = 35\n    xpjp.loc[4] = 15\n\n    xppk.loc['20-25'] = 35\n    xppk.loc['30-35'] = 40\n    xppk.loc['40-45'] = 25\n\n    xijp.loc[501] = [9, 17, 19, 7]\n    xijp.loc[502] = [11, 13, 16, 8]\n\n    xpjk.loc[1] = [7, 9, 4]\n    xpjk.loc[2] = [8, 12, 10]\n    xpjk.loc[3] = [15, 12, 8]\n    xpjk.loc[4] = [5, 7, 3]\n\n    aggregates = [xipp, xpjp, xppk, xijp, xpjk]\n    dimensions = [['dma'], ['size'], ['age'], ['dma', 'size'], ['size', 'age']]\n\n    IPF = ipfn(df, aggregates, dimensions)\n    df = IPF.iteration()\n\n    print df\n    print df.groupby('size')['total'].sum(), xpjp\n\nAdded notes:\n------------\n\nSeveral examples, using the numpy or pandas version of the algorithm are listed in the script `ipfn.py <https://github.com/Dirguis/ipfn.git>`_. Comment, uncomment to parts of interests and run the script::\n\n    python ipfn.py\n\nTo call the algorithm in a program, execute::\n\n    import ipfn",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "https://github.com/Dirguis/ipfn.git",
    "keywords": "iterative proportional fitting ipfp biproportional ras raking scaling",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "ipfn",
    "platform": "Any",
    "project_url": "https://pypi.org/project/ipfn/",
    "release_url": "https://pypi.org/project/ipfn/1.1.7/",
    "requires_python": "",
    "summary": "Iterative Proportional Fitting with N dimensions, for python",
    "version": "1.1.7"
  },
  "releases": {
    "1.1.6": [
      {
        "comment_text": "",
        "digests": {
          "md5": "137b15e382991d3de5ec6eb0985f2e6b",
          "sha256": "302a2d6a7a1845c8e874914dbe948d42bd88d373f881234983190ac72ddec3cb"
        },
        "downloads": 11,
        "filename": "ipfn-1.1.6-py2.py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "137b15e382991d3de5ec6eb0985f2e6b",
        "packagetype": "bdist_wheel",
        "python_version": "py2.py3",
        "size": 10257,
        "upload_time": "2017-01-15T19:42:45",
        "url": "https://files.pythonhosted.org/packages/99/17/89bd84bdc468f16ccded499fcb44cfbe8cb01276a11ef936ee02dd94f63d/ipfn-1.1.6-py2.py3-none-any.whl"
      }
    ],
    "1.1.7": [
      {
        "comment_text": "",
        "digests": {
          "md5": "5c2c1ae6e010a1cadfb2403c11f1ce71",
          "sha256": "0d9826d756b532710905a562f798ce50f0849a3e6c2b6b2da3f91a07a4105fff"
        },
        "downloads": 14,
        "filename": "ipfn-1.1.7-py2.py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "5c2c1ae6e010a1cadfb2403c11f1ce71",
        "packagetype": "bdist_wheel",
        "python_version": "py2.py3",
        "size": 10285,
        "upload_time": "2017-02-11T03:12:05",
        "url": "https://files.pythonhosted.org/packages/7c/7e/5679bc5f276db1ea78d62eb48fb8f817e0789cfff82717c3a7ac2e7044bd/ipfn-1.1.7-py2.py3-none-any.whl"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "5c2c1ae6e010a1cadfb2403c11f1ce71",
        "sha256": "0d9826d756b532710905a562f798ce50f0849a3e6c2b6b2da3f91a07a4105fff"
      },
      "downloads": 14,
      "filename": "ipfn-1.1.7-py2.py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "5c2c1ae6e010a1cadfb2403c11f1ce71",
      "packagetype": "bdist_wheel",
      "python_version": "py2.py3",
      "size": 10285,
      "upload_time": "2017-02-11T03:12:05",
      "url": "https://files.pythonhosted.org/packages/7c/7e/5679bc5f276db1ea78d62eb48fb8f817e0789cfff82717c3a7ac2e7044bd/ipfn-1.1.7-py2.py3-none-any.whl"
    }
  ]
}