{
  "info": {
    "author": "Fantix King",
    "author_email": "fantix.king@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 3 - Alpha",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: BSD License",
      "Natural Language :: English",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.6"
    ],
    "description": "====\nGINO\n====\n\n\n.. image:: https://img.shields.io/pypi/v/gino.svg\n        :target: https://pypi.python.org/pypi/gino\n\n.. image:: https://img.shields.io/travis/fantix/gino.svg\n        :target: https://travis-ci.org/fantix/gino\n\n.. image:: https://readthedocs.org/projects/ginorm/badge/?version=latest\n        :target: https://ginorm.readthedocs.io/en/latest/?badge=latest\n        :alt: Documentation Status\n\n.. image:: https://pyup.io/repos/github/fantix/gino/shield.svg\n     :target: https://pyup.io/repos/github/fantix/gino/\n     :alt: Updates\n\n\nGINO - GINO Is Not ORM - is an extremely simple Python ORM, using SQLAlchemy_\ncore to define table models, and asyncpg_ to interact with database.\n\n\n* Free software: BSD license\n* Documentation: https://gino.readthedocs.io.\n\nThere's been a lot of words about ORM a.k.a. Object-relational mapping - good\nor bad - as well as a lot of ORM libraries in Python. It is crucial to pick a\nmost suitable one for your project, and for your team. GINO tries to stay in\nthe middle between ORM and non-ORM, offering an extremely simple option.\n\nGINO operates database rows with \"plain old Python objects\" - they *are* just\nnormal Python objects, a rollback doesn't magically change their values. Any\ndatabase operations are explicit - it is crystal clear what is done underneath\neach GINO API. There are no dirty models, no sessions, no magic. You have\nconcrete control to the database, through a convenient object interface. That's\nit.\n\nGINO depends on asyncpg_, which means it works only for PostgreSQL_ and\nasyncio_, which means Python 3 is required - actually 3.6 required for now.\nBased on SQLAlchemy_, gate to its ecosystem is open - feel free to use e.g.\nAlembic_ to manage your schema changes. And we specially designed a few candies\nfor the Sanic_ server.\n\n\nExample\n-------\n\nA piece of code is worth a thousand words:\n\n\n.. code-block:: python\n\n   import asyncio\n   from gino import Gino, enable_task_local\n   from sqlalchemy import Column, Integer, Unicode, cast\n\n   db = Gino()\n\n\n   class User(db.Model):\n       __tablename__ = 'users'\n\n       id = Column(Integer(), primary_key=True)\n       nickname = Column(Unicode(), default='noname')\n\n\n   async def main():\n       await db.create_pool('postgresql://localhost/gino')\n\n       # Create object, `id` is assigned by database\n       u1 = await User.create(nickname='fantix')\n       print(u1.id, u1.nickname)  # 1 fantix\n\n       # Retrieve the same row, as a different object\n       u2 = await User.get(u1.id)\n       print(u2.nickname)  # fantix\n\n       # Update affects only database row and the operating object\n       await u2.update(nickname='daisy')\n       print(u2.nickname)  # daisy\n       print(u1.nickname)  # fantix\n\n       # Returns all user objects with \"d\" in their nicknames\n       users = await User.query.where(User.nickname.contains('d')).gino.all()\n\n       # Find one user object, None if not found\n       user = await User.query.where(User.nickname == 'daisy').gino.first()\n\n       # Execute complex statement and return command status\n       status = await User.update.values(\n           nickname='No.' + cast(User.id, Unicode),\n       ).where(\n           User.id > 10,\n       ).gino.status()\n\n       # Iterate over the results of a large query in a transaction as required\n       async with db.transaction():\n           async for u in User.query.order_by(User.id).gino.iterate():\n               print(u.id, u.nickname)\n\n\n   loop = asyncio.get_event_loop()\n   enable_task_local(loop)\n   loop.run_until_complete(main())\n\nThe code explains a lot, but not everything. Let's go through again briefly.\n\n\nDeclare Models\n--------------\n\nEach model maps to a database table. To define a model, you'll need a ``Gino``\nobject first, usually as a global variable named ``db``. It is actually an\nextended instance of ``sqlalchemy.MetaData``, which can be used in Alembic_ for\nexample. By inheriting from ``db.Model``, you can define database tables in a\ndeclarative way as shown above:\n\n.. code-block:: python\n\n   db = Gino()\n\n   class User(db.Model):\n       __tablename__ = 'users'\n\n       id = Column(Integer(), primary_key=True)\n       nickname = Column(Unicode(), default='noname')\n\nNote that ``__tablename__`` is required, GINO suggests singular for model\nnames, and plural for table names. After declaration, access to SQLAlchemy\ncolumns is available on class level, allowing vanilla SQLAlchemy programming\nlike this:\n\n.. code-block:: python\n\n   import sqlalchemy as sa\n\n   sa.select([User.nickname]).where(User.id > 10)\n\nBut on object level, model objects are just normal objects in memory. The only\nconnection to database happens when you explicitly calls a GINO API,\n``user.update`` for example. Otherwise, any changes made to the object stay in\nmemory only. That said, different objects are isolated from each other, even if\nthey all map to the same database row - modifying one doesn't affect another.\n\nSpeaking of mapping, GINO automatically detects the primary keys and uses them\nto identify the correct row in database. This is no magic, it is only a\n``WHERE`` clause automatically added to the ``UPDATE`` statement when calling\nthe ``user.update`` method, or during ``User.get`` retrieval.\n\n.. code-block:: python\n\n   u = await User.get(1)              # SELECT * FROM users WHERE id = 1\n   await u.update(nickname='fantix')  # UPDATE users SET ... WHERE id = 1\n   u.id = 2                           # No SQL here!!\n   await u.update(nickname='fantix')  # UPDATE users SET ... WHERE id = 2\n\nUnder the hood, model values are stored in a dict named ``__values__``. And the\ncolumns you defined are wrapped with special attribute objects, which deliver\nthe ``__values__`` to you on object level, or as column objects on class level.\n\n\nBind Database\n-------------\n\nThough optional, GINO can bind to an asyncpg database connection or pool to\nmake life easier. The most obvious way is to create a database pool with GINO.\n\n.. code-block:: python\n\n   pool = await db.create_pool('postgresql://localhost/gino')\n\nOnce created, the pool is automatically bound to the ``db`` object, therefore\nto all the models too. To unplug the database, just close the pool. This API is\nidentical to the one from asyncpg, so can it be used as a context manager too:\n\n.. code-block:: python\n\n   async with db.create_pool('postgresql://localhost/gino') as pool:\n       # play with pool\n\nOtherwise, you will need to manually do the binding:\n\n.. code-block:: python\n\n   import asyncpg\n\n   pool = await asyncpg.create_pool('postgresql://localhost/gino')\n   db = Gino(pool)\n\n   # or\n   db = Gino()\n   db.bind = pool\n\nIt is theoretically possible to bind to a connection object, but this scenario\nis not normally well tested. And as stated in the beginning, it is possible to\nuse GINO without binding to a database. In such case, you should manually pass\nasyncpg pool or connection object to GINO APIs as the ``bind`` keyword argument:\n\n.. code-block:: python\n\n   import asyncpg\n   conn = await asyncpg.connect('postgresql://localhost/gino')\n   user = await User.get(3, bind=conn)\n\n\nAt last, GINO can be used to only define models and translate SQLAlchemy\nqueries into SQL with its builtin asyncpg dialect:\n\n.. code-block:: python\n\n   query, params = db.compile(User.query.where(User.id == 3))\n   row = await conn.fetchval(query, *params)\n\n\nExecute Queries\n---------------\n\nThere are several levels of API available for use in GINO. On model objects:\n\n.. code-block:: python\n\n   await user.update(nickname='fantix')\n   await user.delete()\n\nOn model class level, to operate objects:\n\n.. code-block:: python\n\n   user = await User.create(nickname='fantix')\n   user = await User.get(9)\n\nOn model class level, to generate queries:\n\n.. code-block:: python\n\n   query = User.query.where(User.id > 10)\n   query = User.select('id', 'nickname')\n   query = User.update.values(nickname='fantix').where(User.id = 6)\n   query = User.delete.where(User.id = 7)\n\nOn query level, GINO adds an extension ``gino`` to run query in place:\n\n.. code-block:: python\n\n   users = await query.gino.all()\n   user = await query.gino.first()\n   user_id = await query.gino.scalar()\n\nThese query APIs are simply delegates to the concrete ones on the ``Gino``\nobject:\n\n.. code-block:: python\n\n   users = await gino.all(query)\n   user = await gino.first(query)\n   user_id = await gino.scalar(query)\n\nIf the database pool is created by ``db.create_pool``, then such APIs are also\navailable on the pool object and connection objects:\n\n.. code-block:: python\n\n   async with db.create_pool('...') as pool:\n       users = await pool.all(query)\n       user = await pool.first(query)\n       user_id = await pool.scalar(query)\n\n       async with pool.acquire() as conn:\n           users = await conn.all(query)\n           user = await conn.first(query)\n           user_id = await conn.scalar(query)\n\n\nTransaction and Context\n-----------------------\n\nIn normal cases when ``db`` is bound to a pool, you can start a transaction\nthrough ``db`` directly:\n\n.. code-block:: python\n\n   async with db.transaction() as (conn, tx):\n       # play within a transaction\n\nAs you can see from the unpacked arguments, ``db.transaction()`` acquired a\nconnection and started a transaction in one go. It is identical to do it\nseparately:\n\n.. code-block:: python\n\n   async with db.acquire() as conn:\n       async with conn.transaction() as tx:\n           # play within a transaction\n\nPlease note, there is no ``db.release`` to return the connection to the pool,\nthus you cannot do ``conn = await db.acquire()``. Using ``async with`` is the\nonly way, and the reason is about context.\n\nBecause GINO offers query APIs on not only connections but also model classes\nand objects and even query objects, it would be too much trouble passing\nconnection object around when dealing with transactions. Therefore GINO offers\nan optional feature to automatically manage connection objects, by enabling a\nbuiltin task local hack before any tasks are created:\n\n.. code-block:: python\n\n   from gino import enable_task_local\n   enable_task_local()\n\nThis switch creates a local storage for each coroutine, where ``db.acquire()``\nshall store the connection object. Hence executions within the acquire context\nwill be able to make use of the same connection right in the local storage.\nFurthermore, nested ``db.acquire()`` will simply return the same connection.\nThis allows ``db.transaction()`` to be nested in the same way that asyncpg\n``conn.transaction()`` does it - to use database save points.\n\n.. code-block:: python\n\n   async with db.transaction() as (conn1, tx1):      # BEGIN\n       async with db.transaction() as (conn2, tx2):  # SAVEPOINT ...\n           assert conn1 == conn2\n\nIf nested transactions or reused connections are not expected, you can\nexplicitly use ``db.acquire(reuse=False)`` or ``db.transaction(reuse=False)``\nto borrow new connections from the pool. Non-reused connections are stacked,\nthey will be returned to the pool in the reversed order as they were borrowed.\nLocal storage covers between different tasks that are awaited in a chain, it is\ntheoretically safe in most cases. However it is still some sort of a hack, but\nit would be like this before Python officially supports task local storage one\nday.\n\n\nContribute\n----------\n\nThere are a few tasks in GitHub issues marked as ``help wanted``. Please feel\nfree to take any of them and pull requests are greatly welcome.\n\nTo run tests:\n\n.. code-block:: shell\n\n   python setup.py test\n\n\nCredits\n---------\n\nCredit goes to all contributors listed in the AUTHORS file. This project is\ninspired by asyncpgsa_, peewee-async_ and asyncorm_. asyncpg_ and SQLAlchemy_\nas the dependencies did most of the heavy lifting. This package was created\nwith Cookiecutter_ and the `audreyr/cookiecutter-pypackage`_ project template.\n\n.. _Cookiecutter: https://github.com/audreyr/cookiecutter\n.. _`audreyr/cookiecutter-pypackage`: https://github.com/audreyr/cookiecutter-pypackage\n.. _SQLAlchemy: https://www.sqlalchemy.org/\n.. _asyncpg: https://github.com/MagicStack/asyncpg\n.. _PostgreSQL: https://www.postgresql.org/\n.. _asyncio: https://docs.python.org/3/library/asyncio.html\n.. _Alembic: https://bitbucket.org/zzzeek/alembic\n.. _Sanic: https://github.com/channelcat/sanic\n.. _asyncpgsa: https://github.com/CanopyTax/asyncpgsa\n.. _peewee-async: https://github.com/05bit/peewee-async\n.. _asyncorm: https://github.com/monobot/asyncorm\n\n\n=======\nHistory\n=======\n\n0.3.0 (2017-08-07)\n------------------\n\n* Supported ``__table_args__`` (#12)\n* Introduced task local to manage connection in context (#19)\n* Added ``query.gino`` extension for in-place execution\n* Refreshed README (#3)\n* Adopted PEP 487 (Contributed by Tony Wang in #17 #27)\n* Used ``weakref`` on ``__model__`` of table and query (Contributed by Tony Wang)\n* Delegated asyncpg ``timeout`` parameter (Contributed by Neal Wang in #16 #22)\n\n0.2.3 (2017-08-04)\n------------------\n\n* Supported any primary key (Contributed by Tony Wang in #11)\n\n0.2.2 (2017-08-02)\n------------------\n\n* Supported SQLAlchemy result processor\n* Added rich support on JSON/JSONB\n* Bug fixes\n\n0.2.1 (2017-07-28)\n------------------\n\n* Added ``update`` and ``delete`` API\n\n0.2.0 (2017-07-28)\n------------------\n\n* Changed API, no longer reuses asyncpg API\n\n0.1.1 (2017-07-25)\n------------------\n\n* Added ``db.bind``\n* API changed: parameter ``conn`` renamed to optional ``bind``\n* Delegated asyncpg Pool with ``db.create_pool``\n* Internal enhancement and bug fixes\n\n0.1.0 (2017-07-21)\n------------------\n\n* First release on PyPI.\n",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "https://github.com/fantix/gino",
    "keywords": "gino",
    "license": "BSD license",
    "maintainer": "",
    "maintainer_email": "",
    "name": "gino",
    "platform": "",
    "project_url": "https://pypi.org/project/gino/",
    "release_url": "https://pypi.org/project/gino/0.3.0/",
    "requires_dist": [],
    "requires_python": "",
    "summary": "GINO Is Not ORM - a Python ORM on asyncpg and SQLAlchemy core.",
    "version": "0.3.0"
  },
  "releases": {
    "0.1.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "68e0236a7cd8de56fb7e06e5b74a85ac",
          "sha256": "017f830b4111ef76effd46b7d31629dd04b98fd473b677550387843b5c47d880"
        },
        "downloads": 0,
        "filename": "gino-0.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "68e0236a7cd8de56fb7e06e5b74a85ac",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 17048,
        "upload_time": "2017-07-22T02:59:19",
        "url": "https://files.pythonhosted.org/packages/78/e3/f8106fda62c5041806f358ae1dd582b4b1907e528879d7cba2c4e624284b/gino-0.1.0.tar.gz"
      }
    ],
    "0.1.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "d842e5fc9b7aecc00feba3a809f00022",
          "sha256": "858027f23e47e074c82f83ceaedb6a97b953955a8c578e4be79f37ca49fdb844"
        },
        "downloads": 0,
        "filename": "gino-0.1.1.tar.gz",
        "has_sig": false,
        "md5_digest": "d842e5fc9b7aecc00feba3a809f00022",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 19004,
        "upload_time": "2017-07-25T09:13:34",
        "url": "https://files.pythonhosted.org/packages/ea/4c/e532ad9320a815b9ca10af30b638cbf8f8de7c2486f49f2c8e3aaf7836ee/gino-0.1.1.tar.gz"
      }
    ],
    "0.2.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "626afe5c4bef16bb30d6c98b38f22b34",
          "sha256": "b27662cdfd585f37673e964e8101fc8b7d5f043468594786587a58de99d5d81c"
        },
        "downloads": 0,
        "filename": "gino-0.2.0.tar.gz",
        "has_sig": false,
        "md5_digest": "626afe5c4bef16bb30d6c98b38f22b34",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 19285,
        "upload_time": "2017-07-28T06:35:53",
        "url": "https://files.pythonhosted.org/packages/2f/2c/1b1bf5a93c82381d70ddea758f5dad7470ef4f128cbebfacd2c5332f6049/gino-0.2.0.tar.gz"
      }
    ],
    "0.2.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "045ce30e475fc9e545fa6858b6756f34",
          "sha256": "4e30001413edce5f5245e9b3bdd14b191234ae10799815d4d86268abc2ce2d83"
        },
        "downloads": 0,
        "filename": "gino-0.2.1.tar.gz",
        "has_sig": false,
        "md5_digest": "045ce30e475fc9e545fa6858b6756f34",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 19474,
        "upload_time": "2017-07-28T07:07:43",
        "url": "https://files.pythonhosted.org/packages/1b/54/b9ce428ade3d1119f26780c6ac96e1531866b53ad6cb518439564e2d66e9/gino-0.2.1.tar.gz"
      }
    ],
    "0.2.2": [
      {
        "comment_text": "",
        "digests": {
          "md5": "55cd5a60f2e27bfff2f42e346946614f",
          "sha256": "340d8c0c87869c3396e5505a86d5d1bd249333ef5c02219d072541e6429906b5"
        },
        "downloads": 0,
        "filename": "gino-0.2.2.tar.gz",
        "has_sig": false,
        "md5_digest": "55cd5a60f2e27bfff2f42e346946614f",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 20580,
        "upload_time": "2017-08-02T02:02:36",
        "url": "https://files.pythonhosted.org/packages/ac/07/a71e5039a2f31b28064e8670b6a3a57fd3015d27d7cd8887836f2414b55c/gino-0.2.2.tar.gz"
      }
    ],
    "0.2.3": [
      {
        "comment_text": "",
        "digests": {
          "md5": "b9ef2c953f4939fcdb3af7cc72640828",
          "sha256": "bf4ecc71d5017bd5c4c0e509701efc4a05f49d3c7b0348e2cd459b83f405595b"
        },
        "downloads": 0,
        "filename": "gino-0.2.3.tar.gz",
        "has_sig": false,
        "md5_digest": "b9ef2c953f4939fcdb3af7cc72640828",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 22413,
        "upload_time": "2017-08-04T03:23:36",
        "url": "https://files.pythonhosted.org/packages/07/ed/a20a7bb30080d858c2600c22c09f61d5057cdec12cc4217b5d5f7e56b182/gino-0.2.3.tar.gz"
      }
    ],
    "0.3.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "0994fde3a8dce61cd89f848dacb710e1",
          "sha256": "211b5cdc6d6c612b969a57a551e5d267e2be147c97e54582e96e91c17c452ce2"
        },
        "downloads": 0,
        "filename": "gino-0.3.0.tar.gz",
        "has_sig": false,
        "md5_digest": "0994fde3a8dce61cd89f848dacb710e1",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 27956,
        "upload_time": "2017-08-07T06:11:57",
        "url": "https://files.pythonhosted.org/packages/6f/ea/7038a98f49a6802a5a8c4f710c309fbc7f52ce4c8a0e3c697ede87bceba0/gino-0.3.0.tar.gz"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "0994fde3a8dce61cd89f848dacb710e1",
        "sha256": "211b5cdc6d6c612b969a57a551e5d267e2be147c97e54582e96e91c17c452ce2"
      },
      "downloads": 0,
      "filename": "gino-0.3.0.tar.gz",
      "has_sig": false,
      "md5_digest": "0994fde3a8dce61cd89f848dacb710e1",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 27956,
      "upload_time": "2017-08-07T06:11:57",
      "url": "https://files.pythonhosted.org/packages/6f/ea/7038a98f49a6802a5a8c4f710c309fbc7f52ce4c8a0e3c697ede87bceba0/gino-0.3.0.tar.gz"
    }
  ]
}