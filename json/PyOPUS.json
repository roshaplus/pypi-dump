{
  "info": {
    "author": "\u00c1rp\u00e1d B\u0171rmen",
    "author_email": "arpadb@fides.fe.uni-lj.si",
    "bugtrack_url": "",
    "classifiers": [],
    "description": "PyOPUS is a library for simulation-based optimization of arbitrary systems. \r\nIt was developed with circuit optimization in mind. PyOPUS provides\r\nseveral optimization algorithms (Coordinate Search, Hooke-Jeeves,\r\nNelder-Mead Simplex, Successive Approximation Simplex, PSADE (global), MADS, ...).\r\nOptimization algorithms can be fitted with plugins that are triggered at\r\nevery function evaluation and have full access to the internals of the\r\noptimization algorithm. \r\n\r\nPyOPUS has a large library of optimization test functions that can be used for \r\noptimization algorithm development. The functions include benchmark sets by \r\nMor\u00e9-Garbow-Hillstrom, Luk\u0161an-Vl\u010dek (nonsmooth problems), Karmitsa (nonsmooth \r\nproblems), Mor\u00e9-Wild, global optimization problems by Yao, Hedar, and Yang, \r\nproblems used in the developement of MADS algorithms, and an interface to \r\nthousands of problems in the CUTEr/CUTEst collection. Benchmark results can \r\nbe converted to data profiles that visualize the relative performance of \r\noptimization algorithms. \r\n\r\nThe ``pyopus.simulator`` module currently supports SPICE OPUS, HSPICE, and \r\nSPECTRE (supports OP, DC, AC, TRAN, and NOISE analyses, as well as, collecting \r\ndevice properties like Vdsat). The interface is simple can be easily extended to support any simulator.\r\n\r\nPyOPUS provides an extensible library of postprocessing functions which\r\nenable you to easily extract performance measures like gain, bandwidth, rise\r\ntime, slew-rate, etc. from simulation results.\r\n\r\nThe collected performance measures can be further post-processed to obtain\r\na user-defined cost function which can be used for guiding the optimization\r\nalgorithms toward better circuits.\r\n\r\nPyOPUS provides sensitivity analysis, parameter screening, worst case \r\nperformance analysis, worst case distance analysis (deterministic approximation \r\nof parametric yield), and Monte Carlo analysis (statistical approximation of \r\nparametric yield). Designs can be sized efficiently across a large number of \r\ncorners. Finally, automated design for achieving a parametric yield target is \r\nalso available. Most of these procedures can take advantage of parallel \r\ncomputing which significantly speeds up the process. \r\n\r\nParallel computing is supported through the use of the MPI library. A \r\ncluster of computers is represented by a VirtualMachine object which\r\nprovides a simple interface to the underlying MPI library. Parallel programs \r\ncan be written with the help of a simple cooperative multitasking OS. This \r\nOS can outsource function evaluations to computing nodes, but it can also \r\nperform all evaluations on a single processor. \r\n\r\nWriting parallel programs follows the UNIX philosophy. A function can be run \r\nremotely with the ``Spawn`` OS call. One or more remote functions can be \r\nwaited on with the ``Join`` OS call. The OS is capable of running a parallel \r\nprogram on a single computing node using cooperative multitasking or on a set \r\nof multiple computing nodes using a VirtualMachine object. Parallelism can be \r\nintroduced on multiple levels of the program (i.e. parallel performance \r\nevaluation across multiple corners, parallel optimization algorithms, evaluation of multiple worst case performances in parallel, ...). \r\n\r\nPyOPUS provides a plotting mechanism based on MatPlotLib and wxPython with \r\nan interface and capabilities similar to those available in MATLAB.\r\nThe plots are handled by a separate thread so you can write your programs\r\njust like you are were used to in MATLAB. Professional quality plots can be \r\neasily exported to a large number of raster and vector formats for inclusion \r\nin your documents. The plotting capability is used in the ``pyopus.visual`` module \r\nthat enables the programmer to visualize the simulation results after an \r\noptimization run or even during an optimization run.",
    "docs_url": null,
    "download_url": "UNKNOWN",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "http://fides.fe.uni-lj.si/pyopus/",
    "keywords": "",
    "license": "GPL V3",
    "maintainer": "",
    "maintainer_email": "",
    "name": "PyOPUS",
    "platform": "Linux,Windows",
    "project_url": "https://pypi.org/project/PyOPUS/",
    "release_url": "https://pypi.org/project/PyOPUS/0.8/",
    "requires_python": null,
    "summary": "Simulation, optimization, and design for circuits and everything else",
    "version": "0.8"
  },
  "releases": {
    "0.8": []
  },
  "urls": []
}