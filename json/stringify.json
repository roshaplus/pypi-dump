{
  "info": {
    "author": "Jason R. Jones",
    "author_email": "slightlynybbled@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 3 - Alpha",
      "Natural Language :: English",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.5",
      "Programming Language :: Python :: 3.6"
    ],
    "description": "----------------\nPurpose\n----------------\n\nThe `stringify` module allows you to easily include your project's binary files as python base64 strings.  This may not be useful for your little tkinter project until you try to bundle the project as an executable using pyinstaller.  Suddenly, you get to spend lots of time thinking about how to best write your spec files so that they capture the current files and any future changes as well.  Or you could use `stringify`.\n\n----------------\nInstallation\n----------------\n\nSimply `pip install stringify` should do the trick.  You could also download this repository and `python setup.py install`, but that isn't as fun, is it?\n\n----------------\nUse Case\n----------------\n\nSomewhere - probably within your module - you have a file that has static, non-code data.  You probably have a directory called 'images' or 'bin' that the python code references when building a GUI or executing a program... whatever.  This works great when using python directly - such as when you install the package via pip and call it from the command-line. This doesn't work so well when you try to bundle your package using [`pyinstaller`](http://www.pyinstaller.org/), which doesn't natively recognize your non-code dependencies.\n\nThis library allows you to read those binary files into python code and include that data as python variables in your code base.\n\nA quick note, this library has only been tested on relatively modestly-sized files - such as images.  Larger file packaging using this method has not been tested.\n\n----------------\nQuickstart\n----------------\n\nWe will assume a project structure that starts begins as outlined below.  Note that the image paths are explicitly\ncalled out as part of `my_package/package_file_0.py`.::\n\n    setup.py\n    my_package/\n        __init__.py\n        package_file_0.py\n        images/\n            img1.png\n            img2.png\n\n==========================\nExile Binary Files\n==========================\n\nMove your binary files outside of the package that you wish to include them within.  We will put something in there to take their place, but don't worry about that for the moment.  Our new project structure::\n\n    setup.py\n    images/\n        img1.png\n        img2.png\n    my_package/\n        __init__.py\n        package_file_0.py\n\n===============================\nRun 'dir_to_py_file()' Utility\n===============================\n\nOur files are now located within `images` and our desired location will be `images.py` within the package.::\n\n    from stringify import dir_to_py_file\n\n    dir_to_py_file(source_path='images', destination_file='my_package/images.py')\n\nNote that dashes will be replaced with underscores and spaces will be replaced with underscores and that the extensions will be removed before the name of the python variable is created.  For instance, `green-dot one.png` will become the variable `green_dot_one`.\n\nThe source tree as it existed earlier remains intact, but we have an extra file within `my_package` called `images.py`::\n\n    setup.py\n    images/\n        img1.png\n        img2.png\n    my_package/\n        __init__.py\n        package_file_0.py\n        images.py\n\nFeel free to have a look at images.py, you can't hurt it and you can always regenerate it.  You should see two variables located within called `img1` and `img2`.  Each of these has a long byte string assigned to it that can be easily referenced and mined for the data.\n\n============================\nReference the Image Strings\n============================\n\nRecall that it was `package_file_0.py` that utilized the image data.  Within `package_file_0.py`, import the new image strings:\n\n    from images import img1, img2\n\nReplace any absolute function calls to those images with the variable.  Note that some functions, such as `tkinter.PhotoImage()` can take image data directly in this format.::\n\n    # tkinter.PhotoImage(file='./images/img1.png')  # replace this call...\n    tkinter.PhotoImage(data=img1)                   # with this one\n\nDepending on your use case, you may have to experiment with method of unpacking the data for use.\n\n====================\nLock it Down\n====================\n\nTo reduce the chances of messing this up later, you may wish to add this funcitonality to your workflow so that it is automatically completed as you are developing and distributing your package.  Simply include `dir_to_py_file` in your `setup.py` script for `my_package` just before the call to `setup()`.::\n\n    from setuptools import setup\n    from stringify import dir_to_py_file\n\n    dir_to_py_file(source_path='images', destination_file='my_package/images.py')\n\n    setup(\n        name='my_package',\n        version=__version__,\n        setup_requires=['stringify']\n        ...\n\nAs shown, you may also wish to add `stringify` to your `setup_requires`, but you will get an error on import if `stringify` isn't installed, so it won't mess up your packaging to skip this line.\n\n=============================\nRun your PyInstaller Script\n=============================\n\nNow that your files are simply bundled into your application, there should be nothing 'special' about your package.\n\nSimply `pyinstaller my_package/package_file_0.py` (assuming that is where your entry point is), and you are ready to rock!\n\n=======================\nDrink\n=======================\n\nNow that you aren't spending all of your time trying to write customer pyinstaller scripts for your project, then you can celebrate by having a drink.  Enjoy!\n\n\n",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "https://github.com/slightlynybbled/stringify",
    "keywords": "string base64 binary",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "stringify",
    "platform": "",
    "project_url": "https://pypi.org/project/stringify/",
    "release_url": "https://pypi.org/project/stringify/0.0.1/",
    "requires_dist": [],
    "requires_python": "",
    "summary": "Automatic string encoding of binary files into python variables",
    "version": "0.0.1"
  },
  "releases": {
    "0.0.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "00edd86a214170f7a5f83012d727da5a",
          "sha256": "f2486468d02a78d3829b8a418acc698fc697e5292703edc76c000c6ce94d82d4"
        },
        "downloads": -1,
        "filename": "stringify-0.0.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "00edd86a214170f7a5f83012d727da5a",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "size": 7761,
        "upload_time": "2017-10-24T00:52:48",
        "url": "https://files.pythonhosted.org/packages/b2/6c/67198a753563a9683ef0852a2f65ebd7e7a9be2ecda7f3722aa4002204a5/stringify-0.0.1-py3-none-any.whl"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "00edd86a214170f7a5f83012d727da5a",
        "sha256": "f2486468d02a78d3829b8a418acc698fc697e5292703edc76c000c6ce94d82d4"
      },
      "downloads": -1,
      "filename": "stringify-0.0.1-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "00edd86a214170f7a5f83012d727da5a",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "size": 7761,
      "upload_time": "2017-10-24T00:52:48",
      "url": "https://files.pythonhosted.org/packages/b2/6c/67198a753563a9683ef0852a2f65ebd7e7a9be2ecda7f3722aa4002204a5/stringify-0.0.1-py3-none-any.whl"
    }
  ]
}