{
  "info": {
    "author": "TitanSnow",
    "author_email": "tttnns1024@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 3 - Alpha",
      "Intended Audience :: Developers",
      "Intended Audience :: Information Technology",
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Other Scripting Engines",
      "Programming Language :: Python :: 2",
      "Programming Language :: Python :: 2.7",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.3",
      "Programming Language :: Python :: 3.4",
      "Programming Language :: Python :: 3.5",
      "Programming Language :: Python :: 3.6",
      "Topic :: Software Development"
    ],
    "description": "ffilupa\n=======\n\ncffi_ implement of lupa_ with lowlevel lua API\n\n.. _cffi: https://bitbucket.org/cffi/cffi\n.. _lupa: https://github.com/scoder/lupa\n\nMajor features\n--------------\n\n* complete lupa compatibility and features\n\n* much more easier to hack on, extend and *monkey patch* as it is written in Python using cffi, not Cython or C\n\n* expose all lua C APIs and lua state object, easy to do lowlevel operations\n\n  .. code:: python\n\n    >>> from ffilupa import LuaRuntime, lua\n    >>> lua_runtime = LuaRuntime()\n    >>> # get lua state\n    >>> L = lua_runtime.lua_state\n    >>> code = b'return \"Hello\" .. \"World!\"'\n    >>> # loadbuffer\n    >>> status = lua.lib.luaL_loadbuffer(L, code, len(code), b'<python>')\n    >>> status == lua.lib.LUA_OK\n    True\n    >>> def insert_traceback():\n    ...     \"\"\"insert ``debug.traceback`` to the bottom of stack\"\"\"\n    ...     lua.lib.lua_getglobal(L, b'debug')\n    ...     lua.lib.lua_pushstring(L, b'traceback')\n    ...     lua.lib.lua_gettable(L, -2)\n    ...     lua.lib.lua_insert(L, 1)\n    ...     lua.lib.lua_pop(L, 1)\n    >>> insert_traceback()\n    >>> # protected call\n    >>> status = lua.lib.lua_pcall(L, 0, lua.lib.LUA_MULTRET, 1)\n    >>> status == lua.lib.LUA_OK\n    True\n    >>> # get return value\n    >>> lua.ffi.string(lua.lib.lua_tostring(L, -1))\n    b'HelloWorld!'\n\n\nLupa\n====\n\nLupa integrates the runtimes of Lua_ or LuaJIT2_ into CPython.\nIt is a partial rewrite of LunaticPython_ in Cython_ with some\nadditional features such as proper coroutine support.\n\n.. _Lua: http://lua.org/\n.. _LuaJIT2: http://luajit.org/\n.. _LunaticPython: http://labix.org/lunatic-python\n.. _Cython: http://cython.org\n\nFor questions not answered here, please contact the `Lupa mailing list`_.\n\n.. _`Lupa mailing list`: http://www.freelists.org/list/lupa-dev\n\n.. contents:: :local:\n\n\nMajor features\n--------------\n\n* separate Lua runtime states through a ``LuaRuntime`` class\n\n* Python coroutine wrapper for Lua coroutines\n\n* iteration support for Python objects in Lua and Lua objects in\n  Python\n\n* proper encoding and decoding of strings (configurable per runtime,\n  UTF-8 by default)\n\n* frees the GIL and supports threading in separate runtimes when\n  calling into Lua\n\n* tested with Python 2.6/3.2 and later\n\n* written for LuaJIT2 (tested with LuaJIT 2.0.2), but also works\n  with the normal Lua interpreter (5.1 and 5.2)\n\n* easy to hack on and extend as it is written in Cython, not C\n\n\nWhy the name?\n-------------\n\nIn Latin, \"lupa\" is a female wolf, as elegant and wild as it sounds.\nIf you don't like this kind of straight forward allegory to an\nendangered species, you may also happily assume it's just an\namalgamation of the phonetic sounds that start the words \"Lua\" and\n\"Python\", two from each to keep the balance.\n\n\nWhy use it?\n-----------\n\nIt complements Python very well.  Lua is a language as dynamic as\nPython, but LuaJIT compiles it to very fast machine code, sometimes\nfaster than many statically compiled languages for computational code.\nThe language runtime is very small and carefully designed for\nembedding.  The complete binary module of Lupa, including a statically\nlinked LuaJIT2 runtime, only weighs some 700KB on a 64 bit machine.\nWith standard Lua 5.1, it's less than 400KB.\n\nHowever, the Lua ecosystem lacks many of the batteries that Python\nreadily includes, either directly in its standard library or as third\nparty packages. This makes real-world Lua applications harder to write\nthan equivalent Python applications. Lua is therefore not commonly\nused as primary language for large applications, but it makes for a\nfast, high-level and resource-friendly backup language inside of\nPython when raw speed is required and the edit-compile-run cycle of\nbinary extension modules is too heavy and too static for agile\ndevelopment or hot-deployment.\n\nLupa is a very fast and thin wrapper around Lua or LuaJIT.  It makes it\neasy to write dynamic Lua code that accompanies dynamic Python code by\nswitching between the two languages at runtime, based on the tradeoff\nbetween simplicity and speed.\n\n\nExamples\n--------\n\n..\n      ## doctest helpers:\n      >>> try: _ = sorted\n      ... except NameError:\n      ...     def sorted(seq):\n      ...         l = list(seq)\n      ...         l.sort()\n      ...         return l\n\n.. code:: python\n\n      >>> import lupa\n      >>> from lupa import LuaRuntime\n      >>> lua = LuaRuntime(unpack_returned_tuples=True)\n\n      >>> lua.eval('1+1')\n      2\n\n      >>> lua_func = lua.eval('function(f, n) return f(n) end')\n\n      >>> def py_add1(n): return n+1\n      >>> lua_func(py_add1, 2)\n      3\n\n      >>> lua.eval('python.eval(\" 2 ** 2 \")') == 4\n      True\n      >>> lua.eval('python.builtins.str(4)') == '4'\n      True\n\nThe function ``lua_type(obj)`` can be used to find out the type of a\nwrapped Lua object in Python code, as provided by Lua's ``type()``\nfunction:\n\n.. code:: python\n\n      >>> lupa.lua_type(lua_func)\n      'function'\n      >>> lupa.lua_type(lua.eval('{}'))\n      'table'\n\nTo help in distinguishing between wrapped Lua objects and normal\nPython objects, it returns ``None`` for the latter:\n\n.. code:: python\n\n      >>> lupa.lua_type(123) is None\n      True\n      >>> lupa.lua_type('abc') is None\n      True\n      >>> lupa.lua_type({}) is None\n      True\n\nNote the flag ``unpack_returned_tuples=True`` that is passed to create\nthe Lua runtime.  It is new in Lupa 0.21 and changes the behaviour of\ntuples that get returned by Python functions.  With this flag, they\nexplode into separate Lua values:\n\n.. code:: python\n\n      >>> lua.execute('a,b,c = python.eval(\"(1,2)\")')\n      >>> g = lua.globals()\n      >>> g.a\n      1\n      >>> g.b\n      2\n      >>> g.c is None\n      True\n\nWhen set to False, functions that return a tuple pass it through to the\nLua code:\n\n.. code:: python\n\n      >>> non_explode_lua = lupa.LuaRuntime(unpack_returned_tuples=False)\n      >>> non_explode_lua.execute('a,b,c = python.eval(\"(1,2)\")')\n      >>> g = non_explode_lua.globals()\n      >>> g.a\n      (1, 2)\n      >>> g.b is None\n      True\n      >>> g.c is None\n      True\n\nSince the default behaviour (to not explode tuples) might change in a\nlater version of Lupa, it is best to always pass this flag explicitly.\n\n\nPython objects in Lua\n---------------------\n\nPython objects are either converted when passed into Lua (e.g.\nnumbers and strings) or passed as wrapped object references.\n\n.. code:: python\n\n      >>> wrapped_type = lua.globals().type     # Lua's own type() function\n      >>> wrapped_type(1) == 'number'\n      True\n      >>> wrapped_type('abc') == 'string'\n      True\n\nWrapped Lua objects get unwrapped when they are passed back into Lua,\nand arbitrary Python objects get wrapped in different ways:\n\n.. code:: python\n\n      >>> wrapped_type(wrapped_type) == 'function'  # unwrapped Lua function\n      True\n      >>> wrapped_type(len) == 'userdata'       # wrapped Python function\n      True\n      >>> wrapped_type([]) == 'userdata'        # wrapped Python object\n      True\n\nLua supports two main protocols on objects: calling and indexing.  It\ndoes not distinguish between attribute access and item access like\nPython does, so the Lua operations ``obj[x]`` and ``obj.x`` both map\nto indexing.  To decide which Python protocol to use for Lua wrapped\nobjects, Lupa employs a simple heuristic.\n\nPratically all Python objects allow attribute access, so if the object\nalso has a ``__getitem__`` method, it is preferred when turning it\ninto an indexable Lua object.  Otherwise, it becomes a simple object\nthat uses attribute access for indexing from inside Lua.\n\nObviously, this heuristic will fail to provide the required behaviour\nin many cases, e.g. when attribute access is required to an object\nthat happens to support item access.  To be explicit about the\nprotocol that should be used, Lupa provides the helper functions\n``as_attrgetter()`` and ``as_itemgetter()`` that restrict the view on\nan object to a certain protocol, both from Python and from inside\nLua:\n\n.. code:: python\n\n      >>> lua_func = lua.eval('function(obj) return obj[\"get\"] end')\n      >>> d = {'get' : 'value'}\n\n      >>> value = lua_func(d)\n      >>> value == d['get'] == 'value'\n      True\n\n      >>> value = lua_func( lupa.as_itemgetter(d) )\n      >>> value == d['get'] == 'value'\n      True\n\n      >>> dict_get = lua_func( lupa.as_attrgetter(d) )\n      >>> dict_get == d.get\n      True\n      >>> dict_get('get') == d.get('get') == 'value'\n      True\n\n      >>> lua_func = lua.eval(\n      ...     'function(obj) return python.as_attrgetter(obj)[\"get\"] end')\n      >>> dict_get = lua_func(d)\n      >>> dict_get('get') == d.get('get') == 'value'\n      True\n\nNote that unlike Lua function objects, callable Python objects support\nindexing in Lua:\n\n.. code:: python\n\n      >>> def py_func(): pass\n      >>> py_func.ATTR = 2\n\n      >>> lua_func = lua.eval('function(obj) return obj.ATTR end')\n      >>> lua_func(py_func)\n      2\n      >>> lua_func = lua.eval(\n      ...     'function(obj) return python.as_attrgetter(obj).ATTR end')\n      >>> lua_func(py_func)\n      2\n      >>> lua_func = lua.eval(\n      ...     'function(obj) return python.as_attrgetter(obj)[\"ATTR\"] end')\n      >>> lua_func(py_func)\n      2\n\n\nIteration in Lua\n----------------\n\nIteration over Python objects from Lua's for-loop is fully supported.\nHowever, Python iterables need to be converted using one of the\nutility functions which are described here.  This is similar to the\nfunctions like ``pairs()`` in Lua.\n\nTo iterate over a plain Python iterable, use the ``python.iter()``\nfunction.  For example, you can manually copy a Python list into a Lua\ntable like this:\n\n.. code:: python\n\n      >>> lua_copy = lua.eval('''\n      ...     function(L)\n      ...         local t, i = {}, 1\n      ...         for item in python.iter(L) do\n      ...             t[i] = item\n      ...             i = i + 1\n      ...         end\n      ...         return t\n      ...     end\n      ... ''')\n\n      >>> table = lua_copy([1,2,3,4])\n      >>> len(table)\n      4\n      >>> table[1]   # Lua indexing\n      1\n\nPython's ``enumerate()`` function is also supported, so the above\ncould be simplified to:\n\n.. code:: python\n\n      >>> lua_copy = lua.eval('''\n      ...     function(L)\n      ...         local t = {}\n      ...         for index, item in python.enumerate(L) do\n      ...             t[ index+1 ] = item\n      ...         end\n      ...         return t\n      ...     end\n      ... ''')\n\n      >>> table = lua_copy([1,2,3,4])\n      >>> len(table)\n      4\n      >>> table[1]   # Lua indexing\n      1\n\nFor iterators that return tuples, such as ``dict.iteritems()``, it is\nconvenient to use the special ``python.iterex()`` function that\nautomatically explodes the tuple items into separate Lua arguments:\n\n.. code:: python\n\n      >>> lua_copy = lua.eval('''\n      ...     function(d)\n      ...         local t = {}\n      ...         for key, value in python.iterex(d.items()) do\n      ...             t[key] = value\n      ...         end\n      ...         return t\n      ...     end\n      ... ''')\n\n      >>> d = dict(a=1, b=2, c=3)\n      >>> table = lua_copy( lupa.as_attrgetter(d) )\n      >>> table['b']\n      2\n\nNote that accessing the ``d.items`` method from Lua requires passing\nthe dict as ``attrgetter``.  Otherwise, attribute access in Lua would\nuse the ``getitem`` protocol of Python dicts and look up ``d['items']``\ninstead.\n\n\nNone vs. nil\n------------\n\nWhile ``None`` in Python and ``nil`` in Lua differ in their semantics, they\nusually just mean the same thing: no value.  Lupa therefore tries to map one\ndirectly to the other whenever possible:\n\n.. code:: python\n\n      >>> lua.eval('nil') is None\n      True\n      >>> is_nil = lua.eval('function(x) return x == nil end')\n      >>> is_nil(None)\n      True\n\nThe only place where this cannot work is during iteration, because Lua\nconsiders a ``nil`` value the termination marker of iterators.  Therefore,\nLupa special cases ``None`` values here and replaces them by a constant\n``python.none`` instead of returning ``nil``:\n\n.. code:: python\n\n      >>> _ = lua.require(\"table\")\n      >>> func = lua.eval('''\n      ...     function(items)\n      ...         local t = {}\n      ...         for value in python.iter(items) do\n      ...             table.insert(t, value == python.none)\n      ...         end\n      ...         return t\n      ...     end\n      ... ''')\n\n      >>> items = [1, None ,2]\n      >>> list(func(items).values())\n      [False, True, False]\n\nLupa avoids this value escaping whenever it's obviously not necessary.\nThus, when unpacking tuples during iteration, only the first value will\nbe subject to ``python.none`` replacement, as Lua does not look at the\nother items for loop termination anymore.  And on ``enumerate()``\niteration, the first value is known to be always a number and never None,\nso no replacement is needed.\n\n.. code:: python\n\n      >>> func = lua.eval('''\n      ...     function(items)\n      ...         for a, b, c, d in python.iterex(items) do\n      ...             return {a == python.none, a == nil,   -->  a == python.none\n      ...                     b == python.none, b == nil,   -->  b == nil\n      ...                     c == python.none, c == nil,   -->  c == nil\n      ...                     d == python.none, d == nil}   -->  d == nil ...\n      ...         end\n      ...     end\n      ... ''')\n\n      >>> items = [(None, None, None, None)]\n      >>> list(func(items).values())\n      [True, False, False, True, False, True, False, True]\n\n      >>> items = [(None, None)]   # note: no values for c/d => nil in Lua\n      >>> list(func(items).values())\n      [True, False, False, True, False, True, False, True]\n\n\nNote that this behaviour changed in Lupa 1.0.  Previously, the ``python.none``\nreplacement was done in more places, which made it not always very predictable.\n\n\nLua Tables\n----------\n\nLua tables mimic Python's mapping protocol.  For the special case of\narray tables, Lua automatically inserts integer indices as keys into\nthe table.  Therefore, indexing starts from 1 as in Lua instead of 0\nas in Python.  For the same reason, negative indexing does not work.\nIt is best to think of Lua tables as mappings rather than arrays, even\nfor plain array tables.\n\n.. code:: python\n\n      >>> table = lua.eval('{10,20,30,40}')\n      >>> table[1]\n      10\n      >>> table[4]\n      40\n      >>> list(table)\n      [1, 2, 3, 4]\n      >>> list(table.values())\n      [10, 20, 30, 40]\n      >>> len(table)\n      4\n\n      >>> mapping = lua.eval('{ [1] = -1 }')\n      >>> list(mapping)\n      [1]\n\n      >>> mapping = lua.eval('{ [20] = -20; [3] = -3 }')\n      >>> mapping[20]\n      -20\n      >>> mapping[3]\n      -3\n      >>> sorted(mapping.values())\n      [-20, -3]\n      >>> sorted(mapping.items())\n      [(3, -3), (20, -20)]\n\n      >>> mapping[-3] = 3     # -3 used as key, not index!\n      >>> mapping[-3]\n      3\n      >>> sorted(mapping)\n      [-3, 3, 20]\n      >>> sorted(mapping.items())\n      [(-3, 3), (3, -3), (20, -20)]\n\nTo simplify the table creation from Python, the ``LuaRuntime`` comes with\na helper method that creates a Lua table from Python arguments:\n\n.. code:: python\n\n      >>> t = lua.table(1, 2, 3, 4)\n      >>> lupa.lua_type(t)\n      'table'\n      >>> list(t)\n      [1, 2, 3, 4]\n\n      >>> t = lua.table(1, 2, 3, 4, a=1, b=2)\n      >>> t[3]\n      3\n      >>> t['b']\n      2\n\nA second helper method, ``.table_from()``, is new in Lupa 1.1 and accepts\nany number of mappings and sequences/iterables as arguments.  It collects\nall values and key-value pairs and builds a single Lua table from them.\nAny keys that appear in multiple mappings get overwritten with their last\nvalue (going from left to right).\n\n.. code:: python\n\n      >>> t = lua.table_from([1, 2, 3], {'a': 1, 'b': 2}, (4, 5), {'b': 42})\n      >>> t['b']\n      42\n      >>> t[5]\n      5\n\nA lookup of non-existing keys or indices returns None (actually ``nil``\ninside of Lua).  A lookup is therefore more similar to the ``.get()``\nmethod of Python dicts than to a mapping lookup in Python.\n\n.. code:: python\n\n      >>> table[1000000] is None\n      True\n      >>> table['no such key'] is None\n      True\n      >>> mapping['no such key'] is None\n      True\n\nNote that ``len()`` does the right thing for array tables but does not\nwork on mappings:\n\n.. code:: python\n\n      >>> len(table)\n      4\n      >>> len(mapping)\n      0\n\nThis is because ``len()`` is based on the ``#`` (length) operator in\nLua and because of the way Lua defines the length of a table.\nRemember that unset table indices always return ``nil``, including\nindices outside of the table size.  Thus, Lua basically looks for an\nindex that returns ``nil`` and returns the index before that.  This\nworks well for array tables that do not contain ``nil`` values, gives\nbarely predictable results for tables with 'holes' and does not work\nat all for mapping tables.  For tables with both sequential and\nmapping content, this ignores the mapping part completely.\n\nNote that it is best not to rely on the behaviour of len() for\nmappings.  It might change in a later version of Lupa.\n\nSimilar to the table interface provided by Lua, Lupa also supports\nattribute access to table members:\n\n.. code:: python\n\n      >>> table = lua.eval('{ a=1, b=2 }')\n      >>> table.a, table.b\n      (1, 2)\n      >>> table.a == table['a']\n      True\n\nThis enables access to Lua 'methods' that are associated with a table,\nas used by the standard library modules:\n\n.. code:: python\n\n      >>> string = lua.eval('string')    # get the 'string' library table\n      >>> print( string.lower('A') )\n      a\n\n\nPython Callables\n----------------\n\nAs discussed earlier, Lupa allows Lua scripts to call Python functions\nand methods:\n\n.. code:: python\n\n      >>> def add_one(num):\n      ...     return num + 1\n      >>> lua_func = lua.eval('function(num, py_func) return py_func(num) end')\n      >>> lua_func(48, add_one)\n      49\n\n      >>> class MyClass():\n      ...     def my_method(self):\n      ...         return 345\n      >>> obj = MyClass()\n      >>> lua_func = lua.eval('function(py_obj) return py_obj:my_method() end')\n      >>> lua_func(obj)\n      345\n\nLua doesn't have a dedicated syntax for named arguments, so by default\nPython callables can only be called using positional arguments.\n\nA common pattern for implementing named arguments in Lua is passing them\nin a table as the first and only function argument.  See\nhttp://lua-users.org/wiki/NamedParameters for more details.  Lupa supports\nthis pattern by providing two decorators: ``lupa.unpacks_lua_table``\nfor Python functions and ``lupa.unpacks_lua_table_method`` for methods\nof Python objects.\n\nPython functions/methods wrapped in these decorators can be called from\nLua code as ``func(foo, bar)``, ``func{foo=foo, bar=bar}``\nor ``func{foo, bar=bar}``.  Example:\n\n.. code:: python\n\n      >>> @lupa.unpacks_lua_table\n      ... def add(a, b):\n      ...     return a + b\n      >>> lua_func = lua.eval('function(a, b, py_func) return py_func{a=a, b=b} end')\n      >>> lua_func(5, 6, add)\n      11\n      >>> lua_func = lua.eval('function(a, b, py_func) return py_func{a, b=b} end')\n      >>> lua_func(5, 6, add)\n      11\n\nIf you do not control the function implementation, you can also just\nmanually wrap a callable object when passing it into Lupa:\n\n.. code:: python\n\n      >>> import operator\n      >>> wrapped_py_add = lupa.unpacks_lua_table(operator.add)\n\n      >>> lua_func = lua.eval('function(a, b, py_func) return py_func{a, b} end')\n      >>> lua_func(5, 6, wrapped_py_add)\n      11\n\nThere are some limitations:\n\n1. Avoid using ``lupa.unpacks_lua_table`` and ``lupa.unpacks_lua_table_method``\n   for functions where the first argument can be a Lua table.  In this case\n   ``py_func{foo=bar}`` (which is the same as ``py_func({foo=bar})`` in Lua)\n   becomes ambiguous: it could mean either \"call ``py_func`` with a named\n   ``foo`` argument\" or \"call ``py_func`` with a positional ``{foo=bar}``\n   argument\".\n\n2. One should be careful with passing ``nil`` values to callables wrapped in\n   ``lupa.unpacks_lua_table`` or ``lupa.unpacks_lua_table_method`` decorators.\n   Depending on the context, passing ``nil`` as a parameter can mean either\n   \"omit a parameter\" or \"pass None\".  This even depends on the Lua version.\n\n   It is possible to use ``python.none`` instead of ``nil`` to pass None values\n   robustly.  Arguments with ``nil`` values are also fine when standard braces\n   ``func(a, b, c)`` syntax is used.\n\nBecause of these limitations lupa doesn't enable named arguments for all\nPython callables automatically.  Decorators allow to enable named arguments\non a per-callable basis.\n\n\nLua Coroutines\n--------------\n\nThe next is an example of Lua coroutines.  A wrapped Lua coroutine\nbehaves exactly like a Python coroutine.  It needs to get created at\nthe beginning, either by using the ``.coroutine()`` method of a\nfunction or by creating it in Lua code.  Then, values can be sent into\nit using the ``.send()`` method or it can be iterated over.  Note that\nthe ``.throw()`` method is not supported, though.\n\n.. code:: python\n\n      >>> lua_code = '''\\\n      ...     function(N)\n      ...         for i=0,N do\n      ...             coroutine.yield( i%2 )\n      ...         end\n      ...     end\n      ... '''\n      >>> lua = LuaRuntime()\n      >>> f = lua.eval(lua_code)\n\n      >>> gen = f.coroutine(4)\n      >>> list(enumerate(gen))\n      [(0, 0), (1, 1), (2, 0), (3, 1), (4, 0)]\n\nAn example where values are passed into the coroutine using its\n``.send()`` method:\n\n.. code:: python\n\n      >>> lua_code = '''\\\n      ...     function()\n      ...         local t,i = {},0\n      ...         local value = coroutine.yield()\n      ...         while value do\n      ...             t[i] = value\n      ...             i = i + 1\n      ...             value = coroutine.yield()\n      ...         end\n      ...         return t\n      ...     end\n      ... '''\n      >>> f = lua.eval(lua_code)\n\n      >>> co = f.coroutine()   # create coroutine\n      >>> co.send(None)        # start coroutine (stops at first yield)\n\n      >>> for i in range(3):\n      ...     co.send(i*2)\n\n      >>> mapping = co.send(None)   # loop termination signal\n      >>> sorted(mapping.items())\n      [(0, 0), (1, 2), (2, 4)]\n\nIt also works to create coroutines in Lua and to pass them back into\nPython space:\n\n.. code:: python\n\n      >>> lua_code = '''\\\n      ...   function f(N)\n      ...         for i=0,N do\n      ...             coroutine.yield( i%2 )\n      ...         end\n      ...   end ;\n      ...   co1 = coroutine.create(f) ;\n      ...   co2 = coroutine.create(f) ;\n      ...\n      ...   status, first_result = coroutine.resume(co2, 2) ;   -- starting!\n      ...\n      ...   return f, co1, co2, status, first_result\n      ... '''\n\n      >>> lua = LuaRuntime()\n      >>> f, co, lua_gen, status, first_result = lua.execute(lua_code)\n\n      >>> # a running coroutine:\n\n      >>> status\n      True\n      >>> first_result\n      0\n      >>> list(lua_gen)\n      [1, 0]\n      >>> list(lua_gen)\n      []\n\n      >>> # an uninitialised coroutine:\n\n      >>> gen = co(4)\n      >>> list(enumerate(gen))\n      [(0, 0), (1, 1), (2, 0), (3, 1), (4, 0)]\n\n      >>> gen = co(2)\n      >>> list(enumerate(gen))\n      [(0, 0), (1, 1), (2, 0)]\n\n      >>> # a plain function:\n\n      >>> gen = f.coroutine(4)\n      >>> list(enumerate(gen))\n      [(0, 0), (1, 1), (2, 0), (3, 1), (4, 0)]\n\n\nThreading\n---------\n\nThe following example calculates a mandelbrot image in parallel\nthreads and displays the result in PIL. It is based on a `benchmark\nimplementation`_ for the `Computer Language Benchmarks Game`_.\n\n.. _`Computer Language Benchmarks Game`: http://shootout.alioth.debian.org/u64/benchmark.php?test=all&lang=luajit&lang2=python3\n.. _`benchmark implementation`: http://shootout.alioth.debian.org/u64/program.php?test=mandelbrot&lang=luajit&id=1\n\n.. code:: python\n\n    lua_code = '''\\\n        function(N, i, total)\n            local char, unpack = string.char, unpack\n            local result = \"\"\n            local M, ba, bb, buf = 2/N, 2^(N%8+1)-1, 2^(8-N%8), {}\n            local start_line, end_line = N/total * (i-1), N/total * i - 1\n            for y=start_line,end_line do\n                local Ci, b, p = y*M-1, 1, 0\n                for x=0,N-1 do\n                    local Cr = x*M-1.5\n                    local Zr, Zi, Zrq, Ziq = Cr, Ci, Cr*Cr, Ci*Ci\n                    b = b + b\n                    for i=1,49 do\n                        Zi = Zr*Zi*2 + Ci\n                        Zr = Zrq-Ziq + Cr\n                        Ziq = Zi*Zi\n                        Zrq = Zr*Zr\n                        if Zrq+Ziq > 4.0 then b = b + 1; break; end\n                    end\n                    if b >= 256 then p = p + 1; buf[p] = 511 - b; b = 1; end\n                end\n                if b ~= 1 then p = p + 1; buf[p] = (ba-b)*bb; end\n                result = result .. char(unpack(buf, 1, p))\n            end\n            return result\n        end\n    '''\n\n    image_size = 1280   # == 1280 x 1280\n    thread_count = 8\n\n    from lupa import LuaRuntime\n    lua_funcs = [ LuaRuntime(encoding=None).eval(lua_code)\n                  for _ in range(thread_count) ]\n\n    results = [None] * thread_count\n    def mandelbrot(i, lua_func):\n        results[i] = lua_func(image_size, i+1, thread_count)\n\n    import threading\n    threads = [ threading.Thread(target=mandelbrot, args=(i,lua_func))\n                for i, lua_func in enumerate(lua_funcs) ]\n    for thread in threads:\n        thread.start()\n    for thread in threads:\n        thread.join()\n\n    result_buffer = b''.join(results)\n\n    # use PIL to display the image\n    import Image\n    image = Image.fromstring('1', (image_size, image_size), result_buffer)\n    image.show()\n\nNote how the example creates a separate ``LuaRuntime`` for each thread\nto enable parallel execution.  Each ``LuaRuntime`` is protected by a\nglobal lock that prevents concurrent access to it.  The low memory\nfootprint of Lua makes it reasonable to use multiple runtimes, but\nthis setup also means that values cannot easily be exchanged between\nthreads inside of Lua.  They must either get copied through Python\nspace (passing table references will not work, either) or use some Lua\nmechanism for explicit communication, such as a pipe or some kind of\nshared memory setup.\n\n\nRestricting Lua access to Python objects\n----------------------------------------\n\n..\n        >>> try: unicode = unicode\n        ... except NameError: unicode = str\n\nLupa provides a simple mechanism to control access to Python objects.\nEach attribute access can be passed through a filter function as\nfollows:\n\n.. code:: python\n\n        >>> def filter_attribute_access(obj, attr_name, is_setting):\n        ...     if isinstance(attr_name, unicode):\n        ...         if not attr_name.startswith('_'):\n        ...             return attr_name\n        ...     raise AttributeError('access denied')\n\n        >>> lua = lupa.LuaRuntime(\n        ...           register_eval=False,\n        ...           attribute_filter=filter_attribute_access)\n        >>> func = lua.eval('function(x) return x.__class__ end')\n        >>> func(lua)\n        Traceback (most recent call last):\n         ...\n        AttributeError: access denied\n\nThe ``is_setting`` flag indicates whether the attribute is being read\nor set.\n\nNote that the attributes of Python functions provide access to the\ncurrent ``globals()`` and therefore to the builtins etc.  If you want\nto safely restrict access to a known set of Python objects, it is best\nto work with a whitelist of safe attribute names.  One way to do that\ncould be to use a well selected list of dedicated API objects that you\nprovide to Lua code, and to only allow Python attribute access to the\nset of public attribute/method names of these objects.\n\nSince Lupa 1.0, you can alternatively provide dedicated getter and\nsetter function implementations for a ``LuaRuntime``:\n\n.. code:: python\n\n        >>> def getter(obj, attr_name):\n        ...     if attr_name == 'yes':\n        ...         return getattr(obj, attr_name)\n        ...     raise AttributeError(\n        ...         'not allowed to read attribute \"%s\"' % attr_name)\n\n        >>> def setter(obj, attr_name, value):\n        ...     if attr_name == 'put':\n        ...         setattr(obj, attr_name, value)\n        ...         return\n        ...     raise AttributeError(\n        ...         'not allowed to write attribute \"%s\"' % attr_name)\n\n        >>> class X(object):\n        ...     yes = 123\n        ...     put = 'abc'\n        ...     noway = 2.1\n\n        >>> x = X()\n\n        >>> lua = lupa.LuaRuntime(attribute_handlers=(getter, setter))\n        >>> func = lua.eval('function(x) return x.yes end')\n        >>> func(x)  # getting 'yes'\n        123\n        >>> func = lua.eval('function(x) x.put = \"ABC\"; end')\n        >>> func(x)  # setting 'put'\n        >>> print(x.put)\n        ABC\n        >>> func = lua.eval('function(x) x.noway = 42; end')\n        >>> func(x)  # setting 'noway'\n        Traceback (most recent call last):\n         ...\n        AttributeError: not allowed to write attribute \"noway\"\n\n\nImporting Lua binary modules\n----------------------------\n\n**This will usually work as is**, but here are the details, in case\nanything goes wrong for you.\n\nTo use binary modules in Lua, you need to compile them against the\nheader files of the LuaJIT sources that you used to build Lupa, but do\nnot link them against the LuaJIT library.\n\nFurthermore, CPython needs to enable global symbol visibility for\nshared libraries before loading the Lupa module.  This can be done by\ncalling ``sys.setdlopenflags(flag_values)``.  Importing the ``lupa``\nmodule will automatically try to set up the correct ``dlopen`` flags\nif it can find the platform specific ``DLFCN`` Python module that\ndefines the necessary flag constants.  In that case, using binary\nmodules in Lua should work out of the box.\n\nIf this setup fails, however, you have to set the flags manually.\nWhen using the above configuration call, the argument ``flag_values``\nmust represent the sum of your system's values for ``RTLD_NEW`` and\n``RTLD_GLOBAL``.  If ``RTLD_NEW`` is 2 and ``RTLD_GLOBAL`` is 256, you\nneed to call ``sys.setdlopenflags(258)``.\n\nAssuming that the Lua luaposix_ (``posix``) module is available, the\nfollowing should work on a Linux system:\n\n.. code:: python\n\n      >>> import sys\n      >>> orig_dlflags = sys.getdlopenflags()\n      >>> sys.setdlopenflags(258)\n      >>> import lupa\n      >>> sys.setdlopenflags(orig_dlflags)\n\n      >>> lua = lupa.LuaRuntime()\n      >>> posix_module = lua.require('posix')     # doctest: +SKIP\n\n.. _luaposix: http://git.alpinelinux.org/cgit/luaposix",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "https://github.com/TitanSnow/lupa/tree/ffi",
    "keywords": "",
    "license": "MIT style",
    "maintainer": "",
    "maintainer_email": "",
    "name": "ffilupa",
    "platform": "",
    "project_url": "https://pypi.org/project/ffilupa/",
    "release_url": "https://pypi.org/project/ffilupa/1.0.0a2/",
    "requires_dist": [],
    "requires_python": "",
    "summary": "cffi implement of lupa with lowlevel lua API",
    "version": "1.0.0a2"
  },
  "releases": {
    "1.0.0a1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "3dd960d7e2f0c3f372ad789bd1219835",
          "sha256": "70a8d8c7b80ed128327eca23df72035ab4c3583129777ffd5cf1363e1554220a"
        },
        "downloads": 0,
        "filename": "ffilupa-1.0.0a1.zip",
        "has_sig": false,
        "md5_digest": "3dd960d7e2f0c3f372ad789bd1219835",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 286680,
        "upload_time": "2017-08-18T06:51:28",
        "url": "https://files.pythonhosted.org/packages/24/df/1edad54f0a5aff2ef63c13df20faccb9489e9191105b996847e6e89c1d5c/ffilupa-1.0.0a1.zip"
      }
    ],
    "1.0.0a2": [
      {
        "comment_text": "",
        "digests": {
          "md5": "b3a394560eaced407111deff748186b8",
          "sha256": "411fb2645b11407f25d7b8e36db6efc212a5ff70fa563153f6815e613fdf4833"
        },
        "downloads": 0,
        "filename": "ffilupa-1.0.0a2.zip",
        "has_sig": false,
        "md5_digest": "b3a394560eaced407111deff748186b8",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 286756,
        "upload_time": "2017-08-19T06:55:39",
        "url": "https://files.pythonhosted.org/packages/d0/62/4730d7b39caf650de9a5aa353c1ba35684d98430a666abef288bbb9012cd/ffilupa-1.0.0a2.zip"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "b3a394560eaced407111deff748186b8",
        "sha256": "411fb2645b11407f25d7b8e36db6efc212a5ff70fa563153f6815e613fdf4833"
      },
      "downloads": 0,
      "filename": "ffilupa-1.0.0a2.zip",
      "has_sig": false,
      "md5_digest": "b3a394560eaced407111deff748186b8",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 286756,
      "upload_time": "2017-08-19T06:55:39",
      "url": "https://files.pythonhosted.org/packages/d0/62/4730d7b39caf650de9a5aa353c1ba35684d98430a666abef288bbb9012cd/ffilupa-1.0.0a2.zip"
    }
  ]
}