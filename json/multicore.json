{
  "info": {
    "author": "Praekelt Consulting",
    "author_email": "dev@praekelt.com",
    "bugtrack_url": null,
    "classifiers": [
      "Intended Audience :: Developers",
      "License :: OSI Approved :: BSD License",
      "Operating System :: OS Independent",
      "Programming Language :: Python",
      "Topic :: Internet :: WWW/HTTP :: Dynamic Content"
    ],
    "description": "Python Multicore\n================\n**A module that makes it easy to parallelize Python code.**\n\n.. figure:: https://travis-ci.org/praekelt/multicore.svg?branch=develop\n   :align: center\n   :alt: Travis\n\n.. contents:: Contents\n    :depth: 5\n\nInstallation\n------------\n\n#. Install or add ``dill`` and ``multicore`` to your Python path.\n\nOverview\n--------\n\nPython supports multi-threading but the global interpreter lock (GIL) prevents\nus from utilising all CPU cores for CPU heavy tasks. The recommended approach\nis to use Python's multiprocessing module to work around the GIL, but that has its own set of challenges, notably\nthe ability to share data between sub-processes is limited.\n\nThe goal of the multicore module is to make it as simple as possible to parallelize code\nwhile incurring the least amount of overhead.\n\nFeatures\n--------\n\n#. Persistent pool of workers enabling persistent database connections.\n#. Can take system load average into account to decide whether parallelization\n   is worth it at any given time.\n\nArchitecture\n------------\n\nPython Multicore is effectively an in-memory queue that is processed by a fixed\nset of workers. It uses memory mapping to avoid the latency imposed by using a\nqueing system such as celery. Even pipes are too slow for us!\n\nUsage\n-----\n\nLet's render 100 users. Always break a large task into smaller tasks, but not\ntoo small! If the ranges are too small then tasks aren't worth the effort\nbecause the overhead becomes too much.::\n\n    import time\n\n    from multicore import Task\n    from multicore.utils import ranges\n\n\n    def expensive_render(user):\n        time.sleep(0.01)\n        return user.username\n\n\n    def multi_expensive_render(start, end):\n        s = \"\"\n        for user in User.objects.all()[start:end]:\n            s += expensive_render(user)\n        return s\n\n\n    users = User.objects.all()[:100]\n    task = Task()\n    if task:\n        for start, end in ranges(users):\n            # Note we don't pass \"users\" to run because it can't be pickled\n            task.run(multi_expensive_render, start, end)\n        print \", \".join(task.get())\n    else:\n        print \", \".join([expensive_render(u) for u in users])\n\nThe ``Task`` constructor accepts an optional parameter ``max_load_average``. If\nthe load average for the last minute is larger than a defined threshold then\n``None`` is returned and your code must cater for the sequential code path.\nNote that the threshold is specified as for a single core machine, so typically\nless than one.\n\nThe ``run`` method accepts an optional parameter ``serialization_format`` with value\n``pickle`` (the default), ``json`` or ``string``. Pickle is slow and safe. If you\nknow what type of data you have (you should!) set this as appropriate.\n\nThe ``run`` method also accepts an optional parameter ``use_dill`` with default\nvalue ``False``. Dill is a library that can often pickle things that can't be\npickled by the standard pickler but it is slightly slower.\n\nFAQ's\n-----\n\nWill it try to execute hundreds of pieces of code in parallel?\n**************************************************************\n\nNo. The worker pool has a fixed size and can only execute number-of-cores\ntasks in parallel. You may also set `max_load_average` as a further guard.\n\nWhy didn't you use multiprocessing.Pool?\n****************************************\n\nIt just has too many issues with eg. Django when it comes to scoping. Even pipes\nand sockets introduce too much overhead, so memory mapping is used.\n\nDo you have any benchmarks?\n***************************\n\nNo, because this is just an interface, not a collection of parallel code.\n\nIn general the code scales nearly linearly if you don't access the database.\nMulticore itself adds about 5 milliseconds overhead on my machine.\n\nThe memory map is too small for my data structures\n**************************************************\n\nA future version will address this through dynamic memory map scaling.\n\nAuthors\n=======\n\nPraekelt Consulting\n-------------------\n* Hedley Roos\n\nChangelog\n=========\n\n0.1\n---\n#. Initial release.\n\n",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "http://github.com/praekelt/multicore",
    "keywords": "",
    "license": "BSD",
    "maintainer": "",
    "maintainer_email": "",
    "name": "multicore",
    "platform": "",
    "project_url": "https://pypi.org/project/multicore/",
    "release_url": "https://pypi.org/project/multicore/0.1/",
    "requires_dist": [],
    "requires_python": "",
    "summary": "A library that makes it easy to parallelize Python code.",
    "version": "0.1"
  },
  "releases": {
    "0.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "16374c34d0c43b1ffa544c9bd412359c",
          "sha256": "776cc0fa4c1ae44e75e29de8c8fc0227f5170c3f560fac00cc978ac89c0466fa"
        },
        "downloads": 0,
        "filename": "multicore-0.1-py2.7.egg",
        "has_sig": false,
        "md5_digest": "16374c34d0c43b1ffa544c9bd412359c",
        "packagetype": "bdist_egg",
        "python_version": "2.7",
        "size": 15466,
        "upload_time": "2017-08-07T15:29:58",
        "url": "https://files.pythonhosted.org/packages/e0/ec/2c58a5b993d7a798879f8748bf87cdcbeb61a4b098673224968d95bb9c9b/multicore-0.1-py2.7.egg"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "b0cdc0169e79d19c5f7df544d9474119",
          "sha256": "aa52d6ae79ea9e9ac21aae02c095b26edd2fa30d1a4a1991923f9f0b46dd4f8e"
        },
        "downloads": 0,
        "filename": "multicore-0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "b0cdc0169e79d19c5f7df544d9474119",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 22590,
        "upload_time": "2017-08-07T15:29:55",
        "url": "https://files.pythonhosted.org/packages/3b/51/ad00107b9b32d58019701d3e082b12152d4ae77407d32f63e2fab140176d/multicore-0.1.tar.gz"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "16374c34d0c43b1ffa544c9bd412359c",
        "sha256": "776cc0fa4c1ae44e75e29de8c8fc0227f5170c3f560fac00cc978ac89c0466fa"
      },
      "downloads": 0,
      "filename": "multicore-0.1-py2.7.egg",
      "has_sig": false,
      "md5_digest": "16374c34d0c43b1ffa544c9bd412359c",
      "packagetype": "bdist_egg",
      "python_version": "2.7",
      "size": 15466,
      "upload_time": "2017-08-07T15:29:58",
      "url": "https://files.pythonhosted.org/packages/e0/ec/2c58a5b993d7a798879f8748bf87cdcbeb61a4b098673224968d95bb9c9b/multicore-0.1-py2.7.egg"
    },
    {
      "comment_text": "",
      "digests": {
        "md5": "b0cdc0169e79d19c5f7df544d9474119",
        "sha256": "aa52d6ae79ea9e9ac21aae02c095b26edd2fa30d1a4a1991923f9f0b46dd4f8e"
      },
      "downloads": 0,
      "filename": "multicore-0.1.tar.gz",
      "has_sig": false,
      "md5_digest": "b0cdc0169e79d19c5f7df544d9474119",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 22590,
      "upload_time": "2017-08-07T15:29:55",
      "url": "https://files.pythonhosted.org/packages/3b/51/ad00107b9b32d58019701d3e082b12152d4ae77407d32f63e2fab140176d/multicore-0.1.tar.gz"
    }
  ]
}