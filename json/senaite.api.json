{
  "info": {
    "author": "SENAITE Foundation",
    "author_email": "hello@senaite.com",
    "bugtrack_url": null,
    "classifiers": [
      "Framework :: Plone",
      "Framework :: Zope2",
      "Programming Language :: Python"
    ],
    "description": "SENAITE API\n===========\n\nThe API provides a unified interface for developers to work with the SENAITE\nframework.\n\n\nSENAITE API DOCTEST\n===================\n\nThe SENAITE LIMS API provides single functions for single purposes.\nThis Test builds completely on the API without any further imports needed.\n\nRunning this test from the buildout directory::\n\n    bin/test test_doctests -t API\n\nIntroduction\n------------\n\nThe purpose of this API is to help coders to follow the DRY principle (Don't\nRepeat Yourself). It also ensures that the most effective and efficient method is\nused to achieve a task.\n\nImport it first::\n\n    >>> from senaite import api\n\n\nGetting the Portal\n------------------\n\nThe Portal is the SENAITE LIMS root object::\n\n    >>> portal = api.get_portal()\n    >>> portal\n    <PloneSite at /plone>\n\n\nGetting the Bika Setup object\n-----------------------------\n\nThe Bika Setup object gives access to all of the Bika configuration settings::\n\n    >>> bika_setup = api.get_bika_setup()\n    >>> bika_setup\n    <BikaSetup at /plone/bika_setup>\n\n\nCreating new Content\n--------------------\n\nCreating new contents in Bika LIMS requires some special knowledge.\nThis function helps to do it right and creates a content for you.\n\nHere we create a new `Client` in the `plone/clients` folder::\n\n    >>> client = api.create(portal.clients, \"Client\", title=\"Test Client\")\n    >>> client\n    <Client at /plone/clients/client-1>\n\n     >>> client.Title()\n     'Test Client'\n\n\nGetting a Tool\n--------------\n\nThere are many ways to get a tool in Bika LIMS / Plone. This function\ncentralizes this functionality and makes it painless::\n\n    >>> api.get_tool(\"bika_setup_catalog\")\n    <BikaSetupCatalog at /plone/bika_setup_catalog>\n\nTrying to fetch an non-existing tool raises a custom `SenaiteAPIError`.\n\n    >>> api.get_tool(\"NotExistingTool\")\n    Traceback (most recent call last):\n    [...]\n    SenaiteAPIError: No tool named 'NotExistingTool' found.\n\nThis error can also be used for custom methods with the `fail` function::\n\n    >>> api.fail(\"This failed badly\")\n    Traceback (most recent call last):\n    [...]\n    SenaiteAPIError: This failed badly\n\n\nGetting an Object\n-----------------\n\nGetting a tool from a catalog brain is a common task in Bika LIMS. This function\nprovides an unified interface to portal objects **and** brains.\nFurthermore it is idempotent, so it can be called multiple times in a row.\n\nWe will demonstrate the usage on the client object we created above::\n\n    >>> api.get_object(client)\n    <Client at /plone/clients/client-1>\n\n    >>> api.get_object(api.get_object(client))\n    <Client at /plone/clients/client-1>\n\nNow we show it with catalog results::\n\n    >>> portal_catalog = api.get_tool(\"portal_catalog\")\n    >>> brains = portal_catalog(portal_type=\"Client\")\n    >>> brains\n    [<Products.ZCatalog.Catalog.mybrains object at 0x...>]\n\n    >>> brain = brains[0]\n\n    >>> api.get_object(brain)\n    <Client at /plone/clients/client-1>\n\n    >>> api.get_object(api.get_object(brain))\n    <Client at /plone/clients/client-1>\n\nNo supported objects raise an error::\n\n    >>> api.get_object(object())\n    Traceback (most recent call last):\n    [...]\n    SenaiteAPIError: <object object at 0x...> is not supported.\n\nTo check if an object is supported, e.g. is an ATCT, Dexterity, ZCatalog or\nPortal object, we can use the `is_object` function::\n\n    >>> api.is_object(client)\n    True\n\n    >>> api.is_object(brain)\n    True\n\n    >>> api.is_object(api.get_portal())\n    True\n\n    >>> api.is_object(None)\n    False\n\n  >>> api.is_object(object())\n    False\n\n\nChecking if an Object is the Portal\n-----------------------------------\n\nSometimes it can be handy to check if the current object is the portal::\n\n    >>> api.is_portal(portal)\n    True\n\n    >>> api.is_portal(client)\n    False\n\n    >>> api.is_portal(object())\n    False\n\n\nChecking if an Object is a Catalog Brain\n----------------------------------------\n\nKnowing if we have an object or a brain can be handy. This function checks this for you::\n\n    >>> api.is_brain(brain)\n    True\n\n    >>> api.is_brain(api.get_object(brain))\n    False\n\n    >>> api.is_brain(object())\n    False\n\n\nChecking if an Object is a Dexterity Content\n--------------------------------------------\n\nThis function checks if an object is a `Dexterity` content type::\n\n    >>> api.is_dexterity_content(client)\n    False\n\n    >>> api.is_dexterity_content(portal)\n    False\n\nWe currently have no `Dexterity` contents, so testing this comes later...\n\n\nChecking if an Object is an AT Content\n--------------------------------------\n\nThis function checks if an object is an `Archetypes` content type::\n\n    >>> api.is_at_content(client)\n    True\n\n    >>> api.is_at_content(portal)\n    False\n\n    >>> api.is_at_content(object())\n    False\n\n\nGetting the Schema of a Content\n-------------------------------\n\nThe schema contains the fields of a content object. Getting the schema is a\ncommon task, but differs between `ATContentType` based objects and `Dexterity`\nbased objects. This function brings it under one umbrella::\n\n    >>> schema = api.get_schema(client)\n    >>> schema\n    <Products.Archetypes.Schema.Schema object at 0x...>\n\nCatalog brains are also supported::\n\n    >>> api.get_schema(brain)\n    <Products.Archetypes.Schema.Schema object at 0x...>\n\n\nGetting the Fields of a Content\n-------------------------------\n\nThe fields contain all the values that an object holds and are therefore\nresponsible for getting and setting the information.\n\nThis function returns the fields as a dictionary mapping of `{\"key\": value}`::\n\n    >>> fields = api.get_fields(client)\n    >>> fields.get(\"ClientID\")\n    <Field ClientID(string:rw)>\n\nCatalog brains are also supported::\n\n    >>> api.get_fields(brain).get(\"ClientID\")\n    <Field ClientID(string:rw)>\n\n\nGetting the ID of a Content\n---------------------------\n\nGetting the ID is a common task in Bika LIMS.\nThis function takes care that catalog brains are not waked up for this task::\n\n    >>> api.get_id(portal)\n    'plone'\n\n    >>> api.get_id(client)\n    'client-1'\n\n    >>> api.get_id(brain)\n    'client-1'\n\n\nGetting the Title of a Content\n------------------------------\n\nGetting the Title is a common task in Bika LIMS.\nThis function takes care that catalog brains are not waked up for this task::\n\n    >>> api.get_title(portal)\n    u'Plone site'\n\n    >>> api.get_title(client)\n    'Test Client'\n\n    >>> api.get_title(brain)\n    'Test Client'\n\n\nGetting the Description of a Content\n------------------------------------\n\nGetting the Description is a common task in Bika LIMS.\nThis function takes care that catalog brains are not waked up for this task::\n\n    >>> api.get_description(portal)\n    ''\n\n    >>> api.get_description(client)\n    ''\n\n    >>> api.get_description(brain)\n    ''\n\n\nGetting the UID of a Content\n----------------------------\n\nGetting the UID is a common task in Bika LIMS.\nThis function takes care that catalog brains are not waked up for this task.\n\nThe portal object actually has no UID. This funciton defines it therfore to be `0`::\n\n    >>> api.get_uid(portal)\n    '0'\n\n    >>> uid_client = api.get_uid(client)\n    >>> uid_client_brain = api.get_uid(brain)\n    >>> uid_client is uid_client_brain\n    True\n\n\nGetting the URL of a Content\n----------------------------\n\nGetting the URL is a common task in Bika LIMS.\nThis function takes care that catalog brains are not waked up for this task::\n\n    >>> api.get_url(portal)\n    'http://nohost/plone'\n\n    >>> api.get_url(client)\n    'http://nohost/plone/clients/client-1'\n\n    >>> api.get_url(brain)\n    'http://nohost/plone/clients/client-1'\n\n\nGetting the Icon of a Content\n-----------------------------\n\n    >>> api.get_icon(client)\n    '<img width=\"16\" height=\"16\" src=\"http://nohost/plone/++resource++bika.lims.images/client.png\" title=\"Test Client\" />'\n\n    >>> api.get_icon(brain)\n    '<img width=\"16\" height=\"16\" src=\"http://nohost/plone/++resource++bika.lims.images/client.png\" title=\"Test Client\" />'\n\n    >>> api.get_icon(client, html_tag=False)\n    'http://nohost/plone/++resource++bika.lims.images/client.png'\n\n    >>> api.get_icon(client, html_tag=False)\n    'http://nohost/plone/++resource++bika.lims.images/client.png'\n\n\nGetting an object by UID\n------------------------\n\nThis function finds an object by its uinique ID (UID).\nThe portal object with the defined UId of '0' is also supported::\n\n    >>> api.get_object_by_uid('0')\n    <PloneSite at /plone>\n\n    >>> api.get_object_by_uid(uid_client)\n    <Client at /plone/clients/client-1>\n\n    >>> api.get_object_by_uid(uid_client_brain)\n    <Client at /plone/clients/client-1>\n\nIf a default value is provided, the function will never fail.  Any exception\nor error will result in the default value being returned::\n\n    >>> api.get_object_by_uid('invalid uid', 'default')\n    'default'\n\n    >>> api.get_object_by_uid(None, 'default')\n    'default'\n\n\nGetting an object by Path\n-------------------------\n\nThis function finds an object by its physical path::\n\n    >>> api.get_object_by_path('/plone')\n    <PloneSite at /plone>\n\n    >>> api.get_object_by_path('/plone/clients/client-1')\n    <Client at /plone/clients/client-1>\n\nPaths outside the portal raise an error::\n\n    >>> api.get_object_by_path('/root')\n    Traceback (most recent call last):\n    [...]\n    SenaiteAPIError: Not a physical path inside the portal.\n\nAny exception returns default value::\n\n    >>> api.get_object_by_path('/invaid/path', 'default')\n    'default'\n\n    >>> api.get_object_by_path(None, 'default')\n    'default'\n\n\nGetting the Physical Path of an Object\n--------------------------------------\n\nThe physical path describes exactly where an object is located inside the portal.\nThis function unifies the different approaches to get the physical path and does\nso in the most efficient way::\n\n    >>> api.get_path(portal)\n    '/plone'\n\n    >>> api.get_path(client)\n    '/plone/clients/client-1'\n\n    >>> api.get_path(brain)\n    '/plone/clients/client-1'\n\n    >>> api.get_path(object())\n    Traceback (most recent call last):\n    [...]\n    SenaiteAPIError: <object object at 0x...> is not supported.\n\n\nGetting the Physical Parent Path of an Object\n---------------------------------------------\n\nThis function returns the physical path of the parent object::\n\n    >>> api.get_parent_path(client)\n    '/plone/clients'\n\n    >>> api.get_parent_path(brain)\n    '/plone/clients'\n\nHowever, this function goes only up to the portal object::\n\n    >>> api.get_parent_path(portal)\n    '/plone'\n\nLike with the other functions, only portal objects are supported::\n\n    >>> api.get_parent_path(object())\n    Traceback (most recent call last):\n    [...]\n    SenaiteAPIError: <object object at 0x...> is not supported.\n\n\nGetting the Parent Object\n-------------------------\n\nThis function returns the parent object::\n\n    >>> api.get_parent(client)\n    <ClientFolder at /plone/clients>\n\nBrains are also supported::\n\n    >>> api.get_parent(brain)\n    <ClientFolder at /plone/clients>\n\nThe function can also use a catalog query on the `portal_catalog` and return a\nbrain, if the passed parameter `catalog_search` was set to true. ::\n\n    >>> api.get_parent(client, catalog_search=True)\n    <Products.ZCatalog.Catalog.mybrains object at 0x...>\n\n    >>> api.get_parent(brain, catalog_search=True)\n    <Products.ZCatalog.Catalog.mybrains object at 0x...>\n\nHowever, this function goes only up to the portal object::\n\n    >>> api.get_parent(portal)\n    <PloneSite at /plone>\n\nLike with the other functions, only portal objects are supported::\n\n    >>> api.get_parent(object())\n    Traceback (most recent call last):\n    [...]\n    SenaiteAPIError: <object object at 0x...> is not supported.\n\n\nSearching Objects\n-----------------\n\nSearching in Bika LIMS requires knowledge in which catalog the object is indexed.\nThis function unifies all Bika LIMS catalog to a single search interface::\n\n    >>> results = api.search({'portal_type': 'Client'})\n    >>> results\n    [<Products.ZCatalog.Catalog.mybrains object at 0x...>]\n\nMultiple content types are also supported::\n\n    >>> results = api.search({'portal_type': ['Client', 'ClientFolder'], 'sort_on': 'getId'})\n    >>> map(api.get_id, results)\n    ['client-1', 'clients']\n\nNow we create some objects which are located in the `bika_setup_catalog`::\n\n    >>> instruments = bika_setup.bika_instruments\n    >>> instrument1 = api.create(instruments, \"Instrument\", title=\"Instrument-1\")\n    >>> instrument2 = api.create(instruments, \"Instrument\", title=\"Instrument-2\")\n    >>> instrument3 = api.create(instruments, \"Instrument\", title=\"Instrument-3\")\n\n    >>> results = api.search({'portal_type': 'Instrument', 'sort_on': 'getId'})\n    >>> len(results)\n    3\n\n    >>> map(api.get_id, results)\n    ['instrument-1', 'instrument-2', 'instrument-3']\n\nQueries which result in multiple catalogs will be refused, as it would require\nmanual merging and sorting of the results afterwards. Thus, we fail here:\n\n    >>> results = api.search({'portal_type': ['Client', 'ClientFolder', 'Instrument'], 'sort_on': 'getId'})\n    Traceback (most recent call last):\n    [...]\n    SenaiteAPIError: Multi Catalog Queries are not supported, please specify a catalog.\n\nCatalog queries w/o any `portal_type`, default to the `portal_catalog`, which\nwill not find the following items::\n\n    >>> analysiscategories = bika_setup.bika_analysiscategories\n    >>> analysiscategory1 = api.create(analysiscategories, \"AnalysisCategory\", title=\"AC-1\")\n    >>> analysiscategory2 = api.create(analysiscategories, \"AnalysisCategory\", title=\"AC-2\")\n    >>> analysiscategory3 = api.create(analysiscategories, \"AnalysisCategory\", title=\"AC-3\")\n\n    >>> results = api.search({\"id\": \"analysiscategory-1\"})\n    >>> len(results)\n    0\n\nWould we add the `portal_type`, the search function would ask the\n`archetype_tool` for the right catalog, and it would return a result::\n\n    >>> results = api.search({\"portal_type\": \"AnalysisCategory\", \"id\": \"analysiscategory-1\"})\n    >>> len(results)\n    1\n\nWe could also explicitly define a catalog to achieve the same::\n\n    >>> results = api.search({\"id\": \"analysiscategory-1\"}, catalog=\"bika_setup_catalog\")\n    >>> len(results)\n    1\n\nTo see inactive or dormant items, we must explicitly query them of filter them\nafterwars manually::\n\n    >>> results = api.search({\"portal_type\": \"AnalysisCategory\", \"id\": \"analysiscategory-1\"})\n    >>> len(results)\n    1\n\nNow we deactivate the item::\n\n    >>> analysiscategory1 = api.do_transition_for(analysiscategory1, 'deactivate')\n    >>> api.is_active(analysiscategory1)\n    False\n\nThe search will still find the item::\n\n    >>> results = api.search({\"portal_type\": \"AnalysisCategory\", \"id\": \"analysiscategory-1\"})\n    >>> len(results)\n    1\n\nUnless we filter it out manually::\n\n    >>> len(filter(api.is_active, results))\n    0\n\nOr provide a correct query::\n\n    >>> results = api.search({\"portal_type\": \"AnalysisCategory\", \"id\": \"analysiscategory-1\", \"inactive_status\": \"active\"})\n    >>> len(results)\n    1\n\n\nGetting the registered Catalogs\n-------------------------------\n\nBika LIMS uses multiple catalogs registered via the Archetype Tool. This\nfunction returns a list of registered catalogs for a brain or object::\n\n    >>> api.get_catalogs_for(client)\n    [<CatalogTool at /plone/portal_catalog>]\n\n    >>> api.get_catalogs_for(instrument1)\n    [<BikaSetupCatalog at /plone/bika_setup_catalog>, <CatalogTool at /plone/portal_catalog>]\n\n    >>> api.get_catalogs_for(analysiscategory1)\n    [<BikaSetupCatalog at /plone/bika_setup_catalog>]\n\n\nGetting an Attribute of an Object\n---------------------------------\n\nThis function handles attributes and methods the same and returns their value.\nIt also handles security and is able to return a default value instead of\nraising an `Unauthorized` error::\n\n    >>> uid_brain = api.safe_getattr(brain, \"UID\")\n    >>> uid_obj = api.safe_getattr(client, \"UID\")\n\n    >>> uid_brain == uid_obj\n    True\n\n    >>> api.safe_getattr(brain, \"review_state\")\n    'active'\n\n    >>> api.safe_getattr(brain, \"NONEXISTING\")\n    Traceback (most recent call last):\n    [...]\n    SenaiteAPIError: Attribute 'NONEXISTING' not found.\n\n    >>> api.safe_getattr(brain, \"NONEXISTING\", \"\")\n    ''\n\nGetting the Portal Catalog\n--------------------------\n\nThis tool is needed so often, that this function just returns it::\n\n    >>> api.get_portal_catalog()\n    <CatalogTool at /plone/portal_catalog>\n\n\nGetting the Review History of an Object\n---------------------------------------\n\nThe review history gives information about the objects' workflow changes::\n\n    >>> review_history = api.get_review_history(client)\n    >>> sorted(review_history[0].items())\n    [('action', None), ('actor', 'test_user_1_'), ('comments', ''), ('review_state', 'active'), ('time', DateTime('...'))]\n\n\nGetting the Revision History of an Object\n-----------------------------------------\n\nThe review history gives information about the objects' workflow changes::\n\n    >>> revision_history = api.get_revision_history(client)\n    >>> sorted(revision_history[0])\n    ['action', 'actor', 'actor_home', 'actorid', 'comments', 'review_state', 'state_title', 'time', 'transition_title', 'type']\n    >>> revision_history[0][\"transition_title\"]\n    u'Create'\n\n\nGetting the assigned Workflows of an Object\n-------------------------------------------\n\nThis function returns all assigned workflows for a given object::\n\n    >>> api.get_workflows_for(bika_setup)\n    ('bika_one_state_workflow',)\n\n    >>> api.get_workflows_for(client)\n    ('bika_client_workflow', 'bika_inactive_workflow')\n\nThis function also supports the portal_type as parameter::\n\n    >>> api.get_workflows_for(api.get_portal_type(client))\n    ('bika_client_workflow', 'bika_inactive_workflow')\n\n\nGetting the Workflow Status of an Object\n----------------------------------------\n\nThis function returns the state of a given object::\n\n    >>> api.get_workflow_status_of(client)\n    'active'\n\nIt is also capable to get the state of another state variable::\n\n    >>> api.get_workflow_status_of(client, \"inactive_state\")\n    'active'\n\nDeactivate the client::\n\n    >>> api.do_transition_for(client, \"deactivate\")\n    <Client at /plone/clients/client-1>\n\n    >>> api.get_workflow_status_of(client, \"inactive_state\")\n    'inactive'\n\n    >>> api.get_workflow_status_of(client)\n    'active'\n\nReactivate the client::\n\n    >>> api.do_transition_for(client, \"activate\")\n    <Client at /plone/clients/client-1>\n\n    >>> api.get_workflow_status_of(client, \"inactive_state\")\n    'active'\n\n\nGetting the registered Catalogs of an Object\n--------------------------------------------\n\nThis function returns a list of all registered catalogs within the\n`archetype_tool` for a given portal_type or object::\n\n    >>> api.get_catalogs_for(client)\n    [<CatalogTool at /plone/portal_catalog>]\n\nIt also supports the `portal_type` as a parameter::\n\n    >>> api.get_catalogs_for(\"Analysis\")\n    [<BikaAnalysisCatalog at /plone/bika_analysis_catalog>]\n\n\nTransitioning an Object\n-----------------------\n\nThis function performs a workflow transition and returns the object::\n\n    >>> client = api.do_transition_for(client, \"deactivate\")\n    >>> api.is_active(client)\n    False\n\n    >>> client = api.do_transition_for(client, \"activate\")\n    >>> api.is_active(client)\n    True\n\n\nGetting inactive/cancellation state of different workflows\n----------------------------------------------------------\n\nThere are two workflows allowing an object to be set inactive.  We provide\nthe is_active function to return False if an item is set inactive with either\nof these workflows.\n\nIn the search() test above, the is_active function's handling of brain states\nis tested.  Here, I just want to test if object states are handled correctly.\n\nFor setup types, we use bika_inctive_workflow::\n\n    >>> method1 = api.create(portal.methods, \"Method\", title=\"Test Method\")\n    >>> api.is_active(method1)\n    True\n    >>> method1 = api.do_transition_for(method1, 'deactivate')\n    >>> api.is_active(method1)\n    False\n\nFor transactional types, bika_cancellation_workflow is used::\n\n    >>> batch1 = api.create(portal.batches, \"Batch\", title=\"Test Batch\")\n    >>> api.is_active(batch1)\n    True\n    >>> batch1 = api.do_transition_for(batch1, 'cancel')\n    >>> api.is_active(batch1)\n    False\n\n\nGetting the granted Roles for a certain Permission on an Object\n---------------------------------------------------------------\n\nThis function returns a list of Roles, which are granted the given Permission\nfor the passed in object::\n\n    >>> api.get_roles_for_permission(\"Modify portal content\", bika_setup)\n    ['LabManager', 'Manager']\n\n\n\nChecking if an Object is Versionable\n------------------------------------\n\nSome contents in Bika LIMS support versioning. This function checks this for you.\n\nInstruments are not versionable::\n\n    >>> api.is_versionable(instrument1)\n    False\n\nAnalysisservices are versionable::\n\n    >>> analysisservices = bika_setup.bika_analysisservices\n    >>> analysisservice1 = api.create(analysisservices, \"AnalysisService\", title=\"AnalysisService-1\")\n    >>> analysisservice2 = api.create(analysisservices, \"AnalysisService\", title=\"AnalysisService-2\")\n    >>> analysisservice3 = api.create(analysisservices, \"AnalysisService\", title=\"AnalysisService-3\")\n\n    >>> api.is_versionable(analysisservice1)\n    True\n\n\nGetting the Version of an Object\n--------------------------------\n\nThis function returns the version as an integer::\n\n    >>> api.get_version(analysisservice1)\n    0\n\nCalling `processForm` bumps the version::\n\n    >>> analysisservice1.processForm()\n    >>> api.get_version(analysisservice1)\n    1\n\n\nGetting a Browser View\n----------------------\n\nGetting a browser view is a common task in Bika LIMS::\n\n    >>> api.get_view(\"plone\")\n    <Products.Five.metaclass.Plone object at 0x...>\n\n    >>> api.get_view(\"workflow_action\")\n    <Products.Five.metaclass.WorkflowAction object at 0x...>\n\n\nGetting the Request\n-------------------\n\nThis function will return the global request object::\n\n    >>> api.get_request()\n    <HTTPRequest, URL=http://nohost>\n\n\nGetting a Group\n---------------\n\nUsers in Bika LIMS are managed in groups. A common group is the `Clients` group,\nwhere all users of client contacts are grouped.\nThis function gives easy access and is also idempotent::\n\n    >>> clients_group = api.get_group(\"Clients\")\n    >>> clients_group\n    <GroupData at /plone/portal_groupdata/Clients used for /plone/acl_users/source_groups>\n\n    >>> api.get_group(clients_group)\n    <GroupData at /plone/portal_groupdata/Clients used for /plone/acl_users/source_groups>\n\nNon-existing groups are not found::\n\n    >>> api.get_group(\"NonExistingGroup\")\n\n\nGetting a User\n--------------\n\nUsers can be fetched by their user id. The function is idempotent and handles\nuser objects as well::\n\n    >>> from plone.app.testing import TEST_USER_ID\n    >>> user = api.get_user(TEST_USER_ID)\n    >>> user\n    <MemberData at /plone/portal_memberdata/test_user_1_ used for /plone/acl_users>\n\n    >>> api.get_user(api.get_user(TEST_USER_ID))\n    <MemberData at /plone/portal_memberdata/test_user_1_ used for /plone/acl_users>\n\nNon-existing users are not found::\n\n    >>> api.get_user(\"NonExistingUser\")\n\n\nGetting User Properties\n-----------------------\n\nUser properties, like the email or full name, are stored as user properties.\nThis means that they are not on the user object. This function retrieves these\nproperties for you::\n\n    >>> properties = api.get_user_properties(TEST_USER_ID)\n    >>> sorted(properties.items())\n    [('description', ''), ('email', ''), ('error_log_update', 0.0), ('ext_editor', False), ...]\n\n    >>> sorted(api.get_user_properties(user).items())\n    [('description', ''), ('email', ''), ('error_log_update', 0.0), ('ext_editor', False), ...]\n\nAn empty property dict is returned if no user could be found::\n\n    >>> api.get_user_properties(\"NonExistingUser\")\n    {}\n\n    >>> api.get_user_properties(None)\n    {}\n\n\nGetting Users by their Roles\n----------------------------\n\n    >>> from operator import methodcaller\n\nRoles in Bika LIMS are basically a name for one or more permissions. For\nexample, a `LabManager` describes a role which is granted the most permissions.\n\nTo see which users are granted a certain role, you can use this function::\n\n    >>> labmanagers = api.get_users_by_roles([\"LabManager\"])\n    >>> sorted(labmanagers, key=methodcaller('getId'))\n    [<PloneUser 'test_labmanager'>, <PloneUser 'test_labmanager1'>, <PloneUser 'test-user'>]\n\nA single value can also be passed into this function::\n\n    >>> sorted(api.get_users_by_roles(\"LabManager\"), key=methodcaller('getId'))\n    [<PloneUser 'test_labmanager'>, <PloneUser 'test_labmanager1'>, <PloneUser 'test-user'>]\n\n\nGetting the Current User\n------------------------\n\nGetting the current logged in user::\n\n    >>> api.get_current_user()\n    <MemberData at /plone/portal_memberdata/test_user_1_ used for /plone/acl_users>\n\n\nChangelog\n=========\n1.0.0 (2017-09-30)\n------------------\n\n- First release\n\n\nAuthors and maintainers\n=======================\n\n- Ramon Bartl (RIDING BYTES) <rb@ridingbytes.com>",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "https://github.com/senaite/senaite.api",
    "keywords": "",
    "license": "GPLv3",
    "maintainer": "",
    "maintainer_email": "",
    "name": "senaite.api",
    "platform": "",
    "project_url": "https://pypi.org/project/senaite.api/",
    "release_url": "https://pypi.org/project/senaite.api/1.0.1/",
    "requires_dist": [],
    "requires_python": "",
    "summary": "SENAITE API",
    "version": "1.0.1"
  },
  "releases": {
    "1.0.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "f5e7e6818623154c7b0b15a9a701b730",
          "sha256": "47665ac3ab08f49c20552ddbc13c7cc48122d3b40c3387a781b7a78da8ccd47b"
        },
        "downloads": 0,
        "filename": "senaite.api-1.0.1.zip",
        "has_sig": false,
        "md5_digest": "f5e7e6818623154c7b0b15a9a701b730",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 45635,
        "upload_time": "2017-09-30T17:50:58",
        "url": "https://files.pythonhosted.org/packages/bf/a5/20dca784a34d99aafb2cb2379c7fc45e262e71000fe296ab5838a1d89335/senaite.api-1.0.1.zip"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "f5e7e6818623154c7b0b15a9a701b730",
        "sha256": "47665ac3ab08f49c20552ddbc13c7cc48122d3b40c3387a781b7a78da8ccd47b"
      },
      "downloads": 0,
      "filename": "senaite.api-1.0.1.zip",
      "has_sig": false,
      "md5_digest": "f5e7e6818623154c7b0b15a9a701b730",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 45635,
      "upload_time": "2017-09-30T17:50:58",
      "url": "https://files.pythonhosted.org/packages/bf/a5/20dca784a34d99aafb2cb2379c7fc45e262e71000fe296ab5838a1d89335/senaite.api-1.0.1.zip"
    }
  ]
}