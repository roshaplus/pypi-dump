{
  "info": {
    "author": "The Laboratory for Computational Physiology",
    "author_email": "support@physionet.org",
    "bugtrack_url": null,
    "classifiers": [],
    "description": "wfdb-python\n===========\n\n|Build Status|\n\n.. figure:: https://raw.githubusercontent.com/MIT-LCP/wfdb-python/master/demoimg.png\n   :alt: wfdb signals\n\nIntroduction\n------------\n\nNative python scripts for reading and writing WFDB signals and annotations. Package to be expanded with other useful functionalities.\n\n\nInstallation\n------------\n\nThe distribution is hosted on pypi and directly installable via pip without needing clone or download this repository. Note that the pypi package does not contain the demo scripts or the example data. To install the package from pypi, run from your terminal:\n``pip install wfdb``\n\nDownload or clone this repository https://github.com/MIT-LCP/wfdb-python for the latest development version, the demo scripts, and the example data. To install the downloaded package, change directory into the base directory of the repository and run:\n``pip install .``\n\n\nUsage\n-----\n\nSee the **demo.ipynb** file for example cases.\n\nObjects\n~~~~~~~\n\nAs of version 1.0.0, wfdb records are stored in **Record** or **MultiRecord** objects, and annotations are stored in **Annotation** objects. To see all attributes of an object, call `object.__dict__`\n\n\n**Record** - The class representing WFDB headers, and single segment WFDB records.\n\nRecord objects can be created using the constructor, by reading a WFDB header\nwith 'rdheader', or a WFDB record (header and associated dat files) with rdsamp'\nor 'srdsamp'.\n\nThe attributes of the Record object give information about the record as specified\nby https://www.physionet.org/physiotools/wag/header-5.htm\n\nIn addition, the d_signals and p_signals attributes store the digital and physical\nsignals of WFDB records with at least one channel.\n\nContructor function:\n::\n\n    def __init__(self, p_signals=None, d_signals=None,\n                 recordname=None, nsig=None,\n                 fs=None, counterfreq=None, basecounter=None,\n                 siglen=None, basetime=None, basedate=None,\n                 filename=None, fmt=None, sampsperframe=None,\n                 skew=None, byteoffset=None, adcgain=None,\n                 baseline=None, units=None, adcres=None,\n                 adczero=None, initvalue=None, checksum=None,\n                 blocksize=None, signame=None, comments=None)\n\nExample Usage:\n::\n\n    import wfdb\n    record1 = wfdb.Record(recordname='r1', fs=250, nsig=2, siglen=1000, filename=['r1.dat','r1.dat'])\n\n\n**MultiRecord** - The class representing multi-segment WFDB records.\n\nMultiRecord objects can be created using the constructor, or by reading a multi-segment\nWFDB record using 'rdsamp' with the 'm2s' (multi to single) input parameter set to False.\n\nThe attributes of the MultiRecord object give information about the entire record as specified\nby https://www.physionet.org/physiotools/wag/header-5.htm\n\nIn addition, the 'segments' parameter is a list of Record objects representing each\nindividual segment, or 'None' representing empty segments, of the entire multi-segment record.\n\nNoteably, this class has no attribute representing the signals as a whole. The 'multi_to_single'\ninstance method can be called on MultiRecord objects to return a single segment representation\nof the record as a Record object. The resulting Record object will have its 'p_signals' field set.\n\nContructor function:\n::\n\n    def __init__(self, segments = None, layout = None,\n                 recordname=None, nsig=None, fs=None,\n                 counterfreq=None, basecounter=None,\n                 siglen=None, basetime=None, basedate=None,\n                 segname = None, seglen = None, comments=None)\n\nExample Usage:\n::\n\n    import wfdb\n    recordM = wfdb.MultiRecord(recordname='rm', fs=50, nsig=8, siglen=9999, segname=['rm_1', '~', rm_2'], seglen=[800, 200, 900])\n\n    recordL = wfdb.rdsamp('s00001-2896-10-10-00-31', m2s = False)\n    recordL = recordL.multi_to_single()\n\n\n**Annotation** - The class representing WFDB annotations.\n\nAnnotation objects can be created using the constructor, or by reading a WFDB annotation\nfile with 'rdann'.\n\nThe attributes of the Annotation object give information about the annotation as specified\nby https://www.physionet.org/physiotools/wag/annot-5.htm:\n\n- ``recordname``: The base file name (without extension) of the record that the annotation is attached to.\n- ``extension``: The file extension of the file the annotation is stored in.\n- ``sample``: The annotation locations in samples relative to the beginning of the record.\n- ``symbol``: The annotation type according the the standard WFDB codes.\n- ``subtype``: The marked class/category of each annotation.\n- ``chan``: The signal channel associated with each annotations.\n- ``num``: The labelled annotation number for each annotation.\n- ``aux_note``: The auxiliary information string for each annotation.\n- ``fs``: The sampling frequency of the record, if available.\n- ``label_store``: The integer value used to store/encode each annotation label\n- ``description``: The descriptive string of each annotation label\n- ``custom_labels``: The custom annotation labels defined in the annotation file.\n  Maps the relationship between the three label fields.\n  The data type is a pandas DataFrame with three columns: ['label_store', 'symbol', 'description']\n- ``contained_labels``: The unique labels contained in this annotation. Same structure\n  as custom_labels.\n\n\nConstructor function:\n::\n    def __init__(self, recordname, extension, sample, symbol=None, subtype=None,\n                 chan=None, num=None, aux_note=None, fs=None, label_store=None,\n                 description=None, custom_labels=None, contained_labels=None)\n\nCall `showanncodes()` to see the list of standard annotation codes. Any text used to label annotations that are not one of these codes should go in the 'aux_note' field rather than the 'symbol' field.\n\nExample usage:\n::\n\n    import wfdb\n    ann1 = wfdb.Annotation(recordname='ann1', annotator='atr', sample=[10,20,400],\n                           symbol = ['N','N','['], aux_note=[None, None, 'Serious Vfib'])\n\nReading Signals\n~~~~~~~~~~~~~~~\n\n\n**rdsamp** - Read a WFDB record and return the signal and record descriptors as attributes in a Record or MultiRecord object.\n\n::\n\n    record = rdsamp(recordname, sampfrom=0, sampto=None, channels=None, physical=True, pbdir = None, m2s=True)\n\nExample Usage:\n\n::\n\n    import wfdb\n    ecgrecord = wfdb.rdsamp('sampledata/test01_00s', sampfrom=800, channels = [1,3])\n\nInput Arguments:\n\n-  ``recordname`` (required): The name of the WFDB record to be read (without any file extensions).\n-  ``sampfrom`` (default=0): The starting sample number to read for each channel.\n-  ``sampto`` (default=length of entire signal)- The final sample number to read for each channel.\n-  ``channels`` (default=all channels): Indices specifying the channels to be returned.\n-  ``physical`` (default=True): Flag that specifies whether to return  signals in physical (True) or digital (False) units.\n-  ``pbdir`` (default=None): Option used to stream data from Physiobank. The Physiobank database directory from which to find the required record files. eg. For record '100' in 'http://physionet.org/physiobank/database/mitdb', pbdir = 'mitdb'.\n-  ``m2s`` (default=True): Flag used only for multi-segment records. Specifies whether to convert the returned wfdb.MultiRecord object into a wfdb.Record object (True) or not (False).\n-  ``smoothframes`` (default=True): Flag used when reading records with signals having multiple samples per frame. Specifies whether to smooth the samples in signals with more than one sample per frame and return an mxn uniform numpy array as the d_signals or p_signals field (True), or to return a list of 1d numpy arrays containing every expanded sample as the e_d_signals or e_p_signals field (False).\n-  ``ignoreskew`` (default=False): Flag used when reading records with at least one skewed signal. Specifies whether to apply the skew to align the signals in the output variable (False), or to ignore the skew field and load in all values contained in the dat files unaligned (True).\n-  ``returnres`` (default=64): The numpy array dtype of the returned signals. Options are: 64, 32, 16, and 8, where the value represents the numpy int or float dtype. Note that the value cannot be 8 when physical is True since there is no float8 format.\n\nOutput Arguments:\n\n-  ``record`` - The wfdb Record or MultiRecord object representing the contents of the record read.\n\n**srdsamp** - A simplified wrapper function around rdsamp. Read a WFDB record and return the physical signal and a few important descriptor fields.\n\n::\n\n    signals, fields = srdsamp(recordname, sampfrom=0, sampto=None, channels=None, pbdir=None)\n\nExample Usage:\n\n::\n\n    import wfdb\n    sig, fields = wfdb.srdsamp('sampledata/test01_00s', sampfrom=800, channels = [1,3])\n\nInput arguments:\n\n- ``recordname`` (required): The name of the WFDB record to be read (without any file extensions). If the argument contains any path delimiter characters, the argument will be interpreted as PATH/baserecord and the data files will be searched for in the local path.\n- ``sampfrom`` (default=0): The starting sample number to read for each channel.\n- ``sampto`` (default=None): The sample number at which to stop reading for each channel.\n- ``channels`` (default=all): Indices specifying the channel to be returned.\n\nOutput arguments:\n\n- ``signals``: A 2d numpy array storing the physical signals from the record.\n- ``fields``: A dictionary specifying several key attributes of the read record:\n- ``fs``: The sampling frequency of the record\n- ``units``: The units for each channel\n- ``signame``: The signal name for each channel\n- ``comments``: Any comments written in the header\n\n\nWriting Signals\n~~~~~~~~~~~~~~~\n\nThe Record class has a **wrsamp** instance method for writing wfdb record files. Create a valid Record object and call ``record.wrsamp()``. If you choose this more advanced method, see also the `setdefaults`, `set_d_features`, and `set_p_features` instance methods to help populate attributes. In addition, there is also the following simpler module level **wrsamp** function.\n\n\n**wrsamp** - Write a single segment WFDB record, creating a WFDB header file and any associated dat files.\n\n::\n\n    wrsamp(recordname, fs, units, signames, p_signals = None, d_signals=None, fmt = None, gain = None, baseline = None, comments = None)\n\nExample Usage:\n\n::\n\n    import wfdb\n    sig, fields = wfdb.srdsamp('a103l', sampfrom = 50000, channels = [0,1], pbdir = 'challenge/2015/training')\n    wfdb.wrsamp('ecgrecord', fs = 250, units = ['mV', 'mV'], signames = ['I', 'II'], p_signals = sig, fmt = ['16', '16'])\n\nInput Arguments:\n\n- ``recordname`` (required): The string name of the WFDB record to be written (without any file extensions).\n- ``fs`` (required): The numerical sampling frequency of the record.\n- ``units`` (required): A list of strings giving the units of each signal channel.\n- ``signames`` (required): A list of strings giving the signal name of each signal channel.\n- ``p_signals`` (default=None): An MxN 2d numpy array, where M is the signal length. Gives the physical signal\n  values intended to be written. Either p_signals or d_signals must be set, but not both. If p_signals\n  is set, this method will use it to perform analogue-digital conversion, writing the resultant digital\n  values to the dat file(s). If fmt is set, gain and baseline must be set or unset together. If fmt is\n  unset, gain and baseline must both be unset.\n- ``d_signals`` (default=None): An MxN 2d numpy array, where M is the signal length. Gives the digital signal\n  values intended to be directly written to the dat file(s). The dtype must be an integer type. Either\n  p_signals or d_signals must be set, but not both. In addition, if d_signals is set, fmt, gain and baseline\n  must also all be set.\n- ``fmt`` (default=None): A list of strings giving the WFDB format of each file used to store each channel.\n  Accepted formats are: \"80\",\"212\",\"16\",\"24\", and \"32\". There are other WFDB formats but this library\n  will not write (though it will read) those file types.\n- ``gain`` (default=None): A list of integers specifying the DAC/ADC gain.\n- ``baseline`` (default=None): A list of integers specifying the digital baseline.\n- ``comments`` (default-None): A list of string comments to be written to the header file.\n\n\nReading Annotations\n~~~~~~~~~~~~~~~~~~~\n\n**rdann** - Read a WFDB annotation file ``recordname.annot`` and return an Annotation object.\n\n::\n\n    annotation = rdann(recordname, extension, sampfrom=0, sampto=None, shiftsamps=False,\n                       pbdir=None, return_label_elements=['symbol'], summarize_labels=False)\n\nExample Usage:\n::\n\n    import wfdb\n    ann = wfdb.rdann('sampledata/100', 'atr', sampto = 300000)\n\nInput arguments:\n\n- ``recordname`` (required): The record name of the WFDB annotation file. ie. for file `100.atr`, recordname='100'\n- ``extension`` (required): The annotatator extension of the annotation file. ie. for \n  file '100.atr', extension='atr'\n- ``sampfrom`` (default=0): The minimum sample number for annotations to be returned.\n- ``sampto`` (default=None): The maximum sample number for annotations to be returned.\n- ``shiftsamps`` (default=False): Boolean flag that specifies whether to return the\n  sample indices relative to 'sampfrom' (True), or sample 0 (False). Annotation files\n  store exact sample locations.\n- ``pbdir`` (default=None): Option used to stream data from Physiobank. The Physiobank database \n  directory from which to find the required annotation file.\n  eg. For record '100' in 'http://physionet.org/physiobank/database/mitdb', pbdir = 'mitdb'.\n- ``return_label_elements`` (default=['symbol']): The label elements that are to be returned\n  from reading the annotation file. A list with at least one of the following: 'symbol',\n  'label_store', 'description'.\n- ``summarize_labels`` (default=False): Assign a summary table of the set of annotation labels\n  contained in the file to the 'contained_labels' attribute of the returned object.\n  This table will contain the columns: ['label_store', 'symbol', 'description', 'n_occurences']\n\nOutput arguments:\n\n- ``annotation``: The Annotation object. Contains the following attributes:\n    - ``recordname``: The base file name (without extension) of the record that the annotation is attached to.\n    - ``extension``: The file extension of the file the annotation is stored in.\n    - ``sample``: The annotation locations in samples relative to the beginning of the record.\n    - ``symbol``: The annotation type according the the standard WFDB codes.\n    - ``subtype``: The marked class/category of each annotation.\n    - ``chan``: The signal channel associated with each annotations.\n    - ``num``: The labelled annotation number for each annotation.\n    - ``aux_note``: The auxiliary information string for each annotation.\n    - ``fs``: The sampling frequency of the record, if available.\n    - ``label_store``: The integer value used to store/encode each annotation label\n    - ``description``: The descriptive string of each annotation label\n    - ``custom_labels``: The custom annotation labels defined in the annotation file.\n      Maps the relationship between the three label fields.\n      The data type is a pandas DataFrame with three columns: ['label_store', 'symbol', 'description']\n    - ``contained_labels``: The unique labels contained in this annotation. Same structure\n      as custom_labels.\n\n\\*\\ **NOTE**: In annotation files, every annotation contains the \u2018sample\u2019 and \u2018symbol\u2019 field. All other fields default to 0 or empty if not present.\n\n**show_ann_labels** -  Display the annotation symbols and the codes they represent according to the standard WFDB library 10.5.24\n\n::\n\n    show_ann_labels()\n\nWriting Annotations\n~~~~~~~~~~~~~~~~~~~\n\nThe Annotation class has a **wrann** instance method for writing wfdb annotation files. Create a valid Annotation object and call ``annotation.wrsamp()``. In addition, there is also the following simpler module level **wrann** function.\n\n**wrann** - Write a WFDB annotation file.\n\n::\n\n    wrann(recordname, extension, sample, symbol=None, subtype=None, chan=None, num=None, aux_note=None, label_store=None, fs=None, custom_labels=None)\n\nExample Usage:\n\n::\n\n    import wfdb\n    annotation = wfdb.rdann('b001', 'atr', pbdir='cebsdb')\n    wfdb.wrann('b001', 'cpy', annotation.sample, annotation.symbol)\n\nInput Arguments:\n\n- ``recordname`` (required): The string name of the WFDB record to be written (without any file extensions).\n- ``extension`` (required): The string annotation file extension.\n- ``sample`` (required): The annotation location in samples relative to the beginning of the record. Numpy array.\n- ``symbol`` (default=None): The symbols used to display the annotation labels. List or numpy array. If this field is present, 'label_store' must not be present.\n- ``subtype`` (default=None): The marked class/category of each annotation. Numpy array.\n- ``chan`` (default=None): The signal channel associated with each annotation. Numpy array.\n- ``num`` (default=None): The labelled annotation number of each annotation. Numpy array.\n- ``aux_note`` (default=None): The auxiliary information strings. List or numpy array.\n- ``label_store`` (default=None): The integer values used to store the annotation labels. Numpy array. If this field is present, 'symbol' must not be present.\n- ``fs`` (default=None): The numerical sampling frequency of the record to be written to the file.\n- ``custom_labels`` (default=None): The map of custom defined annotation labels used for this annotation, in addition to the standard WFDB annotation labels. The custom labels are defined by two or three fields:\n\n  - The integer values used to store custom annotation labels in the file (optional)\n  - Their short display symbols\n  - Their long descriptions.\n\n  This input argument may come in four formats:\n\n  1. A pandas.DataFrame object with columns: ['label_store', 'symbol', 'description']\n  2. A pandas.DataFrame object with columns: ['symbol', 'description']\n     If this option is chosen, label_store values are automatically chosen.\n  3. A list or tuple of tuple triplets, with triplet elements representing: (label_store, symbol, description).\n  4. A list or tuple of tuple pairs, with pair elements representing: (symbol, description).\n     If this option is chosen, label_store values are automatically chosen.\n  \n  If the 'label_store' field is given for this function, and 'custom_labels' is defined, 'custom_labels'\n  must contain 'label_store' in its mapping. ie. it must come in format 1 or 3 above.\n\n\\*\\ **NOTE**: Each annotation stored in a WFDB annotation file contains a sample and a label field. All other fields may or may not be present. Therefore in order to save space, when writing additional string features such as 'aux_note' that are not present for every annotation, it is recommended to make the field a list, with empty indices set to None so that they are not written to the file.\n\n\nPlotting Data\n~~~~~~~~~~~~~\n\n**plotrec** - Subplot and label each channel of a WFDB Record. Optionally, subplot annotation locations over selected channels.\n\n::\n\n    plotrec(record=None, title = None, annotation = None, timeunits='samples',\n            sigstyle='', figsize=None, returnfig = False, ecggrids=[]):\n\nExample Usage:\n\n::\n\n    import wfdb\n    record = wfdb.rdsamp('sampledata/100', sampto = 3000)\n    annotation = wfdb.rdann('sampledata/100', 'atr', sampto = 3000)\n\n    wfdb.plotrec(record, annotation = annotation, title='Record 100 from MIT-BIH Arrhythmia Database', timeunits = 'seconds', figsize = (10,4), ecggrids = 'all')\n\nInput Arguments:\n\n- ``record`` (required): A wfdb Record object. The p_signals attribute will be plotted.\n- ``title`` (default=None): A string containing the title of the graph.\n- ``annotation`` (default=None): A list of Annotation objects or numpy arrays. The locations of the Annotation objects' 'sample' attribute, or the locations of the numpy arrays' values, will be overlaid on the signals. The list index of the annotation item corresponds to the signal channel that each annotation set will be plotted on. For channels without annotations to plot, put None in the list. This argument may also be just an Annotation object or numpy array, which will be plotted over channel 0.\n- ``timeunits`` (default='samples'): String specifying the x axis unit. Allowed options are: 'samples', 'seconds', 'minutes', and 'hours'.\n- ``sigstyle`` (default=''): String, or list of strings, specifying the styling of the matplotlib plot for the signals. If 'sigstyle' is a string, each channel will have the same style. If it is a list, each channel's style will correspond to the list element. ie. sigtype=['r','b','k'].\n- ``annstyle`` (default='r*'): String, or list of strings, specifying the styling of the matplotlib plot for the annotations. If 'annstyle' is a string, each channel will have the same style. If it is a list, each channel's style will correspond to the list element.\n- ``figsize`` (default=None): Tuple pair specifying the width, and height of the figure. Same as the 'figsize' argument passed into matplotlib.pyplot's figure() function.\n- ``returnfig`` (default=False): Specifies whether the figure is to be returned as an output argument\n- ``ecggrids`` (default=[]): List of integers specifying channels in which to plot ecg grids. May be set to [] for no channels, or 'all' for all channels. Major grids at 0.5mV, and minor grids at 0.125mV. All channels to be plotted with grids must have units equal to 'uV', 'mV', or 'V'.\n\nOutput argument:\n- ``figure``: The matplotlib figure generated. Only returned if the 'returnfig' option is set to True.\n\n\n**plotann** - Plot sample locations of an Annotation object.\n\n::\n\n    plotann(annotation, title = None, timeunits = 'samples', returnfig = False)\n\nExample Usage:\n\n::\n\n    import wfdb\n    record = wfdb.rdsamp('sampledata/100', sampto = 15000)\n    annotation = wfdb.rdann('sampledata/100', 'atr', sampto = 15000)\n\n    wfdb.plotrec(record, annotation = annotation, title='Record 100 from MIT-BIH Arrhythmia Database', timeunits = 'seconds')\n\n\nInput Arguments:\n\n- ``annotation`` (required): An Annotation object. The sample attribute locations will be overlaid on the signal.\n- ``title`` (default=None): A string containing the title of the graph.\n- ``annotation`` (default=None): An Annotation object. The sample attribute locations will be overlaid on the signal.\n- ``timeunits`` (default='samples'): String specifying the x axis unit. Allowed options are: 'samples', 'seconds', 'minutes', and 'hours'.\n- ``returnfig`` (default=False): Specifies whether the figure is to be returned as an output argument\n\nOutput argument:\n- ``figure``: The matplotlib figure generated. Only returned if the 'returnfig' option is set to True.\n\nDownloading Physiobank Content\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nDownload files from various Physiobank databases. The Physiobank index page located at http://physionet.org/physiobank/database lists all available databases.\n\n\n**getdblist** - Return a list of all the physiobank databases available.\n\n::\n\n    dblist = wfdb.getdblist()\n\nExample Usage:\n\n::\n\n    import wfdb\n    dblist = wfdb.getdblist()\n\n**dldatabase** - Download WFDB record (and optionally annotation) files from a Physiobank database. The database must contain a 'RECORDS' file in its base directory which lists its WFDB records.\n\n::\n\n    dldatabase(pbdb, dlbasedir, records = 'all', annotators = 'all' , keepsubdirs = True, overwrite = False)\n\nExample Usage:\n\n::\n\n    import wfdb\n    wfdb.dldatabase('ahadb', os.getcwd())\n\nInput arguments:\n\n- ``pbdb`` (required): The Physiobank database directory to download. eg. For database 'http://physionet.org/physiobank/database/mitdb', pbdb = 'mitdb'.\n- ``dlbasedir`` (required): The full local directory path in which to download the files.\n- ``records`` (default='all'): Specifier of the WFDB records to download. Is either a list of strings which each specify a record, or 'all' to download all records listed in the database's RECORDS file. eg. records = ['test01_00s', test02_45s] for database https://physionet.org/physiobank/database/macecgdb/\n- ``annotators`` (default='all'): Specifier of the WFDB annotation file types to download along with the record files. Is either None to skip downloading any annotations, 'all' to download all annotation types as specified by the ANNOTATORS file, or a list of strings which each specify an annotation extension. eg. annotators = ['anI'] for database https://physionet.org/physiobank/database/prcp/\n- ``keepsubdirs`` (default=True): Whether to keep the relative subdirectories of downloaded files as they are organized in Physiobank (True), or to download all files into the same base directory (False).\n- ``overwrite`` (default=False): If set to True, all files will be redownloaded regardless. If set to False, existing files with the same name and relative subdirectory will be checked. If the local file is the same size as the online file, the download is skipped. If the local file is larger, it will be deleted and the file will be redownloaded. If the local file is smaller, the file will be assumed to be partially downloaded and the remaining bytes will be downloaded and appended.\n\n\n**dldatabasefiles** - Download specified files from a Physiobank database.\n\n::\n\n    dldatabasefiles(pbdb, dlbasedir, files, keepsubdirs = True, overwrite = False)\n\nExample Usage:\n\n::\n\n    import wfdb\n    wfdb.dldatabasefiles('ahadb', os.getcwd(), ['STAFF-Studies-bibliography-2016.pdf', 'data/001a.hea', 'data/001a.dat'])\n\nInput arguments:\n\n- ``pbdb`` (required): The Physiobank database directory to download. eg. For database 'http://physionet.org/physiobank/database/mitdb', pbdb = 'mitdb'.\n- ``dlbasedir`` (required): The full local directory path in which to download the files.\n- ``files`` (required): A list of strings specifying the file names to download relative to the database base directory\n- ``keepsubdirs`` (default=True): Whether to keep the relative subdirectories of downloaded files as they are organized in Physiobank (True), or to download all files into the same base directory (False).\n- ``overwrite`` (default=False): If set to True, all files will be redownloaded regardless. If set to False, existing files with the same name and relative subdirectory will be checked. If the local file is the same size as the online file, the download is skipped. If the local file is larger, it will be deleted and the file will be redownloaded. If the local file is smaller, the file will be assumed to be partially downloaded and the remaining bytes will be downloaded and appended.\n\n\nSignal processing\n-----------------\n\nBasic functionalities\n~~~~~~~~~~~~~~~~~~~~~\n\n**resample_sig** - Resample a single-channel signal\n\n::\n\n    resample_sig(x, fs, fs_target)\n\nExample Usage:\n\n::\n\n    import wfdb\n    sig, fields = wfdb.srdsamp('sampledata/100', sampto=10000)\n    x, _ = wfdb.processing.resample_sig(x=sig[:,0], fs=fields['fs'], fs_target=128)\n\nInput arguments:\n\n- ``x`` (required): The signal.\n- ``fs`` (required): The signal frequency.\n- ``fs_target`` (required): The target signal frequency.\n\n\n**resample_singlechan** - Resample a single-channel signal and its annotation.\n\n::\n\n    resample_singlechan(x, ann, fs, fs_target)\n\nExample Usage:\n\n::\n\n    import wfdb\n    sig, fields = wfdb.srdsamp('sampledata/100')\n    ann = wfdb.rdann('sampledata/100', 'atr')\n    new_sig, new_ann = wfdb.processing.resample_singlechan(x=sig[:, 0], ann=ann, fs=fields['fs'], fs_target=50)\n\nInput arguments:\n\n- ``x`` (required): The signal.\n- ``ann`` (required): The signal Annotation.\n- ``fs`` (required): The signal frequency.\n- ``fs_target`` (required): The target signal frequency.\n\n\n\n**resample_multichan** - Resample a multi-channel signal and its annotation.\n\n::\n\n    resample_multichan(sig, ann, fs, fs_target)\n\nExample Usage:\n\n::\n\n    import wfdb\n    sig, fields = wfdb.srdsamp('sampledata/100')\n    ann = wfdb.rdann('sampledata/100', 'atr')\n    new_sig, new_ann = wfdb.processing.resample_multichan(sig=sig, ann=ann, fs=fields['fs'], fs_target=50)\n\nInput arguments:\n\n- ``x`` (required): The signal.\n- ``ann`` (required): The signal Annotation.\n- ``fs`` (required): The signal frequency.\n- ``fs_target`` (required): The target signal frequency.\n\n\n\n**normalize** - Resizes a signal between a lower and upper bound\n\n::\n\n    normalize(x, lb=0, ub=1)\n\nExample Usage:\n\n::\n\n    import wfdb\n    sig, _ = wfdb.srdsamp('sampledata/100')\n    x = wfdb.processing.normalize(x=sig[:, 0], lb=-2, ub=15)\n\nInput arguments:\n\n- ``x`` (required): The signal.\n- ``lb`` (required): The lower bound.\n- ``ub`` (required): The upper bound.\n\n\n\n**smooth** - Signal smoothing\n\n::\n\n    smooth(x, window_size)\n\nExample Usage:\n\n::\n\n    import wfdb\n    sig, _ = wfdb.srdsamp('sampledata/100')\n    x = smooth(x=sig[:,0], window_size=150)\n\nInput arguments:\n\n- ``x`` (required): The signal.\n- ``window_size`` (required): The smoothing window width.\n\n\nPeak detection\n~~~~~~~~~~~~~~\n\n**gqrs_detect** - The GQRS detector function\n\n::\n\n  gqrs_detect(x, frequency, adcgain, adczero, threshold=1.0, hr=75, RRdelta=0.2, RRmin=0.28, RRmax=2.4, QS=0.07, QT=0.35, RTmin=0.25, RTmax=0.33, QRSa=750, QRSamin=130)\n\nExample Usage:\n\n::\n\n    import wfdb\n    t0 = 10000\n    tf = 20000\n    sig, fields = wfdb.srdsamp('sampledata/100', sampfrom=t0, sampto=tf, channels=[0])\n    record = wfdb.rdsamp(\"sampledata/100\", sampfrom=t0, sampto=tf, channels=[0], physical=False)\n    peaks_indexes = wfdb.processing.gqrs_detect(x=sig[:,0], frequency=fields['fs'], adcgain=record.adcgain[0], adczero=record.adczero[0], threshold=1.0)\n\nInput arguments:\n\n- ``x`` (required): The signal.\n- ``frequency`` (required): The signal frequency.\n- ``adcgain`` (required): The gain of the signal (the number of adus (q.v.) per physical unit).\n- ``adczero`` (required): The value produced by the ADC given a 0 volt input.\n- ``threshold`` (default=1.0): The threshold for detection.\n- ``hr`` (default=75): Typical heart rate, in beats per minute.\n- ``RRdelta`` (default=0.2): Typical difference between successive RR intervals in seconds.\n- ``RRmin`` (default=0.28): Minimum RR interval (\"refractory period\"), in seconds.\n- ``RRmax`` (default=2.4): Maximum RR interval, in seconds; thresholds will be adjusted if no peaks are detected within this interval.\n- ``QS`` (default=0.07): Typical QRS duration, in seconds.\n- ``QT`` (default=0.35): Typical QT interval, in seconds.\n- ``RTmin`` (default=0.25): Minimum interval between R and T peaks, in seconds.\n- ``RTmax`` (default=0.33): Maximum interval between R and T peaks, in seconds.\n- ``QRSa`` (default=750): Typical QRS peak-to-peak amplitude, in microvolts.\n- ``QRSamin`` (default=130): Minimum QRS peak-to-peak amplitude, in microvolts.\n\nOutput Arguments:\n\n- ``peaks_indexes``: A python list containing the peaks indexes.\n\n\n**correct_peaks** - A post-processing algorithm to correct peaks position.\n\nSee code comments for details about the algorithm.\n\n\n::\n\n  correct_peaks(x, peaks_indexes, min_gap, max_gap, smooth_window)\n\nExample Usage:\n\n::\n\n    import wfdb\n    t0 = 10000\n    tf = 20000\n    sig, fields = wfdb.srdsamp('sampledata/100', sampfrom=t0, sampto=tf, channels=[0])\n    record = wfdb.rdsamp(\"sampledata/100\", sampfrom=t0, sampto=tf, channels=[0], physical=False)\n    peak_indexes = wfdb.processing.gqrs_detect(x=sig[:,0], frequency=fields['fs'], adcgain=record.adcgain[0], adczero=record.adczero[0], threshold=1.0)\n    fs = fields['fs']\n    min_bpm = 10\n    max_bpm = 350\n    min_gap = fs*60/min_bpm\n    max_gap = fs*60/max_bpm\n    new_indexes = wfdb.processing.correct_peaks(x=sig[:,0], peaks_indexes=peak_indexes, min_gap=min_gap, max_gap=max_gap, smooth_window=150)\n\nInput arguments:\n\n- ``x`` (required): The signal.\n- ``peaks_indexes`` (required): The location of the peaks.\n- ``min_gap`` (required): The minimum gap in samples between two peaks.\n- ``max_gap`` (required): The maximum gap in samples between two peaks.\n- ``smooth_window`` (required): The size of the smoothing window.\n\nOutput Arguments:\n\n- ``new_indexes``: A python list containing the new peaks indexes.\n\n\nHeart rate\n~~~~~~~~~~~~~~\n\n**compute_hr** - Compute heart rate from peak indexes and signal frequency.\n\n::\n\n  compute_hr(length, peaks_indexes, fs)\n\nExample Usage:\n\n::\n\n    import wfdb\n    t0 = 10000\n    tf = 20000\n    sig, fields = wfdb.srdsamp('sampledata/100', sampfrom=t0, sampto=tf, channels=[0])\n    record = wfdb.rdsamp(\"sampledata/100\", sampfrom=t0, sampto=tf, channels=[0], physical=False)\n    peaks_indexes = wfdb.processing.gqrs_detect(x=sig[:,0], frequency=fields['fs'], adcgain=record.adcgain[0], adczero=record.adczero[0], threshold=1.0)\n    hr = compute_hr(length=tf-t0, peaks_indexes=peaks_indexes, fs=fields['fs'])\n\nInput arguments:\n\n- ``length`` (required): The length of the corresponding signal.\n- ``peaks_indexes`` (required): The peak indexes.\n- ``fs`` (required): The signal frequency.\n\n\nOutput Arguments:\n\n- ``hr``: A numpy.array containing heart rate for each sample. Contains numpy.nan where heart rate could not be computed.\n\n\n\nBased on the original WFDB software package specifications\n----------------------------------------------------------\n\n| `WFDB Software Package`_\n| `WFDB Applications Guide`_\n| `WFDB Header File Specifications`_\n\n.. _WFDB Software Package: http://physionet.org/physiotools/wfdb.shtml\n.. _WFDB Applications Guide: http://physionet.org/physiotools/wag/\n.. _WFDB Header File Specifications: https://physionet.org/physiotools/wag/header-5.htm\n\n\n.. |Build Status| image:: https://travis-ci.org/MIT-LCP/wfdb-python.svg?branch=master\n   :target: https://travis-ci.org/MIT-LCP/wfdb-python\n",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "https://github.com/MIT-LCP/wfdb-python",
    "keywords": "WFDB clinical waveform",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "wfdb",
    "platform": "",
    "project_url": "https://pypi.org/project/wfdb/",
    "release_url": "https://pypi.org/project/wfdb/1.3.4/",
    "requires_dist": [],
    "requires_python": "",
    "summary": "The WFDB Python Toolbox",
    "version": "1.3.4"
  },
  "releases": {
    "0.1.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "673ae28e32807de8aacbf43fdc2bab49",
          "sha256": "e37c8e18db31acbaef81b5f153bf1fa9fde015aba7c50bf643a773db55fcab6c"
        },
        "downloads": 234,
        "filename": "wfdb-0.1.1.tar.gz",
        "has_sig": false,
        "md5_digest": "673ae28e32807de8aacbf43fdc2bab49",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 22606,
        "upload_time": "2016-09-07T17:45:56",
        "url": "https://files.pythonhosted.org/packages/b4/bd/22bb1f3058ea3ba63fb3d5e2381a267806b2f19282b0b9584c3e6a48d216/wfdb-0.1.1.tar.gz"
      }
    ],
    "0.1.2": [
      {
        "comment_text": "",
        "digests": {
          "md5": "fbb28e36e10c2aba7343af74f9934e26",
          "sha256": "ddd39b0073ae61ca6bd0fbedb02e2324ab26d874a00aa91fb351566c9179b097"
        },
        "downloads": 200,
        "filename": "wfdb-0.1.2.tar.gz",
        "has_sig": false,
        "md5_digest": "fbb28e36e10c2aba7343af74f9934e26",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 23999,
        "upload_time": "2016-09-07T19:22:59",
        "url": "https://files.pythonhosted.org/packages/79/4b/e193d8482ea0eaf9e8db74d499b7b526116b509b97c59d7430513f1f3cda/wfdb-0.1.2.tar.gz"
      }
    ],
    "1.0.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "1bd75ebf6d9aa6f2fd86ed34cb33f158",
          "sha256": "6c02e3faa67172fd9c008e4c5d829652b75d9106cc82693f73244b43851c9ba1"
        },
        "downloads": 27,
        "filename": "wfdb-1.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "1bd75ebf6d9aa6f2fd86ed34cb33f158",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 49690,
        "upload_time": "2017-04-04T15:54:58",
        "url": "https://files.pythonhosted.org/packages/67/15/3fa6311f99354a8dbd181bcd860107aa0a04501358e25edeb31ceee66752/wfdb-1.0.0.tar.gz"
      }
    ],
    "1.0.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "b836e3e10f571a5c4964c5acf020d31f",
          "sha256": "a8019307ddb5d2175481c268d72d871451a76e30adfe127f973ab1ee592040b7"
        },
        "downloads": 35,
        "filename": "wfdb-1.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "b836e3e10f571a5c4964c5acf020d31f",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 49871,
        "upload_time": "2017-04-04T20:49:46",
        "url": "https://files.pythonhosted.org/packages/24/be/6ca9a0bcda0860818cd795b7d65ab52947c1844b15bdde3196f08fc42231/wfdb-1.0.1.tar.gz"
      }
    ],
    "1.0.2": [
      {
        "comment_text": "",
        "digests": {
          "md5": "fc4a798c1d23f4d074aec8497557b6a8",
          "sha256": "9c5e9525ee7fda6ad44916d4bf74f97c99834e010f04264d811885a8608a73c4"
        },
        "downloads": 230,
        "filename": "wfdb-1.0.2.tar.gz",
        "has_sig": false,
        "md5_digest": "fc4a798c1d23f4d074aec8497557b6a8",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 49923,
        "upload_time": "2017-04-06T13:46:02",
        "url": "https://files.pythonhosted.org/packages/56/fe/647a079ca93c254abf73f60707f0f0feff48159138fb62fae36cbb67e457/wfdb-1.0.2.tar.gz"
      }
    ],
    "1.0.3": [
      {
        "comment_text": "",
        "digests": {
          "md5": "e5be3dfb92e105c86e24e15ab3437e95",
          "sha256": "6696d78cfcdccb77e9d2adbf80a16a33bc0ee6c8efee21576f01a3c322c097de"
        },
        "downloads": 0,
        "filename": "wfdb-1.0.3.tar.gz",
        "has_sig": false,
        "md5_digest": "e5be3dfb92e105c86e24e15ab3437e95",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 49512,
        "upload_time": "2017-04-14T14:46:02",
        "url": "https://files.pythonhosted.org/packages/0e/2f/2033d159132169c004c0505dfa9a4847480a7d0c0d7c640a38db52421401/wfdb-1.0.3.tar.gz"
      }
    ],
    "1.0.4": [
      {
        "comment_text": "",
        "digests": {
          "md5": "565d9befce2111f3a0300fd6a76ba0fc",
          "sha256": "350647b292736f9183603154c0055b85b24ce6636b276e2d604594e9dadc40aa"
        },
        "downloads": 0,
        "filename": "wfdb-1.0.4.tar.gz",
        "has_sig": false,
        "md5_digest": "565d9befce2111f3a0300fd6a76ba0fc",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 49567,
        "upload_time": "2017-04-19T14:07:54",
        "url": "https://files.pythonhosted.org/packages/ab/6a/155f91318efb519e3092c1e876276c43e8e408cc4f0f4b45fa7fe83e46da/wfdb-1.0.4.tar.gz"
      }
    ],
    "1.0.5": [
      {
        "comment_text": "",
        "digests": {
          "md5": "928d72849cbfa5dae569fb4cc4b16e81",
          "sha256": "40c07ff7d42b04fd3d5fefe7b656140cd750879373c688dba4d8bdb5128f031d"
        },
        "downloads": 0,
        "filename": "wfdb-1.0.5.tar.gz",
        "has_sig": false,
        "md5_digest": "928d72849cbfa5dae569fb4cc4b16e81",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 49571,
        "upload_time": "2017-04-19T20:31:22",
        "url": "https://files.pythonhosted.org/packages/fe/75/14fc474a27674b85e91497edb476097bbeab91cce75d9d04075210e9d257/wfdb-1.0.5.tar.gz"
      }
    ],
    "1.0.6": [
      {
        "comment_text": "",
        "digests": {
          "md5": "925e72d807c2494a880fdef96194637c",
          "sha256": "3a0f642efbabef5cc1559f7d9883b09c147c51a5f2f4f0bfc60db9c180da987a"
        },
        "downloads": 0,
        "filename": "wfdb-1.0.6.tar.gz",
        "has_sig": false,
        "md5_digest": "925e72d807c2494a880fdef96194637c",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 51620,
        "upload_time": "2017-05-18T19:10:40",
        "url": "https://files.pythonhosted.org/packages/ac/cd/aeb323df62868cbcc0c0994d053e1b095c8b2d7c1faaf503a6ccec4caf14/wfdb-1.0.6.tar.gz"
      }
    ],
    "1.1.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "de863c500be7014dce146e6fd269d4d8",
          "sha256": "5a218b4c6e9f7f220ffa56b49dd61a230d31bbe4a3e46f6bead699329cfd782a"
        },
        "downloads": 0,
        "filename": "wfdb-1.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "de863c500be7014dce146e6fd269d4d8",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 11623,
        "upload_time": "2017-06-05T14:07:20",
        "url": "https://files.pythonhosted.org/packages/72/4b/c882b78515b01ef5217c0878cd0d673d3ab7eb139d94386312ede1d768f1/wfdb-1.1.0.tar.gz"
      }
    ],
    "1.1.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "44c59b87a0e3e9e5094208c3960507e6",
          "sha256": "5276d84e1e2c91b40e43bfb83a597846d5fec8089ec8a1bd2f5057b00c377076"
        },
        "downloads": 0,
        "filename": "wfdb-1.1.1.tar.gz",
        "has_sig": false,
        "md5_digest": "44c59b87a0e3e9e5094208c3960507e6",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 57269,
        "upload_time": "2017-06-06T17:36:25",
        "url": "https://files.pythonhosted.org/packages/19/83/625c328a4d800239173df8d84a3ca6b06d76bbb7aad85445a50c6cef21db/wfdb-1.1.1.tar.gz"
      }
    ],
    "1.1.2": [
      {
        "comment_text": "",
        "digests": {
          "md5": "1d6b1160fb2fded5e989a5feed82e0de",
          "sha256": "dd9df569bf30f2418c4af25dcd624fefcbb1a57d8aad7b9c492792e4b9744e15"
        },
        "downloads": 0,
        "filename": "wfdb-1.1.2.tar.gz",
        "has_sig": false,
        "md5_digest": "1d6b1160fb2fded5e989a5feed82e0de",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 58297,
        "upload_time": "2017-06-06T23:20:54",
        "url": "https://files.pythonhosted.org/packages/17/f5/8bd0ebeec623567bea07f97796d96461c815b9a31c530458f7047c19d45b/wfdb-1.1.2.tar.gz"
      }
    ],
    "1.2.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "251d3cfe4eca35501982a4fc72b333db",
          "sha256": "928fc2460dc5524933fe7cf0f7b2ad1a723b63803b4abcb9ebe65bb08e9567e3"
        },
        "downloads": 0,
        "filename": "wfdb-1.2.0.tar.gz",
        "has_sig": false,
        "md5_digest": "251d3cfe4eca35501982a4fc72b333db",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 77927,
        "upload_time": "2017-06-26T14:17:06",
        "url": "https://files.pythonhosted.org/packages/f7/84/bb1d36288570fd4ff8ec7cae579c14898c3e370756950a0bf9e6ee6b6984/wfdb-1.2.0.tar.gz"
      }
    ],
    "1.2.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "e430d987fbfcc7933212fc6db66322a2",
          "sha256": "2e022b11654e37eebab4567a81aa7bd2e6e6d3143e5f97ca63b010e87d6f7aaf"
        },
        "downloads": 0,
        "filename": "wfdb-1.2.1.tar.gz",
        "has_sig": false,
        "md5_digest": "e430d987fbfcc7933212fc6db66322a2",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 80535,
        "upload_time": "2017-08-15T14:29:23",
        "url": "https://files.pythonhosted.org/packages/c0/15/2f674e4be26e9a89ccf50512b5db32e55dc3a15f1009d09652271bb68503/wfdb-1.2.1.tar.gz"
      }
    ],
    "1.2.2": [
      {
        "comment_text": "",
        "digests": {
          "md5": "8a65b3d9815f04da1242357ae3dfbe35",
          "sha256": "3526c3e1ef248c80c32192d3e9e929d97ccf5ea80ebe0897faef27ed5df78819"
        },
        "downloads": 0,
        "filename": "wfdb-1.2.2.tar.gz",
        "has_sig": false,
        "md5_digest": "8a65b3d9815f04da1242357ae3dfbe35",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 80501,
        "upload_time": "2017-08-18T14:45:04",
        "url": "https://files.pythonhosted.org/packages/48/17/04399a346c3ebb7da32bca16bc16ea6eb5ebc0b5a4594d16382c98e08162/wfdb-1.2.2.tar.gz"
      }
    ],
    "1.3.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "77c33a55728495b013af7f2fc19bc781",
          "sha256": "56088df269dedf2005fc125ae3cb00f7e7ec9e42a6f8f516424a711d4da898fb"
        },
        "downloads": 0,
        "filename": "wfdb-1.3.0.tar.gz",
        "has_sig": false,
        "md5_digest": "77c33a55728495b013af7f2fc19bc781",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 86561,
        "upload_time": "2017-09-26T13:28:27",
        "url": "https://files.pythonhosted.org/packages/d4/ea/3c7f285ae9cb1dd2d4b90d01a7c437838629ec8bba45d26e6325a33662bb/wfdb-1.3.0.tar.gz"
      }
    ],
    "1.3.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "510832508c43379eee7cb155648295cc",
          "sha256": "ae7721ef15e6f923c7877c5574131ecfd17b48653037dff4950596ce13d78718"
        },
        "downloads": 0,
        "filename": "wfdb-1.3.1.tar.gz",
        "has_sig": false,
        "md5_digest": "510832508c43379eee7cb155648295cc",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 86509,
        "upload_time": "2017-09-26T15:10:46",
        "url": "https://files.pythonhosted.org/packages/dd/49/09b9cce0ef9627abc08d21843699f128d13178d080c7abbe33809071abb5/wfdb-1.3.1.tar.gz"
      }
    ],
    "1.3.3": [
      {
        "comment_text": "",
        "digests": {
          "md5": "5207d7bd6fbd0bd6e29d845db83498d1",
          "sha256": "befb3e9eda6e6a4691cd5fecd371b5c3fe97e05a9b00e9b93a7cfb3b81ca864e"
        },
        "downloads": 0,
        "filename": "wfdb-1.3.3.tar.gz",
        "has_sig": false,
        "md5_digest": "5207d7bd6fbd0bd6e29d845db83498d1",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 86775,
        "upload_time": "2017-09-27T13:51:25",
        "url": "https://files.pythonhosted.org/packages/fb/e5/871c55398b517f552efb5150d6449f472e704231b800d9c259f592c90f0b/wfdb-1.3.3.tar.gz"
      }
    ],
    "1.3.4": [
      {
        "comment_text": "",
        "digests": {
          "md5": "7cf431d7d126727389fd1a6e0788cf55",
          "sha256": "8f7a04a1bfd7c1de65cfdbab3b68c797bbb7ef131464c0c831a61c449d552886"
        },
        "downloads": 0,
        "filename": "wfdb-1.3.4.tar.gz",
        "has_sig": false,
        "md5_digest": "7cf431d7d126727389fd1a6e0788cf55",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 86820,
        "upload_time": "2017-09-27T15:46:35",
        "url": "https://files.pythonhosted.org/packages/9f/4a/1ad374eae6c006c8f3bd9ca387b046898390db0cce36125cba442462552e/wfdb-1.3.4.tar.gz"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "7cf431d7d126727389fd1a6e0788cf55",
        "sha256": "8f7a04a1bfd7c1de65cfdbab3b68c797bbb7ef131464c0c831a61c449d552886"
      },
      "downloads": 0,
      "filename": "wfdb-1.3.4.tar.gz",
      "has_sig": false,
      "md5_digest": "7cf431d7d126727389fd1a6e0788cf55",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 86820,
      "upload_time": "2017-09-27T15:46:35",
      "url": "https://files.pythonhosted.org/packages/9f/4a/1ad374eae6c006c8f3bd9ca387b046898390db0cce36125cba442462552e/wfdb-1.3.4.tar.gz"
    }
  ]
}