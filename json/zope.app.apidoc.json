{
  "info": {
    "author": "Zope Corporation and Contributors",
    "author_email": "zope-dev@zope.org",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Environment :: Web Environment",
      "Framework :: Zope3",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: Zope Public License",
      "Natural Language :: English",
      "Operating System :: OS Independent",
      "Programming Language :: Python",
      "Programming Language :: Python :: 2",
      "Programming Language :: Python :: 2.7",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.4",
      "Programming Language :: Python :: 3.5",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: Implementation :: CPython",
      "Programming Language :: Python :: Implementation :: PyPy",
      "Topic :: Internet :: WWW/HTTP"
    ],
    "description": "This Zope 3 package provides fully dynamic API documentation of Zope 3 and\nregistered add-on components. The package is very extensible and can be easily\nextended by implementing new modules.\n\nThe static version of the full Zope tree is available at:\n\nhttp://apidoc.zope.org\n\n\n.. contents::\n\n==========================\n Zope 3 API Documentation\n==========================\n\nThis Zope 3 package provides fully dynamic API documentation of Zope 3 and\nregistered add-on components. The package is very extensible and can be easily\nextended by implementing new modules.\n\nBesides being an application, the API doctool also provides several public\nAPIs to extract information from various objects used by Zope 3.\n\n * utilities -- Miscellaneous classes and functions that aid all documentation\n   modules. They are broadly usable.\n\n * interface -- This module contains functions to inspect interfaces and\n   schemas.\n\n * component -- This modules provides utility functions to lookup components\n   given an interface.\n\n * presentation -- Presentation components are generally more complex than\n   others, so a separate utilities module is provided to inspect views.\n\n * classregistry -- Here a simple dictionary-based registry for all known\n   classes is provided. It allows us to search in classes.\n\n\nUsing the API Dcoumentation\n===========================\n\nThe `APIDocumentation` class provides access to all available documentation\nmodules. Documentation modules are utilities providing `IDocumentationModule`:\n\n\n  >>> from zope import component as ztapi\n  >>> from zope.app.apidoc.interfaces import IDocumentationModule\n  >>> from zope.app.apidoc.ifacemodule.ifacemodule import InterfaceModule\n  >>> from zope.app.apidoc.zcmlmodule import ZCMLModule\n\n  >>> ztapi.provideUtility(InterfaceModule(), IDocumentationModule,\n  ...                      'Interface')\n  >>> ztapi.provideUtility(ZCMLModule(), IDocumentationModule, 'ZCML')\n\nNow we can instantiate the class (which is usually done when traversing\n'++apidoc++') and get a list of available modules:\n\n  >>> from zope.app.apidoc.apidoc import APIDocumentation\n  >>> doc = APIDocumentation(None, '++apidoc++')\n\n  >>> modules = sorted(doc.keys())\n  >>> modules\n  [u'Interface', u'ZCML']\n\n  >>> doc['ZCML']\n  <zope.app.apidoc.zcmlmodule.ZCMLModule 'ZCML' at ...>\n\n\nDeveloping a Module\n===================\n\n1. Implement a class that realizes the `IDocumentationModule`\n   interface.\n\n2. Register this class as a utility using something like this::\n\n     <utility\n         provides=\"zope.app.apidoc.interfaces.IDocumentationModule\"\n         factory=\".examplemodule.ExampleModule\"\n         name=\"Example\" />\n\n3. Take care of security by allowing at least `IDocumentationModule`::\n\n     <class class=\".ExampleModule\">\n       <allow interface=\"zope.app.apidoc.interfaces.IDocumentationModule\" />\n     </class>\n\n4. Provide a browser view called ``menu.html``.\n\n5. Provide another view, usually ``index.html``, that can show the\n   details for the various menu items.\n\nNote:  There are several modules that come with the product. Just look\nin them for some guidance.\n\n\nNew Static APIDOC-Version\n=========================\n\nAn alternative APIDOC-Version is available through ++apidoc++/static.html\nFind and Tree is implemented in Javascript. So it should be possible to do a\n\"wget\" - Offline-Version of APIDOC\n\n\n================================\n Component Inspection Utilities\n================================\n\nOnce you have an interface, you really want to discover on how this interface\ninteracts with other components in Zope 3. The functions in\n\n  >>> from zope.app.apidoc import component\n\nprovide you with utilities to make those discoveries. The functions are\nexplained in detail in this document. Before we start though, we have to have\nsome interfaces to work with:\n\n  >>> from zope.interface import Interface\n  >>> class IFoo(Interface):\n  ...     pass\n\n  >>> class IBar(Interface):\n  ...     pass\n\n  >>> class IFooBar(IFoo, IBar):\n  ...     pass\n\n  >>> class IResult(Interface):\n  ...     pass\n\n  >>> class ISpecialResult(IResult):\n  ...     pass\n\n\n``getRequiredAdapters(iface, withViews=False)``\n===============================================\n\nThis function returns adapter registrations for adapters that require the\nspecified interface. So let's create some adapter registrations:\n\n  >>> from zope.publisher.interfaces import IRequest\n  >>> from zope import component as ztapi\n  >>> ztapi.provideAdapter(adapts=(IFoo,), provides=IResult, factory=None)\n  >>> ztapi.provideAdapter(adapts=(IFoo, IBar), provides=ISpecialResult, factory=None)\n  >>> ztapi.provideAdapter(adapts=(IFoo, IRequest), provides=ISpecialResult, factory=None)\n  >>> ztapi.provideHandler(adapts=(IFoo,), factory='stubFactory')\n\n  >>> regs = list(component.getRequiredAdapters(IFoo))\n  >>> regs.sort()\n  >>> regs\n  [AdapterRegistration(<BaseGlobalComponents base>,\n                       [IFoo, IBar], ISpecialResult, u'', None, u''),\n   AdapterRegistration(<BaseGlobalComponents base>,\n                       [IFoo], IResult, u'', None, u''),\n   HandlerRegistration(<BaseGlobalComponents base>,\n                       [IFoo], u'', 'stubFactory', u'')]\n\nNote how the adapter requiring an ``IRequest`` at the end of the required\ninterfaces is neglected. This is because it is recognized as a view and views\nare not returned by default. But you can simply turn this flag on:\n\n  >>> regs = list(component.getRequiredAdapters(IFoo, withViews=True))\n  >>> regs.sort()\n  >>> regs\n  [AdapterRegistration(<BaseGlobalComponents base>,\n                       [IFoo, IBar], ISpecialResult, u'', None, u''),\n   AdapterRegistration(<BaseGlobalComponents base>,\n                       [IFoo, IRequest], ISpecialResult, u'', None, u''),\n   AdapterRegistration(<BaseGlobalComponents base>,\n                       [IFoo], IResult, u'', None, u''),\n   HandlerRegistration(<BaseGlobalComponents base>,\n                       [IFoo], u'', 'stubFactory', u'')]\n\nThe function will also pick up registrations that have required interfaces the\nspecified interface extends:\n\n  >>> regs = list(component.getRequiredAdapters(IFoo))\n  >>> regs.sort()\n  >>> regs\n  [AdapterRegistration(<BaseGlobalComponents base>,\n                       [IFoo, IBar], ISpecialResult, u'', None, u''),\n   AdapterRegistration(<BaseGlobalComponents base>,\n                       [IFoo], IResult, u'', None, u''),\n   HandlerRegistration(<BaseGlobalComponents base>,\n                       [IFoo], u'', 'stubFactory', u'')]\n\nAnd all of the required interfaces are considered, of course:\n\n  >>> regs = list(component.getRequiredAdapters(IBar))\n  >>> regs.sort()\n  >>> regs\n  [AdapterRegistration(<BaseGlobalComponents base>,\n                       [IFoo, IBar], ISpecialResult, u'', None, u'')]\n\n\n``getProvidedAdapters(iface, withViews=False)``\n===============================================\n\nOf course, we are also interested in the adapters that provide a certain\ninterface. This function returns those adapter registrations, again ignoring\nviews by default.\n\n  >>> regs = list(component.getProvidedAdapters(ISpecialResult))\n  >>> regs.sort()\n  >>> regs\n  [AdapterRegistration(<BaseGlobalComponents base>,\n                       [IFoo, IBar], ISpecialResult, u'', None, u'')]\n\nAnd by specifying the ``withView`` flag, we get views as well:\n\n  >>> regs = list(component.getProvidedAdapters(ISpecialResult, withViews=True))\n  >>> regs.sort()\n  >>> regs\n  [AdapterRegistration(<BaseGlobalComponents base>,\n                       [IFoo, IBar], ISpecialResult, u'', None, u''),\n   AdapterRegistration(<BaseGlobalComponents base>,\n                       [IFoo, IRequest], ISpecialResult, u'', None, u'')]\n\nWe can of course also ask for adapters specifying ``IResult``:\n\n  >>> regs = list(component.getProvidedAdapters(IResult, withViews=True))\n  >>> regs.sort()\n  >>> regs\n  [AdapterRegistration(<BaseGlobalComponents base>,\n                       [IFoo, IBar], ISpecialResult, u'', None, u''),\n   AdapterRegistration(<BaseGlobalComponents base>,\n                       [IFoo, IRequest], ISpecialResult, u'', None, u''),\n   AdapterRegistration(<BaseGlobalComponents base>,\n                       [IFoo], IResult, u'', None, u'')]\n\n\n``getClasses(iface)``\n=====================\n\nThis package comes with a little tool called the class registry\n(see ``classregistry.txt``). It provides a dictionary of all classes in the\nvisible packages. This function utilizes the registry to retrieve all classes\nthat implement the specified interface.\n\nLet's start by creating and registering some classes:\n\n  >>> from zope.interface import implementer\n  >>> from zope.app.apidoc.classregistry import classRegistry\n\n  >>> @implementer(IFoo)\n  ... class MyFoo(object):\n  ...    pass\n  >>> classRegistry['MyFoo'] = MyFoo\n\n  >>> @implementer(IBar)\n  ... class MyBar(object):\n  ...    pass\n  >>> classRegistry['MyBar'] = MyBar\n\n  >>> @implementer(IFooBar)\n  ... class MyFooBar(object):\n  ...    pass\n  >>> classRegistry['MyFooBar'] = MyFooBar\n\nLet's now see whether what results we get:\n\n  >>> classes = component.getClasses(IFooBar)\n  >>> classes.sort()\n  >>> classes\n  [('MyFooBar', <class 'zope.app.apidoc.doctest.MyFooBar'>)]\n\n  >>> classes = component.getClasses(IFoo)\n  >>> classes.sort()\n  >>> classes\n  [('MyFoo', <class 'zope.app.apidoc.doctest.MyFoo'>),\n   ('MyFooBar', <class 'zope.app.apidoc.doctest.MyFooBar'>)]\n\n\n``getFactories(ifaces)``\n========================\n\nReturn the factory registrations of the factories that will return objects\nproviding this interface.\n\nAgain, the first step is to create some factories:\n\n  >>> from zope.component.factory import Factory\n  >>> from zope.component.interfaces import IFactory\n  >>> ztapi.provideUtility(Factory(MyFoo), IFactory, 'MyFoo')\n  >>> ztapi.provideUtility(Factory(MyBar), IFactory, 'MyBar')\n  >>> ztapi.provideUtility(\n  ...     Factory(MyFooBar, 'MyFooBar', 'My Foo Bar'), IFactory, 'MyFooBar')\n\nLet's see whether we will be able to get them:\n\n  >>> regs = list(component.getFactories(IFooBar))\n  >>> regs.sort()\n  >>> regs\n  [UtilityRegistration(<BaseGlobalComponents base>,\n      IFactory, 'MyFooBar',\n      <Factory for <class 'zope.app.apidoc.doctest.MyFooBar'>>, None, u'')]\n\n  >>> regs = list(component.getFactories(IFoo))\n  >>> regs.sort()\n  >>> regs\n  [UtilityRegistration(<BaseGlobalComponents base>, IFactory, 'MyFoo',\n               <Factory for <class 'zope.app.apidoc.doctest.MyFoo'>>, None, u''),\n   UtilityRegistration(<BaseGlobalComponents base>, IFactory, 'MyFooBar',\n            <Factory for <class 'zope.app.apidoc.doctest.MyFooBar'>>, None, u'')]\n\n\n``getUtilities(iface)``\n=======================\n\nReturn all utility registrations for utilities that provide the specified\ninterface.\n\nAs usual, we have to register some utilities first:\n\n  >>> ztapi.provideUtility(MyFoo(), IFoo)\n  >>> ztapi.provideUtility(MyBar(), IBar)\n  >>> ztapi.provideUtility(MyFooBar(), IFooBar)\n\nNow let's have a look what we have:\n\n  >>> regs = list(component.getUtilities(IFooBar))\n  >>> regs.sort()\n  >>> regs\n  [UtilityRegistration(<BaseGlobalComponents base>, IFooBar, u'',\n                       <zope.app.apidoc.doctest.MyFooBar object at ...>, None, u'')]\n\n  >>> regs = list(component.getUtilities(IFoo))\n  >>> regs.sort()\n  >>> regs\n  [UtilityRegistration(<BaseGlobalComponents base>, IFoo, u'',\n                       <zope.app.apidoc.doctest.MyFoo object at ...>, None, u''),\n   UtilityRegistration(<BaseGlobalComponents base>, IFooBar, u'',\n                       <zope.app.apidoc.doctest.MyFooBar object at ...>, None, u'')]\n\n\n``getRealFactory(factory)``\n===========================\n\nDuring registration, factories are commonly masked by wrapper functions. Also,\nfactories are sometimes also ``IFactory`` instances, which are not referencable,\nso that we would like to return the class. If the wrapper objects/functions\nplay nice, then they provide a ``factory`` attribute that points to the next\nwrapper or the original factory.\n\nThe task of this function is to remove all the factory wrappers and make sure\nthat the returned factory is referencable.\n\n  >>> class Factory(object):\n  ...     pass\n\n  >>> def wrapper1(*args):\n  ...     return Factory(*args)\n  >>> wrapper1.factory = Factory\n\n  >>> def wrapper2(*args):\n  ...     return wrapper1(*args)\n  >>> wrapper2.factory = wrapper1\n\nSo whether we pass in ``Factory``,\n\n  >>> component.getRealFactory(Factory)\n  <class 'zope.app.apidoc.doctest.Factory'>\n\n``wrapper1``,\n\n  >>> component.getRealFactory(wrapper1)\n  <class 'zope.app.apidoc.doctest.Factory'>\n\nor ``wrapper2``,\n\n  >>> component.getRealFactory(wrapper2)\n  <class 'zope.app.apidoc.doctest.Factory'>\n\nthe answer should always be the ``Factory`` class. Next we are going to pass in\nan instance, and again we should get our class aas a result:\n\n  >>> factory = Factory()\n  >>> component.getRealFactory(factory)\n  <class 'zope.app.apidoc.doctest.Factory'>\n\nEven, if the factory instance is wrapped, we should get the factory class:\n\n  >>> def wrapper3(*args):\n  ...     return factory(*args)\n  >>> wrapper3.factory = factory\n\n  >>> component.getRealFactory(wrapper3)\n  <class 'zope.app.apidoc.doctest.Factory'>\n\n\n``getInterfaceInfoDictionary(iface)``\n=====================================\n\nThis function returns a small info dictionary for an interface. It only\nreports the module and the name. This is useful for cases when we only want to\nlist interfaces in the context of other components, like adapters and\nutilities.\n\n  >>> from pprint import pprint\n  >>> pprint(component.getInterfaceInfoDictionary(IFoo), width=1)\n  {'module': 'zope.app.apidoc.doctest', 'name': 'IFoo'}\n\nThe functions using this function use it with little care and can also\nsometimes pass in ``None``. In these cases we want to return ``None``:\n\n  >>> component.getInterfaceInfoDictionary(None) is None\n  True\n\nIt's also possible for this function to be passed a\nzope.interface.declarations.Implements instance.  For instance, this function\nis sometimes used to analyze the required elements of an adapter registration:\nif an adapter or subscriber is registered against a class, then the required\nelement will be an Implements instance.  In this case, we currently believe\nthat we want to return the module and name of the object that the Implements\nobject references.  This may change.\n\n  >>> from zope.interface import implementedBy\n  >>> pprint(component.getInterfaceInfoDictionary(implementedBy(MyFoo)), width=1)\n  {'module': 'zope.app.apidoc.doctest', 'name': 'MyFoo'}\n\n\n``getTypeInfoDictionary(type)``\n===============================\n\nThis function returns the info dictionary of a type.\n\n  >>> pprint(component.getTypeInfoDictionary(tuple), width=1)\n  {'module': '__builtin__',\n   'name': 'tuple',\n   'url': '__builtin__/tuple'}\n\n\n``getSpecificationInfoDictionary(spec)``\n========================================\n\nThsi function returns an info dictionary for the given specification. A\nspecification can either be an interface or class. If it is an interface, it\nsimply returns the interface dictionary:\n\n  >>> pprint(component.getSpecificationInfoDictionary(IFoo))\n  {'isInterface': True,\n   'isType': False,\n   'module': 'zope.app.apidoc.doctest',\n   'name': 'IFoo'}\n\nIn addition to the usual interface infos, there are two flags indicating\nwhether the specification was an interface or type. In our case it is an\ninterface.\n\nLet's now look at the behavior when passing a type:\n\n  >>> import zope.interface\n  >>> tupleSpec = zope.interface.implementedBy(tuple)\n\n  >>> pprint(component.getSpecificationInfoDictionary(tupleSpec))\n  {'isInterface': False,\n   'isType': True,\n   'module': '__builtin__',\n   'name': 'tuple',\n   'url': '__builtin__/tuple'}\n\nFor the type, we simply reuse the type info dictionary function.\n\n\n``getAdapterInfoDictionary(reg)``\n=================================\n\nThis function returns a page-template-friendly dictionary representing the\ndata of an adapter registration in an output-friendly format.\n\nLet's first create an adapter registration:\n\n  >>> @implementer(IResult)\n  ... class MyResult(object):\n  ...    pass\n\n  >>> from zope.component.registry import AdapterRegistration\n  >>> reg = AdapterRegistration(None, (IFoo, IBar), IResult, 'FooToResult',\n  ...                            MyResult, 'doc info')\n\nAnd now get the info dictionary:\n\n  >>> pprint(component.getAdapterInfoDictionary(reg), width=50)\n  {'doc': 'doc info',\n   'factory': 'zope.app.apidoc.doctest.MyResult',\n   'factory_url': 'zope/app/apidoc/doctest/MyResult',\n   'name': u'FooToResult',\n   'provided': {'module': 'zope.app.apidoc.doctest',\n                'name': 'IResult'},\n   'required': [{'isInterface': True,\n                 'isType': False,\n                 'module': 'zope.app.apidoc.doctest',\n                 'name': 'IFoo'},\n                {'isInterface': True,\n                 'isType': False,\n                 'module': 'zope.app.apidoc.doctest',\n                 'name': 'IBar'}],\n   'zcml': None}\n\nIf the factory's path cannot be referenced, for example if a type has been\ncreated using the ``type()`` builtin function, then the URL of the factory\nwill be ``None``:\n\n  >>> MyResultType = type('MyResult2', (object,), {})\n  >>> from zope.interface import classImplements\n  >>> classImplements(MyResultType, IResult)\n\n  >>> reg = AdapterRegistration(None, (IFoo, IBar), IResult, 'FooToResult',\n  ...                            MyResultType, 'doc info')\n  >>> pprint(component.getAdapterInfoDictionary(reg), width=50)\n  {'doc': 'doc info',\n   'factory': 'zope.app.apidoc.doctest.MyResult2',\n   'factory_url': None,\n   'name': u'FooToResult',\n   'provided': {'module': 'zope.app.apidoc.doctest',\n                'name': 'IResult'},\n   'required': [{'isInterface': True,\n                 'isType': False,\n                 'module': 'zope.app.apidoc.doctest',\n                 'name': 'IFoo'},\n                {'isInterface': True,\n                 'isType': False,\n                 'module': 'zope.app.apidoc.doctest',\n                 'name': 'IBar'}],\n   'zcml': None}\n\nThis function can also handle subscription registrations, which are pretty\nmuch like adapter registrations, except that they do not have a name. So let's\nsee how the function handles subscriptions:\n\n  >>> from zope.component.registry import HandlerRegistration\n  >>> reg = HandlerRegistration(None, (IFoo, IBar), '', MyResult, 'doc info')\n\n  >>> pprint(component.getAdapterInfoDictionary(reg))\n  {'doc': 'doc info',\n   'factory': 'zope.app.apidoc.doctest.MyResult',\n   'factory_url': 'zope/app/apidoc/doctest/MyResult',\n   'name': u'',\n   'provided': None,\n   'required': [{'isInterface': True,\n                 'isType': False,\n                 'module': 'zope.app.apidoc.doctest',\n                 'name': 'IFoo'},\n                {'isInterface': True,\n                 'isType': False,\n                 'module': 'zope.app.apidoc.doctest',\n                 'name': 'IBar'}],\n   'zcml': None}\n\n\n``getFactoryInfoDictionary(reg)``\n=================================\n\nThis function returns a page-template-friendly dictionary representing the\ndata of a factory (utility) registration in an output-friendly format.\n\nLuckily we have already registered some factories, so we just reuse their\nregistrations:\n\n  >>> pprint(component.getFactoryInfoDictionary(\n  ...     next(component.getFactories(IFooBar))))\n  {'description': u'<p>My Foo Bar</p>\\n',\n   'name': u'MyFooBar',\n   'title': 'MyFooBar',\n   'url': 'zope/app/apidoc/doctest/MyFooBar'}\n\nIf the factory's path cannot be referenced, for example if a type has been\ncreated using the ``type()`` builtin function, then the URL of the factory\nwill be ``None``:\n\n  >>> class IMine(Interface):\n  ...     pass\n\n  >>> class FactoryBase(object):\n  ...     def getInterfaces(self): return [IMine]\n\n  >>> MyFactoryType = type('MyFactory', (FactoryBase,), {})\n  >>> from zope.interface import classImplements\n  >>> classImplements(MyFactoryType, IFactory)\n  >>> ztapi.provideUtility(MyFactoryType(), IFactory, 'MyFactory')\n\n  >>> pprint(component.getFactoryInfoDictionary(\n  ...     next(component.getFactories(IMine))), width=50)\n  {'description': u'',\n   'name': u'MyFactory',\n   'title': u'',\n   'url': None}\n\n\n``getUtilityInfoDictionary(name, factory)``\n===========================================\n\nThis function returns a page-template-friendly dictionary representing the\ndata of a utility registration in an output-friendly format.\n\nLuckily we have already registered some utilities, so we just reuse their\nregistrations:\n\n  >>> pprint(component.getUtilityInfoDictionary(\n  ...     next(component.getUtilities(IFooBar))))\n  {'iface_id': 'zope.app.apidoc.doctest.IFooBar',\n   'name': u'<i>no name</i>',\n   'path': 'zope.app.apidoc.doctest.MyFooBar',\n   'url': 'Code/zope/app/apidoc/doctest/MyFooBar',\n   'url_name': b'X19ub25hbWVfXw=='}\n\n\n================================\n Interface Inspection Utilities\n================================\n\nThis document is a presentation of the utility functions provided by\n\n  >>> from zope.app.apidoc import interface\n\nFor the following demonstrations, we need a nice interface that we can inspect:\n\n  >>> from zope.interface import Interface, Attribute\n  >>> from zope.schema import Field, TextLine\n\n  >>> class IFoo(Interface):\n  ...     foo = Field(title=u\"Foo\")\n  ...\n  ...     bar = TextLine(title=u\"Bar\",\n  ...                    description=u\"The Bar\",\n  ...                    required=True,\n  ...                    default=u\"My Bar\")\n  ...\n  ...     baz = Attribute('baz',\n  ...                     'This is the baz attribute')\n  ...\n  ...     def blah(one, two, three=None, *args, **kwargs):\n  ...         \"\"\"This is the `blah` method.\"\"\"\n\n\n``getElements(iface, type=IElement)``\n=====================================\n\nReturn a dictionary containing all elements in an interface. The type\nspecifies whether we are looking for attributes, fields or methods. So let's\nlook at an example.\n\nFirst, let's get the methods of an interface:\n\n  >>> from zope.interface.interfaces import IMethod\n  >>> sorted(interface.getElements(IFoo, type=IMethod).keys())\n  ['blah']\n\nand now the fields:\n\n  >>> from zope.schema.interfaces import IField\n  >>> names = sorted(interface.getElements(IFoo, type=IField).keys())\n  >>> names\n  ['bar', 'foo']\n\nWe can also get all attributes of course.\n\n  >>> from zope.interface.interfaces import IAttribute\n  >>> names = sorted(interface.getElements(IFoo, type=IAttribute).keys())\n  >>> names\n  ['bar', 'baz', 'blah', 'foo']\n\nYou might be surprised by the above result, since the fields and methods are\nagain included. However, fields and methods are just attributes and thus\nextend the simple attribute implementation. If you want to get a list of\nattributes that does not include fields and methods, see the\n``getAttributes(iface)`` function.\n\nThe default type is ``IElement`` which will simply return all elements of the\ninterface:\n\n  >>> names = sorted(interface.getElements(IFoo).keys())\n  >>> names\n  ['bar', 'baz', 'blah', 'foo']\n\nNote: The interface you pass to this function *cannot* be proxied!\nPresentation code often like to wrap interfaces in security proxies and apidoc\neven uses location proxies for interface.\n\n\n``getFieldsInOrder(iface, _itemkey=...)``\n=========================================\n\nFor presentation purposes we often want fields to have the a certain order,\nmost comonly the order they have in the interface. This function returns a\nlist of (name, field) tuples in a specified order.\n\nThe ``_itemkey`` argument provides the function that is used to extract\nthe key on which to order the fields. The default function, which\nuses the fields' ``order`` attribute, should be the correct one for\n99% of your needs.\n\nReusing the interface created above, we check the output:\n\n  >>> [n for n, a in interface.getFieldsInOrder(IFoo)]\n  ['foo', 'bar']\n\nBy changing the sort method to sort by names, we get:\n\n  >>> [n for n, a in interface.getFieldsInOrder(\n  ...       IFoo, _itemkey=lambda x: x[0])]\n  ['bar', 'foo']\n\n\n``getAttributes(iface)``\n========================\n\nThis function returns a (name, attr) tuple for every attribute in the\ninterface. Note that this function will only return pure attributes; it\nignores methods and fields.\n\n  >>> attrs = interface.getAttributes(IFoo)\n  >>> attrs.sort()\n  >>> attrs\n  [('baz', <zope.interface.interface.Attribute object at ...>)]\n\n\n``getMethods(iface)``\n=====================\n\nThis function returns a (name, method) tuple for every declared method in the\ninterface.\n\n  >>> methods = sorted(interface.getMethods(IFoo))\n  >>> methods\n  [('blah', <zope.interface.interface.Method object at ...>)]\n\n\n``getFields(iface)``\n====================\n\nThis function returns a (name, field) tuple for every declared field in the\ninterface.\n\n  >>> sorted(interface.getFields(IFoo))\n  [('bar', <zope.schema._bootstrapfields.TextLine object at ...>),\n   ('foo', <zope.schema._bootstrapfields.Field object at ...>)]\n\nNote that this returns the same result as ``getFieldsInOrder()`` with the fields\nsorted by their ``order`` attribute, except that you cannot specify the sort\nfunction here. This function was mainly provided for symmetry with the other\nfunctions.\n\n\n``getInterfaceTypes(iface)``\n============================\n\nInterfaces can be categorized/grouped by using interface types. Interface\ntypes simply extend ``zope.interface.interfaces.IInterface``, which are\nbasically meta-interfaces. The interface types are then provided by particular\ninterfaces.\n\nThe ``getInterfaceTypes()`` function returns a list of interface types that are\nprovided for the specified interface. Note that you commonly expect only one\ntype per interface, though.\n\nBefore we assign any type to our ``IFoo`` interface, there are no types\ndeclared.\n\n  >>> interface.getInterfaceTypes(IFoo)\n  []\n\nNow we define a new type called ``IContentType``\n\n  >>> from zope.interface.interfaces import IInterface\n  >>> class IContentType(IInterface):\n  ...     pass\n\nand have our interface provide it:\n\n  >>> from zope.interface import directlyProvides\n  >>> directlyProvides(IFoo, IContentType)\n\nNote that ZCML has some more convenient methods of doing this. Now let's get\nthe interface types again:\n\n  >>> interface.getInterfaceTypes(IFoo)\n  [<InterfaceClass zope.app.apidoc.doctest.IContentType>]\n\nAgain note that the interface passed to this function *cannot* be proxied,\notherwise this method will pick up the proxy's interfaces as well.\n\n\n``getFieldInterface(field)``\n============================\n\nThis function tries pretty hard to determine the best-matching interface that\nrepresents the field. Commonly the field class has the same name as the field\ninterface (minus an \"I\"). So this is our first choice:\n\n  >>> from zope.schema import Text, Int\n  >>> interface.getFieldInterface(Text())\n  <InterfaceClass zope.schema.interfaces.IText>\n\n  >>> interface.getFieldInterface(Int())\n  <InterfaceClass zope.schema.interfaces.IInt>\n\nIf the name matching method fails, it picks the first interface that extends\n``IField``:\n\n  >>> from zope.schema.interfaces import IField\n  >>> class ISpecialField(IField):\n  ...     pass\n  >>> class ISomething(Interface):\n  ...     pass\n\n  >>> from zope.interface import implementer\n  >>> @implementer(ISomething, ISpecialField)\n  ... class MyField:\n  ...     pass\n\n  >>> interface.getFieldInterface(MyField())\n  <InterfaceClass zope.app.apidoc.doctest.ISpecialField>\n\n\n``getAttributeInfoDictionary(attr, format='restructuredtext')``\n===============================================================\n\nThis function returns a page-template-friendly dictionary for a simple\nattribute:\n\n  >>> from pprint import pprint\n  >>> pprint(interface.getAttributeInfoDictionary(IFoo['baz']))\n  {'doc': u'<p>This is the baz attribute</p>\\n',\n   'name': 'baz'}\n\n\n``getMethodInfoDictionary(method, format='restructuredtext')``\n==============================================================\n\nThis function returns a page-template-friendly dictionary for a method:\n\n  >>> pprint(interface.getMethodInfoDictionary(IFoo['blah'])) #doc\n  {'doc':\n     u'<p>This is the <cite>blah</cite> method.</p>\\n',\n   'name': 'blah',\n   'signature': '(one, two, three=None, *args, **kwargs)'}\n\n\n``getFieldInfoDictionary(field, format='restructuredtext')``\n============================================================\n\nThis function returns a page-template-friendly dictionary for a field:\n\n  >>> pprint(interface.getFieldInfoDictionary(IFoo['bar']), width=50)\n  {'class': {'name': 'TextLine',\n             'path': 'zope/schema/_bootstrapfields/TextLine'},\n   'default': \"u'My Bar'\",\n   'description': u'<p>The Bar</p>\\n',\n   'iface': {'id': 'zope.schema.interfaces.ITextLine',\n             'name': 'ITextLine'},\n   'name': 'bar',\n   'required': True,\n   'required_string': u'required',\n   'title': u'Bar'}\n\n\n===================================\n Presentation Inspection Utilities\n===================================\n\nThe ``presentation`` module provides some nice utilities to inspect presentation\nregistrations.\n\n  >>> from zope.app.apidoc import presentation\n\n\n``getViewFactoryData(factory)``\n===============================\n\nThis function tries really hard to determine the correct information about a\nview factory. For example, when you create a page, a new type is dynamically\ngenerated upon registration. Let's look at a couple examples.\n\nFirst, let's inspect a case where a simple browser page was configured without\na special view class. In these cases the factory is a ``SimpleViewClass``:\n\n  >>> from zope.browserpage.simpleviewclass import SimpleViewClass\n  >>> view = SimpleViewClass('browser/index.pt')\n  >>> info = presentation.getViewFactoryData(view)\n\nBefore we can check the result, we have to make sure that all Windows paths\nare converted to Unix-like paths. We also clip off instance-specific parts of\nthe template path:\n\n  >>> info['template'] = info['template'].replace('\\\\', '/')[-32:]\n  >>> from pprint import pprint\n  >>> pprint(info)\n  {'path': 'zope.browserpage.simpleviewclass.simple',\n   'referencable': True,\n   'resource': None,\n   'template': 'zope/app/apidoc/browser/index.pt',\n   'template_obj': <BoundPageTemplateFile of None>,\n   'url': 'zope/browserpage/simpleviewclass/simple'}\n\nSo in the result above we see what the function returns. It is a dictionary\n(converted to a list for test purposes) that contains the Python path of the\nview class, a flag that specifies whether the factory can be referenced and\nthus be viewed by the class browser, the (page) template used for the view and\nthe URL under which the factory will be found in the class browser. Some\nviews, like icons, also use resources to provide their data. In these cases\nthe name of the resource will be provided. Of course, not in all cases all\nvalues will be available. Empty values are marked with ``None``.\n\nBelieve it or not, in some cases the factory is just a simple type. In these\ncases we cannot retrieve any useful information:\n\n  >>> info = presentation.getViewFactoryData(3)\n  >>> pprint(info)\n  {'path': '__builtin__.int',\n   'referencable': False,\n   'resource': None,\n   'template': None,\n   'url': None}\n\nIn some cases factories are callable class instances, where we cannot directly\nhave a referencable name, so we lookup the class and use its name:\n\n  >>> class Factory(object):\n  ...     pass\n\n  >>> info = presentation.getViewFactoryData(Factory())\n  >>> pprint(info)\n  {'path': 'zope.app.apidoc.doctest.Factory',\n   'referencable': True,\n   'resource': None,\n   'template': None,\n   'url': 'zope/app/apidoc/doctest/Factory'}\n\nOne of the more common cases, however, is that the factory is a class or\ntype. In this case we can just retrieve the reference directly:\n\n  >>> info = presentation.getViewFactoryData(Factory)\n  >>> pprint(info)\n  {'path': 'zope.app.apidoc.doctest.Factory',\n   'referencable': True,\n   'resource': None,\n   'template': None,\n   'url': 'zope/app/apidoc/doctest/Factory'}\n\nWhen factories are created by a directive, they can also be functions. In\nthose cases we just simply return the function path:\n\n  >>> def factory():\n  ...     pass\n\n  # The testing framework does not set the __module__ correctly\n  >>> factory.__module__ = 'zope.app.apidoc.doctest'\n\n  >>> info = presentation.getViewFactoryData(factory)\n  >>> pprint(info)\n  {'path': 'zope.app.apidoc.doctest.factory',\n   'referencable': True,\n   'resource': None,\n   'template': None,\n   'url': 'zope/app/apidoc/doctest/factory'}\n\nHowever, the function is rather unhelpful, since it will be the same for all\nviews that use that code path. For this reason the function keeps track of the\noriginal factory component in a function attribute called ``factory``:\n\n  >>> factory.factory = Factory\n\n  >>> info = presentation.getViewFactoryData(factory)\n  >>> pprint(info)\n  {'path': 'zope.app.apidoc.doctest.Factory',\n   'referencable': True,\n   'resource': None,\n   'template': None,\n   'url': 'zope/app/apidoc/doctest/Factory'}\n\nLet's now have a look at some extremly specific cases. If a view is registered\nusing the ``zope:view`` directive and a permission is specified, a\n``ProxyView`` class instance is created that references its original factory:\n\n  >>> class ProxyView(object):\n  ...\n  ...     def __init__(self, factory):\n  ...         self.factory = factory\n  >>> proxyView = ProxyView(Factory)\n\n  >>> info = presentation.getViewFactoryData(proxyView)\n  >>> pprint(info)\n  {'path': 'zope.app.apidoc.doctest.Factory',\n   'referencable': True,\n   'resource': None,\n   'template': None,\n   'url': 'zope/app/apidoc/doctest/Factory'}\n\nAnother use case is when a new type is created by the ``browser:page`` or\n``browser:view`` directive. In those cases the true/original factory is really\nthe first base class. Those cases are detected by inspecting the\n``__module__`` string of the type:\n\n  >>> new_class = type(Factory.__name__, (Factory,), {})\n  >>> new_class.__module__ = 'zope.app.publisher.browser.viewmeta'\n\n  >>> info = presentation.getViewFactoryData(new_class)\n  >>> pprint(info)\n  {'path': 'zope.app.apidoc.doctest.Factory',\n   'referencable': True,\n   'resource': None,\n   'template': None,\n   'url': 'zope/app/apidoc/doctest/Factory'}\n\nThe same sort of thing happens for XML-RPC views, except that those are\nwrapped twice:\n\n  >>> new_class = type(Factory.__name__, (Factory,), {})\n  >>> new_class.__module__ = 'zope.app.publisher.xmlrpc.metaconfigure'\n\n  >>> new_class2 = type(Factory.__name__, (new_class,), {})\n  >>> new_class2.__module__ = 'zope.app.publisher.xmlrpc.metaconfigure'\n\n  >>> info = presentation.getViewFactoryData(new_class2)\n  >>> pprint(info)\n  {'path': 'zope.app.apidoc.doctest.Factory',\n   'referencable': True,\n   'resource': None,\n   'template': None,\n   'url': 'zope/app/apidoc/doctest/Factory'}\n\nFinally, it sometimes happens that a factory is wrapped and the wrapper is\nwrapped in return:\n\n  >>> def wrapper1(*args):\n  ...     return Factory(*args)\n\n  >>> def wrapper2(*args):\n  ...     return wrapper1(*args)\n\nInitially, the documentation is not very helpful:\n\n  >>> info = presentation.getViewFactoryData(wrapper2)\n  >>> pprint(info)\n  {'path': 'zope.app.apidoc.doctest.wrapper2',\n   'referencable': True,\n   'resource': None,\n   'template': None,\n   'url': 'zope/app/apidoc/doctest/wrapper2'}\n\nHowever, if those wrappers play nicely, they provide a factory attribute each\nstep of the way ...\n\n  >>> wrapper1.factory = Factory\n  >>> wrapper2.factory = wrapper1\n\nand the result is finally our original factory:\n\n  >>> info = presentation.getViewFactoryData(wrapper2)\n  >>> pprint(info)\n  {'path': 'zope.app.apidoc.doctest.Factory',\n   'referencable': True,\n   'resource': None,\n   'template': None,\n   'url': 'zope/app/apidoc/doctest/Factory'}\n\n\n``getPresentationType(iface)``\n==============================\n\nIn Zope 3, presentation types (i.e. browser, ftp, ...) are defined through\ntheir special request interface, such as ``IBrowserRequest`` or\n``IFTPRequest``. To complicate matters further, layer interfaces are used in\nbrowser presentations to allow skinning. Layers extend any request type, but\nmost commonly ``IBrowserRequest``. This function inspects the request interface\nof any presentation multi-adapter and determines its type, which is returned\nin form of an interface.\n\n  >>> from zope.app.apidoc.presentation import getPresentationType\n  >>> from zope.publisher.interfaces.http import IHTTPRequest\n  >>> from zope.publisher.interfaces.browser import IBrowserRequest\n\n  >>> class ILayer1(IBrowserRequest):\n  ...     pass\n\n  >>> presentation.getPresentationType(ILayer1)\n  <InterfaceClass zope.publisher.interfaces.browser.IBrowserRequest>\n\n  >>> class ILayer2(IHTTPRequest):\n  ...     pass\n\n  >>> presentation.getPresentationType(ILayer2)\n  <InterfaceClass zope.publisher.interfaces.http.IHTTPRequest>\n\nIf the function cannot determine the presentation type, the interface itself\nis returned:\n\n  >>> from zope.interface import Interface\n  >>> class ILayer3(Interface):\n  ...     pass\n\n  >>> presentation.getPresentationType(ILayer3)\n  <InterfaceClass zope.app.apidoc.doctest.ILayer3>\n\nNote that more specific presentation types are considered first. For example,\n``IBrowserRequest`` extends ``IHTTPRequest``, but it will always determine the\npresentation type to be an ``IBrowserRequest``.\n\n\n``getViews(iface, type=IRequest)``\n==================================\n\nThis function retrieves all available view registrations for a given interface\nand presentation type. The default argument for the presentation type is\n``IRequest``, which will effectively return all views for the specified\ninterface.\n\nTo see how this works, we first have to register some views:\n\n  >>> class IFoo(Interface):\n  ...     pass\n\n  >>> from zope import component as ztapi\n  >>> ztapi.provideAdapter(adapts=(IFoo, IHTTPRequest), provides=Interface, factory=None, name='foo')\n  >>> ztapi.provideAdapter(adapts=(Interface, IHTTPRequest), provides=Interface, factory=None,\n  ...                      name='bar')\n  >>> ztapi.provideAdapter(adapts=(IFoo, IBrowserRequest), provides=Interface, factory=None,\n  ...                      name='blah')\n\nNow let's see what we've got. If we do not specify a type, all registrations\nshould be returned:\n\n  >>> regs = list(presentation.getViews(IFoo))\n  >>> regs.sort()\n  >>> regs\n  [AdapterRegistration(<BaseGlobalComponents base>,\n                       [IFoo, IBrowserRequest], Interface, 'blah', None, u''),\n   AdapterRegistration(<BaseGlobalComponents base>,\n                       [IFoo, IHTTPRequest], Interface, 'foo', None, u''),\n   AdapterRegistration(<BaseGlobalComponents base>,\n                       [Interface, IHTTPRequest], Interface, 'bar', None, u'')]\n\n  >>> regs = list(presentation.getViews(Interface, IHTTPRequest))\n  >>> regs.sort()\n  >>> regs\n  [AdapterRegistration(<BaseGlobalComponents base>,\n                       [Interface, IHTTPRequest], Interface, 'bar', None, u'')]\n\n\n``filterViewRegistrations(regs, iface, level=SPECIFC_INTERFACE_LEVEL)``\n=======================================================================\n\nOftentimes the amount of views that are being returned for a particular\ninterface are too much to show at once. It is then good to split the view into\ncategories. The ``filterViewRegistrations()`` function allows you to filter the\nviews on how specific they are to the interface. Here are the three levels you\ncan select from:\n\n  * SPECIFC_INTERFACE_LEVEL -- Only return registrations that require the\n                               specified interface directly.\n\n  * EXTENDED_INTERFACE_LEVEL -- Only return registrations that require an\n                                interface that the specified interface extends.\n\n  * GENERIC_INTERFACE_LEVEL -- Only return registrations that explicitely\n                               require the ``Interface`` interface.\n\nSo, let's see how this is done. We first need to create a couple of interfaces\nand register some views:\n\n  >>> class IContent(Interface):\n  ...     pass\n  >>> class IFile(IContent):\n  ...     pass\n\n  Clear out the registries first, so we know what we have.\n  >>> from zope.testing.cleanup import cleanUp\n  >>> cleanUp()\n\n  >>> ztapi.provideAdapter(adapts=(IContent, IHTTPRequest), provides=Interface,\n  ...                      factory=None, name='view.html')\n  >>> ztapi.provideAdapter(adapts=(IContent, IHTTPRequest), provides=Interface,\n  ...                      factory=None, name='edit.html')\n  >>> ztapi.provideAdapter(adapts=(IFile, IHTTPRequest), provides=Interface,\n  ...                      factory=None, name='view.html')\n  >>> ztapi.provideAdapter(adapts=(Interface, IHTTPRequest), provides=Interface,\n  ...                      factory=None, name='view.html')\n\nNow we get all the registrations:\n\n  >>> regs = list(presentation.getViews(IFile, IHTTPRequest))\n\nLet's now filter those registrations:\n\n  >>> result = list(presentation.filterViewRegistrations(\n  ...     regs, IFile, level=presentation.SPECIFIC_INTERFACE_LEVEL))\n  >>> result.sort()\n  >>> result\n  [AdapterRegistration(<BaseGlobalComponents base>,\n                     [IFile, IHTTPRequest], Interface, 'view.html', None, u'')]\n\n  >>> result = list(presentation.filterViewRegistrations(\n  ...     regs, IFile, level=presentation.EXTENDED_INTERFACE_LEVEL))\n  >>> result.sort()\n  >>> result\n  [AdapterRegistration(<BaseGlobalComponents base>,\n                  [IContent, IHTTPRequest], Interface, 'edit.html', None, u''),\n   AdapterRegistration(<BaseGlobalComponents base>,\n                  [IContent, IHTTPRequest], Interface, 'view.html', None, u'')]\n\n  >>> result = list(presentation.filterViewRegistrations(\n  ...     regs, IFile, level=presentation.GENERIC_INTERFACE_LEVEL))\n  >>> result.sort()\n  >>> result\n  [AdapterRegistration(<BaseGlobalComponents base>,\n                 [Interface, IHTTPRequest], Interface, 'view.html', None, u'')]\n\nYou can also specify multiple levels at once using the Boolean OR operator,\nsince all three levels are mutually exclusive.\n\n  >>> result = list(presentation.filterViewRegistrations(\n  ...     regs, IFile, level=presentation.SPECIFIC_INTERFACE_LEVEL |\n  ...                        presentation.EXTENDED_INTERFACE_LEVEL))\n  >>> result.sort()\n  >>> result\n  [AdapterRegistration(<BaseGlobalComponents base>,\n                  [IContent, IHTTPRequest], Interface, 'edit.html', None, u''),\n   AdapterRegistration(<BaseGlobalComponents base>,\n                  [IContent, IHTTPRequest], Interface, 'view.html', None, u''),\n   AdapterRegistration(<BaseGlobalComponents base>,\n                  [IFile, IHTTPRequest], Interface, 'view.html', None, u'')]\n\n  >>> result = list(presentation.filterViewRegistrations(\n  ...     regs, IFile, level=presentation.SPECIFIC_INTERFACE_LEVEL |\n  ...                        presentation.GENERIC_INTERFACE_LEVEL))\n  >>> result.sort()\n  >>> result\n  [AdapterRegistration(<BaseGlobalComponents base>,\n                [IFile, IHTTPRequest], Interface, 'view.html', None, u''),\n   AdapterRegistration(<BaseGlobalComponents base>,\n                [Interface, IHTTPRequest], Interface, 'view.html', None, u'')]\n\n\n``getViewInfoDictionary(reg)``\n==============================\n\nNow that we have all these utilities to select the registrations, we need to\nprepare the them for output. For page templates the best data structures are\ndictionaries and tuples/lists. This utility will generate an informational\ndictionary for the specified registration.\n\nLet's first create a registration:\n\n  >>> from zope.component.registry import AdapterRegistration\n  >>> reg = AdapterRegistration(None, (IFile, Interface, IHTTPRequest),\n  ...                           Interface, 'view.html', Factory, 'reg info')\n\n  >>> pprint(presentation.getViewInfoDictionary(reg), width=50)\n  {'doc': 'reg info',\n   'factory': {'path': 'zope.app.apidoc.doctest.Factory',\n               'referencable': True,\n               'resource': None,\n               'template': None,\n               'url': 'zope/app/apidoc/doctest/Factory'},\n   'name': u'view.html',\n   'provided': {'module': 'zope.interface',\n                'name': 'Interface'},\n   'read_perm': None,\n   'required': [{'module': 'zope.app.apidoc.doctest',\n                 'name': 'IFile'},\n                {'module': 'zope.interface',\n                 'name': 'Interface'},\n                {'module': 'zope.publisher.interfaces.http',\n                 'name': 'IHTTPRequest'}],\n   'type': 'zope.publisher.interfaces.http.IHTTPRequest',\n   'write_perm': None,\n   'zcml': None}\n\n\n=========================\n Miscellaneous Utilities\n=========================\n\nThe utilities module provides some useful helper functions and classes that\nmake the work of the API doctool and inspection code easier.\n\n  >>> from zope.app.apidoc import utilities\n\n\n``relativizePath(path)``\n========================\n\nWhen dealing with files, such as page templates and text files, and not with\nPython paths, it is necessary to keep track of the the absolute path of the\nfile. However, for presentation purposes, the absolute path is inappropriate\nand we are commonly interested in the path starting at the Zope 3 root\ndirectory. This function attempts to remove the absolute path to the root\ndirectory and replaces it with \"Zope3\".\n\n  >>> import os\n  >>> path = os.path.join(os.path.dirname(utilities.__file__), 'README.txt')\n\n  >>> path = utilities.relativizePath(path)\n\n  # Be kind to Windows users\n  >>> path.replace('\\\\', '/')\n  'Zope3/zope/app/apidoc/README.txt'\n\nIf the base path is not found in a particular path, the original path is\nreturned:\n\n  >>> otherpath = 'foo/bar/blah.txt'\n  >>> utilities.relativizePath(otherpath)\n  'foo/bar/blah.txt'\n\n\n``truncateSysPath(path)``\n=========================\n\nIn some cases it is useful to just know the path after the sys path of a\nmodule. For example, you have a path of a file in a module. To look up the\nmodule, the simplest to do is to retrieve the module path and look into the\nsystem's modules list.\n\n  >>> import sys\n  >>> sysBase = sys.path[0]\n\n  >>> utilities.truncateSysPath(sysBase + '/some/module/path')\n  'some/module/path'\n\nIf there is no matching system path, then the whole path is returned:\n\n  >>> utilities.truncateSysPath('some/other/path')\n  'some/other/path'\n\n\n``ReadContainerBase`` (Class)\n=============================\n\nThis class serves as a base class for ``IReadContainer`` objects that minimizes\nthe implementation of an ``IReadContainer`` to two methods, ``get()`` and\n``items()``, since the other methods can be implemented using these two.\n\nNote that this implementation might be very expensive for certain container,\nespecially if collecting the items is of high order. However, there are many\nscenarios when one has a complete mapping already and simply want to persent\nit as an ``IReadContainer``.\n\nLet's start by making a simple ``IReadContainer`` implementation using the\nclass:\n\n  >>> class Container(utilities.ReadContainerBase):\n  ...     def get(self, key, default=None):\n  ...         return {'a': 1, 'b': 2}.get(key, default)\n  ...     def items(self):\n  ...         return [('a', 1), ('b', 2)]\n\n  >>> container = Container()\n\nNow we can use the methods. First ``get()``\n\n  >>> container.get('a')\n  1\n  >>> container.get('c') is None\n  True\n  >>> container['b']\n  2\n\nand then ``items()``\n\n  >>> container.items()\n  [('a', 1), ('b', 2)]\n  >>> container.keys()\n  ['a', 'b']\n  >>> container.values()\n  [1, 2]\n\nThen naturally, all the other methods work as well:\n\n  * ``__getitem__(key)``\n\n    >>> container['a']\n    1\n    >>> container['c']\n    Traceback (most recent call last):\n    ...\n    KeyError: 'c'\n\n  * ``__contains__(key)``\n\n    >>> 'a' in container\n    True\n    >>> 'c' in container\n    False\n\n  * ``keys()``\n\n    >>> container.keys()\n    ['a', 'b']\n\n  * ``__iter__()``\n\n    >>> iterator = iter(container)\n    >>> next(iterator)\n    1\n    >>> next(iterator)\n    2\n    >>> next(iterator)\n    Traceback (most recent call last):\n    ...\n    StopIteration\n\n  * ``values()``\n\n    >>> container.values()\n    [1, 2]\n\n  * ``__len__()``\n\n    >>> len(container)\n    2\n\n\n``getPythonPath(obj)``\n======================\n\nReturn the path of the object in standard Python dot-notation.\n\nThis function makes only sense for objects that provide a name, since we\ncannot determine the path otherwise. Instances, for example, do not have a\n``__name__`` attribute, so we would expect them to fail.\n\nFor interfaces we simply get\n\n  >>> from zope.interface import Interface\n  >>> class ISample(Interface):\n  ...     pass\n\n  >>> utilities.getPythonPath(ISample)\n  'zope.app.apidoc.doctest.ISample'\n\nand for classes we get the name of the class\n\n  >>> class Sample(object):\n  ...     def sample(self):\n  ...         pass\n\n  >>> utilities.getPythonPath(Sample)\n  'zope.app.apidoc.doctest.Sample'\n\nIf a method is passed in, its class path is returned. This works for\nboth bound and unbound methods (note that there is no such thing as an\nunbound method in Python 3, just functions, but we still get the same\nresults):\n\n  >>> utilities.getPythonPath(Sample().sample)\n  'zope.app.apidoc.doctest.Sample'\n  >>> utilities.getPythonPath(Sample.sample)\n  'zope.app.apidoc.doctest.Sample'\n\nPlain functions are also supported:\n\n  >>> def sample():\n  ...     pass\n\n  >>> utilities.getPythonPath(sample)\n  'zope.app.apidoc.doctest.sample'\n\nModules are another kind of objects that can return a python path:\n\n  >>> utilities.getPythonPath(utilities)\n  'zope.app.apidoc.utilities'\n\nPassing in ``None`` returns ``None``:\n\n  >>> utilities.getPythonPath(None)\n\nClearly, instance lookups should fail:\n\n  >>> utilities.getPythonPath(Sample())\n  Traceback (most recent call last):\n  ...\n  AttributeError: 'Sample' object has no attribute '__name__'\n\n\n``isReferencable(path)``\n========================\n\nDetermine whether a path can be referenced in the API doc, usually by the code\nbrowser module. Initially you might think that all objects that have paths can\nbe referenced somehow. But that's not true, partially by design of apidoc, but\nalso due to limitations of the Python language itself.\n\nFirst, here are some cases that work:\n\n  >>> utilities.isReferencable('zope')\n  True\n  >>> utilities.isReferencable('zope.app')\n  True\n  >>> utilities.isReferencable('zope.app.apidoc.apidoc.APIDocumentation')\n  True\n  >>> utilities.isReferencable('zope.app.apidoc.apidoc.handleNamespace')\n  True\n\nThe first case is ``None``. When you ask for the python path of ``None``, you\nget ``None``, so that result should not be referencable:\n\n  >>> utilities.isReferencable(None)\n  False\n\nBy design we also do not document any private classes and functions:\n\n  >>> utilities.isReferencable('some.path.to._Private')\n  False\n  >>> utilities.isReferencable('some.path.to.__Protected')\n  False\n  >>> utilities.isReferencable('zope.app.apidoc.__doc__')\n  True\n\nSome objects might fake their module name, so that it does not exist:\n\n  >>> utilities.isReferencable('foo.bar')\n  False\n\nOn the other hand, you might have a valid module, but non-existent attribute:\n\n  >>> utilities.isReferencable('zope.app.apidoc.MyClass')\n  False\n\nNote that this case is also used for types that are generated using the\n``type()`` function:\n\n  >>> mytype = type('MyType', (object,), {})\n  >>> path = utilities.getPythonPath(mytype)\n  >>> path\n  'zope.app.apidoc.doctest.MyType'\n\n  >>> utilities.isReferencable(path)\n  False\n\nNext, since API doc does not allow the documentation of instances yet, it\nis not possible to document singletons, so they are not referencable:\n\n  >>> class Singelton(object):\n  ...     pass\n\n  >>> utilities.isReferencable('zope.app.apidoc.doctest.Singelton')\n  True\n\n  >>> Singelton = Singelton()\n\n  >>> utilities.isReferencable('zope.app.apidoc.doctest.Singelton')\n  False\n\nFinally, the global ``IGNORE_MODULES`` list from the class registry is also\nused to give a negative answer. If a module is listed in ``IGNORE_MODULES``,\nthen ``False`` is returned.\n\n  >>> from zope.app.apidoc import classregistry\n  >>> classregistry.IGNORE_MODULES.append('zope.app.apidoc')\n\n  >>> utilities.isReferencable('zope.app')\n  True\n  >>> utilities.isReferencable('zope.app.apidoc')\n  False\n  >>> utilities.isReferencable('zope.app.apidoc.apidoc.APIDocumentation')\n  False\n\n  >>> classregistry.IGNORE_MODULES.pop()\n  'zope.app.apidoc'\n  >>> utilities.isReferencable('zope.app.apidoc')\n  True\n\n\n``getPermissionIds(name, checker=_marker, klass=_marker)``\n==========================================================\n\nGet the permissions of a class attribute. The attribute is specified by name.\n\nEither the ``klass`` or the ``checker`` argument must be specified. If the class\nis specified, then the checker for it is looked up. Furthermore, this function\nonly works with ``INameBasedChecker`` checkers. If another checker is found,\n``None`` is returned for the permissions.\n\nWe start out by defining the class and then the checker for it:\n\n  >>> from zope.security.checker import Checker, defineChecker\n  >>> from zope.security.checker import CheckerPublic\n\n  >>> class Sample(object):\n  ...     attr = 'value'\n  ...     attr3 = 'value3'\n\n  >>> class Sample2(object):\n  ...      pass\n\n  >>> checker = Checker({'attr': 'zope.Read', 'attr3': CheckerPublic},\n  ...                   {'attr': 'zope.Write', 'attr3': CheckerPublic})\n  >>> defineChecker(Sample, checker)\n\nNow let's see how this function works:\n\n  >>> entries = utilities.getPermissionIds('attr', klass=Sample)\n  >>> entries['read_perm']\n  'zope.Read'\n  >>> entries['write_perm']\n  'zope.Write'\n\n  >>> from zope.security.checker import getCheckerForInstancesOf\n  >>> entries = utilities.getPermissionIds('attr',\n  ...                                      getCheckerForInstancesOf(Sample))\n  >>> entries['read_perm']\n  'zope.Read'\n  >>> entries['write_perm']\n  'zope.Write'\n\nThe ``Sample`` class does not know about the ``attr2`` attribute:\n\n  >>> entries = utilities.getPermissionIds('attr2', klass=Sample)\n  >>> print(entries['read_perm'])\n  n/a\n  >>> print(entries['write_perm'])\n  n/a\n\nThe ``Sample2`` class does not have a checker:\n\n  >>> entries = utilities.getPermissionIds('attr', klass=Sample2)\n  >>> entries['read_perm'] is None\n  True\n  >>> entries['write_perm'] is None\n  True\n\nFinally, the ``Sample`` class' ``attr3`` attribute is public:\n\n  >>> entries = utilities.getPermissionIds('attr3', klass=Sample)\n  >>> print(entries['read_perm'])\n  zope.Public\n  >>> print(entries['write_perm'])\n  zope.Public\n\n\n``getFunctionSignature(func)``\n==============================\n\nReturn the signature of a function or method. The ``func`` argument *must* be a\ngeneric function or a method of a class.\n\nFirst, we get the signature of a function that has a specific positional and\nkeyword argument:\n\n  >>> def func(attr, attr2=None):\n  ...     pass\n  >>> utilities.getFunctionSignature(func)\n  '(attr, attr2=None)'\n\nHere is a function that has an unspecified amount of keyword arguments:\n\n  >>> def func(attr, **kw):\n  ...     pass\n  >>> utilities.getFunctionSignature(func)\n  '(attr, **kw)'\n\nAnd here we mix specified and unspecified keyword arguments:\n\n  >>> def func(attr, attr2=None, **kw):\n  ...     pass\n  >>> utilities.getFunctionSignature(func)\n  '(attr, attr2=None, **kw)'\n\nIn the next example we have unspecified positional and keyword arguments:\n\n  >>> def func(*args, **kw):\n  ...     pass\n  >>> utilities.getFunctionSignature(func)\n  '(*args, **kw)'\n\nAnd finally an example, where we have on unspecified keyword arguments without\nany positional arguments:\n\n  >>> def func(**kw):\n  ...     pass\n  >>> utilities.getFunctionSignature(func)\n  '(**kw)'\n\nNext we test whether the signature is correctly determined for class\nmethods. Note that the ``self`` argument is removed from the signature, since it\nis not essential for documentation; this happens by default on Python\n2 for unbound methods, but since Python 3 doesn't have such a concept\nwe have to explicitly ask for that behaviour:\n\nWe start out with a simple positional argument:\n\n  >>> class Klass(object):\n  ...     def func(self, attr):\n  ...         pass\n  >>> utilities.getFunctionSignature(Klass.func, ignore_self=True)\n  '(attr)'\n  >>> utilities.getFunctionSignature(Klass().func)\n  '(attr)'\n\nNext we have specific and unspecified positional arguments as well as\nunspecified keyword arguments:\n\n  >>> class Klass(object):\n  ...     def func(self, attr, *args, **kw):\n  ...         pass\n  >>> utilities.getFunctionSignature(Klass().func, ignore_self=True)\n  '(attr, *args, **kw)'\n  >>> utilities.getFunctionSignature(Klass().func)\n  '(attr, *args, **kw)'\n\nIf you do not pass a function or method to the function, it will fail:\n\n  >>> utilities.getFunctionSignature('func')\n  Traceback (most recent call last):\n  ...\n  TypeError: func must be a function or method not a ...\n\nA very uncommon, but perfectly valid (in Python 2), case is that tuple arguments are\nunpacked inside the argument list of the function. Here is an example\n(we can't actually test it because it fails on Python 3)::\n\n  def func((arg1, arg2)):\n       pass\n  utilities.getFunctionSignature(func)\n  '((arg1, arg2))'\n\nEven default assignment is allowed::\n\n  def func((arg1, arg2)=(1, 2)):\n       pass\n  utilities.getFunctionSignature(func)\n  '((arg1, arg2)=(1, 2))'\n\nHowever, lists of this type are not allowed inside the argument list::\n\n  >>> def func([arg1, arg2]):\n  ...     pass\n  Traceback (most recent call last):\n  ...\n  SyntaxError: invalid syntax\n\nInternal assignment is also not legal::\n\n  >>> def func((arg1, arg2=1)):\n  ...     pass\n  Traceback (most recent call last):\n  ...\n  SyntaxError: invalid syntax\n\n\n``getPublicAttributes(obj)``\n============================\n\nReturn a list of public attribute names for a given object.\n\nThis excludes any attribute starting with '_', which includes attributes of\nthe form ``__attr__``, which are commonly considered public, but they are so\nspecial that they are excluded. The ``obj`` argument can be either a classic\nclass, type or instance of the previous two. Note that the term \"attributes\"\nhere includes methods and properties.\n\nFirst we need to create a class with some attributes, properties and methods:\n\n  >>> class Nonattr(object):\n  ...     def __get__(*a):\n  ...         raise AttributeError('nonattr')\n\n  >>> class Sample(object):\n  ...     attr = None\n  ...     def __str__(self):\n  ...         return ''\n  ...     def func(self):\n  ...         pass\n  ...     def _getAttr(self):\n  ...         return self.attr\n  ...     attr2 = property(_getAttr)\n  ...\n  ...     nonattr = Nonattr() # Should not show up in public attrs\n\nWe can simply pass in the class and get the public attributes:\n\n  >>> attrs = utilities.getPublicAttributes(Sample)\n  >>> attrs.sort()\n  >>> attrs\n  ['attr', 'attr2', 'func']\n\nNote that we exclude attributes that would raise attribute errors,\nlike our silly Nonattr.\n\nBut an instance of that class will work as well.\n\n  >>> attrs = utilities.getPublicAttributes(Sample())\n  >>> attrs.sort()\n  >>> attrs\n  ['attr', 'attr2', 'func']\n\nThe function will also take inheritance into account and return all inherited\nattributes as well:\n\n  >>> class Sample2(Sample):\n  ...     attr3 = None\n\n  >>> attrs = utilities.getPublicAttributes(Sample2)\n  >>> attrs.sort()\n  >>> attrs\n  ['attr', 'attr2', 'attr3', 'func']\n\n\n``getInterfaceForAttribute(name, interfaces=_marker, klass=_marker, asPath=True)``\n==================================================================================\n\nDetermine the interface in which an attribute is defined. This function is\nnice, if you have an attribute name which you retrieved from a class and want\nto know which interface requires it to be there.\n\nEither the ``interfaces`` or ``klass`` argument must be specified. If ``interfaces``\nis not specified, the ``klass`` is used to retrieve a list of\ninterfaces. ``interfaces`` must be iterable.\n\n``asPath`` specifies whether the dotted name of the interface or the interface\nobject is returned.\n\nFirst, we need to create some interfaces and a class that implements them:\n\n  >>> from zope.interface import Interface, Attribute, implementer\n  >>> class I1(Interface):\n  ...     attr = Attribute('attr')\n\n  >>> class I2(I1):\n  ...     def getAttr():\n  ...         '''get attr'''\n\n  >>> @implementer(I2)\n  ... class Sample(object):\n  ...    pass\n\nFirst we check whether an aatribute can be found in a list of interfaces:\n\n  >>> utilities.getInterfaceForAttribute('attr', (I1, I2), asPath=False)\n  <InterfaceClass zope.app.apidoc.doctest.I1>\n  >>> utilities.getInterfaceForAttribute('getAttr', (I1, I2), asPath=False)\n  <InterfaceClass zope.app.apidoc.doctest.I2>\n\nNow we are repeating the same lookup, but using the class, instead of a list\nof interfaces:\n\n  >>> utilities.getInterfaceForAttribute('attr', klass=Sample, asPath=False)\n  <InterfaceClass zope.app.apidoc.doctest.I1>\n  >>> utilities.getInterfaceForAttribute('getAttr', klass=Sample, asPath=False)\n  <InterfaceClass zope.app.apidoc.doctest.I2>\n\nBy default, ``asPath`` is ``True``, which means the path of the interface is\nreturned:\n\n  >>> utilities.getInterfaceForAttribute('attr', (I1, I2))\n  'zope.app.apidoc.doctest.I1'\n\nIf no match is found, ``None`` is returned.\n\n  >>> utilities.getInterfaceForAttribute('attr2', (I1, I2)) is None\n  True\n  >>> utilities.getInterfaceForAttribute('attr2', klass=Sample) is None\n  True\n\nIf both, the ``interfaces`` and ``klass`` argument are missing, raise an error:\n\n  >>> utilities.getInterfaceForAttribute('getAttr')\n  Traceback (most recent call last):\n  ...\n  ValueError: need to specify interfaces or klass\n\nSimilarly, it does not make sense if both are specified:\n\n  >>> utilities.getInterfaceForAttribute('getAttr', interfaces=(I1,I2),\n  ...                                    klass=Sample)\n  Traceback (most recent call last):\n  ...\n  ValueError: must specify only one of interfaces and klass\n\n\n``columnize(entries, columns=3)``\n=================================\n\nThis function places a list of entries into columns.\n\nHere are some examples:\n\n  >>> utilities.columnize([1], 3)\n  [[1]]\n\n  >>> utilities.columnize([1, 2], 3)\n  [[1], [2]]\n\n  >>> utilities.columnize([1, 2, 3], 3)\n  [[1], [2], [3]]\n\n  >>> utilities.columnize([1, 2, 3, 4], 3)\n  [[1, 2], [3], [4]]\n\n  >>> utilities.columnize([1], 2)\n  [[1]]\n\n  >>> utilities.columnize([1, 2], 2)\n  [[1], [2]]\n\n  >>> utilities.columnize([1, 2, 3], 2)\n  [[1, 2], [3]]\n\n  >>> utilities.columnize([1, 2, 3, 4], 2)\n  [[1, 2], [3, 4]]\n\n\n``getDocFormat(module)``\n========================\n\nThis function inspects a module to determine the supported documentation\nformat. The function returns a valid renderer source factory id.\n\nIf the ``__docformat__`` module attribute is specified, its value will be used\nto look up the factory id:\n\n  >>> from zope.app.apidoc import apidoc\n  >>> utilities.getDocFormat(apidoc)\n  'zope.source.rest'\n\nBy default restructured text is returned:\n\n  >>> utilities.getDocFormat(object())\n  'zope.source.rest'\n\nThis is a sensible default since much documentation is now written\nwith Sphinx in mind (which of course defaults to rendering\nrestructured text). As long as docutils' error reporting level is set\nsufficiently high (``severe``), unknown Sphinx directives and slightly\nmalformed markup do not produce error messages, either on the console\nor in the generated HTML.\n\nThe ``__docformat__`` attribute can also optionally specify a language field. We\nsimply ignore it:\n\n  >>> class Module(object):\n  ...     pass\n  >>> module = Module()\n  >>> module.__docformat__ = 'structuredtext en'\n  >>> utilities.getDocFormat(module)\n  'zope.source.stx'\n\n\n``dedentString(text)``\n======================\n\nBefore doc strings can be processed using STX or ReST they must be dendented,\nsince otherwise the output will be incorrect. Let's have a look at some\ndocstrings and see how they are correctly dedented.\n\nLet's start with a simple one liner. Nothing should happen:\n\n  >>> def func():\n  ...     '''One line documentation string'''\n\n  >>> utilities.dedentString(func.__doc__)\n  'One line documentation string'\n\nNow what about one line docstrings that start on the second line? While this\nformat is discouraged, it is frequently used:\n\n  >>> def func():\n  ...     '''\n  ...     One line documentation string\n  ...     '''\n\n  >>> utilities.dedentString(func.__doc__)\n  '\\nOne line documentation string\\n'\n\nWe can see that the leading whitespace on the string is removed, but not the\nnewline character. Let's now try a simple multi-line docstring:\n\n  >>> def func():\n  ...     '''Short description\n  ...\n  ...     Lengthy description, giving some more background information and\n  ...     discuss some edge cases.\n  ...     '''\n\n  >>> print(utilities.dedentString(func.__doc__))\n  Short description\n  <BLANKLINE>\n  Lengthy description, giving some more background information and\n  discuss some edge cases.\n  <BLANKLINE>\n\nAgain, the whitespace was removed only after the first line. Also note that\nthe function determines the indentation level correctly. So what happens if\nthere are multiple indentation levels? The smallest amount of indentation is\nchosen:\n\n  >>> def func():\n  ...     '''Short description\n  ...\n  ...     Root Level\n  ...\n  ...       Second Level\n  ...     '''\n\n  >>> print(utilities.dedentString(func.__doc__))\n  Short description\n  <BLANKLINE>\n  Root Level\n  <BLANKLINE>\n    Second Level\n  <BLANKLINE>\n\n  >>> def func():\n  ...     '''Short description\n  ...\n  ...       $$$ print 'example'\n  ...       example\n  ...\n  ...     And now the description.\n  ...     '''\n\n  >>> print(utilities.dedentString(func.__doc__))\n  Short description\n  <BLANKLINE>\n    $$$ print 'example'\n    example\n  <BLANKLINE>\n  And now the description.\n  <BLANKLINE>\n\n\n``renderText(text, module=None, format=None)``\n==============================================\n\nA function that quickly renders the given text using the specified format.\n\nIf the ``module`` argument is specified, the function will try to determine the\nformat using the module. If the ``format`` argument is given, it is simply\nused. Clearly, you cannot specify both, the ``module`` and ``format`` argument.\n\nYou specify the format as follows:\n\n  >>> utilities.renderText(u'Hello!\\n', format='zope.source.rest')\n  u'<p>Hello!</p>\\n'\n\nNote that the format string must be a valid source factory id; if the factory\nid is not given, 'zope.source.stx' is used. Thus, specifying the module is\noften safer (if available):\n\n  >>> utilities.renderText(u'Hello!\\n', module=apidoc)\n  u'<p>Hello!</p>\\n'\n\nByte input is accepted, so long as it can be decoded:\n\n  >>> utilities.renderText(b'Hello!\\n', module=apidoc)\n  u'<p>Hello!</p>\\n'\n\n\n====================\n The Class Registry\n====================\n\nThis little registry allows us to quickly query a complete list of classes\nthat are defined and used by Zope 3. The prime feature of the class is the\n``getClassesThatImplement(iface)`` method that returns all classes that\nimplement the passed interface. Another method, ``getSubclassesOf(klass)``\nreturns all registered subclassess of the given class.\n\nThe class registry, subclassing the dictionary type, can be instantiated like\nany other dictionary:\n\n  >>> from zope.app.apidoc.classregistry import ClassRegistry\n  >>> reg = ClassRegistry()\n\nLet's now add a couple of classes to registry. The classes should implement\nsome interfaces, so that we can test all methods on the class registry:\n\n  >>> from zope.interface import Interface, implementer\n\n  >>> class IA(Interface):\n  ...      pass\n  >>> class IB(IA):\n  ...      pass\n  >>> class IC(Interface):\n  ...      pass\n  >>> class ID(Interface):\n  ...      pass\n\n  >>> @implementer(IA)\n  ... class A(object):\n  ...    pass\n  >>> reg['A'] = A\n\n  >>> @implementer(IB)\n  ... class B: # Old style on Python 2\n  ...    pass\n  >>> reg['B'] = B\n\n  >>> @implementer(IB)\n  ... class B2(object):\n  ...    pass\n  >>> reg['B2'] = B2\n\n  >>> @implementer(IC)\n  ... class C(object):\n  ...    pass\n  >>> reg['C'] = C\n  >>> class A2(A):\n  ...    pass\n  >>> reg['A2'] = A2\n\nSince the registry is just a dictionary, we can ask for all its keys, which\nare the names of the classes:\n\n  >>> names = sorted(reg.keys())\n  >>> names\n  ['A', 'A2', 'B', 'B2', 'C']\n\n  >>> reg['A'] is A\n  True\n\nThere are two API methods specific to the class registry:\n\n``getClassesThatImplement(iface)``\n==================================\n\nThis method returns all classes that implement the specified interface:\n\n  >>> from pprint import pprint\n  >>> pprint(reg.getClassesThatImplement(IA))\n  [('A', <class 'zope.app.apidoc.doctest.A'>),\n   ('A2', <class 'zope.app.apidoc.doctest.A2'>),\n   ('B', <class 'zope.app.apidoc.doctest.B'>),\n   ('B2', <class 'zope.app.apidoc.doctest.B2'>)]\n\n  >>> pprint(reg.getClassesThatImplement(IB))\n  [('B', <class 'zope.app.apidoc.doctest.B'>),\n   ('B2', <class 'zope.app.apidoc.doctest.B2'>)]\n\n  >>> pprint(reg.getClassesThatImplement(IC))\n  [('C', <class 'zope.app.apidoc.doctest.C'>)]\n\n  >>> pprint(reg.getClassesThatImplement(ID))\n  []\n\n``getSubclassesOf(klass)``\n==========================\n\nThis method will find all classes that inherit the specified class:\n\n  >>> pprint(reg.getSubclassesOf(A))\n  [('A2', <class '...A2'>)]\n\n  >>> pprint(reg.getSubclassesOf(B))\n  []\n\n\nSafe Imports\n============\n\nUsing the ``safe_import()`` we can quickly look up modules by minimizing\nimport calls.\n\n  >>> from zope.app.apidoc import classregistry\n  >>> from zope.app.apidoc.classregistry import safe_import\n\nFirst we try to find the path in ``sys.modules``, since this lookup is much\nmore efficient than importing it. If it was not found, we go back and try\nto import the path. For security reasons, importing new modules is disabled by\ndefault, unless the global ``__import_unknown_modules__`` variable is set to\ntrue. If that also fails, we return the `default` value.\n\nHere are some examples::\n\n  >>> import sys\n  >>> 'zope.app' in sys.modules\n  True\n\n  >>> safe_import('zope.app') is sys.modules['zope.app']\n  True\n\n  >>> safe_import('weirdname') is None\n  True\n\nFor this example, we'll create a dummy module:\n\n  >>> import os\n  >>> import tempfile\n  >>> dir = tempfile.mkdtemp()\n  >>> filename = os.path.join(dir, 'testmodule.py')\n  >>> sys.path.insert(0, dir)\n  >>> with open(filename, 'w') as f:\n  ...     _ = f.write('# dummy module\\n')\n\nThe temporary module is not already imported:\n\n  >>> module_name = 'testmodule'\n  >>> module_name in sys.modules\n  False\n\nWhen we try ``safe_import()`` now, we will still get the `default` value,\nbecause importing new modules is disabled by default:\n\n  >>> safe_import(module_name) is None\n  True\n\nBut once we activate the ``__import_unknown_modules__`` hook, the module\nshould be imported:\n\n  >>> classregistry.__import_unknown_modules__ = True\n\n  >>> safe_import(module_name).__name__ == module_name\n  True\n  >>> module_name in sys.modules\n  True\n\nNow clean up the temporary module, just to play nice:\n\n  >>> del sys.modules[module_name]\n\nImporting some code we cannot control, such as twisted, might raise errors\nwhen imported without having a certain environment. In those cases, the safe\nimport should prevent the error from penetrating:\n\n  >>> with open(os.path.join(dir, 'alwaysfail.py'), 'w') as f:\n  ...     _ = f.write('raise ValueError\\n')\n  >>> sys.path.insert(0, dir)\n\n  >>> safe_import('alwaysfail') is None\n  True\n\nLet's clean up the python path and temporary files:\n\n  >>> del sys.path[0]\n  >>> import shutil\n  >>> shutil.rmtree(dir)\n\nAnother method to explicitely turning off the import of certain modules is to\ndeclare that they should be ignored. For example, if we tell the class\nregistry to ignore ``zope.app``,\n\n  >>> classregistry.IGNORE_MODULES.append('zope.app')\n\nthen we cannot import it anymore, even though we know it is available:\n\n  >>> safe_import('zope.app') is None\n  True\n\nNote that all sub-packages are also unavailable:\n\n  >>> safe_import('zope.app.apidoc') is None\n  True\n\nWe also need to play nice concerning variables and have to reset the module\nglobals:\n\n  >>> classregistry.IGNORE_MODULES.pop()\n  'zope.app'\n  >>> classregistry.__import_unknown_modules__ = False\n\n\n=========\n CHANGES\n=========\n\n4.0.0 (2017-05-25)\n==================\n\n- Add support for Python 3.4, 3.5, 3.6 and PyPy.\n\n- The long-deprecated layer configuration was removed. It was only\n  ever available if the ``deprecatedlayers`` ZCML feature was installed.\n\n- Modernize some of the templates. ``zope.app.apidoc`` can now be used\n  with Chameleon 3.2 via z3c.pt and z3c.ptcompat.\n\n- Declared install dependency on ``zope.app.exception``.\n\n- Docstrings are treated as UTF-8 on Python 2.\n\n- Handle keyword only arguments and annotations in function signatures\n  on Python 3.\n\n- Change the default documentation format to ``restructuredtext`` for\n  modules that do not specify a ``__docformat__``. Previously it was\n  ``structuredtext`` (STX).\n\n3.7.5 (2010-09-12)\n==================\n\n- Define ``__file__`` in doctests to make them pass under Python 2.4.\n\n3.7.4 (2010-09-01)\n==================\n\n- Prefer the standard libraries doctest module to the one from zope.testing.\n\n- Remove unneeded dependencies zope.app.component and zope.app.container\n\n3.7.3 (2010-07-14)\n==================\n\n- Apply refactoring from #153309.\n- Fix LP bug 605057: ZCML links were no longer working (Guilherme Salgado)\n\n3.7.2 (2010-03-07)\n==================\n\n- Adapted tests for Python2.4\n\n\n3.7.1 (2010-01-05)\n==================\n\n- Updated tests to work with zope.publisher 3.12 (using `zope.login`).\n\n3.7.0 (2009-12-22)\n==================\n\n- Updated tests to work with latest `zope.testing` and use `zope.browserpage` in\n  favor of `zope.app.pagetemplate`.\n\n3.6.8 (2009-11-18)\n==================\n\n- Updated the tests after moving ``IPossibleSite`` and ``ISite`` to\n  `zope.component`.\n\n3.6.7 (2009-09-29)\n==================\n\n- Updated the tests after moving ``ITraverser`` back `to zope.traversing`.\n\n3.6.6 (2009-09-15)\n==================\n\n- Made the tests work again with the most recent Zope Toolkit KGS.\n\n3.6.5 (2009-07-24)\n==================\n\n- Update documentation file in ``zope.site`` from ``README.txt`` to\n  ``site.txt``.\n\n3.6.4 (2009-07-23)\n==================\n\n- The ``IContained`` interface moved to ``zope.location.interfaces``. Make a\n  test pass.\n\n3.6.3 (2009-05-16)\n==================\n\n- Explicitly defined default views.\n\n- Replace relative url links with absolute ones.\n\n- Added ``z3c`` packages to the code browser.\n\n- Made `bin/static-apidoc` principially working (publisher and\n  webserver mode). There are still some files which are not correctly\n  fetched.\n\n3.6.2 (2009-03-17)\n==================\n\n- Adapt principal registry book chapter to a new place, as it was moved\n  from zope.app.security to zope.principalregistry.\n\n- Remove zcml slugs and old zpkg-related files.\n\n3.6.1 (2009-02-04)\n==================\n\n- When a module provides an interface or has an __all__ attribute,\n  use one of those for the module documentation.  Fixes LP #323375.\n\n- Undid broken link to `savepoint.txt` caused in 3.6.0.  The latest\n  version of the transaction package puts savepoint.txt in the `tests`\n  subpackage.\n\n- Expanded the presentation of module documentation.\n\n- Class documentation now includes constructor information.\n\n3.6.0 (2009-01-31)\n==================\n\n- Use zope.container instead of zope.app.container.\n\n- Use zope.site instead of zope.app.component and zope.app.folder (in\n  at least a few places).\n\n- `savepoint.txt` moved from ZODB's test directory a level up -- we\n  follow.\n\n- Make compatible with new zope.traversing and zope.location.\n\n3.5.0 (2009-01-17)\n==================\n\n- Adapted transaction book chapters for new transaction egg. The\n  README.txt was removed and savepoint.txt was moved. Also add chapter\n  about dooming transactions (doom.txt).\n\n- Changed mailing list address to zope-dev at zope.org, because zope3-dev\n  is retired now.\n\n- Cleaned up dependencies.\n\n3.4.3 (2007-11-10)\n==================\n\n- Fix https://bugs.launchpad.net/zope3/+bug/161737: Misleading text in\n  the interface viewer.\n\n- Fix https://bugs.launchpad.net/zope3/+bug/161190: The zope3-dev\n  mailinglist has been retired, point to zope-dev.\n\n\n3.4.2 (2007-10-30)\n==================\n\n- Avoid deprecation warnings for ``ZopeMessageFactory``.\n\n3.4.1 (2007-10-23)\n==================\n\n- Avoid deprecation warnings.\n\n3.4.0 (2007-10-10)\n==================\n\n- Improved package meta-data.\n\n- Fixed the code to at least gracefully ignore unzipped eggs. Eventually we\n  want to handle eggs well.\n\n3.4.0a1 (2007-04-22)\n====================\n\n- Initial release independent of the main Zope tree.",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "http://github.com/zopefoundation/zope.app.apidoc",
    "keywords": "zope3 api documentation",
    "license": "ZPL 2.1",
    "maintainer": "",
    "maintainer_email": "",
    "name": "zope.app.apidoc",
    "platform": "UNKNOWN",
    "project_url": "https://pypi.org/project/zope.app.apidoc/",
    "release_url": "https://pypi.org/project/zope.app.apidoc/4.0.0/",
    "requires_python": "",
    "summary": "API Documentation and Component Inspection for Zope 3",
    "version": "4.0.0"
  },
  "releases": {
    "3.4.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "f9d80bb73fe4d04e1a6d1f45a3578249",
          "sha256": "382e2312021772025405792ca94da523ec64b6d5eb9defa589b9d70a1e723abf"
        },
        "downloads": 4242,
        "filename": "zope.app.apidoc-3.4.0.tar.gz",
        "has_sig": false,
        "md5_digest": "f9d80bb73fe4d04e1a6d1f45a3578249",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 143600,
        "upload_time": "2007-10-11T03:15:30",
        "url": "https://files.pythonhosted.org/packages/e7/9a/db56b55e0777b729b28bf59c51d5501b71346a254a31df90946f2ff181f8/zope.app.apidoc-3.4.0.tar.gz"
      }
    ],
    "3.4.0a1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "037d0ad23c65a618e3c860e77a6901fb",
          "sha256": "20c803bc7ed4d3b5bf387f63ff81422d871d6a580f9122959b309f4b140a674e"
        },
        "downloads": 2961,
        "filename": "zope.app.apidoc-3.4.0a1.tar.gz",
        "has_sig": false,
        "md5_digest": "037d0ad23c65a618e3c860e77a6901fb",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 110260,
        "upload_time": "2007-04-23T13:25:37",
        "url": "https://files.pythonhosted.org/packages/65/6e/e1e4baea33316674f98a322f08a2aebf60d3a4c587b5200346ccc7db283c/zope.app.apidoc-3.4.0a1.tar.gz"
      }
    ],
    "3.4.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "a3716f34f3adccbbb5a2ca5e0f7a6ab8",
          "sha256": "ff9466e09f9fbf004da430cfcaa55a5c1a409b069e903547f036e0e5caf2e94b"
        },
        "downloads": 2986,
        "filename": "zope.app.apidoc-3.4.1.tar.gz",
        "has_sig": false,
        "md5_digest": "a3716f34f3adccbbb5a2ca5e0f7a6ab8",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 145748,
        "upload_time": "2007-10-24T01:27:45",
        "url": "https://files.pythonhosted.org/packages/28/c6/c8500e3bac31ae4ebc3bb7598fea46449e41459313661746e553c27c2484/zope.app.apidoc-3.4.1.tar.gz"
      }
    ],
    "3.4.2": [
      {
        "comment_text": "",
        "digests": {
          "md5": "ad659ec3788e55c6d282e47e8bfbd361",
          "sha256": "d791e9c70390ff1f72c2f92d68e2b5a9044c58c58d1d25939a178370e95710e7"
        },
        "downloads": 3574,
        "filename": "zope.app.apidoc-3.4.2.tar.gz",
        "has_sig": false,
        "md5_digest": "ad659ec3788e55c6d282e47e8bfbd361",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 143938,
        "upload_time": "2007-10-30T18:44:48",
        "url": "https://files.pythonhosted.org/packages/02/96/36d0febe1515b7fec4f6f3ea4e3a79135b6b8d861b4e05c3798ece59f41c/zope.app.apidoc-3.4.2.tar.gz"
      }
    ],
    "3.4.3": [
      {
        "comment_text": "",
        "digests": {
          "md5": "d260c627dfbcc2d81ad4b4aaef043bbb",
          "sha256": "7df05a09d6ee6832496280c48b66aafafb6ede2d764c9ce5bd27b2333e96dcad"
        },
        "downloads": 19166,
        "filename": "zope.app.apidoc-3.4.3.tar.gz",
        "has_sig": false,
        "md5_digest": "d260c627dfbcc2d81ad4b4aaef043bbb",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 146175,
        "upload_time": "2007-11-10T10:13:02",
        "url": "https://files.pythonhosted.org/packages/4f/a3/9ff054163cab19705ac483db26843eeb5c2d4ed1ef9a12db53bac0bc085a/zope.app.apidoc-3.4.3.tar.gz"
      }
    ],
    "3.5.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "f3b1c678210d557fc8c44563a2bcf5ad",
          "sha256": "885fa9f5d7c649743cf3e4cdbee3c5d11050849eef5bac98bcc9b3f5e0028eac"
        },
        "downloads": 3175,
        "filename": "zope.app.apidoc-3.5.0.tar.gz",
        "has_sig": false,
        "md5_digest": "f3b1c678210d557fc8c44563a2bcf5ad",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 146797,
        "upload_time": "2009-01-17T13:09:25",
        "url": "https://files.pythonhosted.org/packages/d9/ce/92ce74f816fbf0d25c36a9b9ade5b918d4bdc79cc6eb2b60b642f3ea5c7e/zope.app.apidoc-3.5.0.tar.gz"
      }
    ],
    "3.6.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "fa649bf96768a7b9740a814ed51bee1f",
          "sha256": "d9f02d238f01c737e93ffe58c8cd3e16cc51bf7ac4ae0d0261d33e826ec48fcd"
        },
        "downloads": 2801,
        "filename": "zope.app.apidoc-3.6.0.tar.gz",
        "has_sig": false,
        "md5_digest": "fa649bf96768a7b9740a814ed51bee1f",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 146928,
        "upload_time": "2009-01-31T13:48:18",
        "url": "https://files.pythonhosted.org/packages/1f/e2/6d4e9183ed155f71aa3eebb190ca9d9a20b6a5d9d2947350348047079cf3/zope.app.apidoc-3.6.0.tar.gz"
      }
    ],
    "3.6.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "55ff18ecc38ff358c229a6af1696c7b6",
          "sha256": "160456857411871ecec960dc400a0d50a421930d5bf02e4df27362a6394296a0"
        },
        "downloads": 3066,
        "filename": "zope.app.apidoc-3.6.1.tar.gz",
        "has_sig": false,
        "md5_digest": "55ff18ecc38ff358c229a6af1696c7b6",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 149574,
        "upload_time": "2009-02-04T21:57:34",
        "url": "https://files.pythonhosted.org/packages/20/18/b2f9d8bf4cbe614372c4d99a511248ba3cf8fef84d5e429045a9887d2eb8/zope.app.apidoc-3.6.1.tar.gz"
      }
    ],
    "3.6.2": [
      {
        "comment_text": "",
        "digests": {
          "md5": "02d6f290a6857b4fb0acc11034fb183d",
          "sha256": "943011a98763735e02e1a77fb2766a8b28bc9ac17b53e14f5d496b14c2b4138d"
        },
        "downloads": 2974,
        "filename": "zope.app.apidoc-3.6.2.tar.gz",
        "has_sig": false,
        "md5_digest": "02d6f290a6857b4fb0acc11034fb183d",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 148591,
        "upload_time": "2009-03-17T16:04:29",
        "url": "https://files.pythonhosted.org/packages/db/e8/031cd121c0d4ea353bd26ac6753fac3d6a63da22ceea6d62692e36cbfe46/zope.app.apidoc-3.6.2.tar.gz"
      }
    ],
    "3.6.3": [
      {
        "comment_text": "",
        "digests": {
          "md5": "558563cc3a480ee07de2fa4adc8b12ce",
          "sha256": "f717a3875444b7cacd5f86bb96fead67f222e753602993de93cb70f5956547fb"
        },
        "downloads": 2833,
        "filename": "zope.app.apidoc-3.6.3.tar.gz",
        "has_sig": false,
        "md5_digest": "558563cc3a480ee07de2fa4adc8b12ce",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 149205,
        "upload_time": "2009-05-16T14:59:45",
        "url": "https://files.pythonhosted.org/packages/b7/60/18e405112c76b4befff602e085cb59f457ccf9eb3e670561f6a709f6adf8/zope.app.apidoc-3.6.3.tar.gz"
      }
    ],
    "3.6.4": [
      {
        "comment_text": "",
        "digests": {
          "md5": "65cb8749f1d5a0b0f2849e16a760807d",
          "sha256": "cc7b127c384db4df3db1021fc7acc036caf697ab42c6e6b16ac714456bf5b0a0"
        },
        "downloads": 2644,
        "filename": "zope.app.apidoc-3.6.4.tar.gz",
        "has_sig": false,
        "md5_digest": "65cb8749f1d5a0b0f2849e16a760807d",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 148246,
        "upload_time": "2009-07-23T22:01:05",
        "url": "https://files.pythonhosted.org/packages/67/82/9c1e24c77e5db20a802d0a8d85f8946cbec08984ce712551d2c103dcb8bf/zope.app.apidoc-3.6.4.tar.gz"
      }
    ],
    "3.6.5": [
      {
        "comment_text": "",
        "digests": {
          "md5": "a5ed1d7b3863e6d5957c9a6445746ba7",
          "sha256": "86cc7e0d1ce25e3e7b500b0e46714f9258d779da1ce45bcdd76c8f39d86adeca"
        },
        "downloads": 3117,
        "filename": "zope.app.apidoc-3.6.5.tar.gz",
        "has_sig": false,
        "md5_digest": "a5ed1d7b3863e6d5957c9a6445746ba7",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 148332,
        "upload_time": "2009-07-24T11:17:22",
        "url": "https://files.pythonhosted.org/packages/3b/fb/c65488b85c2a9c78235a4ae0f05c50059e30ddb719fe9cd2e5845a7c5f94/zope.app.apidoc-3.6.5.tar.gz"
      }
    ],
    "3.6.6": [
      {
        "comment_text": "",
        "digests": {
          "md5": "30e644cc43ca8d0fceedbc17bdf6ef19",
          "sha256": "7ca58347d80d6d9003a22244dae8667082677a15faaf1acbec26d37907fe3836"
        },
        "downloads": 2747,
        "filename": "zope.app.apidoc-3.6.6.zip",
        "has_sig": true,
        "md5_digest": "30e644cc43ca8d0fceedbc17bdf6ef19",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 229459,
        "upload_time": "2009-09-15T15:44:25",
        "url": "https://files.pythonhosted.org/packages/c2/5c/d8d16618197c3982409beafbfc4973ed5b10dc8e3e241c78cf3c43fcf37e/zope.app.apidoc-3.6.6.zip"
      }
    ],
    "3.6.7": [
      {
        "comment_text": "",
        "digests": {
          "md5": "960a851b517b0f30133a473da46d088e",
          "sha256": "d409d3f5a64324ff697cfbbae7cadb2b9301a237fde80431118180e6024adda2"
        },
        "downloads": 3212,
        "filename": "zope.app.apidoc-3.6.7.tar.gz",
        "has_sig": true,
        "md5_digest": "960a851b517b0f30133a473da46d088e",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 151506,
        "upload_time": "2009-09-29T17:37:20",
        "url": "https://files.pythonhosted.org/packages/ce/14/c372f27cfcbd1579dfc6bc1163dd0600b65a8eabc0bc8b994920db467e39/zope.app.apidoc-3.6.7.tar.gz"
      }
    ],
    "3.6.8": [
      {
        "comment_text": "",
        "digests": {
          "md5": "63470155a97c708fe31a76d51ec8fc36",
          "sha256": "72c6a98b202e2f5e90d056c639bd9df90be530f4f6c5958845e8bebdec4e48be"
        },
        "downloads": 2697,
        "filename": "zope.app.apidoc-3.6.8.tar.gz",
        "has_sig": true,
        "md5_digest": "63470155a97c708fe31a76d51ec8fc36",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 151602,
        "upload_time": "2009-11-18T10:23:21",
        "url": "https://files.pythonhosted.org/packages/16/24/a5a2cae0a46458da02cb3a31c02e3a85cf65a4b2b09f3e6662bf60481d62/zope.app.apidoc-3.6.8.tar.gz"
      }
    ],
    "3.7.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "2e6b02f4959f92cafed0809bf3875fc8",
          "sha256": "150ac7b9b147341fde6da01644366056b6676ac0cf0a681d666b6439c2fea3e7"
        },
        "downloads": 2740,
        "filename": "zope.app.apidoc-3.7.0.zip",
        "has_sig": false,
        "md5_digest": "2e6b02f4959f92cafed0809bf3875fc8",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 229867,
        "upload_time": "2009-12-22T20:21:05",
        "url": "https://files.pythonhosted.org/packages/7a/5a/9370d66901b28f3d8986a653369407ef1ea5035184a5632d4d0a4d84170b/zope.app.apidoc-3.7.0.zip"
      }
    ],
    "3.7.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "0228c065877257683e70ec3882626a7c",
          "sha256": "3b52c293abaae16a9692d791fdd44b9d50dba9fb61bb831a1596710e9bd91a93"
        },
        "downloads": 3419,
        "filename": "zope.app.apidoc-3.7.1.tar.gz",
        "has_sig": false,
        "md5_digest": "0228c065877257683e70ec3882626a7c",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 150448,
        "upload_time": "2010-01-05T00:01:12",
        "url": "https://files.pythonhosted.org/packages/99/06/f649b70f310bd1584eac3b0f70252ab7e21521d074ca376f8603863c14cb/zope.app.apidoc-3.7.1.tar.gz"
      }
    ],
    "3.7.2": [
      {
        "comment_text": "",
        "digests": {
          "md5": "20b87d06b0f20322b4e1133d8ce634ca",
          "sha256": "82345c108513a7a82e511e4143bb621ab7df9af5e93ab60dc661cba045b176c1"
        },
        "downloads": 3175,
        "filename": "zope.app.apidoc-3.7.2.tar.gz",
        "has_sig": false,
        "md5_digest": "20b87d06b0f20322b4e1133d8ce634ca",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 151769,
        "upload_time": "2010-03-07T06:41:39",
        "url": "https://files.pythonhosted.org/packages/f5/9f/02fa52d2ecbf11f264b5146bd63abc20fabfe6cad898dc30c738281fc0c7/zope.app.apidoc-3.7.2.tar.gz"
      }
    ],
    "3.7.3": [
      {
        "comment_text": "",
        "digests": {
          "md5": "3073f62e66dc450b072c821e620e4b7a",
          "sha256": "cf5dc5171250bf96a6a02752a69d90c3db2e4b127aca04749e08889a454e97f2"
        },
        "downloads": 2700,
        "filename": "zope.app.apidoc-3.7.3.tar.gz",
        "has_sig": false,
        "md5_digest": "3073f62e66dc450b072c821e620e4b7a",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 149169,
        "upload_time": "2010-07-14T17:15:14",
        "url": "https://files.pythonhosted.org/packages/99/0e/15e7080b0ea327fd0dbad5f96496ba8150a4a863c8da8bdbde6c7c56ed1a/zope.app.apidoc-3.7.3.tar.gz"
      }
    ],
    "3.7.4": [
      {
        "comment_text": "",
        "digests": {
          "md5": "6beba6ce74b8fbd8ebd701e379e34b91",
          "sha256": "e0f9b51701d4a2ffa322a04aa2bb244269fc98f0f13748930892ee9f3b0c0bb7"
        },
        "downloads": 2583,
        "filename": "zope.app.apidoc-3.7.4.tar.gz",
        "has_sig": false,
        "md5_digest": "6beba6ce74b8fbd8ebd701e379e34b91",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 152882,
        "upload_time": "2010-09-01T13:20:18",
        "url": "https://files.pythonhosted.org/packages/74/f2/8949b31d2431c9ff23a7364c7aa8184f68a5a452fdf236451b352aac0c87/zope.app.apidoc-3.7.4.tar.gz"
      }
    ],
    "3.7.5": [
      {
        "comment_text": "",
        "digests": {
          "md5": "91e969b2d1089bb0a6a303990d269f0a",
          "sha256": "18589f73f9d1bd5bab6bcc2919c20023f20a65c2a753d2ff589451117eec29f7"
        },
        "downloads": 5233,
        "filename": "zope.app.apidoc-3.7.5.zip",
        "has_sig": false,
        "md5_digest": "91e969b2d1089bb0a6a303990d269f0a",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 233986,
        "upload_time": "2010-09-12T14:33:15",
        "url": "https://files.pythonhosted.org/packages/79/77/f4fbce3ca5c1d1a23b6fbdc919ef00c37eb885fd80d4da38eb137fcc4991/zope.app.apidoc-3.7.5.zip"
      }
    ],
    "4.0.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "7da92c23a93e36c5aa89e2adb98bf82e",
          "sha256": "3bf61e72f04d73a99b7744ef0aca76e71d278c3d507b580ab1f87d3322066a61"
        },
        "downloads": 0,
        "filename": "zope.app.apidoc-4.0.0-py2.py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "7da92c23a93e36c5aa89e2adb98bf82e",
        "packagetype": "bdist_wheel",
        "python_version": "py2.py3",
        "size": 228853,
        "upload_time": "2017-05-25T12:31:21",
        "url": "https://files.pythonhosted.org/packages/6f/8c/686e2d6e7fd995183e886b219f9909173b90722b939f69f8b2ba506c9693/zope.app.apidoc-4.0.0-py2.py3-none-any.whl"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "b3cd719f361e1e6030b1b1390b91959a",
          "sha256": "a515e3feb40d8a9e56da855b5774c434aff66d54ea7a0a988a6fabaf8101bb39"
        },
        "downloads": 0,
        "filename": "zope.app.apidoc-4.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "b3cd719f361e1e6030b1b1390b91959a",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 162184,
        "upload_time": "2017-05-25T12:31:23",
        "url": "https://files.pythonhosted.org/packages/de/b0/ea3f736bd535c7fe480a787aed370e813f2187742672f59f0b4f2d09d8f0/zope.app.apidoc-4.0.0.tar.gz"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "7da92c23a93e36c5aa89e2adb98bf82e",
        "sha256": "3bf61e72f04d73a99b7744ef0aca76e71d278c3d507b580ab1f87d3322066a61"
      },
      "downloads": 0,
      "filename": "zope.app.apidoc-4.0.0-py2.py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "7da92c23a93e36c5aa89e2adb98bf82e",
      "packagetype": "bdist_wheel",
      "python_version": "py2.py3",
      "size": 228853,
      "upload_time": "2017-05-25T12:31:21",
      "url": "https://files.pythonhosted.org/packages/6f/8c/686e2d6e7fd995183e886b219f9909173b90722b939f69f8b2ba506c9693/zope.app.apidoc-4.0.0-py2.py3-none-any.whl"
    },
    {
      "comment_text": "",
      "digests": {
        "md5": "b3cd719f361e1e6030b1b1390b91959a",
        "sha256": "a515e3feb40d8a9e56da855b5774c434aff66d54ea7a0a988a6fabaf8101bb39"
      },
      "downloads": 0,
      "filename": "zope.app.apidoc-4.0.0.tar.gz",
      "has_sig": false,
      "md5_digest": "b3cd719f361e1e6030b1b1390b91959a",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 162184,
      "upload_time": "2017-05-25T12:31:23",
      "url": "https://files.pythonhosted.org/packages/de/b0/ea3f736bd535c7fe480a787aed370e813f2187742672f59f0b4f2d09d8f0/zope.app.apidoc-4.0.0.tar.gz"
    }
  ]
}