{
  "info": {
    "author": "Amazon Web Services",
    "author_email": "",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: Apache Software License",
      "Natural Language :: English",
      "Programming Language :: Python",
      "Programming Language :: Python :: 2.7",
      "Programming Language :: Python :: 3.5"
    ],
    "description": ".. image:: branding/icon/sagemaker-banner.png\n    :height: 100px\n    :alt: SageMaker\n\n====================\nSageMaker Python SDK\n====================\n\nSageMaker Python SDK is an open source library for training and deploying machine learning models on Amazon SageMaker.\n\nWith the SDK, you can train and deploy models using popular deep learning frameworks: **Apache MXNet** and **TensorFlow**. You can also train and deploy models with **Amazon algorithms**, these are scalable implementations of core machine learning algorithms that are optimized for SageMaker and GPU training. If you have **your own algorithms** built into SageMaker compatible Docker containers, you can train and host models using these as well.\n\nFor detailed API reference please go to: `Read the Docs <https://readthedocs.org/projects/sagemaker/>`_\n\nTable of Contents\n-----------------\n\n1. `Getting SageMaker Python SDK <#getting-sagemaker-python-sdk>`__\n2. `SageMaker Python SDK Overview <#sagemaker-python-sdk-overview>`__\n3. `MXNet SageMaker Estimators <#mxnet-sagemaker-estimators>`__\n4. `TensorFlow SageMaker Estimators <#tensorflow-sagemaker-estimators>`__\n5. `AWS SageMaker Estimators <#aws-sagemaker-estimators>`__\n6. `BYO Docker Containers with SageMaker Estimators <#byo-docker-containers-with-sagemaker-estimators>`__\n\n\nGetting SageMaker Python SDK\n----------------------------\n\nSageMaker Python SDK is built to PyPI and can be installed with pip.\n\n::\n\n    pip install sagemaker\n\nYou can install from source by cloning this repository and issuing a pip install command in the root directory of the repository.\n\n::\n\n    git clone https://github.com/aws/sagemaker-python-sdk.git\n    python setup.py sdist\n    pip install dist/sagemaker-1.0.0.tar.gz\n\nSupported Python versions\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\nSageMaker Python SDK is tested on: \\* Python 2.7 \\* Python 3.5\n\nLicensing\n~~~~~~~~~\nSageMaker Python SDK is licensed under the Apache 2.0 License. It is copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved. The license is available at:  http://aws.amazon.com/apache2.0/\n\nRunning tests\n~~~~~~~~~~~~~\n\nSageMaker Python SDK uses tox for running Python tests. You can run the tests by running tox:\n\n::\n\n    tox\n\nTests are defined in ``tests/`` and includes unit and integ tests. If you just want to run unit tests, then you can issue:\n\n::\n\n    tox tests/unit\n\nTo just run integ tests, issue the following command:\n\n::\n\n    pytest tests/integ\n\nYou can also filter by individual test function names (usable with any of the previous commands):\n\n::\n\n    pytest -k 'test_i_care_about'\n\nBuilding Sphinx docs\n~~~~~~~~~~~~~~~~~~~~\n\n``cd`` into the ``doc`` directory and run:\n\n::\n\n    make html\n\nYou can edit the templates for any of the pages in the docs by editing the .rst files in the \"doc\" directory and then running \"``make html``\" again.\n\n\nSageMaker Python SDK Overview\n-----------------------------\n\nSageMaker Python SDK provides several high-level abstractions for working with Amazon SageMaker. These are:\n\n- **Estimators**: Encapsulate training on SageMaker. Can be ``fit()`` to run training, then the resulting model ``deploy()`` ed to a SageMaker Endpoint. \n- **Models**: Encapsulate built ML models. Can be ``deploy()`` ed to a SageMaker Endpoint.\n- **Predictors**: Provide real-time inference and transformation using Python data-types against a SageMaker Endpoint.\n- **Session**: Provides a collection of convience methods for working with SageMaker resources.\n\nEstimator and Model implementations for MXNet, TensorFlow, and Amazon ML algorithms are included. There's also an Estimator that runs SageMaker compatible custom Docker containers, allowing you to run your own ML algorithms via SageMaker Python SDK.\n\nLater sections of this document explain how to use the different Estimators and Models. These are:\n\n* `MXNet SageMaker Estimators and Models <#mxnet-sagemaker-estimators>`__\n* `TensorFlow SageMaker Estimators and Models <#tensorflow-sagemaker-estimators>`__\n* `AWS SageMaker Estimators and Models <#aws-sagemaker-estimators>`__\n* `Custom SageMaker Estimators and Models <#byo-docker-containers-with-sagemaker-estimators>`__\n\n\nMXNet SageMaker Estimators\n--------------------------\n\nWith MXNet Estimators, you can train and host MXNet models on Amazon SageMaker.\n\nTraining with MXNet\n~~~~~~~~~~~~~~~~~~~\n\nTraining MXNet models using ``MXNet`` Estimators is a two-step process. First, you prepare your training script, then second, you run this on SageMaker via an ``MXNet`` Estimator. You should prepare your script in a separate source file than the notebook, terminal session, or source file you're using to submit the script to SageMaker via an ``MXNet`` Estimator.\n\nSuppose that you already have an MXNet training script called\n``mxnet-train.py``. You can run this script in SageMaker as follows:\n\n.. code:: python\n\n    from sagemaker.mxnet import MXNet\n    mxnet_estimator = MXNet(\"mxnet-train.py\", role=\"SageMakerRole\", train_instance_type=\"ml.p2.xlarge\", )\n    mxnet_estimator.fit(\"s3://bucket/path/to/training/data\")\n\nWhere the s3 url is a path to your training data, within Amazon S3. The constructor keyword arguments define how SageMaker runs your training script and are discussed, in detail, in a later section.\n\nIn the following sections, we'll discuss how to prepare a training script for execution on SageMaker, then how to run that script on SageMaker using an ``MXNet`` Estimator.\n\nPreparing the MXNet training script\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nYour MXNet training script must be a Python 2.7 or 3.5 compatible source file. The MXNet training script must contain a function ``train``, which SageMaker invokes to run training. You can include other functions as well, but it must contain a ``train`` function.\n\nWhen you run your script on SageMaker via the ``MXNet`` Estimator, SageMaker injects information about the training environment into your training function via Python keyword arguments. You can choose to take advantage of these by including them as keyword arguments in your train function. The full list of arguments is:\n\n-  ``hyperparameters (dict[string,string])``: The hyperparameters passed\n   to SageMaker TrainingJob that runs your MXNet training script. You\n   can use this to pass hyperparameters to your training script.\n-  ``input_data_config (dict[string,dict])``: The SageMaker TrainingJob\n   InputDataConfig object, that's set when the SageMaker TrainingJob is\n   created. This is discussed in more detail below.\n-  ``channel_input_dirs (dict[string,string])``: A collection of\n   directories containing training data. When you run training, you can\n   partition your training data into different logical \"channels\".\n   Depending on your problem, some common channel ideas are: \"train\",\n   \"test\", \"evaluation\" or \"images',\"labels\".\n-  ``output_data_dir (str)``: A directory where your training script can\n   write data that will be moved to s3 after training is complete.\n-  ``num_gpus (int)``: The number of GPU devices available on your\n   training instance.\n-  ``num_cpus (int)``: The number of CPU devices available on your training instance.\n-  ``hosts (list[str])``: The list of host names running in the\n   SageMaker Training Job cluster.\n-  ``current_host (str)``: The name of the host executing the script.\n   When you use SageMaker for MXNet training, the script is run on each\n   host in the cluster.\n\nA training script that takes advantage of all arguments would have the following definition:\n\n.. code:: python\n\n    def train(hyperparameters, input_data_config, channel_input_dirs, output_data_dir,\n              num_gpus, num_cpus, hosts, current_host):\n        pass\n\nYou don't have to use all the arguments, arguments you don't care about can be ignored by including ``**kwargs``.\n\n.. code:: python\n\n    # Only work with hyperparameters and num_gpus, ignore all other hyperparameters\n    def train(hyperparameters, num_gpus, **kwargs):\n        pass\n\n**Note: Writing a training script that imports correctly**\nWhen SageMaker runs your training script, it imports it as a Python module and then invokes ``train`` on the imported module. Consequently, you should not include any statements that won't execute successfully in SageMaker when your module is imported. For example, don't attempt to open any local files in top-level statements in your training script. \n\nIf you want to run your training script locally via the Python interpreter, look at using a ``___name__ == '__main__'`` guard, discussed in more detail here: https://stackoverflow.com/questions/419163/what-does-if-name-main-do .\n\nUsing MXNet and numpy\n^^^^^^^^^^^^^^^^^^^^^\n\nYou can import both ``mxnet`` and ``numpy`` in your training script. When your script runs in SageMaker, it will run with access to MXNet version 0.12 and numpy version 1.12.0. For more information on the environment your script runs in, please see `SageMaker MXNet Containers <#sagemaker-mxnet-containers>`__.\n\nRunning an MXNet training script in SageMaker\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nYou run MXNet training scripts on SageMaker by creating ``MXNet`` Estimators. SageMaker training of your script is invoked when you call ``fit`` on an ``MXNet`` Estimator. The following code sample shows how you train a custom MXNet script \"train.py\".\n\n.. code:: python\n\n    mxnet_estimator = MXNet(\"train.py\",\n                            train_instance_type=\"ml.p2.xlarge\",\n                            train_instance_count=1)\n    mxnet_estimator.fit(\"s3://my_bucket/my_training_data/\")\n\nMXNet Estimators\n^^^^^^^^^^^^^^^^\n\nThe ``MXNet`` constructor takes both required and optional arguments.\n\nRequired arguments\n''''''''''''''''''\n\nThe following are required arguments to the ``MXNet`` constructor. When you create an MXNet object, you must include these in the constructor, either positionally or as keyword arguments.\n\n-  ``entry_point`` Path (absolute or relative) to the Python file which\n   should be executed as the entry point to training.\n-  ``role`` An AWS IAM role (either name or full ARN). The Amazon\n   SageMaker training jobs and APIs that create Amazon SageMaker\n   endpoints use this role to access training data and model artifacts.\n   After the endpoint is created, the inference code might use the IAM\n   role, if accessing AWS resource.\n-  ``train_instance_count`` Number of Amazon EC2 instances to use for\n   training.\n-  ``train_instance_type`` Type of EC2 instance to use for training, for\n   example, 'ml.c4.xlarge'.\n\nOptional arguments\n''''''''''''''''''\n\nThe following are optional arguments. When you create an ``MXNet`` object, you can specify these as keyword arguments.\n\n-  ``source_dir`` Path (absolute or relative) to a directory with any\n   other training source code dependencies aside from the entry point\n   file. Structure within this directory will be preserved when training\n   on SageMaker.\n-  ``hyperparameters`` Hyperparameters that will be used for training.\n   Will be made accessible as a dict[str, str] to the training code on\n   SageMaker. For convenience, accepts other types besides str, but\n   str() will be called on keys and values to convert them before\n   training.\n-  ``py_version`` Python version you want to use for executing your\n   model training code.\n-  ``train_volume_size`` Size in GB of the EBS volume to use for storing\n   input data during training. Must be large enough to store training\n   data if input_mode='File' is used (which is the default).\n-  ``train_max_run`` Timeout in hours for training, after which Amazon\n   SageMaker terminates the job regardless of its current status.\n-  ``input_mode`` The input mode that the algorithm supports. Valid\n   modes: 'File' - Amazon SageMaker copies the training dataset from the\n   s3 location to a directory in the Docker container. 'Pipe' - Amazon\n   SageMaker streams data directly from s3 to the container via a Unix\n   named pipe.\n-  ``output_path`` s3 location where you want the training result (model\n   artifacts and optional output files) saved. If not specified, results\n   are stored to a default bucket. If the bucket with the specific name\n   does not exist, the estimator creates the bucket during the fit()\n   method execution.\n-  ``output_kms_key`` Optional KMS key ID to optionally encrypt training\n   output with.\n-  ``job_name`` Name to assign for the training job that the fit()\n   method launches. If not specified, the estimator generates a default\n   job name, based on the training image name and current timestamp\n\nCalling fit\n^^^^^^^^^^^\n\nYou start your training script by calling ``fit`` on an ``MXNet`` Estimator. ``fit`` takes both required and optional arguments.\n\nRequired argument\n'''''''''''''''''\n\n-  ``inputs``: This can take one of the following forms: A string\n   s3 URI, for example ``s3://my-bucket/my-training-data``. In this\n   case, the s3 objects rooted at the ``my-training-data`` prefix will\n   be available in the default ``train`` channel. A dict from\n   string channel names to s3 URIs. In this case, the objects rooted at\n   each s3 prefix will available as files in each channel directory.\n\nFor example:\n\n.. code:: python\n\n    {'train':'s3://my-bucket/my-training-data',\n     'eval':'s3://my-bucket/my-evaluation-data'}\n\n.. optional-arguments-1:\n\nOptional arguments\n''''''''''''''''''\n\n-  ``wait``: Defaults to True, whether to block and wait for the\n   training script to complete before returning.\n-  ``logs``: Defaults to True, whether to show logs produced by training\n   job in the Python session. Only meaningful when wait is True.\n\nSaving models\n~~~~~~~~~~~~~\n\nWhen we run MXNet training, we often want to save or manipulate the models that MXNet produces. SageMaker Estimators provides several ways to save MXNet models. The method used is driven by functions you define on your training script, run via the ``MXNet`` Estimator in SageMaker in response to ``fit``.\n\nJust as you enable training by defining a ``train`` function in your training script, you enable model saving by defining a ``save`` function in your script. If your script includes a ``save`` function, SageMaker will invoke it with the return-value of ``train``. Model saving is a two-step process, firstly you return the model you want to save from\n``train``, then you define your model-serialization logic in ``save``.\n\nSageMaker provides a default implementation of ``save`` that works with MXNet Module API ``Module`` objects. If your training script does not define a ``save`` function, then the default ``save`` function will be invoked on the return-value of your ``train`` function.\n\nThe following script demonstrates how to return a model from train, that's compatible with the default ``save`` function.\n\n.. code:: python\n\n    import mxnet as mx\n\n    def create_graph():\n        # Code to create graph omitted for brevity\n\n    def train(num_gpus, channel_input_dirs, **kwargs):\n        ctx = mx.cpu() if not num_gpus else [mx.gpu(i) for i in range(num_gpus)]\n        sym = create_graph()\n        mod = mx.mod.Module(symbol=sym, context=ctx)\n\n        # Code to fit mod omitted for brevity\n        # ...\n\n        # Return the Module object. SageMaker will save this.\n        return mod\n\nIf you define your own ``save`` function, it should have the following signature:\n\n.. code:: python\n\n    def save(model, model_dir)\n\nWhere ``model`` is the return-value from ``train`` and ``model_dir`` is the directory SageMaker requires you to save your model. If you write files into ``model_dir`` then they will be persisted to s3 after the SageMaker Training Job completes.\n\nAfter your training job is complete, your model data will available in the s3 ``output_path`` you specified when you created the MXNet Estimator. Handling of s3 output is discussed in: `Accessing SageMaker output and model data in s3 <#accessing%20-sagemaker-output-and-model-data-in-s3>`__.\n\nMXNet Module serialization in SageMaker\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf you train function returns a ``Module`` object, it will be serialized by the default Module serialization system, unless you've specified a custom ``save`` function.\n\nThe default serialization system generates three files:\n\n-  ``model-shapes.json``: A json list, containing a serialization of the\n   ``Module`` ``data_shapes`` property. Each object in the list contains\n   the serialization of one ``DataShape`` in the returned ``Module``.\n   Each object has a ``name`` property, containing the ``DataShape``\n   name and a ``shape`` property, which is a list of that dimensions for\n   the shape of that ``DataShape``. For example:\n\n.. code:: javascript\n\n    [\n        {\"name\":\"images\", \"shape\":[100, 1, 28, 28]},\n        {\"name\":\"labels\", \"shape\":[100, 1]}\n    ]\n\n-  ``model-symbol.json``: The MXNet ``Module`` ``Symbol`` serialization,\n   produced by invoking ``save`` on the ``symbol`` property of the\n   ``Module`` being saved.\n-  ``modle.params``: The MXNet ``Module`` parameters. Produced by\n   invoking ``save_params`` on the ``Module`` being saved.\n\nWriting a custom save function\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nYou can provide your own save function. This is useful if you are not working with the ``Module`` API or you need special processing.\n\nTo provide your own save function, define a ``save`` function in your training script. The function should take two arguments:\n\n-  model: This is the object that was returned from your ``train``\n   function. If your ``train`` function does not return an object, it\n   will be ``None``. You are free to return an object of any type from\n   ``train``, you do not have to return ``Module`` or ``Gluon`` API\n   specific objects.\n-  model_dir: This is the string path on the SageMaker training host\n   where you save your model. Files created in this directory will be\n   accessible in S3 after your SageMaker Training Job completes.\n\nAfter your ``train`` function completes, SageMaker will invoke ``save`` with the object returned from ``train``.\n\n**Note: How to save Gluon models with SageMaker**\n\nIf your train function returns a Gluon API ``net`` object as its model, you'll need to write your own ``save`` function. You will want to serialize the ``net`` parameters. Saving ``net`` parameters is covered in the `Serialization section <http://gluon.mxnet.io/chapter03_deep-neural-networks/serialization.html>`__ of the collaborative Gluon deep-learning book `\"The Straight Dope\" <http://gluon.mxnet.io/index.html>`__.\n\nDeploying MXNet models\n~~~~~~~~~~~~~~~~~~~~~~\n\nAfter an MXNet Estimator has been fit, you can host the newly created model in SageMaker.\n\nAfter calling ``fit``, you can call ``deploy`` on an ``MXNet`` Estimator to create a SageMaker Endpoint. The Endpoint runs a SageMaker-provided MXNet model server and hosts the model produced by your training script, which was run when you called ``fit``. This was the model object you returned from ``train`` and saved with either a custom save function or the default save function.\n\n``deploy`` returns a ``Predictor`` object, which you can use to do inference on the Endpoint hosting your MXNet model. Each ``Predictor`` provides a ``predict`` method which can do inference with numpy arrays or Python lists. Inference arrays or lists are serialized and sent to the MXNet model server by an ``InvokeEndpoint`` SageMaker operation.\n\n``predict`` returns the result of inference against your model. By default, the inference result is either a Python list or dictionary.\n\n.. code:: python\n\n    # Train my estimator\n    mxnet_estimator = MXNet(\"train.py\",\n                            train_instance_type=\"ml.p2.xlarge\",\n                            train_instance_count=1)\n    mxnet_estimator.fit(\"s3://my_bucket/my_training_data/\")\n\n    # Deploy my estimator to a SageMaker Endpoint and get a Predictor\n    predictor = mxnet_estimator.deploy(deploy_instance_type=\"ml.p2.xlarge\",\n                                       min_instances=1,\n\nYou use the SageMaker MXNet model server to host your MXNet model when you call ``deploy`` on an ``MXNet`` Estimator. The model server runs inside a SageMaker Endpoint, which your call to ``deploy`` creates. You can access the name of the Endpoint by the ``name`` property on the returned ``Predictor``.\n\nThe SageMaker MXNet Model Server\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe MXNet Endpoint you create with ``deploy`` runs a SageMaker MXNet model server. The model server loads the model that was saved by your training script and performs inference on the model in response to SageMaker InvokeEndpoint API calls.\n\nYou can configure two components of the SageMaker MXNet model server: Model loading and model serving. Model loading is the process of deserializing your saved model back into an MXNet model. Serving is the process of translating InvokeEndpoint requests to inference calls on the loaded model.\n\nAs with MXNet training, you configure the MXNet model server by defining functions in the Python source file you passed to the MXNet constructor. \n\nModel loading\n^^^^^^^^^^^^^\n\nBefore a model can be served, it must be loaded. The SageMaker model server loads your model by invoking a ``model_fn`` function on your training script. If you don't provide a ``model_fn`` function, SageMaker will use a default ``model_fn`` function. The default function works with MXNet Module model objects, saved via the default ``save`` function.\n\nIf you wrote a custom ``save`` function then you may need to write a custom ``model_fn`` function. If your save function serializes ``Module`` objects under the same format as the default ``save`` function, then you won't need to write a custom model_fn function. If you do write a ``model_fn`` function must have the following signature:\n\n.. code:: python\n\n    def model_fn(model_dir)\n\nSageMaker will inject the directory where your model files and sub-directories, saved by ``save``, have been mounted. Your model function should return a model object that can be used for model serving. SageMaker provides automated serving functions that work with Gluon API ``net`` objects and Module API ``Module`` objects. If you return either of these types of objects, then you will be able to use the default serving request handling functions.\n\nThe following code-snippet shows an example custom ``model_fn`` implementation. This loads returns an MXNet Gluon net model for resnet-34 inference. It loads the model parameters from a ``model.params`` file in the SageMaker model directory.\n\n.. code:: python\n\n    def model_fn(model_dir):\n        \"\"\"\n        Load the gluon model. Called once when hosting service starts.\n        :param: model_dir The directory where model files are stored.\n        :return: a model (in this case a Gluon network)\n        \"\"\"\n        net = models.get_model('resnet34_v2', ctx=mx.cpu(), pretrained=False, classes=10)\n        net.load_params('%s/model.params' % model_dir, ctx=mx.cpu())\n        return net\n\nModel serving\n^^^^^^^^^^^^^\n\nAfter the SageMaker model server has loaded your model, by calling either the default ``model_fn`` or the implementation in your training script, SageMaker will serve your model. Model serving is the process of responding to inference requests, received by SageMaker InvokeEndpoint API calls. The SageMaker MXNet model server breaks request handling into three steps:\n\n\n-  input processing,\n-  prediction, and\n-  output processing.\n\nIn a similar way to previous steps, you configure these steps by defining functions in your Python source file.\n\nEach step involves invoking a python function, with information about the request and the return-value from the previous function in the chain. Inside the SageMaker MXNet model server, the process looks like:\n\n.. code:: python\n\n    # Deserialize the Invoke request body into an object we can perform prediction on\n    input_object = input_fn(request_body, request_content_type, model)\n\n    # Perform prediction on the deserialized object, with the loaded model\n    prediction = predict_fn(input_object, model)\n\n    # Serialize the prediction result into the desired response content type\n    ouput = output_fn(prediction, response_content_type)\n\nThe above code-sample shows the three function definitions:\n\n-  ``input_fn``: Takes request data and deserializes the data into an\n   object for prediction.\n-  ``predict_fn``: Takes the deserialized request object and performs\n   inference against the loaded model.\n-  ``output_fn``: Takes the result of prediction and serializes this\n   according to the response content type.\n\nThe SageMaker MXNet model server provides default implementations of these functions. These work with common-content types, and Gluon API and Module API model objects. You can provide your own implementations for these functions in your training script. If you omit any definition then the SageMaker MXNet model server will use its default implementation for that function.\n\nIf you rely solely on the SageMaker MXNet model server defaults, you get the following functionality:\n\n-  Prediction on MXNet Gluon API ``net`` and Module API ``Module``\n   objects.\n-  Deserialization from CSV and JSON to NDArrayIters.\n-  Serialization of NDArrayIters to CSV or JSON.\n\nIn the following sections we describe the default implementations of input_fn, predict_fn, and output_fn. We describe the input arguments and expected return types of each, so you can define your own implementations.\n\nInput processing\n''''''''''''''''\n\nWhen an InvokeEndpoint operation is made against an Endpoint running a SageMaker MXNet model server, the model server receives two pieces of information:\n\n-  The request Content-Type, for example \"application/json\"\n-  The request data body, a byte array which is at most 5 MB (5 \\* 1024\n   \\* 1024 bytes) in size.\n\nThe SageMaker MXNet model server will invoke an \"input_fn\" function in your training script, passing in this information. If you define an ``input_fn`` function definition, it should return an object that can be passed to ``predict_fn`` and have the following signature:\n\n.. code:: python\n\n    def input_fn(request_body, request_content_type, model)\n\nWhere ``request_body`` is a byte buffer, ``request_content_type`` is a Python string, and model is the result of invoking ``model_fn``.\n\nThe SageMaker MXNet model server provides a default implementation of ``input_fn``. This function deserializes JSON or CSV encoded data into an MXNet ``NDArrayIter`` `(external API docs) <https://mxnet.incubator.apache.org/api/python/io.html#mxnet.io.NDArrayIter>`__ multi-dimensional array iterator. This works with the default ``predict_fn`` implementation, which expects an ``NDArrayIter`` as input.\n\nDefault json deserialization requires ``request_body`` contain a single json list. Sending multiple json objects within the same ``request_body`` is not supported. The list must have a dimensionality compatible with the MXNet ``net`` or ``Module`` object. Specifically, after the list is loaded, it's either padded or split to fit the first dimension of the model input shape. The list's shape must be identical to the model's input shape, for all dimensions after the first.\n\nDefault csv deserialization requires ``request_body`` contain one or more lines of CSV numerical data. The data is loaded into a two-dimensional array, where each line break defines the boundaries of the first dimension. This two-dimensional array is then re-shaped to be compatible with the shape expected by the model object. Specifically, the first dimension is kept unchanged, but the second dimension is reshaped to be consistent with the shape of all dimensions in the model, following the first dimension.\n\nIf you provide your own implementation of input_fn, you should abide by the ``input_fn`` signature. If you want to use this with the default\n``predict_fn``, then you should return an NDArrayIter. The NDArrayIter should have a shape identical to the shape of the model being predicted on. The example below shows a custom ``input_fn`` for preparing pickled numpy arrays.\n\n.. code:: python\n\n    import numpy as np\n    import mxnet as mx\n\n    def input_fn(request_body, request_content_type, model):\n        \"\"\"An input_fn that loads a pickled numpy array\"\"\"\n        if request_content_type == \"application/python-pickle\":\n            array = np.load(StringIO(request_body))\n            array.reshape(model.data_shpaes[0])\n            return mx.io.NDArrayIter(mx.ndarray(array))\n        else:\n            # Handle other content-types here or raise an Exception\n            # if the content type is not supported.\n            pass\n\nPrediction\n''''''''''\n\nAfter the inference request has been deserialized by ``input_fn``, the SageMaker MXNet model server invokes ``predict_fn``. As with ``input_fn``, you can define your own ``predict_fn`` or use the SageMaker Mxnet default.\n\nThe ``predict_fn`` function has the following signature:\n\n.. code:: python\n\n    def predict_fn(input_object, model)\n\nWhere ``input_object`` is the object returned from ``input_fn`` and\n``model`` is the model loaded by ``model_fn``.\n\nThe default implementation of ``predict_fn`` requires ``input_object`` be an ``NDArrayIter``, which is the return-type of the default\n``input_fn``. It also requires that ``model`` be either an MXNet Gluon API ``net`` object or a Module API ``Module`` object.\n\nThe default implementation performs inference with the input\n``NDArrayIter`` on the Gluon or Module object. If the model is a Gluon\n``net`` it performs: ``net.forward(input_object)``. If the model is a Module object it performs ``module.predict(input_object)``. In both cases, it returns the result of that call.\n\nIf you implement your own prediction function, you should take care to ensure that:\n\n-  The first argument is expected to be the return value from input_fn.\n   If you use the default input_fn, this will be an ``NDArrayIter``.\n-  The second argument is the loaded model. If you use the default\n   ``model_fn`` implementation, this will be an MXNet Module object.\n   Otherwise, it will be the return value of your ``model_fn``\n   implementation.\n-  The return value should be of the correct type to be passed as the\n   first argument to ``output_fn``. If you use the default\n   ``output_fn``, this should be an ``NDArrayIter``.\n\nOutput processing\n'''''''''''''''''\n\nAfter invoking ``predict_fn``, the model server invokes ``output_fn``, passing in the return-value from ``predict_fn`` and the InvokeEndpoint requested response content-type.\n\nThe ``output_fn`` has the following signature:\n\n.. code:: python\n\n    def output_fn(prediction, content_type)\n\nWhere ``prediction`` is the result of invoking ``predict_fn`` and\n``content_type`` is the InvokeEndpoint requested response content-type. The function should return a byte array of data serialized to content_type.\n\nThe default implementation expects ``prediction`` to be an ``NDArray`` and can serialize the result to either JSON or CSV. It accepts response content types of \"application/json\" and \"text/csv\".\n\nDistributed MXNet training\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nYou can run a multi-machine, distributed MXNet training using the MXNet Estimator. By default, MXNet objects will submit single-machine training jobs to SageMaker. If you set ``train_instance_count`` to be greater than one, multi-machine training jobs will be launched when ``fit`` is called. When you run multi-machine training, SageMaker will import your training script and invoke ``train`` on each host in the cluster.\n\nWhen you develop MXNet distributed learning algorithms, you often want to use an MXNet kvstore to store and share model parameters. To learn more about writing distributed MXNet programs, please see `Distributed Training <http://newdocs.readthedocs.io/en/latest/distributed_training.html>`__ in the MXNet docs.\n\nWhen using an MXNet Estimator, SageMaker automatically starts MXNet kvstore server and scheduler processes on hosts in your training job cluster. Your script runs as an MXNet worker task. SageMaker runs one server process on each host in your cluster. One host is selected arbitrarily to run the scheduler process.\n\nWorking with existing model data and training jobs\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nAttaching to existing training jobs\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nYou can attach an MXNet Estimator to an existing training job using the\n``attach`` method.\n\n.. code:: python\n\n    my_training_job_name = \"MyAwesomeMXNetTrainingJob\"\n    mxnet_estimator = MXNet.attach(my_training_job_name)\n\nAfter attaching, if the training job is in a Complete status, it can be\n``deploy``\\ ed to create a SageMaker Endpoint and return a\n``Predictor``. If the training job is in progress, attach will block and display log messages from the training job, until the training job completes.\n\nThe ``attach`` method accepts the following arguments:\n\n-  ``training_job_name (str):`` The name of the training job to attach\n   to.\n-  ``sagemaker_session (sagemaker.Session or None):`` The Session used\n   to interact with SageMaker\n\nDeploying Endpoints from model data\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs well as attaching to existing training jobs, you can deploy models directly from model data in S3. The following code sample shows how to do this, using the ``MXNetModel`` class.\n\n.. code:: python\n\n    mxnet_model = MXNetModel(model_data=\"s3://bucket/model.tar.gz\", role=\"SageMakerRole\", entry_point=\"trasform_script.py\")\n\n    predictor = mxnet_model.deploy(instance_type=\"ml.c4.xlarge\", initial_instance_count=1)\n\nThe MXNetModel constructor takes the following arguments:\n\n-  ``model_data (str):`` An S3 location of a SageMaker model data\n   .tar.gz file\n-  ``image (str):`` A Docker image URI\n-  ``role (str):`` An IAM role name or Arn for SageMaker to access AWS\n   resources on your behalf.\n-  ``predictor_cls (callable[string,sagemaker.Session]):`` A function to\n   call to create a predictor. If not None, ``deploy`` will return the\n   result of invoking this function on the created endpoint name\n-  ``env (dict[string,string]):`` Environment variables to run with\n   ``image`` when hosted in SageMaker.\n-  ``name (str):`` The model name. If None, a default model name will be\n   selected on each ``deploy.``\n-  ``entry_point (str):`` Path (absolute or relative) to the Python file\n   which should be executed as the entry point to model hosting.\n-  ``source_dir (str):`` Optional. Path (absolute or relative) to a\n   directory with any other training source code dependencies aside from\n   tne entry point file. Structure within this directory will be\n   preserved when training on SageMaker.\n-  ``enable_cloudwatch_metrics (boolean):`` Optional. If true, training\n   and hosting containers will generate Cloudwatch metrics under the\n   AWS/SageMakerContainer namespace.\n-  ``container_log_level (int):`` Log level to use within the container.\n   Valid values are defined in the Python logging module.\n-  ``code_location (str):`` Optional. Name of the S3 bucket where your\n   custom code will be uploaded to. If not specified, will use the\n   SageMaker default bucket created by sagemaker.Session.\n-  ``sagemaker_session (sagemaker.Session):`` The SageMaker Session\n   object, used for SageMaker interaction\"\"\"\n\nYour model data must be a .tar.gz file in S3. SageMaker Training Job model data is saved to .tar.gz files in S3, however if you have local data you want to deploy, you can prepare the data yourself.\n\nAssuming you have a local directory containg your model data named \"my_model\" you can tar and gzip compress the file and upload to S3 using the following commands:\n\n::\n\n    tar -czf model.tar.gz my_model\n    aws s3 cp model.tar.gz s3://my-bucket/my-path/model.tar.gz\n\nThis uploads the contents of my_model to a gzip compressed tar file to S3 in the bucket \"my-bucket\", with the key \"my-path/model.tar.gz\".\n\nTo run this command, you'll need the aws cli tool installed. Please refer to our `FAQ <#FAQ>`__ for more information on installing this.\n\nMXNet Training Examples\n~~~~~~~~~~~~~~~~~~~~~~~\n\nAmazon provides several example Jupyter notebooks that demonstrate end-to-end training on Amazon SageMaker using MXNet. Please refer to:\n\nhttps://github.com/awslabs/amazon-sagemaker-examples/tree/master/sagemaker-python-sdk\n\n\nThese are also availble in SageMaker Notebook Instance hosted Jupyter notebooks under the \"sample notebooks\" folder.\n\nSageMaker MXNet Containers\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nWhen training and deploying training scripts, SageMaker runs your Python script in a Docker container with several libraries installed. When creating the Estimator and calling deploy to create the SageMaker Endpoint, you can control the environment your script runs in.\n\nSageMaker runs MXNet Estimator scripts in either Python 2.7 or Python 3.5. You can select the Python version by passing a ``py_version`` keyword arg to the MXNet Estimator constructor. Setting this to ``py2`` (the default) will cause your training script to be run on Python 2.7. Setting this to ``py3`` will cause your training script to be run on Python 3.5. This Python version applies to both the Training Job, created by fit, and the Endpoint, created by deploy.\n\nYour MXNet training script will be run on version 0.12 of MXNet, built for either GPU or CPU use. The decision to use the GPU or CPU version of MXNet is made by the train_instance_type, set on the MXNet constructor. If you choose a GPU instance type, your training job will be run on a GPU version of MXNet. If you choose a CPU instance type, your training job will be run on a CPU version of MXNet. Similarly, when you call deploy, specifying a GPU or CPU deploy_instance_type, will control which MXNet build your Endpoint runs.\n\nEach Docker container has the following dependencies installed:\n\n-  Python 2.7 or Python 3.5, depending on the ``py_version`` argument on\n   the MXNet constructor.\n-  MXNet 0.12, built for either GPU or CPU, depending on the instance\n   type for training or deploying.\n-  CUDA 9.0\n-  numpy 1.12\n\nThe Docker images extend Ubuntu 16.04.\n\nTensorFlow SageMaker Estimators\n-------------------------------\n\nTensorFlow SageMaker Estimators allow you to run your own TensorFlow \ntraining algorithms on SageMaker Learner, and to host your own TensorFlow \nmodels on SageMaker Hosting.\n\nTraining with TensorFlow\n~~~~~~~~~~~~~~~~~~~~~~~~\n\nTraining TensorFlow models using a ``sagemaker.tensorflow.TensorFlow`` \nis a two-step process.\nFirst, you prepare your training script, then second, you run it on \nSageMaker Learner via the ``sagemaker.tensorflow.TensorFlow`` estimator.\n\nSuppose that you already have a TensorFlow training script called \n``tf-train.py``. You can train this script in SageMaker Learner as\nfollows:\n\n.. code:: python\n\n  from sagemaker.tensorflow import TensorFlow\n\n  tf_estimator = TensorFlow('tf-train.py', role='SageMakerRole',\n                            training_steps=10000, evaluation_steps=100,\n                            train_instance_count=1, train_instance_type='ml.p2.xlarge')\n  tf_estimator.fit('s3://bucket/path/to/training/data')\n\nWhere the s3 url is a path to your training data, within Amazon S3. The\nconstructor keyword arguments define how SageMaker runs your training\nscript and are discussed, in detail, in a later section.\n\nIn the following sections, we'll discuss how to prepare a training script for execution on\nSageMaker, then how to run that script on SageMaker using a ``sagemaker.tensorflow.TensorFlow`` \nestimator.\n\nPreparing the TensorFlow training script\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nYour TensorFlow training script must be a **Python 2.7** source file. The current supported TensorFlow\nversion is **1.4.0**. This training script **must contain** the following functions:\n\n- ``model_fn``: defines the model that will be trained.\n- ``train_input_fn``: preprocess and load training data.\n- ``eval_input_fn``: preprocess and load evaluation data.\n- ``serving_input_fn``: defines the features to be passed to the model during prediction.\n\nCreating a ``model_fn``\n^^^^^^^^^^^^^^^^^^^^^^^\n\nA ``model_fn`` is a function that contains all the logic to support training, evaluation, \nand prediction. The basic skeleton for a ``model_fn`` looks like this:\n\n.. code:: python\n\n  def model_fn(features, labels, mode, hyperparameters):\n    # Logic to do the following:\n    # 1. Configure the model via TensorFlow operations\n    # 2. Define the loss function for training/evaluation\n    # 3. Define the training operation/optimizer\n    # 4. Generate predictions\n    # 5. Return predictions/loss/train_op/eval_metric_ops in EstimatorSpec object\n    return EstimatorSpec(mode, predictions, loss, train_op, eval_metric_ops)\n\nThe ``model_fn`` must accept four positional arguments:\n\n- ``features``: A dict containing the features passed to the model via ``train_input_fn``\n  in **training** mode, via ``eval_input_fn`` in **evaluation** mode, and via ``serving_input_fn``\n  in **predict** mode.\n- ``labels``: A ``Tensor`` containing the labels passed to the model via ``train_input_fn``\n  in **training** mode and ``eval_input_fn`` in **evaluation** mode. It will be empty for\n  **predict** mode.\n- ``mode``: One of the following ``tf.estimator.ModeKeys`` string values indicating the\n  context in which the ``model_fn`` was invoked:\n  - ``TRAIN``: the ``model_fn`` was invoked in **training** mode.\n  - ``EVAL``: the ``model_fn`` was invoked in **evaluation** mode.\n  - ``PREDICT``: the ``model_fn`` was invoked in **predict** mode.\n- ``hyperparameters``: The hyperparameters passed to SageMaker TrainingJob that runs \n  your TensorFlow training script. You can use this to pass hyperparameters to your \n  training script.\n\nExample of a complete ``model_fn``\n''''''''''''''''''''''''''''''''''\n\n.. code:: python\n\n  def model_fn(features, labels, mode, hyperparameters):\n    # Connect the first hidden layer to input layer\n    # (features[\"x\"]) with relu activation\n    first_hidden_layer = Dense(10, activation='relu', name='first-layer')(features[INPUT_TENSOR_NAME])\n\n    # Connect the second hidden layer to first hidden layer with relu\n    second_hidden_layer = Dense(20, activation='relu')(first_hidden_layer)\n\n    # Connect the output layer to second hidden layer (no activation fn)\n    output_layer = Dense(1, activation='linear')(second_hidden_layer)\n\n    # Reshape output layer to 1-dim Tensor to return predictions\n    predictions = tf.reshape(output_layer, [-1])\n\n    # Provide an estimator spec for `ModeKeys.PREDICT`.\n    if mode == tf.estimator.ModeKeys.PREDICT:\n      return tf.estimator.EstimatorSpec(mode=mode, predictions={\"ages\": predictions})\n\n    # Calculate loss using mean squared error\n    loss = tf.losses.mean_squared_error(labels, predictions)\n\n    # Calculate root mean squared error as additional eval metric\n    eval_metric_ops = {\n        \"rmse\": tf.metrics.root_mean_squared_error(tf.cast(labels, tf.float64), predictions)\n    }\n\n    optimizer = tf.train.GradientDescentOptimizer(\n        learning_rate=hyperparameters[\"learning_rate\"])\n    train_op = optimizer.minimize(\n        loss=loss, global_step=tf.train.get_global_step())\n\n    # Provide an estimator spec for `ModeKeys.EVAL` and `ModeKeys.TRAIN` modes.\n    return tf.estimator.EstimatorSpec(\n        mode=mode,\n        loss=loss,\n        train_op=train_op,\n        eval_metric_ops=eval_metric_ops)\n\nDistributed training\n''''''''''''''''''''\n\nWhen distributed training happens, a copy of the same neural network will be sent to \nmultiple training instances. Each instance will train with a batch of the dataset, \ncalculate loss and minimize the optimizer. One entire loop of this process is called training step.\n\nA `global step <https://www.tensorflow.org/api_docs/python/tf/train/global_step>`_ is a global\ncounter shared between the instances. It is necessary for distributed training, so the optimizer\ncan keep track of the number of training steps across instances. The only change in the \nprevious complete ``model_fn`` to enable distributed training is to pass in the global \nstep into the ``optimizer.minimize`` function:\n\n.. code:: python\n  \n  train_op = optimizer.minimize(loss, tf.train.get_or_create_global_step())\n\nMore information about distributed training can be find in talk from the TensorFlow Dev Summit 2017 \n`Distributed TensorFlow <https://www.youtube.com/watch?time_continue=1&v=la_M6bCV91M>`_.\n\n\nMore details on how to create a ``model_fn`` can be find in `Constructing the model_fn <https://github.com/tensorflow/tensorflow/blob/r1.4/tensorflow/docs_src/extend/estimators.md#constructing-the-model_fn-constructing-modelfn>`_.\n\n\nCreating ``train_input_fn`` and ``eval_input_fn`` functions\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe ``train_input_fn`` is used to pass ``features`` and ``labels`` to the ``model_fn`` \nin **training** mode. The ``eval_input_fn`` is used to ``features`` and ``labels`` to the \n``model_fn`` in **evaluation** mode.\n\nThe basic skeleton for the ``train_input_fn`` looks like this:\n\n.. code:: python\n\n  def train_input_fn(training_dir, hyperparameters):\n    # Logic to the following:\n    # 1. Reads the **training** dataset files located in training_dir\n    # 2. Preprocess the dataset\n    # 3. Return 1)  a mapping of feature columns to Tensors with\n    # the corresponding feature data, and 2) a Tensor containing labels\n    return feature_cols, labels \n\nAn ``eval_input_fn`` follows the same format:\n\n.. code:: python\n\n  def eval_input_fn(training_dir, hyperparameters):\n    # Logic to the following:\n    # 1. Reads the **evaluation** dataset files located in training_dir\n    # 2. Preprocess the dataset\n    # 3. Return 1)  a mapping of feature columns to Tensors with\n    # the corresponding feature data, and 2) a Tensor containing labels\n    return feature_cols, labels \n\nExample of a complete ``train_input_fn`` and ``eval_input_fn``\n''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''\n\n.. code:: python\n\n  def train_input_fn(training_dir, hyperparameters):\n    # invokes _input_fn with training dataset\n    return _input_fn(training_dir, 'training_dataset.csv')\n\n  def eval_input_fn(training_dir, hyperparameters):\n    # invokes _input_fn with evaluation dataset\n    return _input_fn(training_dir, 'evaluation_dataset.csv')\n\n  def _input_fn(training_dir, training_filename):\n      # reads the dataset using tf.dataset API\n      training_set = tf.contrib.learn.datasets.base.load_csv_without_header(\n          filename=os.path.join(training_dir, training_filename), target_dtype=np.int, features_dtype=np.float32)\n\n      # returns features x and labels y\n      return tf.estimator.inputs.numpy_input_fn(\n          x={INPUT_TENSOR_NAME: np.array(training_set.data)},\n          y=np.array(training_set.target),\n          num_epochs=None,\n          shuffle=True)()\n\n\nMore details on how to create input functions can be find in `Building Input Functions with tf.estimator <https://github.com/tensorflow/tensorflow/blob/r1.4/tensorflow/docs_src/get_started/input_fn.md#building-input-functions-with-tfestimator>`_.\n\nCreating a ``serving_input_fn``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nDuring training, ``train_input_fn`` ingests data and prepares it for use by the model. \nAt the end of training, similarly, ``serving_input_fn`` is used to create the model that \nis exported for TensorFlow Serving. This function has the following purposes:\n\n- To add placeholders to the graph that the serving system will feed with inference requests.\n- To add any additional ops needed to convert data from the input format into the feature Tensors \n  expected by the model.\n\nThe basic skeleton for the ``serving_input_fn`` looks like this:\n\n.. code:: python\n\n  def serving_input_fn(hyperparameters):\n    # Logic to the following:\n    # 1. Defines placeholders that TensorFlow serving will feed with inference requests\n    # 2. Preprocess input data\n    # 3. Returns a tf.estimator.export.ServingInputReceiver object, which packages the placeholders \n    and the resulting feature Tensors together.\n\nExample of a complete ``serving_input_fn``\n''''''''''''''''''''''''''''''''''''''''''\n\n.. code:: python\n\n  def serving_input_fn(hyperparameters):\n      # defines the input placeholder\n      tensor = tf.placeholder(tf.float32, shape=[1, 7])\n      # returns the ServingInputReceiver object.\n      return build_raw_serving_input_receiver_fn({INPUT_TENSOR_NAME: tensor})()\n\nMore details on how to create a `serving_input_fn` can be find in `Preparing serving inputs <https://github.com/tensorflow/tensorflow/blob/r1.4/tensorflow/docs_src/programmers_guide/saved_model.md#preparing-serving-inputs>`_.\n\nThe complete example described above can find in `Abalone age predictor using layers notebook example <https://github.com/awslabs/amazon-sagemaker-examples/blob/master/sagemaker-python-sdk/tensorflow_abalone_age_predictor_using_layers/tensorflow_abalone_age_predictor_using_layers.ipynb>`_.\n\nMore examples on how to create a TensorFlow training script can be find in the `Amazon SageMaker examples repository <https://github.com/awslabs/amazon-sagemaker-examples/tree/master/sagemaker-python-sdk>`_.\n\nSupport for pre-made ``tf.estimator`` and ``Keras`` models\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIn addition to ``model_fn``, ``sagemaker.tensorflow.TensorFlow`` supports pre-canned ``tf.estimator`` \nand ``Keras`` models.\n\nUsing a pre-made ``tensorflow.estimator`` instead of a ``model_fn``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPre-canned estimators are machine learning estimators premade for general purpose problems.\n``tf.estimator`` provides the following pre-canned estimators:\n\n- `tf.estimator.LinearClassifier <https://www.tensorflow.org/api_docs/python/tf/estimator/LinearClassifier>`_: Constructs \n  a linear classification model.\n- `tf.estimator.LinearRegressor <https://www.tensorflow.org/api_docs/python/tf/estimator/LinearRegressor>`_: Constructs \n  a linear regression model.\n- `tf.estimator.DNNClassifier <https://www.tensorflow.org/api_docs/python/tf/estimator/DNNClassifier>`_: Constructs \n  a neural network classification model.\n- `tf.estimator.DNNRegressor <https://www.tensorflow.org/api_docs/python/tf/estimator/DNNRegressor>`_: Construct \n  a neural network regression model.\n- `tf.estimator.DNNLinearCombinedClassifier <https://www.tensorflow.org/api_docs/python/tf/estimator/DNNLinearCombinedClassifier>`_: Constructs \n  a neural network and linear combined classification model.\n- `tf.estimator.DNNLinearCombinedRegressor <https://www.tensorflow.org/api_docs/python/tf/estimator/DNNLinearCombinedRegressor>`_: Constructs \n  a neural network and linear combined regression model.\n\nTo use a pre-canned ``tensorflow.estimator`` instead of creating a ``model_fn``, you need to write a ``estimator_fn``. \nThe base skeleton for the ``estimator_fn`` looks like this:\n\n.. code:: python\n\n  def estimator_fn(run_config, hyperparameters):\n    # Logic to the following:\n    # 1. Defines the features columns that will be the input of the estimator\n    # 2. Returns an instance of a ``tensorflow.estimator`` passing in, the input run_config in the\n    #    constructor.\n\nExample of a complete ``estimator_fn``\n''''''''''''''''''''''''''''''''''''''\n\n.. code:: python\n\n  def estimator_fn(run_config, hyperparameters):\n      # Defines the features columns that will be the input of the estimator\n      feature_columns = [tf.feature_column.numeric_column(INPUT_TENSOR_NAME, shape=[4])]\n      # Returns the instance of estimator.\n      return tf.estimator.DNNClassifier(feature_columns=feature_columns,\n                                        hidden_units=[10, 20, 10],\n                                        n_classes=3,\n                                        config=run_config)\n\nMore details on how to create a ``tensorflow.estimator`` can be find in `Creating Estimators in tf.estimator <https://www.tensorflow.org/extend/estimators>`_.\n\nAn example on how to create a TensorFlow training script with an ``estimator_fn`` can find in this `example <https://github.com/awslabs/amazon-sagemaker-examples/tree/master/sagemaker-python-sdk/tensorflow_iris_dnn_classifier_using_estimators>`_.\n\n\nUsing a ``Keras`` model instead of a ``model_fn``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n``tf.keras`` is an full implementation inside TensorFlow of the Keras API. To use a ``tf.keras`` \nmodel for training instead of ``model_fn``, you need to write a ``keras_model_fn``. The base skeleton of\na ``keras_model_fn`` looks like this:\n\n.. code:: python\n\n  def keras_model_fn(hyperparameters):\n      # Logic to do the following:\n      # 1. Instantiate the Keras model\n      # 2. Compile the Keras model\n      return compiled_model\n\n\nExample of a complete ``keras_model_fn``\n''''''''''''''''''''''''''''''''''''''''\n\n.. code:: python\n\n  def keras_model_fn(hyperparameters):\n    # Instantiate a Keras inception v3 model.\n    keras_inception_v3 = tf.keras.applications.inception_v3.InceptionV3(weights=None)\n    # Compile model with the optimizer, loss, and metrics you'd like to train with.\n    keras_inception_v3.compile(optimizer=tf.keras.optimizers.SGD(lr=0.0001, momentum=0.9),\n                          loss='categorical_crossentropy', metric='accuracy')\n    return keras_inception_v3\n\n\nTensorFlow 1.4.0 support for ``Keras`` models is limited only for **non-distributed** training;\ni.e. set the ``train_instance_count`` parameter in the ``TensorFlow`` estimator equal to 1.\n\nMore details on how to create a ``Keras`` model can be find in the `Keras documentation <https://keras.io/>`_.\n\nRunning a TensorFlow training script in SageMaker\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nYou run TensorFlow training scripts on SageMaker by creating a ``sagemaker.tensorflow.TensorFlow`` estimator.\nWhen you call ``fit`` on the ``TensorFlow`` estimator, a training job is created in SageMaker.\nThe following code sample shows how to train a custom TensorFlow script 'tf-train.py'.\n\n.. code:: python\n\n  from sagemaker.tensorflow import TensorFlow\n\n  tf_estimator = TensorFlow('tf-train.py', role='SageMakerRole',\n                            training_steps=10000, evaluation_steps=100,\n                            train_instance_count=1, train_instance_type='ml.p2.xlarge')\n  tf_estimator.fit('s3://bucket/path/to/training/data')\n\nsagemaker.tensorflow.TensorFlow class\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe ``TensorFlow`` constructor takes both required and optional arguments.\n\nRequired arguments\n''''''''''''''''''\n\nThe following are required arguments to the TensorFlow constructor. \n\n-  ``entry_point (str)`` Path (absolute or relative) to the Python file which\n   should be executed as the entry point to training.\n-  ``role (str)`` An AWS IAM role (either name or full ARN). The Amazon\n   SageMaker training jobs and APIs that create Amazon SageMaker\n   endpoints use this role to access training data and model artifacts.\n   After the endpoint is created, the inference code might use the IAM\n   role, if accessing AWS resource.\n-  ``train_instance_count (int)`` Number of Amazon EC2 instances to use for\n   training.\n-  ``train_instance_type (str)`` Type of EC2 instance to use for training, for\n   example, 'ml.c4.xlarge'.\n- ``training_steps (int)`` Perform this many steps of training. ``None``, means train forever. \n- ``evaluation_steps (int)`` Perform this many steps of evaluation. ``None``, means\n  that evaluation runs until input from ``eval_input_fn`` is exhausted (or another exception is raised).\n\nOptional Arguments\n''''''''''''''''''\n\nThe following are optional arguments. When you create a ``TensorFlow`` object,\nyou can specify these as keyword arguments.\n\n-  ``source_dir (str)`` Path (absolute or relative) to a directory with any\n   other training source code dependencies aside from the entry point\n   file. Structure within this directory will be preserved when training\n   on SageMaker.\n-  ``hyperparameters (dict[str,ANY])`` Hyperparameters that will be used for training.\n   Will be made accessible as a dict[] to the training code on\n   SageMaker. Some hyperparameters will be interpreted by TensorFlow and can be use to \n   fine tune training. See `Optional Hyperparameters <#optional-hyperparameters>`_.\n-  ``train_volume_size (int)`` Size in GB of the EBS volume to use for storing\n   input data during training. Must be large enough to the store training\n   data.\n-  ``train_max_run (int)`` Timeout in hours for training, after which Amazon\n   SageMaker terminates the job regardless of its current status.\n-  ``output_path (str)`` S3 location where you want the training result (model\n   artifacts and optional output files) saved. If not specified, results\n   are stored to a default bucket. If the bucket with the specific name\n   does not exist, the estimator creates the bucket during the ``fit``\n   method execution.\n-  ``checkpoint_path`` S3 location where checkpoint data will saved and restored. \n   The default location is *bucket_name/job_name/checkpoint*. If the location \n   already has checkpoints before the training starts, the model will restore \n   state from the last saved checkpoint. It is very useful to restart a training. \n   See `Restoring from checkpoints <#restoring-from-checkpoints>`_.\n-  ``output_kms_key`` Optional KMS key ID to optionally encrypt training\n   output with.\n-  ``base_job_name`` Name to assign for the training job that the ``fit``\n   method launches. If not specified, the estimator generates a default\n   job name, based on the training image name and current timestamp.\n\n\nOptional Hyperparameters\n''''''''''''''''''''''''\n\nThese hyperparameters are used by TensorFlow to fine tune the training. \nYou need to add them inside the hyperparameters dictionary in the \n``TensorFlow`` estimator constructor.\n\n-  ``save_summary_steps (int)`` Save summaries every this many steps.\n-  ``save_checkpoints_secs (int)`` Save checkpoints every this many seconds. Can not be specified with ``save_checkpoints_steps``.\n-  ``save_checkpoints_steps (int)`` Save checkpoints every this many steps. Can not be specified with ``save_checkpoints_secs``.\n-  ``keep_checkpoint_max (int)`` The maximum number of recent checkpoint files to keep. As new files are created, older files are deleted. If None or 0, all checkpoint files are kept. Defaults to 5 (that is, the 5 most recent checkpoint files are kept.)\n-  ``keep_checkpoint_every_n_hours (int)`` Number of hours between each checkpoint to be saved. The default value of 10,000 hours effectively disables the feature.\n-  ``log_step_count_steps (int)`` The frequency, in number of global steps, that the global step/sec will be logged during training.\n-  ``eval_metrics (dict)`` ``dict`` of string, metric function. If `None`, default set is used. This should be ``None`` if the ``estimator`` is `tf.estimator.Estimator <https://www.tensorflow.org/api_docs/python/tf/estimator/Estimator>`_. If metrics are provided they will be *appended* to the default set.\n-  ``train_monitors (list)`` A list of monitors to pass during training.\n-  ``eval_hooks (list)`` A list of `SessionRunHook` hooks to pass during evaluation.\n-  ``eval_delay_secs (int)`` Start evaluating after waiting for this many seconds.\n-  ``continuous_eval_throttle_secs (int)`` Do not re-evaluate unless the last evaluation was started at least this many seconds ago.\n-  ``min_eval_frequency (int)`` The minimum number of steps between evaluations. Of course, evaluation does not occur if no new snapshot is available, hence, this is the minimum. If 0, the evaluation will only happen after training. If None, defaults to default is 1000.\n-  ``delay_workers_by_global_step (bool)`` if ``True`` delays training workers based on global step instead of time.\n- ``train_steps_per_iteration (int)`` Perform this many (integer) number of train steps for each training-evaluation iteration. With a small value, the model will be evaluated more frequently with more checkpoints saved.\n\nCalling fit\n^^^^^^^^^^^\n\nYou start your training script by calling ``fit`` on a ``TensorFlow`` estimator. ``fit`` takes\nboth required and optional arguments.\n\nRequired argument\n'''''''''''''''''\n\n-  ``inputs (str)``: A S3 URI, for example ``s3://my-bucket/my-training-data``, which contains \n   the dataset that will be used for training. When the training job starts in SageMaker the\n   container will download the dataset. Both ``train_input_fn`` and ``eval_input_fn`` functions\n   have a parameter called ``training_dir`` which contains the directory inside the container \n   where the dataset was saved into. See `Creating train_input_fn and eval_input_fn functions`_.\n\nOptional arguments\n''''''''''''''''''\n\n-  ``wait (bool)``: Defaults to True, whether to block and wait for the\n   training script to complete before returning.\n-  ``logs (bool)``: Defaults to True, whether to show logs produced by training\n   job in the Python session. Only meaningful when wait is True.\n- ``run_tensorboard_locally (bool)``: Defaults to False. Executes TensorBoard in a different \n  process with downloaded checkpoint information. Requires modules TensorBoard and AWS CLI. \n  installed. Terminates TensorBoard when the execution ends. See `Running TensorBoard`_.\n- ``job_name (str)``: Training job name. If not specified, the estimator generates a default job name,\n  based on the training image name and current timestamp.\n\nWhat happens when fit is called\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\nCalling ``fit`` starts a SageMaker training job. The training job will execute the following.\n\n- Starts ``train_instance_count`` EC2 instances of the type ``train_instance_type``.\n- On each instance, it will do the following steps:\n\n  - starts a Docker container optimized for TensorFlow, see `SageMaker TensorFlow Docker containers`_.\n  - downloads the dataset.\n  - setup up distributed training.\n  - starts asynchronous training, executing the ``model_fn`` function defined in your script \n    in **training** mode; i.e., ``features`` and ``labels`` are fed by a batch of the \n    training dataset defined by ``train_input_fn``. See `Creating train_input_fn and eval_input_fn functions`_.\n\nThe training job finishes after the number of training steps reaches the value defined by\nthe ``TensorFlow`` estimator parameter ``training_steps`` is finished or when the training\njob execution time reaches the ``TensorFlow`` estimator parameter ``train_max_run``.\n\nWhen the training job finishes, a `TensorFlow serving <https://www.tensorflow.org/serving/serving_basic>`_ \nwith the result of the training is generated and saved to the S3 location define by\nthe ``TensorFlow`` estimator parameter ``output_path``.\n\nThe evaluation process\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\nDuring the training job, the first EC2 instance that is executing the training is named ``master``. All the other instances are called ``workers``.\n\nAll instances execute the training loop, feeding the ``model_fn`` with ``train_input_fn``.\nEvery ``min_eval_frequency`` steps (see `Optional Hyperparameters`_), the ``master`` instance\nwill execute the ``model_fn`` in **evaluation** mode; i.e., ``features`` and ``labels`` are\nfed with the evaluation dataset defined by ``eval_input_fn``. See `Creating train_input_fn and eval_input_fn functions`_. \n\nFor more information on training and evaluation process, see `tf.estimator.train_and_evaluate <https://github.com/tensorflow/tensorflow/blob/r1.4/tensorflow/python/estimator/training.py#L256>`_.\n\nFor more information on fit, see `SageMaker Python SDK Overview <#sagemaker-python-sdk-overview>`_.\n\nTensorFlow serving models\n^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAfter your training job is complete in SageMaker and the ``fit`` call ends, the training job \nwill generate a `TensorFlow serving <https://www.tensorflow.org/serving/serving_basic>`_ \nmodel ready for deployment. Your TensorFlow serving model will be available in the S3 location \n``output_path`` that you specified when you created your `sagemaker.tensorflow.TensorFlow` \nestimator.\n\nRestoring from checkpoints\n^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nWhile your training job is executing, TensorFlow will generate checkpoints and save them in the S3\nlocation defined by ``checkpoint_path`` parameter in the ``TensorFlow`` constructor. \nThese checkpoints can be used to restore a previous session or to evaluate the current training using ``TensorBoard``.\n\nTo restore a previous session, you just need to create a new ``sagemaker.tensorflow.TensorFlow`` \nestimator pointing to the previous checkpoint path:\n\n.. code:: python\n\n  previous_checkpoint_path = 's3://location/of/my/previous/generated/checkpoints'\n\n  tf_estimator = TensorFlow('tf-train.py', role='SageMakerRole',\n                            checkpoint_path=previous_checkpoint_path\n                            training_steps=10000, evaluation_steps=100,\n                            train_instance_count=1, train_instance_type='ml.p2.xlarge')\n  tf_estimator.fit('s3://bucket/path/to/training/data')\n\n\nRunning TensorBoard\n^^^^^^^^^^^^^^^^^^^\n\nWhen the ``fit`` parameter ``run_tensorboard_locally`` is set ``True``, all the checkpoint data \nlocated in ``checkpoint_path`` will be downloaded to a local temporary folder and a local \n``TensorBoard`` application will be watching that temporary folder. \nEvery time a new checkpoint is created by the training job in the S3 bucket, ``fit`` will download that checkpoint to the same temporary folder and update ``TensorBoard``.\n\nWhen the ``fit`` method starts the training, it will log the port that ``TensorBoard`` is using \nto display metrics. The default port is **6006**, but another port can be chosen depending on \navailability. The port number will increase until finds an available port. After that, the port\nnumber will be printed in stdout.\n\nIt takes a few minutes to provision containers and start the training job. TensorBoard will start to display metrics shortly after that.\n\nYou can access TensorBoard locally at http://localhost:6006 or using your SakeMaker workspace at \n`https*workspace_base_url*proxy/6006/ <proxy/6006/>`_ (TensorBoard will not work if you forget to put the slash, \n'/', in end of the url). If TensorBoard started on a different port, adjust these URLs to match.\n\n\nDeploying TensorFlow Serving models\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nAfter a ``TensorFlow`` Estimator has been fit, it saves a ``TensorFlow Serving`` model in\nthe S3 location defined by ``output_path``. You can call ``deploy`` on a ``TensorFlow``\nestimator to create a SageMaker Endpoint. \n\nA common usage of the ``deploy`` method, after the ``TensorFlow`` estimator has been fit look\nlike this:\n\n.. code:: python\n\n  from sagemaker.tensorflow import TensorFlow\n\n  estimator = TensorFlow(entry_point='tf-train.py', ..., train_instance_count=1, train_instance_type='ml.c4.xlarge')\n\n  estimator.fit(inputs)\n\n  predictor = estimator.deploy(initial_instance_count=1, instance_type='ml.c4.xlarge')\n\n\nThe code block above deploys a SageMaker Endpoint with one instance of the type 'ml.c4.xlarge'. \n\nWhat happens when deploy is called\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nCalling ``deploy`` starts the process of creating a SageMaker Endpoint. This process includes the following steps.\n\n- Starts ``initial_instance_count`` EC2 instances of the type ``instance_type``.\n- On each instance, it will do the following steps:\n\n  - start a Docker container optimized for TensorFlow Serving, see `SageMaker TensorFlow Docker containers`_.\n  - start a production ready HTTP Server which supports protobuf, JSON and CSV content types, see `Making predictions against a SageMaker Endpoint`_.\n  - start a `TensorFlow Serving` process\n\nWhen the ``deploy`` call finishes, the created SageMaker Endpoint is ready for prediction requests. The next chapter will explain\nhow to make predictions against the Endpoint, how to use different content-types in your requests, and how to extend the Web server\nfunctionality.\n\n\nMaking predictions against a SageMaker Endpoint\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe following code adds a prediction request to the previous code example:\n\n.. code:: python\n\n  estimator = TensorFlow(entry_point='tf-train.py', ..., train_instance_count=1, train_instance_type='ml.c4.xlarge')\n\n  estimator.fit(inputs)\n\n  predictor = estimator.deploy(initial_instance_count=1, instance_type='ml.c4.xlarge')\n\n  result = predictor.predict([6.4, 3.2, 4.5, 1.5])\n\nThe ``predictor.predict`` method call takes one parameter, the input ``data`` for which you want the ``SageMaker Endpoint`` \nto provide inference. ``predict`` will serialize the input data, and send it in as request to the ``SageMaker Endpoint`` by\nan ``InvokeEndpoint`` SageMaker operation. ``InvokeEndpoint`` operation requests can be made by ``predictor.predict``, by\nboto3 ``SageMaker.runtime`` client or by AWS CLI. \n\nThe ``SageMaker Endpoint`` web server will process the request, make an inference using the deployed model, and return a response. \nThe ``result`` returned by ``predict`` is\na Python dictionary with the model prediction. In the code example above, the prediction ``result`` looks like this:\n\n.. code:: python\n\n  {'result': \n    {'classifications': [\n      {'classes': [\n        {'label': '0', 'score': 0.0012890376383438706},\n        {'label': '1', 'score': 0.9814321994781494},\n        {'label': '2', 'score': 0.017278732731938362}\n      ]}\n    ]}\n  }\n\nSpecifying the output of a prediction request\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe format of the prediction ``result`` is determined by the parameter ``export_outputs`` of the `tf.estimator.EstimatorSpec <https://www.tensorflow.org/api_docs/python/tf/estimator/EstimatorSpec>`_ that you returned when you created your ``model_fn``, see \n`Example of a complete model_fn`_ for an example of ``export_outputs``. \n\nMore information on how to create ``export_outputs`` can find in `specifying the outputs of a custom model <https://github.com/tensorflow/tensorflow/blob/r1.4/tensorflow/docs_src/programmers_guide/saved_model.md#specifying-the-outputs-of-a-custom-model>`_.\n\nEndpoint prediction request handling\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nWhenever a prediction request is made to a SageMaker Endpoint via a ``InvokeEndpoint`` SageMaker operation, the request will\nbe deserialized by the web server, sent to TensorFlow Serving, and serialized back to the client as response.\n\nThe TensorFlow Web server breaks request handling into three steps:\n\n-  input processing,\n-  TensorFlow Serving prediction, and\n-  output processing.\n\nThe SageMaker Endpoint provides default input and output processing, which support by default JSON, CSV, and protobuf requests.\nThis process looks like this:\n\n.. code:: python\n\n    # Deserialize the Invoke request body into an object we can perform prediction on\n    deserialized_input = input_fn(serialized_input, request_content_type)\n\n    # Perform prediction on the deserialized object, with the loaded model\n    prediction_result = make_tensorflow_serving_prediction(deserialized_input)\n\n    # Serialize the prediction result into the desired response content type\n    serialized_output = output_fn(prediction_result, accepts)\n\nThe common functionality can be extended by the addiction of the following two functions to your training script:\n\nOverriding input precessing with an ``input_fn``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn example of ``input_fn`` for the content-type \"application/python-pickle\" can be seen below:\n\n.. code:: python\n\n    import numpy as np\n\n    def input_fn(serialized_input, content_type):\n        \"\"\"An input_fn that loads a pickled object\"\"\"\n        if request_content_type == \"application/python-pickle\":\n            deserialized_input = pickle.loads(serialized_input)\n            return deserialized_input\n        else:\n            # Handle other content-types here or raise an Exception\n            # if the content type is not supported.\n            pass  \n\nOverriding output precessing with an ``output_fn``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn example of ``output_fn`` for the accept type \"application/python-pickle\" can be seen below:\n\n.. code:: python\n\n    import numpy as np\n\n    def output_fn(prediction_result, accepts):\n        \"\"\"An output_fn that dumps a pickled object as response\"\"\"\n        if request_content_type == \"application/python-pickle\":\n            return np.dumps(prediction_result)\n        else:\n            # Handle other content-types here or raise an Exception\n            # if the content type is not supported.\n            pass  \n\nA example with ``input_fn`` and ``output_fn`` above can be found in\n`here <https://github.com/aws/sagemaker-python-sdk/blob/master/tests/data/cifar_10/source/resnet_cifar_10.py#L143>`_.\n\nSageMaker TensorFlow Docker containers\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe TensorFlow Docker container supports Python 2.7. The Docker container has the following Python modules installed:\n- awscli 1.12.1\n- boto3 1.4.7\n- botocore 1.5.92\n- futures 2.2.0\n- gevent 1.2.2\n- grpcio 1.7.0\n- numpy 1.13.3\n- pandas 0.21.0\n- protobuf 3.4.0\n- requests 2.14.2\n- scikit-learn 0.19.1\n- scipy 1.0.0\n- six 1.10.0\n- sklearn 0.0\n- tensorflow 1.4.0\n- tensorflow-serving-api 1.4.0\n- tensorflow-tensorboard 0.4.0rc2\n\nThe Docker images extend Ubuntu 16.04.\n\n\nAWS SageMaker Estimators\n------------------------\nAmazon SageMaker provides several built-in machine learning algorithms that you can use for a variety of problem types. \n\nThe full list of algorithms is available on the AWS website: https://docs.aws.amazon.com/sagemaker/latest/dg/algos.html\n\nSageMaker Python SDK includes Estimator wrappers for the AWS K-means, Principal Components Analysis, and Linear Learner algorithms.\n\nDefinition and usage\n~~~~~~~~~~~~~~~~~~~~\nEstimators that wrap Amazon's built-in algorithms define algorithm's hyperparameters with defaults. When a default is not possible you need to provide the value during construction:\n\n- ``KMeans`` Estimator requires parameter ``k`` to define number of clusters\n- ``PCA`` Estimator requires parameter ``num_components`` to define number of principal components\n\nInteraction is identical as any other Estimators. There are additional details about how data is specified.\n\nInput data format\n^^^^^^^^^^^^^^^^^\nPlease note that Amazon's built-in algorithms are working best with protobuf ``recordIO`` format.\nThe data is expected to be available in S3 location and depending on algorithm it can handle dat in multiple data channels.\n\nThis package offers support to prepare data into required fomrat and upload data to S3.\nProvided class ``RecordSet`` captures necessary details like S3 location, number of records, data channel and is expected as input parameter when calling ``fit()``.\n\nFunction ``record_set`` is available on algorithms objects to make it simple to achieve the above.\nIt takes 2D numpy array as input, uploads data to S3 and returns ``RecordSet`` objects. By default it uses ``train`` data channel and no labels but can be specified when called.\n\nPlease find an example code snippet for illustration:\n\n.. code:: python\n\n    from sagemaker import PCA\n    pca_estimator = PCA(role='SageMakerRole', train_instance_count=1, train_instance_type='ml.m4.xlarge', num_components=3)\n\n    import numpy as np\n    records = pca_estimator.record_set(np.arange(10).reshape(2,5))\n\n    pca_estimator.fit(records)\n\n\nPredictions support\n~~~~~~~~~~~~~~~~~~~\nCalling inference on deployed Amazon's built-in algorithms requires specific input format. By default, this library creates a predictor that allows to use just numpy data.\nData is converted so that ``application/x-recordio-protobuf`` input format is used. Received response is deserialized from the protobuf and provided as result from the ``predict`` call.\n\n\nBYO Docker Containers with SageMaker Estimators\n-----------------------------------------------\n\nWhen you want to use a Docker image prepared earlier and use SageMaker SDK for training the easiest way is to use dedicated ``Estimator`` class. You will be able to instantiate it with desired image and use it in same way as described in previous sections.\n\nPlease refer to the full example in the examples repo:\n\n::\n\n    git clone https://github.com/awslabs/amazon-sagemaker-examples.git\n\n\nThe example notebook is is located here:\n``advanced_functionality/scikit_bring_your_own/scikit_bring_your_own.ipynb``\n\nFAQ\n---\n\nI want to train a SageMaker Estimator with local data, how do I do this?\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nYou'll need to upload the data to S3 before training. You can use the AWS Command Line Tool (the aws cli) to achieve this.\n\nIf you don't have the aws cli, you can install it using pip:\n\n::\n\n    pip install awscli --upgrade --user\n\nIf you don't have pip or want to learn more about installing the aws cli, please refer to the official `Amazon aws cli installation guide <http://docs.aws.amazon.com/cli/latest/userguide/installing.html>`__.\n\nOnce you have the aws cli installed, you can upload a directory of files to S3 with the following command:\n\n::\n\n    aws s3 cp /tmp/foo/ s3://bucket/path\n\nYou can read more about using the aws cli for manipulating S3 resources in the `AWS cli command reference <http://docs.aws.amazon.com/cli/latest/reference/s3/index.html>`__.\n\n\nHow do I make predictions against an existing endpoint?\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nCreate a Predictor object and provide it your endpoint name. Then, simply call its predict() method with your input.\n\nYou can either use the generic RealTimePredictor class, which by default does not perform any serialization/deserialization transformations on your input, but can be configured to do so through constructor arguments:\nhttp://sagemaker.readthedocs.io/en/latest/predictors.html\n\nOr you can use the TensorFlow / MXNet specific predictor classes, which have default serialization/deserialization logic:\nhttp://sagemaker.readthedocs.io/en/latest/sagemaker.tensorflow.html#tensorflow-predictor\nhttp://sagemaker.readthedocs.io/en/latest/sagemaker.mxnet.html#mxnet-predictor\n\nExample code using the TensorFlow predictor:\n\n::\n\n    from sagemaker.tensorflow import TensorFlowPredictor\n    \n    predictor = TensorFlowPredictor('myexistingendpoint')\n    result = predictor.predict(['my request body'])",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "https://github.com/aws/sagemaker-python-sdk/",
    "keywords": "ML Amazon AWS AI Tensorflow MXNet",
    "license": "Apache License 2.0",
    "maintainer": "",
    "maintainer_email": "",
    "name": "sagemaker",
    "platform": "",
    "project_url": "https://pypi.org/project/sagemaker/",
    "release_url": "https://pypi.org/project/sagemaker/1.0.2/",
    "requires_dist": [],
    "requires_python": "",
    "summary": "Open source library for training and deploying models on Amazon SageMaker.",
    "version": "1.0.2"
  },
  "releases": {
    "1.0.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "59476baf3e55acafd40d76a3cdebdec2",
          "sha256": "baeb182ac2e4dc179153eaefc47829e93027076e4f2be454618a6fe267f94833"
        },
        "downloads": -1,
        "filename": "sagemaker-1.0.0.tar.gz",
        "has_sig": true,
        "md5_digest": "59476baf3e55acafd40d76a3cdebdec2",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 120877,
        "upload_time": "2017-11-30T06:11:50",
        "url": "https://files.pythonhosted.org/packages/7c/0d/674ae8b1de262194af4a7bd0445fcb1a7c2ba563ac18310901404b113cd0/sagemaker-1.0.0.tar.gz"
      }
    ],
    "1.0.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "73ade9274d92b15b050c0a0e17541969",
          "sha256": "08ffcf2a1c0c59244729efadcbf67c8f7f29eecb3ae9e6b2f388022e91308be4"
        },
        "downloads": -1,
        "filename": "sagemaker-1.0.1.tar.gz",
        "has_sig": true,
        "md5_digest": "73ade9274d92b15b050c0a0e17541969",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 123120,
        "upload_time": "2017-12-23T03:52:25",
        "url": "https://files.pythonhosted.org/packages/2a/f1/22ac4b1c83297ae87ac6b5b1c088952c2c02093ddd229a5e55342ecd8e1d/sagemaker-1.0.1.tar.gz"
      }
    ],
    "1.0.2": [
      {
        "comment_text": "",
        "digests": {
          "md5": "bbe5718bedc423da1ee55721e36d0f5c",
          "sha256": "c370874201517110f4256d09fef083d1c53fd5d9e98c93e7a621313f2f97a62a"
        },
        "downloads": -1,
        "filename": "sagemaker-1.0.2.tar.gz",
        "has_sig": true,
        "md5_digest": "bbe5718bedc423da1ee55721e36d0f5c",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 126034,
        "upload_time": "2018-01-25T17:12:06",
        "url": "https://files.pythonhosted.org/packages/9d/0d/a0fda5ba95af67ab38ff4cff966f37a9f46a6d4fae6e50820faec0fbc121/sagemaker-1.0.2.tar.gz"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "bbe5718bedc423da1ee55721e36d0f5c",
        "sha256": "c370874201517110f4256d09fef083d1c53fd5d9e98c93e7a621313f2f97a62a"
      },
      "downloads": -1,
      "filename": "sagemaker-1.0.2.tar.gz",
      "has_sig": true,
      "md5_digest": "bbe5718bedc423da1ee55721e36d0f5c",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 126034,
      "upload_time": "2018-01-25T17:12:06",
      "url": "https://files.pythonhosted.org/packages/9d/0d/a0fda5ba95af67ab38ff4cff966f37a9f46a6d4fae6e50820faec0fbc121/sagemaker-1.0.2.tar.gz"
    }
  ]
}