{
  "info": {
    "author": "Gabe Appleton",
    "author_email": "gabe@gabeappleton.me",
    "bugtrack_url": "",
    "classifiers": [
      "Development Status :: 4 - Beta",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: GNU Lesser General Public License v3 (LGPLv3)",
      "Operating System :: OS Independent",
      "Programming Language :: Other",
      "Programming Language :: Python",
      "Programming Language :: Python :: 2",
      "Programming Language :: Python :: 2.7",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.3",
      "Programming Language :: Python :: 3.4",
      "Programming Language :: Python :: 3.5",
      "Programming Language :: Python :: 3.6",
      "Topic :: Internet",
      "Topic :: Scientific/Engineering :: GIS",
      "Topic :: Software Development :: Compilers"
    ],
    "description": "overpassify\n===========\n\nA Python to OverpassQL transpiler\n\n`OverpassQL <http://wiki.openstreetmap.org/wiki/Overpass_API/Overpass_QL>`__\nis the language used to query features on OpenStreetMap. Unfortunately,\nit's not very readable.\n\nThe goal here is to enable people to write in a more developer-friendly\nlanguage, and still have it work on the existing infrastructure. As of\nnow, ``overpassify`` can take a snippet like:\n\n.. code:: python\n\n    from overpassify import overpassify\n\n    @overpassify\n    def query():\n        search = Area(3600134503)\n        ways = Way(search, highway=...)\n        nodes = Node(search)\n        out(ways, geom=True, count=True)\n        out(nodes, geom=True, count=True)\n        out()\n\nAnd from that generate:\n\n.. code::\n\n    (area(3600134503);) -> .search;\n    (way[\"highway\"](area.search);) -> .ways;\n    (node(area.search);) -> .nodes;\n    .ways out count;\n    .ways out geom;\n    .nodes out count;\n    .nodes out geom;\n\nThat last ``out()`` is because of `issue\n#2 <https://github.com/gappleto97/overpassify/issues/2>`__. And as a\nnote, this library assumes you never use a variable name of the form\n``tmp*``. That format will probably be changed to something even less\nlikely in the future, but some translations (for instance, a full\nternary) *require* the use of temporary variables.\n\nOverview\n--------\n\nI'll say this from the outset: ``overpassify`` will support a subset of\nPython. Some things are just too difficult (and maybe impossible) to\nautomatically translate. Functions are an example of that.\n\nOn the other hand, it will try to support a superset of easily-usable\nOverpassQL. Some of those extra features won't be as efficient as their\nPython counterparts, but they will be available.\n\nCurrently ``overpassify`` supports 35/56 of the features listed in the\nOverpassQL guide, and additionally supports ternary, ``if`` blocks,\n``break``, and ``continue``.\n\nClasses\n-------\n\nThis library provides wrappers for five types. ``Set()``, ``Node()``,\n``Way()``, ``Area()``, and ``Relation()``. Those last four are *all*\nconsidered subclasses of ``Set()``.\n\nThis library also provides support for strings and numbers. In the\nfuture it will provide support for regex and other things in specific\nplaces.\n\n(Note: Currently nested constructors have some problems in\nimplementation)\n\nAssignment\n----------\n\nThis works about the way you'd expect it to. There are a couple caveats\nthough.\n\n#. You cannot assign a non-\\ ``Set()`` to a variable. This means only\n   those five classes listed above.\n#. You cannot assign multiple variables in one line. No ``a, b = b, a``,\n   and the like. This could *potentially* be changed later.\n\nNumber and Set Arithmetic\n-------------------------\n\nAnother supported feature is the ability to manipulate these sets and\nnumbers.\n\nAdding sets will produce the union of those sets. Adding numbers will\nproduce their sum.\n\nSubtracting **two** sets will produce their difference. Subtracting\nnumbers will do the same.\n\nSet Filtering\n-------------\n\nYou are also allowed to filter a ``Set()``'s contents by type. For\ninstance, ``Way.filter(<some set>)`` would yield all the ways within\n``<some set>``.\n\nSet intersections\n-----------------\n\nA similar process will allow you to take the intersection of arbitrary\nnumbers of **named** sets. So ``Set.intersect(a, b)`` will yield all\nelements common between ``a`` and ``b``. You cannot, at the moment, use\nan expression inside this function. It **must** be predefined.\n\nYou can also use this in tandem with Set Filtering. So\n``Area.intersect(a, b)`` would yield only the areas common between ``a``\nand ``b``.\n\nSearching for Sets\n------------------\n\nThis library also supports *most* of the ways OverpassQL can search for\ninformation. This currently includes:\n\n#. Checking within an area (or set of areas)\n#. Fetching by ID\n#. Tag matching\n#. Conditional filters (see next section)\n\nThe first two are just given as arguments to the constructor. If you put\nin ``Way(12345)``, that will find the Way with ID 12345. If you put in\n``Way(<some area>)``, it will return all ways within that area.\n\nYou can also define areas using the ``Around()`` function. This has two\nuseful overloads. The first takes the form\n``Around(<some set>, <radius in meters>)``. The second takes the form\n``Around(<radius in meters>, <latitude>, <longitude>)``.\n\nTag matching can be done with keyword arguments. So if you look for\n``Node(highway=\"stop\")``, that will find you all stop signs. It also\nsupports existence checking (``Way(highway=...)``), and non-existence\nchecking (``Area(landuse=None)``), and regex matching\n(``Way(highway=Regex(\"path|cycleway|sidewalk\"))``).\n\nYou can also search by both an area and a filter. For instance:\n``Way(<your hometown>, maxspeed=None)``.\n\nTernary Expressions and Conditional Filters\n-------------------------------------------\n\nYou can also filter using the familiar ``a if b else c``. This would\nmean that if ``b`` is truthy, ``a`` should become ``b``, and otherwise\nbecome ``c``.\n\nUnfortunately, since this is not a native feature to OverpassQL, it ends\nup evaluating both sides of that statement.\n\nIf you want ``c`` to be an empty set, however, we can optimize that. So\n``foo = a if b else Set()`` is the syntax to use there.\n\nAdditional performance is lost because OverpassQL does not support a\nconditional being the *only* filter. This means that we need to provide\nsome other filter, and one in current use is to divide it by type and\nreconstruct. There is some progress which can be made here, but it's not\nyet a priority.\n\nReturning Data\n--------------\n\nIn OverpassQL, data can be returned in pieces throughout the function.\nIt's more equivalent to Python's ``yield`` than ``return``. The function\nwe use for that here is ``out()``.\n\n``out()`` takes in one positional argument, and many possible keyword\narguments. It yields data for the positional argument using all the\ntypes defined in the keywords.\n\nFor instance ``out(<set of nodes>, geom=True, body=True, qt=True)``\nwould return all the data that MapRoulette needs to draw those points on\ntheir map.\n\nAs a sidenote, the value given for these keywords is never actually\nchecked. It could as easily be ``geom=False`` as ``geom=True``, and\n``overpassify`` will not care.\n\nFor-Each Loop\n-------------\n\nHere you can use the traditional Python for loop:\n\n.. code:: python\n\n    for way in ways:\n        out(way, geom=True)\n\nIt does not yet support the else clause, and though it supports ``break`` and\n``continue``, please be aware that this will dramatically slow runtime in that\nloop.\n\nIf Statements\n-------------\n\nThis is a feature that OverpassQL cannot do without some emulation. So\nwhat we do here is:\n\n#. Grab an individual item that will probably be stable over long\n   periods of time; in this case, the ``Relation()`` representing\n   Antarctica\n#. Use a conditional filter on that relation to get a one item or zero\n   item ``Set()``\n#. Iterate over that in a for loop\n#. If there is an else clause, use a conditional filter with the\n   negation of the test given to get a one item or zero item ``Set()``\n#. Iterate over the else clause in a for loop\n\nSettings\n--------\n\nWe also provide a wrapper for the option headers. Note that this will\nraise an error if it's not on the first line of your query.\n\nThe valid keywords for ``Settings()`` are as follows:\n\n-  ``timeout``: The maximum number of seconds you would like your query\n   to run for\n-  ``maxsize``: The maximum number of bytes you would like your query to\n   return\n-  ``out``: The format to return in. It defaults to XML, but you can set\n   it to ``\"json\"`` or a variant on ``\"csv\"``, as described `in the\n   OverpassQL\n   spec <http://wiki.openstreetmap.org/wiki/Overpass_API/Overpass_QL#Output_Format_.28out.29>`__\n-  ``bbox``: The string describing a global bounding box. It is used to\n   limit the area your query can encompass, and should take the form\n   ``\"<southern lat>,<western lon>,<northern lat>,<eastern lon>\"``\n-  ``date``: The string describing what date you would like to query\n   for. This allows you to look at past database states. Note that it\n   needs an extra set of quotes, so it would look like\n   ``date='\"2012-09-12T06:55:00Z\"'``\n-  ``diff``: Similar to the above, except it will return the difference\n   between that query run at each time. If you give one time, it will\n   assume you want to compare to now. It would look like\n   ``diff='\"2012-09-12T06:55:00Z\",\"2014-12-24T13:33:00Z\"'``\n-  ``adiff``: Similar to the above, except that it tells you what\n   happened to each absent element\n\nRough Translation Table\n-----------------------\n\n+--------------------+---------------------------------------+----------------------------------------------------+\n| Feature            | OverpassQL                            | Python                                             |\n+====================+=======================================+====================================================+\n| Assignment         | ``<expr> -> .name``                   | ``name = <expr>``                                  |\n+--------------------+---------------------------------------+----------------------------------------------------+\n| Unions             | ``(<set>; ...; <set>)``               | ``<set> + ... + <set>``                            |\n+--------------------+---------------------------------------+----------------------------------------------------+\n| Difference         | ``(<set> - <set)``                    | ``<set> - <set>``                                  |\n+--------------------+---------------------------------------+----------------------------------------------------+\n| Intersection       | ``.<set>.<set>``                      | ``Set.intersect(<set>, <set>)``                    |\n+--------------------+---------------------------------------+----------------------------------------------------+\n| Type-filtering     | ``way.<set>``                         | ``Way.filter(<set>)``                              |\n+--------------------+---------------------------------------+----------------------------------------------------+\n| Searching          |                                       |                                                    |\n+--------------------+---------------------------------------+----------------------------------------------------+\n| ..By ID            | ``area(1)`` or ``way(7)``             | ``Area(1)`` or ``Way(7)``                          |\n+--------------------+---------------------------------------+----------------------------------------------------+\n| ..In an area       | ``way(area.<set>)``                   | ``Way(<set>)``                                     |\n+--------------------+---------------------------------------+----------------------------------------------------+\n| ..By tags          | ``way[\"tag\"=\"value\"]``                | ``Way(tag=value)``                                 |\n+--------------------+---------------------------------------+----------------------------------------------------+\n| ..In area + tag    | ``way[\"highway\"=\"*\"](area.<set>)``    | ``Way(<set>, highway=\"*\")``                        |\n+--------------------+---------------------------------------+----------------------------------------------------+\n| Ternary            | very long                             | ``<expr> if <condition> else <expr>``              |\n+--------------------+---------------------------------------+----------------------------------------------------+\n| Conditional Filter | ``<type>.<set>(if: <condition>)``\\ \\* | ``<expr> if <condition> else Set()``               |\n+--------------------+---------------------------------------+----------------------------------------------------+\n| For Loop           | ``foreach.<set>->.<each>(<body>)``    | ``for <each> in <set>:\\n    <body>``               |\n+--------------------+---------------------------------------+----------------------------------------------------+\n| If Statement       | very long                             | ``if <condition>:\\n    <body>\\nelse:\\n    <body>`` |\n+--------------------+---------------------------------------+----------------------------------------------------+\n\n\\* ``overpassify`` will allow for mixed sets here by repeating for each\ntype. This may be optimized better in the future.\n\nFeatures Not Yet Implemented\n----------------------------\n\n#. Recursion Queries\n\n   #. Recurse Up\n   #. Recurse Up Relations\n   #. Recurse Down\n   #. Recurse Down Relations\n\n#. Filters\n\n   #. is\\_in Queries\n   #. Key Regex\n   #. Recursion Functions\n   #. Filter By Bounding Box\n   #. Filter By Polygon\n   #. Filter By \"newer\"\n   #. Filter By Date Of Change\n   #. Filter By User\n   #. Filter By Area Pivot\n\n#. ID Evaluators\n\n   #. id() And type()\n   #. is\\_tag() And Tag Fetching\n   #. Property Count Functions\n\n#. Aggregators\n\n   #. Union and Set\n   #. Min and Max\n   #. Sum\n   #. Statistical Counts\n\n#. Number Normalizer\n#. Date Normalizer\n\n\n",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "https://github.com/gappleto97/overpassify",
    "keywords": "OSM OpenStreetMap Overpass OverpassQL Transpiler Compiler Query",
    "license": "LGPLv3",
    "maintainer": "",
    "maintainer_email": "",
    "name": "overpassify",
    "platform": "",
    "project_url": "https://pypi.org/project/overpassify/",
    "release_url": "https://pypi.org/project/overpassify/1.1.0/",
    "requires_python": "",
    "summary": "A tool to more easily develop queries of OpenStreetMap",
    "version": "1.1.0"
  },
  "releases": {
    "1.0.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "f1b786e574219c3309f558be1ddac9b1",
          "sha256": "f60e6b726212e4c33bfd605db3849649643134644aa0f098fa5043c623e8dc00"
        },
        "downloads": 0,
        "filename": "overpassify-1.0.0-py2.py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "f1b786e574219c3309f558be1ddac9b1",
        "packagetype": "bdist_wheel",
        "python_version": "py2.py3",
        "size": 13850,
        "upload_time": "2017-06-13T20:02:29",
        "url": "https://files.pythonhosted.org/packages/4f/33/83173d29bd03047cba8cf529df49f831473e3ef3d2f88fa379a127318cfd/overpassify-1.0.0-py2.py3-none-any.whl"
      }
    ],
    "1.0.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "7702ea6fae1dcb3ad6f59cddd614247a",
          "sha256": "5f229560c3fddbb21257d8c2c599dac88199d7ea8fd9b016a2944b9d657ecb97"
        },
        "downloads": 0,
        "filename": "overpassify-1.0.1-py2.py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "7702ea6fae1dcb3ad6f59cddd614247a",
        "packagetype": "bdist_wheel",
        "python_version": "py2.py3",
        "size": 13814,
        "upload_time": "2017-06-13T20:21:16",
        "url": "https://files.pythonhosted.org/packages/b2/a6/b987cff2e641a81cb1e39f037a1d03f7c1c7cc77d89f0c8eb3175a690699/overpassify-1.0.1-py2.py3-none-any.whl"
      }
    ],
    "1.1.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "4a2bac134a5c8ea4983554b5dc42d7ac",
          "sha256": "ac4cc755e8d06e0ccf6f3427720d2936f1a2c94a001a9d337173f565d585be04"
        },
        "downloads": 0,
        "filename": "overpassify-1.1.0-py2.py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "4a2bac134a5c8ea4983554b5dc42d7ac",
        "packagetype": "bdist_wheel",
        "python_version": "py2.py3",
        "size": 14900,
        "upload_time": "2017-06-14T04:54:44",
        "url": "https://files.pythonhosted.org/packages/94/eb/f837f6519306b4c668b0f2ff0b09186459556650c509e434d4f451140456/overpassify-1.1.0-py2.py3-none-any.whl"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "4a2bac134a5c8ea4983554b5dc42d7ac",
        "sha256": "ac4cc755e8d06e0ccf6f3427720d2936f1a2c94a001a9d337173f565d585be04"
      },
      "downloads": 0,
      "filename": "overpassify-1.1.0-py2.py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "4a2bac134a5c8ea4983554b5dc42d7ac",
      "packagetype": "bdist_wheel",
      "python_version": "py2.py3",
      "size": 14900,
      "upload_time": "2017-06-14T04:54:44",
      "url": "https://files.pythonhosted.org/packages/94/eb/f837f6519306b4c668b0f2ff0b09186459556650c509e434d4f451140456/overpassify-1.1.0-py2.py3-none-any.whl"
    }
  ]
}