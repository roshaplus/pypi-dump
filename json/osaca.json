{
  "info": {
    "author": "Jan Laukemann",
    "author_email": "jan.laukemann@fau.de",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 3 - Alpha",
      "Intended Audience :: Developers",
      "Intended Audience :: Science/Research",
      "License :: OSI Approved :: GNU Affero General Public License v3",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.5",
      "Topic :: Scientific/Engineering",
      "Topic :: Software Development",
      "Topic :: Utilities"
    ],
    "description": ".. image:: doc/osaca-logo.png\n   :alt: OSACA logo\n   :width: 80%\n   \nOSACA\n=====\n\nOpen Source Architecture Code Analyzer\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThis tool allows automatic instruction fetching of assembly code,\nauto-generating of testcases for assembly instructions creating latency\nand throughput benchmarks on a specific instruction form and throughput\nanalysis and throughput prediction for a innermost loop kernel.\n\n.. image:: https://travis-ci.com/RRZE-HPC/OSACA.svg?token=393L6z2HEXNiGLtZ43s6&branch=master\n    :target: https://travis-ci.com/RRZE-HPC/OSACA\n\n.. image:: https://landscape.io/github/RRZE-HPC/OSACA/master/landscape.svg?style=flat&badge_auth_token=c95f01b247f94bc79c09d21c5c827697\n   :target: https://landscape.io/github/RRZE-HPC/OSACA/master\n   :alt: Code Health\n\nGetting started\n===============\n\nInstallation\n~~~~~~~~~~~~\n.. On most systems with python pip and setuputils installed, just run:\n.. ::\n   pip install --user osaca\n.. for the latest release.\nTo build OSACA from source, clone this repository using ``git clone https://github.com/RRZE-HPC/OSACA`` and run in the root directory:\n\n.. code:: bash\n\n   python ./setup.py install\n\nAfter installation, OSACA can be started with the command ``osaca`` in the CLI.\n\nDependencies:\n~~~~~~~~~~~~~~~\nAdditional requirements are:\n\n-  `Python3 <https://www.python.org/>`_\n-  `pandas <http://pandas.pydata.org/>`_\n-  `NumPy <http://www.numpy.org/>`_\n-  `Kerncraft <https://github.com/RRZE-HPC/kerncraft>`_ for marker insertion\n-   `ibench <https://github.com/hofm/ibench>`_ for throughput/latency measurements\n\nDesign\n======\nA schematic design of OSACA's workflow is shown below:\n\n.. image:: doc/osaca-workflow.png\n   :alt: OSACA workflow\n   :width: 80%\n\nUsage\n=====\n\nThe usage of OSACA can be listed as:\n::\n    osaca [-h] [-V] [--arch ARCH] [--tp-list] [-i | --iaca | -m] FILEPATH\n\n- ``-h`` or ``--help`` prints out the help message.\n- ``-V`` or ``--version`` shows the program\u2019s version number.\n- ``ARCH`` needs to be replaced with the wished architecture abbreviation. This flag is necessary for the throughput analysis (default function) and the inclusion of an ibench output (``-i``). Possible options are ``SNB``, ``IVB``, ``HSW``, ``BDW`` and ``SKL`` for the latest Intel micro architectures starting from Intel Sandy Bridge.\n- While in the throughput analysis mode, one can add ``--tp-list`` for printing the additional throughput list of the kernel or ``--iaca`` for letting OSACA to know it has to search for IACA binary markers.\n- ``-i`` or ``--include-ibench`` starts the integration of ibench output into the CSV data file determined by ``ARCH``.\n- With the flag ``-m`` or ``--insert-marker`` OSACA calls the Kerncraft module for the interactively insertion of `IACA <https://software.intel.com/en-us/articles/intel-architecture-code-analyzer>`_ marker in suggested assembly blocks.\n- ``FILEPATH`` describes the filepath to the file to work with and is always necessary\n\nHereinafter OSACA's scope of function will be described.\n\nThroughput analysis\n~~~~~~~~~~~~~~~~~~~\nAs main functionality of OSACA this process starts by default. It is always necessary to specify the core architecture by the flag ``--arch ARCH``, where ``ARCH`` can stand for ``SNB``, ``IVB``, ``HSW``, ``BDW`` or ``SKL``.\n\nFor extracting the right kernel, one has to mark it beforehand. For this there are two different approaches:\n\n| **High level code**\nThe OSACA marker is ``//STARTLOOP`` and must be put in one line in front of the loop head, and the loop code must be indented consistently. This means the marker and the head must have the same indentation level while the whole loop body needs to be more indented than the code before and after. For instance, this is a valid OSACA marker:\n\n.. code-block:: c\n\n    int i = 0;\n    //STARTLOOP\n    while(i < N){\n        // do something...\n        i++;\n    }\n\n| **Assembly code**\nAnother way for marking a kernel is to insert the IACA byte markers in the assembly file in before and after the loop.\nFor this, the start marker has to be inserted right in front of the loop label and the end marker directly after the jump instruction.\nStart and end marker can be seen in the example below:\n\n.. code-block:: assembly\n\n    movl    $111,%ebx       ;IACA START MARKER\n    .byte   100,103,144     ;IACA START MARKER\n    ; LABEL\n        ; do something\n        ; ...\n        ; conditional jump to LABEL\n    movl    $222,%ebx       ;IACA END MARKER\n    .byte   100,103,144     ;IACA END MARKER\n\nThe optional flag ``--iaca`` defines if OSACA needs to search for the IACA byte markers or the OSACA marker in the chosen file.\n\nWith an additional, optional ``--tp-list``, OSACA adds a simple list of all kernel instruction forms together with their reciprocal throughput to the output. This is helpful in case of no further information about the port binding of the single instruction forms.\n\nInclude new measurements into the data file\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nRunning OSACA with the flag ``-i`` or ``--include-ibench`` and a specified micro architecture ``ARCH``, it\ntakes the values given in an ibench output file and checks them for reasonability. If a value is not in the data file already, it will be added, otherwise OSACA prints out a warning message and keeps the old value in the data file. If a value does not pass the validation, a warning message is shown, however, OSACA will keep working with the new value.\nThe handling of ibench is shortly described in the example section below.\n\nInsert IACA markers\n~~~~~~~~~~~~~~~~~~~\nUsing the ``-m`` or ``--insert-marker`` flags for a given file, OSACA calls the implemented Kerncraft module for identifying and marking the inner-loop block in *manual mode*. More information about how this is done can be found in the `Kerncraft repository <https://github.com/RRZE-HPC/kerncraft>`_.\n\nExample\n=======\nFor clarifying the functionality of OSACA a sample kernel is analyzed for an Intel IVB core hereafter:\n\n.. code-block:: c\n\n    double a[N], double b[N];\n    double s;\n    \n    //STARTLOOP\n    for(int i = 0; i < N; ++i)\n        a[i] = s * b[i];\n        \nThe code shows a simple scalar multiplication of a vector ``b`` and a floating-point number ``s``. The result is\nwritten in vector ``a``.\nAfter including the OSACA marker ``//STARTLOOP`` and compiling the source, one can\nstart the analysis typing \n::\n    osaca --arch IVB PATH/TO/FILE\n\nin the command line. Optionally, one can create the assembly code out of the file, identify and mark the kernel of interest and run OSACA with the additional ``--iaca`` flag.\n\nThe output is:\n\n.. code-block::\n\n    Throughput Analysis Report\n    --------------------------\n    X - No information for this instruction in database\n    * - Instruction micro-ops not bound to a port\n    \n    Port Binding in Cycles Per Iteration:\n    -------------------------------------------------\n    |  Port  |   0  |   1  |  2  |  3  |  4  |   5  |\n    -------------------------------------------------\n    | Cycles | 2.33 | 1.33 | 5.0 | 5.0 | 2.0 | 1.33 |\n    -------------------------------------------------\n             \n             Ports Pressure in cycles          \n    |  0   |  1   |  2   |  3   |  4   |  5   |\n    -------------------------------------------\n    |      |      | 0.50 | 0.50 | 1.00 |      | movl   $0x0,-0x24(%rbp)\n    |      |      |      |      |      |      | jmp    10b <scale+0x10b>\n    |      |      | 0.50 | 0.50 |      |      | mov    -0x48(%rbp),%rax\n    |      |      | 0.50 | 0.50 |      |      | mov    -0x24(%rbp),%edx\n    | 0.33 | 0.33 |      |      |      | 0.33 | movslq %edx,%rdx\n    |      |      | 0.50 | 0.50 |      |      | vmovsd (%rax,%rdx,8),%xmm0\n    | 1.00 |      | 0.50 | 0.50 |      |      | vmulsd -0x50(%rbp),%xmm0,%xmm0\n    |      |      | 0.50 | 0.50 |      |      | mov    -0x38(%rbp),%rax\n    |      |      | 0.50 | 0.50 |      |      | mov    -0x24(%rbp),%edx\n    | 0.33 | 0.33 |      |      |      | 0.33 | movslq %edx,%rdx\n    |      |      | 0.50 | 0.50 | 1.00 |      | vmovsd %xmm0,(%rax,%rdx,8)\n    |      |      |      |      |      |      | X addl   $0x1,-0x24(%rbp)\n    |      |      | 0.50 | 0.50 |      |      | mov    -0x24(%rbp),%eax\n    | 0.33 | 0.33 | 0.50 | 0.50 |      | 0.33 | cmp    -0x54(%rbp),%eax\n    |      |      |      |      |      |      | jl     e4 <scale+0xe4>\n    | 0.33 | 0.33 |      |      |      | 0.33 | mov    %rcx,%rsp\n    Total number of estimated throughput: 5.0\n\nIt shows the whole kernel together with the average port pressure of each instruction form and the overall port binding.\nIn the fifth to last line containing ``addl $0x1, -0x24(%rbp)`` one can see an ``X`` in front of the instruction form and no port occupation.\nThis means either there are no measured values for this instruction form or no port binding is provided in the\ndata file.\nIn the first case, OSACA automatically creates two benchmark assembly files (``add-mem_imd.S`` for latency and ``add-mem_imd-TP.S`` for throughput) in the benchmark folder, if it not already exists there.\n\nOne can now run ibench to get the throughput value for addl with the given file. Mind that the assembly\nfile, which is used for ibench, is implemented in Intel syntax. So for a valid run instruction ``addl`` must be\nchanged to ``add`` manually.\n\nFor measuring the instruction forms with ibench we highly recommend to use an exclusively allocated node,\nso there is no other workload falsifying the results. For the correct function of ibench the benchmark files\nfrom OSACA need to be placed in a subdirectory of src in root so ibench can create the a folder with the\nsubdirectory\u2019s name and the shared objects. For running the tests the frequencies of all cores must set to a\nconstant value and this has to be given as an argument together with the directory of the shared objects to\nibench, e.g.:\n::\n    ./ibench ./AVX 2.2\n    \nfor running ibench in the directory ``AVX`` with a core frequency of 2.2 GHz.\nWe get an output like:\n::\n    Using frequency 2.20GHz.\n    add-mem_imd-TP: 1.023 (clock cycles) [DEBUG - result: 1.000000]\n    add-mem_imd: 6.050 (clock cycles) [DEBUG - result: 1.000000]\n    \nThe debug output as resulting value of register ``xmm0`` is additional validation information depending on\nthe executed instruction form meant for the user and is not considered by OSACA.\nThe ibench output information can be included by OSACA running the program with the flag ``--include-ibench`` or just\n``-i`` and the specify micro architecture:\n\n.. code-block:: bash\n\n    osaca --arch IVB -i PATH/TO/IBENCH-OUTPUTFILE\n\nFor now no automatic allocation of ports for a instruction form is implemented, so for getting an output in the Ports Pressure table, one must add the port occupation by hand.\nWe know that the inserted instruction form must be assigned always to Port 2, 3 and 4 and additionally to either 0, 1 or 5, a valid data file therefore would look like this:\n::\n    addl-mem_imd,1.0,6.0,\"(0.33,0.33,1.00,1.00,1.00,0.33)\"\n    \nAnother thorughput analysis with OSACA now returns all information for the kernel:\n\n.. code-block::\n\n    Throughput Analysis Report\n    --------------------------\n    X - No information for this instruction in database\n    * - Instruction micro-ops not bound to a port\n    \n    Port Binding in Cycles Per Iteration:\n    -------------------------------------------------\n    |  Port  |   0  |   1  |  2  |  3  |  4  |   5  |\n    -------------------------------------------------\n    | Cycles | 2.67 | 1.67 | 6.0 | 6.0 | 3.0 | 1.67 |\n    -------------------------------------------------\n             \n             Ports Pressure in cycles          \n    |  0   |  1   |  2   |  3   |  4   |  5   |\n    -------------------------------------------\n    |      |      | 0.50 | 0.50 | 1.00 |      | movl   $0x0,-0x24(%rbp)\n    |      |      |      |      |      |      | jmp    10b <scale+0x10b>\n    |      |      | 0.50 | 0.50 |      |      | mov    -0x48(%rbp),%rax\n    |      |      | 0.50 | 0.50 |      |      | mov    -0x24(%rbp),%edx\n    | 0.33 | 0.33 |      |      |      | 0.33 | movslq %edx,%rdx\n    |      |      | 0.50 | 0.50 |      |      | vmovsd (%rax,%rdx,8),%xmm0\n    | 1.00 |      | 0.50 | 0.50 |      |      | vmulsd -0x50(%rbp),%xmm0,%xmm0\n    |      |      | 0.50 | 0.50 |      |      | mov    -0x38(%rbp),%rax\n    |      |      | 0.50 | 0.50 |      |      | mov    -0x24(%rbp),%edx\n    | 0.33 | 0.33 |      |      |      | 0.33 | movslq %edx,%rdx\n    |      |      | 0.50 | 0.50 | 1.00 |      | vmovsd %xmm0,(%rax,%rdx,8)\n    | 0.33 | 0.33 | 1.00 | 1.00 | 1.00 | 0.33 | addl   $0x1,-0x24(%rbp)\n    |      |      | 0.50 | 0.50 |      |      | mov    -0x24(%rbp),%eax\n    | 0.33 | 0.33 | 0.50 | 0.50 |      | 0.33 | cmp    -0x54(%rbp),%eax\n    |      |      |      |      |      |      | jl     e4 <scale+0xe4>\n    | 0.33 | 0.33 |      |      |      | 0.33 | mov    %rcx,%rsp\n    Total number of estimated throughput: 6.0\n\nCredits\n=======\nImplementation: Jan Laukemann\n\nLicense\n=======\n`AGPL-3.0 </LICENSE>`_\n",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "https://github.com/RRZE-HPC/OSACA",
    "keywords": "hpc performance benchmark analysis architecture",
    "license": "AGPLv3",
    "maintainer": "",
    "maintainer_email": "",
    "name": "osaca",
    "platform": "",
    "project_url": "https://pypi.org/project/osaca/",
    "release_url": "https://pypi.org/project/osaca/0.1/",
    "requires_dist": [],
    "requires_python": "",
    "summary": "Open Source Architecture Code Analyzer",
    "version": "0.1"
  },
  "releases": {
    "0.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "bfc2e081b1baea09e277fe48ca435393",
          "sha256": "af25ed1559fbcabdca25258306535fc20a61d9294ed3f6ef04330a037768a66c"
        },
        "downloads": -1,
        "filename": "osaca-0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "bfc2e081b1baea09e277fe48ca435393",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 2648980,
        "upload_time": "2018-01-24T08:17:47",
        "url": "https://files.pythonhosted.org/packages/f0/99/d8f31ae8f2d0f79257d6cfc036ded8d484c27b5534258b4232e0193e949e/osaca-0.1.tar.gz"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "bfc2e081b1baea09e277fe48ca435393",
        "sha256": "af25ed1559fbcabdca25258306535fc20a61d9294ed3f6ef04330a037768a66c"
      },
      "downloads": -1,
      "filename": "osaca-0.1.tar.gz",
      "has_sig": false,
      "md5_digest": "bfc2e081b1baea09e277fe48ca435393",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 2648980,
      "upload_time": "2018-01-24T08:17:47",
      "url": "https://files.pythonhosted.org/packages/f0/99/d8f31ae8f2d0f79257d6cfc036ded8d484c27b5534258b4232e0193e949e/osaca-0.1.tar.gz"
    }
  ]
}