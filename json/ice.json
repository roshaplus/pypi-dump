{
  "info": {
    "author": "Susam Pal",
    "author_email": "susam@susam.in",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 2 - Pre-Alpha",
      "Environment :: Console",
      "Environment :: Web Environment",
      "Intended Audience :: Developers",
      "Intended Audience :: End Users/Desktop",
      "License :: OSI Approved :: BSD License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3.4",
      "Topic :: Internet :: WWW/HTTP :: WSGI :: Application",
      "Topic :: Software Development :: Libraries :: Python Modules"
    ],
    "description": "Ice - WSGI on the rocks\n=======================\n\nIce is a Python module with a WSGI microframework meant for developing\nsmall web applications in Python.\n\n.. image:: https://travis-ci.org/susam/ice.png?branch=master\n   :target: https://travis-ci.org/susam/ice\n\n.. image:: https://coveralls.io/repos/susam/ice/badge.png?branch=master\n   :target: https://coveralls.io/r/susam/ice?branch=master\n\n.. contents::\n   :backlinks: none\n\nRequirements\n------------\nThis module should be used with Python 3.4 or any later version of\nPython interpreter.\n\nThis module depends only on the Python standard library. It does not\ndepend on any third party libraries.\n\nInstallation\n------------\nYou can install this package using pip3 using the following command. ::\n\n    pip3 install ice\n\nYou can install this package from source distribution. To do so,\ndownload the latest .tar.gz file from https://pypi.python.org/pypi/ice,\nextract it, then open command prompt or shell, and change your current\ndirectory to the directory where you extracted the source distribution,\nand then execute the following command. ::\n\n    python3 setup.py install\n\nNote that on a Windows system, you may have to replace ``python3`` with\nthe path to your Python 3 interpreter.\n\nSupport\n-------\nTo report any bugs, or ask any question, please visit\nhttps://github.com/susam/ice/issues.\n\nResources\n---------\nHere is a list of useful links about this project.\n\n- `Latest release on PyPI <https://pypi.python.org/pypi/ice>`_\n- `Source code on GitHub <https://github.com/susam/ice>`_\n- `Issue tracker on GitHub <https://github.com/susam/ice/issues>`_\n- `Changelog on GitHub\n  <https://github.com/susam/ice/blob/master/CHANGES.rst>`_\n\nLicense\n-------\nThis is free software. You are permitted to redistribute and use it in\nsource and binary forms, with or without modification, under the terms\nof the Simplified BSD License. See the LICENSE.rst file for the complete\nlicense.\n\nThis software is provided WITHOUT ANY WARRANTY; without even the implied\nwarranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\nLICENSE.rst file for the complete disclaimer.\n\n\nTutorial\n========\n\nGetting started\n---------------\nThe simplest way to get started with an ice application is to write a\nminimal application that serves a default web page.\n\n.. code:: python \n\n    import ice\n    app = ice.cube()\n    if __name__ == '__main__':\n       app.run()\n\nSave the above code in a file and execute it with your Python\ninterpreter. Then open your browser, visit http://localhost:8080/, and\nyou should be able to see a web page that says, 'It works!'.\n\n..  reST convention\n    ---------------\n    - URLs are written in plain text.\n    - Request paths are written in plain text.\n    - Request path patterns are enclosed in `` and ``.\n    - Code samples are written in literal blocks constructed with the\n      code directive.\n    - Strings, even when they are part of a request path, are enclosed\n      in ``' and '``.\n\nRoutes\n------\nOnce you are able to run a minimal ice application as mentioned in the\nprevious section, you'll note that while visiting http://localhost:8080/\ndisplays the default 'It works!' page, visiting any other URL, such as\nhttp://localhost:8080/foo displays the '404 Not Found' page. This\nhappens because the application object returned by the ``ice.cube``\nfunction has a default route defined to invoke a function that returns\nthe default page when the client requests / using the HTTP GET method.\nThere is no such route defined by default for /foo or any request path\nother than /.\n\nIn this document, a request path is defined as the part of the URL after\nthe domain name and before the query string. For example, in a request\nfor http://localhost:8080/foo/bar?x=10, the request path is /foo/bar.\n\nA route is used to map an HTTP request made to an ice application to a\nPython callable. A route consists of three objects:\n\n1. HTTP request method, e.g. ``'GET'``, ``'POST'``.\n2. Request path pattern, e.g. ``'/foo'``, ``'/post/<id>'``, ``/(.*)``.\n3. Callable, e.g. Python function\n\nA route is said to match a request path when the request pattern of the\nroute matches the request path. When a client makes a request to an ice\napplication, if a route matches the request path, then the callable of\nthe route is invoked and the value returned by the callable is used to\nsend a response to the client.\n\nThe request path pattern of a route can be specified in one of three\nways:\n\n1. Literal path, e.g. ``'/'``, ``'/contact/'``, ``'/about/'``.\n2. Pattern with wildcards, e.g. ``'/blog/<id>'``, ``'/order/<:int>'``.\n3. Regular expression, e.g. ``'/blog/\\w+'``, ``'/order/\\d+'``.\n\nThese three types of routes are described in the subsections below.\n\nLiteral routes\n~~~~~~~~~~~~~~\nThe following application overrides the default 'It works!' page for /\nwith a custom page. Additionally, it sets up a route for /foo.\n\n.. code:: python \n\n    import ice\n    app = ice.cube()\n\n    @app.get('/')\n    def home():\n        return '<!DOCTYPE html>' \\\n               '<html><head><title>Home</title></head>' \\\n               '<body><p>Home</p></body></html>'\n\n    @app.get('/foo')\n    def foo():\n        return '<!DOCTYPE html>' \\\n               '<html><head><title>Foo</title></head>' \\\n               '<body><p>Foo</p></body></html>'\n\n    if __name__ == '__main__':\n        app.run()\n\nThe routes defined in the above example are called literal routes\nbecause they match the request path exactly as specified in the argument\nto ``app.get`` decorator. Routes defined with the ``app.get`` decorator\nmatches HTTP GET requests. Now, visiting http://localhost:8080/ displays\na page with the following text.\n\n    | Home\n\nVisiting http://localhost:8080/foo displays a page with the following\ntext.\n\n    | Foo\n\nHowever, visiting http://localhost:8080/foo/ or\nhttp://localhost:8080/foo/bar displays the '404 Not Found' page because\nthe literal pattern ``'/foo'`` does not match ``'/foo/'`` or\n``'/foo/bar'``.\n\nWildcard routes\n~~~~~~~~~~~~~~~\nAnonymous wildcards\n'''''''''''''''''''\nThe following code example is the simplest application demonstrating a\nwildcard route that matches request path of the form ``/`` followed by\nany string devoid of ``/``, ``<`` and ``>`` . The characters ``<>`` is\nan anonymous wildcard because there is no name associated with this\nwildcard. The part of the request path matched by an anonymous wildcard\nis passed as a positional argument to the route's callable.\n\n.. code:: python \n\n    import ice\n    app = ice.cube()\n\n    @app.get('/<>')\n    def foo(a):\n        return '<!DOCTYPE html>' \\\n               '<html><head><title>' + a + '</title></head>' \\\n               '<body><p>' + a + '</p></body></html>'\n\n    if __name__ == '__main__':\n        app.run()\n\nSave the above code in a file and execute it with Python interpreter.\nThen open your browser, visit http://localhost:8080/foo, and you should\nbe able to see a page with the followning text.\n\n    | foo\n\nIf you visit http://localhost:8080/bar instead, you should see a page\nwith the following text.\n\n    | bar\n\nHowever, visiting http://localhost:8080/foo/ or\nhttp://localhost:8080/foo/bar displays the '404 Not Found' page because\nthe wildcard based pattern ``/<>`` does not match ``/foo/`` or\n``/foo/bar``.\n\nNamed wildcards\n'''''''''''''''\nA wildcard with a valid Python identifier as its name is called a named\nwildcard. The part of the request path matched by a named wildcard is\npassed as a keyword argument, with the same name as that of the\nwildcard, to the route's callable.\n\n.. code:: python \n\n    import ice\n    app = ice.cube()\n\n    @app.get('/<a>')\n    def foo(a):\n        return '<!DOCTYPE html>' \\\n               '<html><head><title>' + a + '</title></head>' \\\n               '<body><p>' + a + '</p></body></html>'\n\n    if __name__ == '__main__':\n        app.run()\n\nThe ``a``, in ``<a>``, is the name of the wildcard. The ice application\nin this example with a named wildcard behaves similar to the earlier one\nwith an anonymous wildcard. The following example code clearly\ndemonstrates how matches due to anonymous wildcards are passed\ndifferently from the matches due to named wildcards.\n\n.. code:: python \n\n    import ice\n    app = ice.cube()\n\n    @app.get('/foo/<>-<>/<a>-<b>/<>-<c>')\n    def foo(*args, **kwargs):\n        return '<!DOCTYPE html>' \\\n               '<html><head><title>Example</title></head><body>' \\\n               '<p>args: {}<br>kwargs: {}</p>' \\\n               '</body></html>'.format(args, kwargs)\n\n    if __name__ == '__main__':\n        app.run()\n\nAfter running this application, visiting\nhttp://localhost:8080/foo/hello-world/ice-cube/wsgi-rocks displays a\npage with the following text.\n\n    | args: ('hello', 'world', 'wsgi')\n    | kwargs: {'a': 'ice', 'b': 'cube', 'c': 'rocks'}\n\nHere is a more typical example that demonstrates how anonymous wildcard\nand named wildcard may be used together.\n\n.. code:: python\n\n    import ice\n    app = ice.cube()\n\n    @app.get('/<user>/<category>/<>')\n    def page(page_id, user, category):\n        return '<!DOCTYPE html>' \\\n               '<html><head><title>Example</title></head><body>' \\\n               '<p>page_id: {}<br>user: {}<br>category: {}</p>' \\\n               '</body></html>'.format(page_id, user, category)\n\n    if __name__ == '__main__':\n        app.run()\n\nAfter running this application, visiting\nhttp://localhost:8080/snowman/articles/python displays a page with the\nfollowing text.\n\n    | page_id: python\n    | user: snowman\n    | category: articles\n\nNote: Since parts of the request path matched by anonymous wildcards are\npassed as positional arguments and parts of the request path matched by\nnamed wildcards are passed as keyword arguments to the route's callable,\nit is required by the Python language that all positional parameters\nmust come before all keyword parameters in the function definition.\nHowever, the wildcards may appear in any order in the route's pattern.\n\nThrowaway wildcard\n''''''''''''''''''\nA wildcard with exclamation mark, ``!``, as its name is a throwaway\nwildcard. The part of the request path matched by a throwaway wildcard\nis not passed to the route's callable. *They are thrown away!*\n\n.. code:: python \n\n    import ice\n    app = ice.cube()\n\n    @app.get('/<!>')\n    def foo(*args, **kwargs):\n        return '<!DOCTYPE html>' \\\n               '<html><head><title>Example</title></head><body>' \\\n               '<p>args: {}<br>kwargs: {}</p>' \\\n               '</body></html>'.format(args, kwargs)\n\n    if __name__ == '__main__':\n        app.run()\n\nAfter running this application, visiting http://localhost:8080/foo\ndisplays a page the following text.\n\n    | args: ()\n    | kwargs: {}\n\nThe output confirms that no argument is passed to the ``foo`` function.\nHere is a more typical example that demonstrates how a throwaway\nwildcard may be used with other wildcards.\n\n.. code:: python\n\n    import ice\n    app = ice.cube()\n\n    @app.get('/<!>/<!>/<>')\n    def page(page_id):\n        return '<!DOCTYPE html>' \\\n               '<html><head><title>Example</title></head><body>' \\\n               '<p>page_id: ' + page_id + '</p>' \\\n               '</body></html>'\n\n    if __name__ == '__main__':\n        app.run()\n\nAfter running this application, visiting\nhttp://localhost:8080/snowman/articles/python should display a page with\nthe following text.\n\n    | page_id: python\n\nThere are three wildcards in the route's request path pattern but there\nis only one parameter in the route's callable because two out of the\nthree wildcards are throwaway wildcards.\n\nWildcard specification\n''''''''''''''''''''''\nThe complete syntax of a wildcard specification is: <*name*:*type*>.\n\nThe following rules describe how a wildcard is interpreted.\n\n1.  The delimiters ``<`` (less-than sign) and ``>`` (greater-than sign),\n    are mandatory.\n2.  However, *name*, ``:`` (colon) and *type* are optional.\n3.  Either a valid Python identifier or the exclamation mark, ``!``,\n    should be used for *name*.\n4.  If *name* is missing, the part of the request path matched by the\n    wildcard is passed as a positional argument to the route's callable.\n5.  If *name* is present and it is a valid Python identifier, the part\n    of the request path matched by the wildcard is passed as a keyword\n    argument to the route's callable.\n6.  If *name* is present and it is ``!``, the part of the request path\n    matched by the wildcard is not passed to the route's callable.\n7.  If *name* is present but it is neither ``!`` nor a valid Python\n    identifier, ice.RouteError is raised.\n8.  If *type* is present, it must be preceded by ``:`` (colon).\n9.  If *type* is present but it is not ``str``, ``int``, ``+int`` and\n    ``-int``, ice.RouteError is raised.\n10.  If *type* is missing, it is assumed to be ``str``.\n11. If *type* is ``str``, it matches a string not containing ``/``. The\n    path of the request path matched by the wildcard is passed as an\n    ``str`` object to the route's callable.\n12. If *type* is ``int``, ``+int`` or ``-int``, the path of the request\n    path matched by the wildcard is passed as an ``int`` object to the\n    route's callable.\n13. If *type* is ``+int``, the wildcard matches a positive integer where\n    the positive integer beginning with a non-zero digit.\n14. If *type* is ``int``, the wildcard matches ``0`` as well as\n    everything that a wildcard of type ``+int`` matches.\n15. If *type* is ``-int``, the wildcard matches a negative integer that\n    begins with the ``-`` sign followed by a non-zero digit as well as\n    everything that a wildcard of type ``int`` matches.\n\nHere is an example that demonstrates a typical route with an ``int``\nwildcard.\n\n.. code:: python\n\n    import ice\n    app = ice.cube()\n\n    @app.get('/notes/<:int>')\n    def note(note_id):\n        return '<!DOCTYPE html>' \\\n               '<html><head><title>Example</title></head><body>' \\\n               '<p>note_id: {}</p></body></html>'.format(note_id)\n\n    if __name__ == '__main__':\n        app.run()\n\nAfter running this application, visiting http://localhost:8080/notes/12\ndisplays a page with the following text.\n\n    | note_id: 12\n\nVisiting http://localhost:8080/notes/0 displays a page with the\nfollowing text.\n\n    | note_id: 0\n\nHowever, visiting http://localhost:8080/notes/+12,\nhttp://localhost:8080/notes/+0 or http://localhost:8080/notes/012,\ndisplays the '404 Not Found' page because ``<:int>`` does not match an\ninteger with a leading ``+`` sign or with a leading ``0``. It matches\n``0`` and a positive integer beginning with a non-zero digit only.\n\nRegular expression routes\n~~~~~~~~~~~~~~~~~~~~~~~~~\nThe following code demonstrates a simple regular expression based route.\nThe part of the request path matched by a non-symbolic capturing group\nis passed as a positional argument to the route's callable.\n\n.. code:: python\n\n    import ice\n    app = ice.cube()\n\n    @app.get('/(.*)')\n    def foo(a):\n        return '<!DOCTYPE html>' \\\n               '<html><head><title>' + a + '</title></head>' \\\n               '<body><p>' + a + '</p></body></html>'\n\n    if __name__ == '__main__':\n        app.run()\n\nAfter running this application, visiting http://localhost:8080/foo\ndisplays a page with the following text.\n\n    | foo\n\nVisiting http://localhost:8080/foo/bar/ displays a page with the\nfollowing text.\n\n    | foo/bar/\n\nThe part of the request path matched by a symbolic capturing group in\nthe regular expression is passed as a keyword argument with the same\nname as that of the symbolic group.\n\n.. code:: python\n\n    import ice\n    app = ice.cube()\n\n    @app.get('/(?P<user>[^/]*)/(?P<category>[^/]*)/([^/]*)')\n    def page(page_id, user, category):\n        return '<!DOCTYPE html>' \\\n               '<html><head><title>Example</title></head><body>' \\\n               '<p>page_id: {}<br>user: {}<br>category: {}</p>' \\\n               '</body></html>'.format(page_id, user, category)\n\n    if __name__ == '__main__':\n        app.run()\n\nAfter running this application, visiting\nhttp://localhost:8080/snowman/articles/python displays a page with the\nfollowing text.\n\n    | page_id: python\n    | user: snowman\n    | category: articles\n\nNote: Since parts of the request path matched by non-symbolic capturing\ngroups are passed as positional arguments and parts of the request path\nmatched by symbolic capturing groups are passed as keyword arguments to\nthe route's callable, it is required by the Python language that all\npositional parameters must come before all keyword parameters in the\nfunction definition.  However, the capturing groups may appear in any\norder in the route's pattern.\n\nInterpretation of request path pattern\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nThe request path pattern is interpreted according to the following\nrules. The rules are processed in the order specified and as soon as one\nof the rules succeeds in determining how the request path pattern should\nbe interpreted, further rules are not processed.\n\n1. If a route's request path pattern begins with ``regex:`` prefix,\n   then it is interpreted as a regular expression route.\n2. If a route's request path pattern begins with ``wildcard:`` prefix,\n   then it is interpreted as a wildcard route.\n3. If a route's request path pattern begins with ``literal:`` prefix,\n   then it is interpreted as a literal route.\n4. If a route's request path pattern contains what looks like a\n   capturing group, i.e. it contains ``(`` before ``)`` somewhere in\n   the pattern, then it is automatically interpreted as a regular\n   expression route.\n5. If a route's request path pattern contains what looks like a\n   wildcard, i.e. it contains ``<`` before ``>`` somewhere in the\n   pattern with no ``/``, ``<`` and ``>`` in between them, then it is\n   automatically interpreted as a wildcard route.\n6. If none of the above rules succeed in determining how to interpret\n   the request path, then it is interpreted as a literal route.\n   literal route.\n\nThe next three sections clarify the above rules with some contrived\nexamples.\n\nExplicit literal routes\n'''''''''''''''''''''''\nTo define a literal route with the request path pattern as ``/<foo>``,\n``literal:`` prefix must be used. Without it, the ``<foo>`` in the\npattern is interpreted as a wildcard and the route is defined as a\nwildcard route. With the ``literal:`` prefix, the pattern is explicitly\ndefined as a literal pattern.\n\n.. code:: python\n\n    import ice\n    app = ice.cube()\n\n    @app.get('literal:/<foo>')\n    def foo():\n        return '<!DOCTYPE html>' \\\n               '<html><head><title>Foo</title></head>' \\\n               '<body><p>Foo</p></body></html>'\n\n    if __name__ == '__main__':\n        app.run()\n\nAfter running this application, visiting\nhttp://localhost:8080/%3Cfoo%3E displays a page containing the\nfollowing text.\n\n    | Foo\n\nA request path pattern that seems to contain a wildcard or a capturing\ngroup but needs to be treated as a literal pattern must be prefixed with\nthe string ``literal:``.\n\nExplicit wildcard routes\n''''''''''''''''''''''''\nTo define a wildcard route with the request path pattern as\n``/(foo)/<>``, the ``wildcard:`` prefix must be used. Without it, the\npattern is interpreted as a regular expression pattern because the\n``(foo)`` in the pattern looks like a capturing group.\n\n.. code:: python\n\n    import ice\n    app = ice.cube()\n\n    @app.get('wildcard:/(foo)/<>')\n    def foo(a):\n        return '<!DOCTYPE html>' \\\n               '<html><head><title>Foo</title></head>' \\\n               '<body><p>a: ' + a + '</p></body></html>'\n\n    if __name__ == '__main__':\n        app.run()\n\nAfter running this application, visiting http://localhost:8080/(foo)/bar\ndisplays a page with the following text.\n\n    | a: bar\n\nA request path pattern that seems to contain a regular expression\ncapturing group but needs to be treated as a wildcard pattern must be\nprefixed with the string ``wildcard:``.\n\nExplicit regular expression routes\n''''''''''''''''''''''''''''''''''\nTo define a regular expression route with the request path pattern as\n``^/foo\\d*$``, the ``regex:`` prefix must be used. Without it, the\npattern is interpreted as a literal pattern because there is no\ncapturing group in the pattern.\n\n.. code:: python\n\n    import ice\n    app = ice.cube()\n\n    @app.get('regex:/foo\\d*')\n    def foo():\n        return '<!DOCTYPE html>' \\\n               '<html><head><title>Foo</title></head>' \\\n               '<body><p>Foo</p></body></html>'\n\n    if __name__ == '__main__':\n        app.run()\n\nAfter running this application, visiting http://localhost:8080/foo or\nhttp://localhost:8080/foo123 displays a page containing the following\ntext.\n\n    | Foo\n\nA request path pattern that does not contain a regular expression\ncapturing group but needs to be treated as a regular expression pattern\nmust be prefixed with the string ``regex:``.\n\nQuery strings\n-------------\nThe following example shows an application that can process a query\nstring in a GET request.\n\n.. code:: python\n\n    import ice\n    app = ice.cube()\n\n    @app.get('/')\n    def home():\n        return '<!DOCTYPE html>' \\\n               '<html><head><title>Foo</title></head>' \\\n               '<body><p>name: {}</p></body>' \\\n               '</html>'.format(app.request.query['name'])\n\n    if __name__ == '__main__':\n        app.run()\n\nAfter running this application, visiting\nhttp://localhost:8080/?name=Humpty+Dumpty displays a page with the\nfollowing text.\n\n    | name: Humpty Dumpty\n\nNote that the ``+`` sign in the query string has been properly URL\ndecoded into a space.\n\nThe ``app.request.query`` object in the code is an ``ice.MultiDict``\nobject that can store multiple values for every key. However, when used\nlike a dictionary, it returns the most recently added value for a key.\nTherefore, visiting http://localhost:8080/?name=Humpty&name=Santa\ndisplays a page with the following text.\n\n    | name: Santa\n\nNote that in this URL, there are two values passed for the ``name``\nfield in the query string, but accessing ``app.request.query['name']``\nprovides us only the value that is most recently added. To get all the\nvalues for a key in ``app.request.query``, we can use the\n``ice.MultiDict.getall`` method as shown below.\n\n.. code:: python\n\n    import ice\n    app = ice.cube()\n\n    @app.get('/')\n    def home():\n        return '<!DOCTYPE html>' \\\n               '<html><head><title>Foo</title></head>' \\\n               '<body><p>name: {}</p></body>' \\\n               '</html>'.format(app.request.query.getall('name'))\n\n    if __name__ == '__main__':\n        app.run()\n\nNow, visiting http://localhost:8080/?name=Humpty&name=Santa\ndisplays a page with the following text.\n\n    | name: ['Humpty', 'Santa']\n\nNote that the ``ice.MultiDict.getall`` method returns all the values\nbelonging to the key as a ``list`` object.\n\nForms\n-----\nThe following example shows an application that can process forms\nsubmitted by a POST request.\n\n.. code:: python\n\n    import ice\n    app = ice.cube()\n\n    @app.get('/')\n    def show_form():\n        return '<!DOCTYPE html>' \\\n               '<html><head><title>Foo</title></head>' \\\n               '<body><form action=\"/result\" method=\"post\">' \\\n               'First name: <input name=\"firstName\"><br>' \\\n               'Last name: <input name=\"lastName\"><br>' \\\n               '<input type=\"submit\">' \\\n               '</form></body></html>'\n\n    @app.post('/result')\n    def show_post():\n        return '<!DOCTYPE html>' \\\n               '<html><head><title>Foo</title></head><body>' \\\n               '<p>First name: {}<br>Last name: {}</p>' \\\n               '</body></html>'.format(app.request.form['firstName'],\n                                       app.request.form['lastName'])\n\n    if __name__ == '__main__':\n        app.run()\n\nAfter running this application, visiting http://localhost:8080/, filling\nup the form and submitting it displays the form data.\n\nThe ``app.request.form`` object in this code, like the\n``app.request.query`` object in the previous section, is a MultiDict\nobject.\n\n.. code:: python\n\n    import ice\n    app = ice.cube()\n\n    @app.get('/')\n    def show_form():\n        return '<!DOCTYPE html>' \\\n               '<html><head><title>Foo</title></head>' \\\n               '<body><form action=\"/result\" method=\"post\">' \\\n               'name1: <input name=\"name\"><br>' \\\n               'name2: <input name=\"name\"><br>' \\\n               '<input type=\"submit\">' \\\n               '</form></body></html>'\n\n    @app.post('/result')\n    def show_post():\n        return '<!DOCTYPE html>' \\\n               '<html><head><title>Foo</title></head><body>' \\\n               '<p>name (single): {}<br>name (multi): {}</p>' \\\n               '</body></html>'.format(app.request.form['name'],\n                                       app.request.form.getall('name'))\n\n    if __name__ == '__main__':\n        app.run()\n\nAfter running this application, visiting http://localhost:8080/, filling\nup the form and submitting it displays the form data. While\n``app.request.form['name']`` returns the string entered in the second\ninput field, ``app.request.form.getall('name')`` returns strings entered\nin both input fields as a list object.\n\nError pages\n-----------\nThe application object returned by the ``ice.cube`` function contains a\ngeneric fallback error handler that displays a simple error page with\nthe HTTP status line, a short description of the status and the version\nof the ice package.\n\nThis error handler may be overridden using the ``error`` decorator. This\ndecorator accepts one optional integer argument that may be used to\nexplicitly specify the HTTP status code of responses for which the\nhandler should be invoked to generate an error page. If no argument is\nprovided, the error handler is defined as a fallback error handler. A\nfallback error handler is invoked to generate an error page for any HTTP\nresponse representing an error when there is no error handler defined\nexplicitly for the response tatus code of the HTTP response.\n\nHere is an example.\n\n.. code:: python\n\n    import ice\n    app = ice.cube()\n\n    @app.error(404)\n    def error():\n        return '<!DOCTYPE html>' \\\n               '<html><head><title>Page not found</title></head>' \\\n               '<body><p>Page not found</p></body></html>'\n\n    if __name__ == '__main__':\n        app.run()\n\nAfter running this application, visiting http://localhost:8080/foo\ndisplays a page with the following text.\n\n    | Page not found",
    "docs_url": null,
    "download_url": "https://pypi.python.org/pypi/ice",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "https://github.com/susam/ice",
    "keywords": "wsgi,web,www,framework",
    "license": "Simplified BSD License",
    "maintainer": null,
    "maintainer_email": null,
    "name": "ice",
    "platform": "Any",
    "project_url": "https://pypi.org/project/ice/",
    "release_url": "https://pypi.org/project/ice/0.0.1/",
    "requires_python": null,
    "summary": "Ice - WSGI on the rocks.",
    "version": "0.0.1"
  },
  "releases": {
    "0.0.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "039abfd40c71048896883be992b9ec3c",
          "sha256": "c3eba505b4ce2a4e8f211f8de52b6cdc3976d218c0522b56474e9075da229b18"
        },
        "downloads": 3495,
        "filename": "ice-0.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "039abfd40c71048896883be992b9ec3c",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 22934,
        "upload_time": "2014-06-05T21:23:30",
        "url": "https://files.pythonhosted.org/packages/8c/ca/7da3b0b56593e18de2669724a776ef0a971e8a69e54bb8ebb328afe5e4f3/ice-0.0.1.tar.gz"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "039abfd40c71048896883be992b9ec3c",
        "sha256": "c3eba505b4ce2a4e8f211f8de52b6cdc3976d218c0522b56474e9075da229b18"
      },
      "downloads": 3495,
      "filename": "ice-0.0.1.tar.gz",
      "has_sig": false,
      "md5_digest": "039abfd40c71048896883be992b9ec3c",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 22934,
      "upload_time": "2014-06-05T21:23:30",
      "url": "https://files.pythonhosted.org/packages/8c/ca/7da3b0b56593e18de2669724a776ef0a971e8a69e54bb8ebb328afe5e4f3/ice-0.0.1.tar.gz"
    }
  ]
}