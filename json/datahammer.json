{
  "info": {
    "author": "NVRAM",
    "author_email": "nvram@users.sourceforge.net",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python",
      "Programming Language :: Python :: 2.7",
      "Programming Language :: Python :: 3",
      "Topic :: Software Development :: Libraries :: Python Modules",
      "Topic :: Text Processing :: Filters",
      "Topic :: Utilities"
    ],
    "description": "datahammer\n##########\n\n`Version 0.9.1`\n\n\"When all you have is a hammer, everything looks like a nail.\" - *Anonymous*\n\n.. contents:: **Index**\n   :depth: 2\n   :local:\n\n.. style table { border: 2px solid red; font-family: fujimoto; }\n\nSummary\n------------------\n\nThis module provides an easy way to filter, inspect, analyze and manipulate many similar data items.  It was\ndesigned to handle plain data types, especially the output from parsing JSON.  It is designed to allow\noperations to be done a concise fashion, and on all items in a simple parallel manner.\n\nIt mostly works on other data types, for either data as attributes, properties or with *[]*.\n\nBy design, concise usages was favored over speed of performance.  It was inspired by a need for a\nconcise data manipulation syntax and by the projects `jQuery <https://jquery.com/>`_ and\n`jq <https://stedolan.github.io/sjq/>`_.\n\n\nDetails\n-------\n\n- Most operations on a *DataHammer* instance return a value or a new instance, they do not mutate the\n  contained data, although a returned ITEM could be mutated by the calling code.\n\n- The contained data can be retrieved with the invert operator (**~**).  It will be a **list**\n  unless constructed with a single ITEM, in which case that ITEM will be returned.\n\n- In order to allow accessing arbitrary ITEM attributes uses the dot notation, **public functions start\n  with a single underscore**, in contrast to typical Python conventions.  See `Functions`_.\n\n- It uses a **list** as its top-level container, and will convert a **tuple** and some generators into a\n  **list**.\n\n- When constructed with a single ITEM, that item will be wrapped in a **list** and *most* operations will\n  be identitical to having been constructed with a list with that single ITEM.\n\n- It uses '.' to access *dict* members or object attributes, using **None** for items where there is no key or\n  attribute with the specified name, thus no *KeyError* or *AttributeError* will be raised.\n\n- Almost all operations will silently ignore items that do not have a member with the \"intended\" key, attribute\n  or index.\n\n- There is a **Mutator** class returned by the **_mutator()** function that is designed to allow modifying the\n  data in-place for some of the\n  `Augmented Assignment statements <https://docs.python.org/3/reference/simple_stmts.html#grammar-token-augmented_assignment_stmt>`_.\n\nKnown Issues\n^^^^^^^^^^^^\n\n- Using \"*ITEM in OBJ*\" works as you probably expect, but avoid using \"*OBJ in OTHER*\" for iterable\n  containers. [6]_\n\n- By design and intent, the bitwise operators (`&`, `|`, `^`) actually create a new instance by applying\n  the `and`, `or` and `xor` operators, respectively.  This is because those keyword operators cannot be\n  overridden to return an object as we wish.\n\n- There are missing operators that could be added. Among these are **del** (attribute or key),\n  and the bitwise math operators.\n\n\nConstruction\n^^^^^^^^^^^^\n\nCreating a *DataHammer* can take several sources for its input.  It is designed for use on a **list** of items\nwith the same schema.\n\n:class: attention\n\n+--------------------+----------------------------------------------------------------+\n|  **Parameters**    |     **Description**                                            |\n+====================+================================================================+\n| ``data``           | This must be one of:                                           |\n|                    |                                                                |\n|                    | * A `list` of ITEMS.                                           |\n|                    | * A single, non-`list` ITEM.                                   |\n|                    |                                                                |\n|                    | If the **json** value is true, then `data` can be either of:   |\n|                    |                                                                |\n|                    | * A `file` object, from which *all* data is read, and the      |\n|                    |   results are treated as TEXT, or...                           |\n|                    | * TEXT to be parsed as JSON.                                   |\n+--------------------+----------------------------------------------------------------+\n| ``copy``           | If given and true, then a `deepcopy` will be made of `data`.   |\n+--------------------+----------------------------------------------------------------+\n| ``json``           | If provided, it should either be `True` or a dict of arguments |\n|                    | to be passed to *JSON.loads()* for when `data` is of either    |\n|                    | the `file` or `TEXT` forms.                                    |\n+--------------------+----------------------------------------------------------------+\n\n\nOperations\n^^^^^^^^^^\n\nThis is a list of supported operations, including applying builtin Python functions. [1]_\n\n+------------------------------------------+---------------------------------------------------------------+\n|             **Operation**                |     **Description**                                           |\n+==========================================+===============================================================+\n| ``~OBJ``                                 | Returns the contained data.                                   |\n+------------------------------------------+---------------------------------------------------------------+\n| | ``OBJ.index``                          | Creates a list by applying the *index* (an *int* for *list*   |\n| | ``OBJ._ind(index)``                    | items, a key for *dict* items, or the name of an *attribute*  |\n| | ``OBJ._get(index)``                    | or *property*), returning a *DataHammer* instance created     |\n|                                          | using that list. [2]_                                         |\n+------------------------------------------+---------------------------------------------------------------+\n| | ``OBJ`` *op* ``OTHER``                 | Return a *DataHammer* instance with a bool result from the    |\n| |  *op* can be: ``< <= == != >= >``      | comparison of each ITEM with OTHER. [3]_                      |\n|                                          |                                                               |\n|                                          | To test equality of contents, use: *~OBJ == OTHER*            |\n+------------------------------------------+---------------------------------------------------------------+\n| | ``OBJ`` *bitop* ``OTHER``              | Return a *DataHammer* instance with the results of applying   |\n| | ``OTHER`` *bitop* ``OBJ``              | `and`, `or` and a \"bool-xor\" to each *ITEM* and *OTHER*, or   |\n| |  *bitop* can be: ``& ^ |``             | (*OTHER* and *ITEM*).  These are needed since those keywords  |\n|                                          | cannot be overridden in the desired fashion. [4]_             |\n+------------------------------------------+---------------------------------------------------------------+\n| | ``OBJ`` *mathop* ``OTHER``             | Return a *DataHammer* instance with the results of applying   |\n| |  *mathop* can be: ``+ - * / // ** %``  | a math operators in: *ITEM mathop OTHER*. [3]_                |\n+------------------------------------------+---------------------------------------------------------------+\n| | ``OTHER`` *mathop* ``OBJ``             | Return a *DataHammer* instance with the results of applying   |\n| |  *mathop* can be: ``+ - * / // ** %``  | a math operators in: *OTHER mathop ITEM*. [3]_                |\n+------------------------------------------+---------------------------------------------------------------+\n| ``OBJ[indexes]``                         | Depending on the argument, returns a *DataHammer* instance, a |\n|                                          | single contained ITEM, or a list of ITEMs. [4]_               |\n|                                          | See `Indexing`_, for more information.                        |\n+------------------------------------------+---------------------------------------------------------------+\n| | ``OBJ._bool()``                        | Return a *DataHammer* instance with the results of applying   |\n| | ``OBJ._int()``                         | the builtin type (*of the same name w/o the underscore*) to   |\n| | ``OBJ._float()``                       | each item in the list.                                        |\n| | ``OBJ._long()``                        | *(Use of 'long' is only allowed for Python 2)*                |\n+------------------------------------------+---------------------------------------------------------------+\n| ``reversed(OBJ)``                        | Return a *DataHammer* instance with the contained data in     |\n|                                          | reversed order.                                               |\n+------------------------------------------+---------------------------------------------------------------+\n| ``len(OBJ)``                             | Return an *int* for the number of contained data ITEMs.       |\n+------------------------------------------+---------------------------------------------------------------+\n| ``hash(OBJ)``                            | Return an *int* that is the hash of the tuple of the hash of  |\n|                                          | every ITEM.                                                   |\n|                                          | This will raise an exception if *any* ITEM cannot be hashed.  |\n+------------------------------------------+---------------------------------------------------------------+\n| ``ARG in OBJ``                           | Return a bool, which is `True` if any *ITEM == OBJ*.          |\n|                                          | With regard to limiting the items tested. [3]_                |\n+------------------------------------------+---------------------------------------------------------------+\n| ``OBJ in ARG``                           | *This is almost never what you want!*  Return a single bool,  |\n|                                          | ignoring of contents of ARG or OBJ.  The result is `True` if  |\n|                                          | neither ARG nor OBJ are empty, and `False` if they both are.  |\n+------------------------------------------+---------------------------------------------------------------+\n| ``-OBJ``    *(unary minus)*              | Return a *DataHammer* instance with the results of applying   |\n|                                          | *not ITEM* on each item.                                      |\n+------------------------------------------+---------------------------------------------------------------+\n\n\nFunctions\n^^^^^^^^^\n\nThis is a list of supported functions. [1]_\n\n+------------------------------------------+---------------------------------------------------------------+\n|            **Function**                  |     **Description**                                           |\n+==========================================+===============================================================+\n| | ``OBJ._ind(name)``                     | Attribute, index or *dict* key dereference. [2]_              |\n| | ``OBJ._get(name)``                     |                                                               |\n+------------------------------------------+---------------------------------------------------------------+\n| ``str(OBJ)``                             | Returns a JSON dump of the contained data.                    |\n+------------------------------------------+---------------------------------------------------------------+\n| ``OBJ._contains(ARG)``                   | Return a *DataHammer* instance with the results of applying   |\n|                                          | *ARG in ITEM* for each item.                                  |\n+------------------------------------------+---------------------------------------------------------------+\n| ``OBJ._apply(FUNC, ARG, *ARGS, **KWDS)`` | Return a *DataHammer* instance with the results of applying   |\n|                                          | ``FUNC(ITEM, ARG, *ARGS, **KWDS)`` to each item. [3]_         |\n+------------------------------------------+---------------------------------------------------------------+\n| ``OBJ._strip(ARG)``                      | Return a *DataHammer* instance with only the desired items.   |\n|                                          | Based on the type of ARG given, the new instance has only the |\n|                                          | items for which the result is true of:                        |\n|                                          | 1. If ARG is not given:  *bool(ITEM)*                         |\n|                                          | 2. If ARG is a callable: *ARG(ITEM)*                          |\n|                                          | 3. If ARG is a list, tuple or set: *(ITEM in ARG)*            |\n|                                          | 4. Otherwise: *ITEM == ARG*                                   |\n+------------------------------------------+---------------------------------------------------------------+\n| ``OBJ._insert(INDEX, ITEM)``             | Return a *DataHammer* instance with ITEM inserted at INDEX.   |\n+------------------------------------------+---------------------------------------------------------------+\n| ``OBJ._extend(INDEX, ITEMS)``            | Return a *DataHammer* instance with ITEMS added at the end.   |\n+------------------------------------------+---------------------------------------------------------------+\n| ``OBJ._splice(INDEX, DELNUM, *ITEM)``    | Return a *DataHammer* instance with DELNUM items deleted at   |\n|                                          | INDEX, and with ITEM(s) inserted there. [5]_                  |\n+------------------------------------------+---------------------------------------------------------------+\n| ``OBJ._slice(START [, END [, STEP ] ])`` | Return a *DataHammer* instance with the list sliced according |\n|                                          | to the given indices (like *list* slicing works).             |\n+------------------------------------------+---------------------------------------------------------------+\n| ``OBJ._pick(SELECTOR, SELECTOR, ...)``   | Return a *DataHammer* instance with a *dict* created from one |\n|                                          | or more parts of the contained data picked by *str* given by  |\n|                                          | the *SELECTOR* , either positional named parameters.          |\n|                                          | Parameters indicate the key in the resulting item, and how to |\n|                                          | dereference the data from the contained items. The rules are: |\n|                                          | [8]_                                                          |\n|                                          |                                                               |\n|                                          | * Positional parameters are *str* used to dereference parts   |\n|                                          |   of contained items, with the text after the last \".\" used   |\n|                                          |   as the key in the resulting items.                          |\n|                                          | * Named parameters are similar, but allow renaming the data   |\n|                                          |   the resulting items.                                        |\n+------------------------------------------+---------------------------------------------------------------+\n| ``OBJ._mutator()``                       | Returns a *DataHammer.Mutator* instance to be used for making |\n|                                          | modifications to the contained data.  See `Mutators`_.        |\n+------------------------------------------+---------------------------------------------------------------+\n\n\nIndexing\n^^^^^^^^\n\nIndexing a *DataHammer* instance with *[]* allows simple access to items from the contained data, but\nthere are various types of parameters types allowed. [4]_\n\n1. Indexing with an **int** or an implicit or explicit **slice** object works like indexing **list**; the\n   result is identical to **(~OBJ)[...]**.\n\n   * A single item is returned with an **int** argument, and can raise an IndexError.\n   * A (possibly empty) list of items is returned with either:\n\n     * An explicit **slice** argument, eg:   OBJ[slice(1, None, 5)]\n     * An implicit **slice** argument, eg:   OBJ[1::5]\n\n2. Indexing with a **list**, **tuple** or a *DataHammer* instance, will return another *DataHammer*\n   instance. [3]_  The parameter must either be all **bool** or all **int**, and they\n   dictate *which* items are used to construct the new instance:\n\n   * For **bool** indexes, each bool in the argument indicates if the corresponding item in the\n     *DataHammer* is included in the new instance.\n\n   * For **int** indexes, each int is used to index into the contained data, and which item is include\n     in the new instance.  This allows both filtering and reordering of data.\n\nIndexing Examples:\n\n     .. code:: python\n\n        >>> OBJ = DataHammer(list(range(10, 15)))\n\n        # Note that the following dereference the instance with \"~\" to show the contents:\n\n        >>> ~OBJ\n        [10, 11, 12, 13, 14]\n        >>> ~OBJ[(True, False, True, True, False, True)]\n        [10, 12, 13]      # The last/6th `True` is ignored since len(OBJ)==5\n        >>> ~OBJ[(4, 2, 1, 40, -1, 3, 1)]\n        [14, 12, 11, 14, 13, 11]    # 40 is ignored.\n\n        # Note these DO NOT dereference the result, they are not a DataHammer instance.\n\n        >>> type(OBJ[1])\n        <type 'int'>\n        >>> type(OBJ[:5])\n        <type 'list'>\n        >>> type(OBJ[slice(3)])\n        <type 'list'>\n        >>> OBJ[::3]\n        [10, 13]\n\n\nMutators\n^^^^^^^^\n\nThere is some support for making modifications to the data contained within a *DataHammer*, beyond\ndirect access.  This is done with the *DataHammer._mutator* method on the instance.\n\nHere **MUT** is used as a shorthand for **OBJ._mutator()** - which returns a *DataHammer.Mutator*\ninstance, and the name *Mutator* is also used for *DataHammer.Mutator*.\n\n\n+-----------------------------------------+----------------------------------------------------------------+\n|    **Functions and Operation**          |     **Description**                                            |\n+=========================================+================================================================+\n| ``MUT = OBJ._mutator()``                | Returns a new *Mutator* for the given *DataHammer* instance.   |\n+-----------------------------------------+----------------------------------------------------------------+\n| ``~MUT``                                | Returns the *DataHammer* instance for this *Mutator*.          |\n+-----------------------------------------+----------------------------------------------------------------+\n| | ``MUT.index``                         | Returns a new *Mutator* instance useful for modifying the      |\n| | ``MUT[index]``                        | key, attribute or list item at *index*. [7]_                   |\n| | ``MUT._get(index)``                   |                                                                |\n| | ``MUT._ind(index)``                   | Note that *all of these forms work identically*, though the    |\n|                                         | first form can only be used with valid identifier names. This  |\n|                                         | is in contrast with **[]** on a *DataHammer* instance where    |\n|                                         | it returns an item from the contained data.                    |\n+-----------------------------------------+----------------------------------------------------------------+\n| | ``MUT`` *op* ``OTHER``                | Update the item member for the given *Mutator* instance, with  |\n| |  *op* can be: ``+= -= *= /= **= //=`` | the given operation, which should be number (or object that    |\n|                                         | supports that operation).                                      |\n+-----------------------------------------+----------------------------------------------------------------+\n| ``MUT._set(OTHER)``                     | Update the value designated by the given *Mutator* instance,   |\n|                                         | overwriting with the given value(s).  If *OTHER* is a list,    |\n|                                         | tuple or *DataHammer* instance, then an interator is used,     |\n|                                         | and application stops when the end is reached. [3]_            |\n+-----------------------------------------+----------------------------------------------------------------+\n| ``MUT._setall(OTHER)``                  | Like ``MUT._set(OTHER)`` but regardless of the type, *OTHER*   |\n|                                         | is used without iterating.  Used to set all rows to the same   |\n|                                         | *list* or *tuple* value, but can be used with any value/type.  |\n+-----------------------------------------+----------------------------------------------------------------+\n| ``MUT._apply(FUNC, *ARGS, **KWDS)``     | Update the value designated by the given *Mutator* instance,   |\n|                                         | overwriting with the the *return value* from calling:          |\n|                                         | **``FUNC(VALUE, *ARGS, **KWDS)``**.                            |\n+-----------------------------------------+----------------------------------------------------------------+\n\nExamples\n--------\n\n\nGiven a JSON file that has metadata separated from the data values, we can easily\ncombine these, and find the ones which match criteria we want.\n\n  .. code:: python\n\n      >>> from datahammer import DataHammer\n      >>> from six.moves.urllib import request\n      >>> from collections import Counter\n\n      >>> URL = 'https://data.ny.gov/api/views/pxa9-czw8/rows.json?accessType=DOWNLOAD'\n      >>> req = request.urlopen(URL)\n      >>> jobs = DataHammer(req, json=dict(encoding='utf-8'))\n\n      # Grab the contained data in order to find its keys.\n      >>> (~jobs).keys()\n      dict_keys(['meta', 'data'])\n      >>> names = jobs.meta.view.columns.name\n      >>> norm = DataHammer(dict(zip(names, row)) for row in jobs.data)\n\n      # Here 'norm' contains 840 items, each a dict with the same schema.\n      >>> len(norm)\n      840\n      >>> print(norm[0])\n      {'sid': 1, 'id': 'A0447302-02D8-4EFD-AB68-777680645F02', 'position': 1,\n       'created_at': 1437380960, 'created_meta': '707861', 'updated_at': 1437380960,\n       'updated_meta': '707861', 'meta': None, 'Year': '2012', 'Region': 'Capital Region',\n       'NAICS Code': '11', 'Industry': 'Agriculture, Forestry, Fishing and Hunting',\n       'Jobs': '2183'}\n\n      # Use collections.Counter to count the number of instances of values:\n      >>> Counter(norm.Year)\n      Counter({'2012': 210, '2013': 210, '2014': 210, '2015': 210})\n      >>> Counter(norm._get('NAICS Code'))\n      Counter({'11': 40, '21': 40, '22': 40, '23': 40, '42': 40, '51': 40, '52': 40,\n               '53': 40, '54': 40, '55': 40, '56': 40, '61': 40, '62': 40, '71': 40,\n               '72': 40, '81': 40, '90': 40, '99': 40, '31-33': 30, '44-45': 30,\n               '48-49': 30, '31': 10, '44': 10, '48': 10})\n\n      # Use '&' to require both conditions.\n      >>> fish3 = norm[(norm.Year == '2013') & norm.Region._contains('Capital Region')]\n      >>> len(fish3)\n      21\n      >>> keepers = norm.Jobs._int() > 500000\n      >>> sum(keepers)\n      8\n      >>> large = norm[keepers]\n      >>> len(large)\n      8\n\n\nInstallation\n------------\nInstall the package using **pip**, eg:\n\n  `sudo pip install datahammer`\n\nOr for a specific version:\n\n  `sudo python3 -m pip install datahammer`\n\n\nTo the source git repository, use:\n\n  `git clone https://github.com/n2vram/datahammer.git`\n\n\nReleases\n^^^^^^^^\n\n   +-------------+--------------------------------------------------------+\n   | **Version** | **Description**                                        |\n   +=============+========================================================+\n   |     0.9     | Initial release, documentation prototyping.            |\n   +-------------+--------------------------------------------------------+\n   |    0.9.1    | Addition of \"_pick\" method.                            |\n   +-------------+--------------------------------------------------------+\n\nFoot Notes\n----------\n\n.. [1]  Tokens\n\nIn these examples, *OBJ* refers to a *DataHammer* instance, *LIST* refers to the list of\ncontained items, and *ITEM* refers to an item in the contained list or directly in the *OBJ*.\n\n\n.. [2]  Dereferences\n\nAn attribute dereference (eg: *OBJ.index*) and the methods *OBJ._ind(index)* and *OBJ._get(index)* all\nfunction identically, returning a new **DataHammer** instance.  The latter are provided for use when\n*index* is an *int* or otherwise not a valid string identifier.\n\n\n.. [3]  Scalars, Vectors and DataHammers\n\nFor most operations and functions that return a new instance, when a *DataHammer* instance is combined\nwith a list, tuple or other *DataHammer* instance, the length of the new instance will be limited by the\nlength of the shorter of the two operands.  For example:\n\n  - Using a shorter operand, the result will be shortened as if the *DataHammer* instance had only that\n    many items.\n\n  - Using a longer operand, the result will be as if the *DataHammer* instance had only as many items as\n    that other operand.\n\n  .. code:: python\n\n     >>> dh1 = DataHammer(range(8))\n     >>> ~(dh1 + (10, 20))\n     [10, 21]\n     >>> dh2 = DataHammer((3, 1, 4))\n     >>> ~(dh1 == dh2)\n     [False, True, False]\n     >>> ~(dh1[dh2])\n     [3, 1, 4]\n\n\n.. [4]  Bracket Indexing\n\nBecause the **[]** syntax is used for `Indexing`_ and returns an ITEM or list, we cannot use this syntax\nfor chaining or to create another instance as we do for dotted-attribute access.  This is why there is a\n**_ind()** method, to allow\n\n  .. code:: python\n\n     >>> dh = DataHammer([[i, i*i] for i in range(10, 15)])\n     >>> ~dh\n     [[10, 100], [11, 121], [12, 144], [13, 169], [14, 196]]\n     >>> ~dh._ind(1)\n     [100, 121, 144, 169, 196]\n     >>> ~(dh._ind(1) > 125)\n     [False, False, True, True, True]\n     >>> ~dh[dh._ind(1) > 125]\n     [[12, 144], [13, 169], [14, 196]]\n     >>> dh = DataHammer([dict(a=i, b=tuple(range(i, i*2))) for i in range(6)])\n\n     # 'dh.b' returns a DataHammer of N-tuples, then '[3]' retrieves the 4th of these tuples as a `tuple`.\n     >>> dh.b[2]\n     (2, 3)\n\n     # Here 'dh.b' gives a DataHammer instance of N-tuples, but '_ind(2)' returns another DataHammer\n     # with the 3rd item from those N-tuples.  Note the `None` for slots where the tuple length.\n     >>> dh.b._ind(2)\n     <datahammer.DataHammer object at 0x7f79eb1a9c10>\n     >>> ~dh.b._ind(2)\n     [None, None, None, 5, 6, 7]\n\n\n.. [5]  Slicing\n\nThis works similar to the *slice* method of the\n`Javascript Array <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice>`_\nclass.\n\n\n.. [6]  In / Contains\n\nUsing \"*ITEM in OBJ*\" returns True if ITEM matches one of the items in OBJ, using the operator **==**\nfor the test.  However, using *OBJ in OTHER* for an iterable containers *OTHER*, is useless.\nuseless.\n\nUsing \"*OBJ in OTHER*\" will evaluate the expression \"**X == OBJ**\" for each item X in OTHER,, resulting\nin a list of bool.  Unless either *OTHER* or *OBJ* are empty, this means a non-empty list will be\nconverted to **True** even if all of the comparisons fail.\n\n\n.. [7]  Mutator\n\n*Mutator* operations dereference items based on the type of an item, regardless of the type of other items in\nthe contained data.  Meaning: if a *DataHammer* with two items contains a `dict` with a key \"foo\" and an object\nwith an attribute \"foo\", then using **OBJ._mutator().foo** will update differently.\n\n\n.. [8] The `_pick()` method.\n\nA *SELECTOR* must be a `str`, but can be named or positional.\n\n1. Resulting items are all `dict` instances.\n2. For named parameters, the name will be used for the key in the resulting items.\n3. For positional parameters, the text after the last dot, if any, is used for the resulting key.\n4. Recursive dereferences are allowed with a dot (`.`) separator between sub-keys.\n\nCaveats:\n\n5. If there are multiple parameters that result in the same key, the result is undefined.\n   Currently, positional parameters are processed in order before the named parameters,\n   but that is not guaranteed to be true in future releases.\n6. Currently, a bare int (in decimal form) is used to index into lists, but that syntax may\n   change and is not guaranteed to be true in future releases.\n\nExample:\n\n    .. code:: python\n\n        >>> dh = DataHammer([\n        ...   {\"a\": 100, \"b\": {\"b1\": [101, 102, 103], \"b2\": \"ape\"}, \"c\": [\"Apple\", \"Anise\"]},\n        ...   {\"a\": 200, \"b\": {\"b1\": [201, 202, 203], \"b2\": \"bat\"}, \"c\": [\"Banana\", \"Basil\"]},\n        ...   {\"a\": 300, \"b\": {\"b1\": [301, 302, 303], \"b2\": \"cat\"}, \"c\": [\"Cherry\", \"Cayenne\"]}\n        ... ])\n\n        >>> ~dh._pick('a', 'b.b1', animal='b.b2', food='c', nil='this.is.missing')\n        [{'a': 100, 'b1': [101, 102, 103], 'animal': 'ape', 'food': ['Apple', 'Anise'], 'nil': None},\n         {'a': 200, 'b1': [201, 202, 203], 'animal': 'bat', 'food': ['Banana', 'Basil'], 'nil': None},\n         {'a': 300, 'b1': [301, 302, 303], 'animal': 'cat', 'food': ['Cherry', 'Cayenne'], 'nil': None}]         \n\n        >>> ~dh._pick('b.b1', b1='c')\n        #### Result is undefined due to the key collision.\n\n        >>> ~dh._pick(animal='b.b2', fruit='c.0')   ## This '.0' syntax *might* change in future releases.\n        [{'animal': 'ape', 'fruit': 'Apple'},\n         {'animal': 'bat', 'fruit': 'Banana'},\n         {'animal': 'cat', 'fruit': 'Carmel'}]",
    "docs_url": null,
    "download_url": "https://github.com/n2vram/datahammer/archive/0.9.1",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "https://github.com/n2vram/datahammer",
    "keywords": "data,datasets,queries,JSON,resultsets,datahammer,hammer",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "datahammer",
    "platform": "any",
    "project_url": "https://pypi.org/project/datahammer/",
    "release_url": "https://pypi.org/project/datahammer/0.9.1/",
    "requires_dist": [],
    "requires_python": "",
    "summary": "This module provides an easy way to manipulate and inspect lists of data.  It was designed to handle plain data types, especially the output from parsing JSON.  It allows simple operations to be done on the items in parallel in a concise fashion.  Many features will also work on other data types.",
    "version": "0.9.1"
  },
  "releases": {
    "0.9": [
      {
        "comment_text": "",
        "digests": {
          "md5": "18c1c76868a131b6513654df9d2f0e2c",
          "sha256": "5118a047e397ae9c113bac33b28149b62022938ee3e57ce54c359bf7f82c5645"
        },
        "downloads": -1,
        "filename": "datahammer-0.9.tar.gz",
        "has_sig": false,
        "md5_digest": "18c1c76868a131b6513654df9d2f0e2c",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 13937,
        "upload_time": "2018-01-11T04:06:09",
        "url": "https://files.pythonhosted.org/packages/28/33/a6ffee7ce42b942be273f06eb6c4e15b25bfcdfde1164ec244518f903806/datahammer-0.9.tar.gz"
      }
    ],
    "0.9.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "b10d1af7aec717068299cd6710ebead9",
          "sha256": "d0cb3d3a4d5fa6327811d901c9b0acbbe49ec1a814c3369964fac6e05aaff3fa"
        },
        "downloads": -1,
        "filename": "datahammer-0.9.1.tar.gz",
        "has_sig": false,
        "md5_digest": "b10d1af7aec717068299cd6710ebead9",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 19314,
        "upload_time": "2018-02-08T14:51:18",
        "url": "https://files.pythonhosted.org/packages/f5/b4/f594f079ebdcc7389cbac21b69be3d57b6fb2aba7a1eb29b188df30ad246/datahammer-0.9.1.tar.gz"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "b10d1af7aec717068299cd6710ebead9",
        "sha256": "d0cb3d3a4d5fa6327811d901c9b0acbbe49ec1a814c3369964fac6e05aaff3fa"
      },
      "downloads": -1,
      "filename": "datahammer-0.9.1.tar.gz",
      "has_sig": false,
      "md5_digest": "b10d1af7aec717068299cd6710ebead9",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 19314,
      "upload_time": "2018-02-08T14:51:18",
      "url": "https://files.pythonhosted.org/packages/f5/b4/f594f079ebdcc7389cbac21b69be3d57b6fb2aba7a1eb29b188df30ad246/datahammer-0.9.1.tar.gz"
    }
  ]
}