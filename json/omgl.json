{
  "info": {
    "author": "Adam Griffiths",
    "author_email": "UNKNOWN",
    "bugtrack_url": null,
    "classifiers": [
      "Intended Audience :: Developers",
      "License :: OSI Approved :: BSD License",
      "Natural Language :: English",
      "Operating System :: MacOS :: MacOS X",
      "Operating System :: Microsoft :: Windows",
      "Operating System :: POSIX",
      "Programming Language :: Python",
      "Topic :: Multimedia :: Graphics",
      "Topic :: Software Development :: Libraries",
      "Topic :: Software Development :: Libraries :: Python Modules"
    ],
    "description": "====\nOMGL\n====\n\nAn easy to use Pythonic 3D OpenGL framework.\n\nOMGL is the Graphical core of the `Bast 3D engine <https://github.com/adamlwgriffiths/bast>`_.\n\nInspired by the following projects:\n\n* `PyGLy <https://github.com/adamlwgriffiths/PyGLy>`_\n* `PyGL <https://github.com/Ademan/pygl>`_\n* `Glitter <https://github.com/swenger/glitter>`_\n\n\nFeatures\n========\n\n* Pythonic - Don't worry about OpenGL's horrible state machine.\n* NumPy at the Core - Easily pass complex data structures to OpenGL.\n* BYOWS - Bring your own windowing system (`CyGLFW3 recommended <https://github.com/adamlwgriffiths/cyglfw3>`_).\n\n\n\nDependencies\n============\n\n* Numpy (1.8.2 as 1.9 has a `critical bug <https://github.com/numpy/numpy/issues/5224>`_)\n* PyOpenGL\n* Pillow\n\n\nOptional dependencies dependencies\n==================================\n\n* PyOpenGL-accelerate - Speed boost for PyOpenGL\n    * `pip install -r requirements-accelerate.txt`\n    * or `pip install omgl[accelerate]`\n* CyGLFW3 - Windowing system used in examples (or other windowing system)\n    * `pip install -r requirements-cyglfw3.txt`\n    * or `pip install omgl[cyglfw3]`\n* Pyrr - 3D Mathematics library used in examples\n    * `pip install -r requirements-pyrr.txt`\n    * or `pip install omgl[pyrr]`\n\nTo install all dependencies:\n\n* `pip install omgl[accelerate,cyglfw3,pyrr]`\n\n\nExamples\n========\n\n\nDebugging\n---------\n\nYou can print out each OpenGL call you or OMGL make by enabling function printing.\nThis is excellent for debugging OpenGL issues or inspecting the OMGL call logic.\n\nEssentially this replaces all the PyOpenGL glX functions with a proxy function that\nprints the functions name and arguments before calling the original function.\n\n::\n\n    from omgl import debug\n    debug.print_gl_calls(True)\n\n\n\nNumpy Dtypes\n------------\n\nIt is often important to convert between OpenGL and Numpy dtypes for variable types\nand enumerations.\n\nThis is easily done with the dtypes module.\n\n::\n\n    from OpenGL import GL\n    from omgl import dtypes\n    print(dtypes.uint8.dtype)\n    print(dtypes.uint8.gl_type)\n    print(dtypes.uint8.gl_enum)\n    print(dtypes.uint8.char_code)\n\n    d = dtypes.for_enum(GL.GL_UNSIGNED_INT)\n    print(d.gl_enum, d.dtype)\n\n    d = dtypes.for_dtype(np.float32)\n    print(d.gl_enum, d.dtype)\n\n    d = dtypes.for_code('f')\n    print(d.gl_enum, d.dtype)\n\n\n\nTextures\n--------\n\nTextures can be created using raw data.\n\n::\n\n    from omgl.texture import Texture2D\n    data = np.random.random((32,32,4))\n    data *= 255\n    data = data.astype(np.uint8)\n\n    texture = Texture2D(data)\n\n    texture.active_unit = 0\n    texture.bind()\n\n\nOr loaded from a file using PIL / Pillow\n\n::\n\n    from omgl.texture import Texture2D\n    texture = Texture2D.open('assets/texture/formats/RGBA.png')\n\n\nTextures also provide information about themselves.\n\n::\n\n\n    from omgl.texture import Texture2D\n    texture = Texture2D.open('assets/texture/formats/RGBA.png')\n\n    print(texture.internal_format)\n    print(texture.size)\n    print(texture.dtype)\n    print(texture.shape)\n\n\nTextures can also be created empty using a shape and dtype.\nPassed formats and Internal formats are auto-detected, but can be over-ridden\nwith the internal_format and format arguments.\n\n::\n\n    from OpenGL import GL\n    from omgl.texture import Texture2D\n    # create an empty 256x256 texture with 4 channels, RGBA.\n    texture = Texture2D(shape=(256,256,4), dtype=np.uint8)\n    texture.set_data(data=np.random.random((256,256,4)))\n\n    texture = Texture2D(shape=(256,256,4), dtype=np.uint8, internal_format=GL.GL_RGBA)\n\n\n\nTextures will automatically have their min and mag filters set to GL_LINEAR\nto avoid 'black textures' in OpenGL 3.\nThis can be avoided by passing the desired filter mode to the constructor as the\nmin_filter and mag_filter properties.\n\n::\n\n    from OpenGL import GL\n    from omgl.texture import Texture2D\n    texture = Texture2D.open('assets/texture/formats/RGBA.png',\n        min_filter=GL.GL_NEAREST,\n        mag_filter=GL.GL_NEAREST,\n    )\n\n\nMipMap's are automatically generated, and can be re-generated with the 'mipmap' function.\nAutomatic generation of mipmaps can be disabled by over-riding the mipmap argument\nin the constructor and set_data functions.\n\n::\n\n    from omgl.texture import Texture2D\n    texture = Texture2D(shape=(256,256,4), dtype=np.uint8, mipmap=False)\n    texture.set_data(data=np.random.random((256,256,4)), mipmap=False)\n    texture.mipmap()\n    texture.set_data(data=np.random.random((256,256,4)), mipmap=False)\n    texture.mipmap()\n\n\n\nBecause of the need for texture minification and magnification, textures consist\nof a number of 'levels'. This also means that getting and setting data must specify\nthe requested level.\nBy default this is 0.\n\n::\n\n    from omgl.texture import Texture2D\n    texture = Texture2D(shape=(256,256,4), dtype=np.uint8, mipmap=False)\n    texture.set_data(np.random.random((256,256,4)))\n    texture.mipmap()\n\n    # get base level texture data\n    print(texture.get_data())\n\n    # get first mipmap level data\n    print(texture.get_data(1))\n\n    # a convenience property is provided for level 0\n    texture.data = np.random.random((256,256,4))\n    print(texture.data)\n\n\nVarious texture parameters can be set at creation via named arguments, or later.\n\n::\n\n    from omgl.texture import Texture2D\n    texture = Texture2D.open('assets/texture/formats/RGBA.png', wrap_s=GL.GL_REPEAT)\n    texture.wrap_t = GL.GL_CLAMP_TO_EDGE\n\n\nThe active texture unit can be set from the Texture class (or derived classes)\nor texture objects themselves.\nNote that this property accesses the global active unit property, and isn't\nsetting that object's texture unit.\n\n::\n\n    from omgl.texture import Texture, Texture2D\n    texture = Texture2D.open('assets/texture/formats/RGBA.png')\n\n    # the following calls are all equivalent\n    texture.active_unit = 1\n    Texture.active_unit = 1\n    Texture2D.active_unit = 1\n\n    # we can get the current active unit.\n    print(Texture.active_unit)\n\n\nBuffers\n-------\n\n\nBuffers make use of complex numpy dtype's. This let's OMGL automatically tell OpenGL\nabout the layout of your buffers.\n\n::\n\n    from omgl.buffer import VertexBuffer\n    data = np.array([\n        [([ 1., 0.,-1.], [1., 0.])],\n        [([-1., 0.,-1.], [0., 0.])],\n        [([ 0., 1.,-1.], [.5, 1.])],\n        ],\n        dtype=[('in_position', np.float32, 3,),('in_uv', np.float32, 2,),]\n    )\n    vb = VertexBuffer(data)\n\n\nTo avoid the complexities of creating the array, you can convert to a complex array after creation.\n\n::\n\n    from omgl.buffer import VertexBuffer\n    flat_data = np.array([\n        [ 1., 0.,-1., 1., 0.],\n        [-1., 0.,-1., 0., 0.],\n        [ 0., 1.,-1., .5, 1.],\n    ])\n    data = flat_data.view(dtype=[('in_position', np.float32, 3,),('in_uv', np.float32, 2,),])\n    vb = VertexBuffer(data)\n\n\nYou can manually provide this information should you not want to use complex dtypes.\n\n::\n\n    from omgl.buffer import VertexBuffer, BufferPointer\n    flat_data = np.array([\n        [ 1., 0.,-1., 1., 0.],\n        [-1., 0.,-1., 0., 0.],\n        [ 0., 1.,-1., .5, 1.],\n    ])\n    data = flat_data.view(dtype=[('in_position', np.float32, 3,),('in_uv', np.float32, 2,),])\n    vb = VertexBuffer(data)\n\n    # pointer to vertex data\n    # total size of an element is 5 * 32bit floats\n    stride = 5 * np.dtype(np.float32).itemsize\n    vertex_ptr = BufferPointer(vb, count=3, stride=stride, offset=0, dtype=np.float32)\n\n    # pointer of uv data\n    # offset of uv's is the vertex x,y,z, which is 3 * 32bit float.\n    offset = 3 * np.dtype(np.float32).itemsize\n    uv_tr = BufferPointer(vb, count=2, stride=stride, offset=offset, dtype=np.float32)\n\n\nOr use the entire array as a single data type\n\n::\n\n    from omgl.buffer import VertexBuffer, BufferPointer\n    vertex_data = np.array([\n        [ 1., 0.,-1.],\n        [-1., 0.,-1.],\n        [ 0., 1.,-1.],\n    ], dtype=np.float32)\n    vertices = VertexBuffer(vertex_data)\n\n    # this data is 2 dimensional to make it easier to read\n    # it could be 1 dimensional, with no code changes, if we wished\n    uv_data = np.array([\n        [1., 0.],\n        [0., 0.],\n        [0.5, 1.],\n    ], dtype=np.float32)\n    uvs = VertexBuffer(uv_data)\n\n\nTexture Buffer's allow like access to 1 dimensional buffer data.\nThis is great for passing large amounts of random-access data to shaders.\n\n::\n\n    from omgl.buffer import TextureBuffer\n    data = np.ones((32,32,4), dtype=np.float32)\n    texture_buffer = TextureBuffer(data)\n    texture = texture_buffer.texture\n\n    texture.active_unit = 0\n    texture.bind()\n\n\n\nShaders\n-------\n\nShader and Program objects wrap GLSL shaders.\nAttributes must be set at construction time.\n\n::\n\n    from omgl.shader import VertexShader, FragmentShader, Program\n    # vertex shader\n    vs = \"\"\"\n        #version 400\n        in vec3 in_position;\n        in vec2 in_uv;\n        uniform mat4 in_projection;\n        uniform mat4 in_model_view;\n        out vec2 ex_uv;\n        void main() {\n            gl_Position = in_projection * in_model_view * vec4(in_position, 1.0);\n            ex_uv = in_uv;\n        }\n        \"\"\"\n\n    # fragment shader\n    fs = \"\"\"\n        #version 400\n        uniform sampler2D in_diffuse_texture;\n        in vec2 ex_uv;\n        out vec4 out_color;\n        void main(void) {\n            out_color = texture(in_diffuse_texture, ex_uv);\n        }\n        \"\"\"\n\n    # create and link\n    # specify attributes at link time\n    program = Program([\n        VertexShader(vs),\n        FragmentShader(fs),\n        ],\n        in_position=1,\n        in_uv=2,\n    )\n\n    # these values can be set automatically using a Pipeline\n    with program:\n        program.in_projection = np.eye(4)\n        program.in_model_view = np.eye(4)\n        # set the texture unit to read from\n        program.in_diffuse_texture = 0\n\n\nOr load shaders from a file\n\n::\n\n    from omgl.shader import FragmentShader, VertexShader, Program\n    program = Program([\n        VertexShader.open('assets/shaders/test.vs'),\n        FragmentShader.open('assets/shaders/test.fs'),\n        ],\n        in_position=1,\n        in_uv=2,\n    )\n\n\nShader Programs automatically find and provide wrappers for their Uniform and\nAttribute variables.\nUniform data can be read or set easily.\n\nVariable's are loaded from OpenGL only when accessed, meaning you won't get any\npipeline stalls while loading shaders in parallel.\n\n\n::\n\n    from omgl.shader import FragmentShader, VertexShader, Program\n    program = Program([\n        VertexShader.open('assets/shaders/test.vs'),\n        FragmentShader.open('assets/shaders/test.fs'),\n        ],\n        in_position=1,\n        in_uv=2,\n    )\n\n    # get a variable directly\n    program.in_position\n\n    # get an attribute from the attributes dict\n    program.attributes['in_position']\n\n    # print a list of attribute variable names\n    print(program.attributes.keys())\n\n    # inspect an attribute\n    print(program['in_position'].location)\n    print(program['in_position'].dtype)\n    print(program['in_position'].itemsize)\n    print(program['in_position'].nbytes)\n    print(program['in_position'].dimensions)\n    print(program['in_position'].enum)\n    print(program['in_position'].name)\n    print(program['in_position'].enum)\n\n    # get a uniform directly\n    program.in_projection\n\n    # get a uniform from the uniforms dict\n    program.uniforms['in_projection']\n\n    # print a list of uniform variable names\n    print(program.uniforms.keys())\n\n    # inspect a uniform\n    print(program['in_projection'].location)\n    print(program['in_projection'].dtype)\n    print(program['in_projection'].itemsize)\n    print(program['in_projection'].nbytes)\n    print(program['in_projection'].dimensions)\n    print(program['in_projection'].enum)\n    print(program['in_projection'].name)\n    print(program['in_projection'].enum)\n\n    # print the current value of the uniform\n    print(program['in_projection'].data)\n\n    # set the value of the uniform\n    program['in_projection'].data = np.eye(4)\n\n\n\nPipelines\n---------\n\nPipelines provide a way to automatically link textures, values (uniforms) and\nvertex data (attributes) to a shader program before rendering.\n\nThe Pipeline allows you to assign values to the shader program without worrying about it being bound or not at the time.\n\nThis lets you decouple the shader program from the renderable object itself.\n\n\n::\n\n    from OpenGL import GL\n    from omgl.shader import FragmentShader, VertexShader, Program\n    from omgl.buffer import VertexBuffer, VertexArray\n    from omgl.pipeline.pipeline import Pipeline\n\n    # shader program\n    program = Program([\n        VertexShader.open('assets/shaders/test.vs'),\n        FragmentShader.open('assets/shaders/test.fs'),\n        ],\n        in_position=1,\n        in_uv=2,\n    )\n\n    # vertex data\n    data = np.array([\n        [([ 1., 0.,-1.], [1., 0.])],\n        [([-1., 0.,-1.], [0., 0.])],\n        [([ 0., 1.,-1.], [.5, 1.])],\n        ],\n        dtype=[('in_position', np.float32, 3,),('in_uv', np.float32, 2,),]\n    )\n    vb = VertexBuffer(data)\n\n    # bind the vertex attributes to a vertex array\n    va = VertexArray()\n\n    # bind the vertex array and notify it of our vertex pointers\n    with va:\n        # get the location of the attributes\n        in_position = program.attributes.get('in_position').location\n        va[in_position] = vb.pointers['in_position']\n\n        in_uv = program.attributes.get('in_uv')\n        va[in_uv] = vb.pointers['in_uv']\n\n\n    # load our texture\n    texture = Texture2D.open('assets/textures/formats/RGBA.png')\n\n    # create a pipeline for our shader\n    # the pipeline will automatically assign these uniforms to any matching\n    # variable in our shader\n    # we can pass any variables we want at construction time as named parameters\n    pipeline = Pipeline(program,\n        in_diffuse_texture=texture,\n    )\n\n    # we can also set any value after creation, there is no difference\n    pipeline.in_projection = np.eye(4)\n    pipeline.in_model_view = np.eye(4)\n    # textures are automatically handled\n    # variables that don't exist in the shader are ignored\n    pipeline.this_variable_doesnt_exist = (1,2,3,4)\n\n    # bind the pipeline\n    # this will actually bind the shader program and push any values into it\n    with pipeline:\n        # tell the vertex array to render our vertex data as lists of triangles\n        va.render(GL.GL_TRIANGLES)\n\n\nMeshes\n------------------\n\nMeshes greatly simplify the boilerplate required to render an object\nby wrapping a lot of the above functionality.\nMeshes handle vertex arrays, shaders and pipelines for you.\n\n\n::\n\n    from OpenGL import GL\n    from omgl.shader import FragmentShader, VertexShader, Program\n    from omgl.buffer import VertexBuffer\n    from omgl.pipeline.pipeline import Pipeline\n    from omgl.mesh import Mesh\n\n    # shader program\n    program = Program([\n        VertexShader.open('assets/shaders/test.vs'),\n        FragmentShader.open('assets/shaders/test.fs'),\n        ],\n        in_position=1,\n        in_uv=2,\n    )\n\n    # vertex data\n    data = np.array([\n        [([ 1., 0.,-1.], [1., 0.])],\n        [([-1., 0.,-1.], [0., 0.])],\n        [([ 0., 1.,-1.], [.5, 1.])],\n        ],\n        dtype=[('in_position', np.float32, 3,),('in_uv', np.float32, 2,),]\n    )\n    vb = VertexBuffer(data)\n\n    # load our texture\n    texture = Texture2D.open('assets/textures/formats/RGBA.png')\n\n    # create a pipeline with our shader and our texture\n    pipeline = Pipeline(program, in_diffuse_texture=texture)\n\n    # create a mesh using our pipeline and vertex data\n    mesh = Mesh(pipeline, **vb.pointers)\n\n    # render the mesh automatically\n    # we can pass in any frame-to-frame here as named arguments\n    mesh.render(in_projection=np.eye(4), in_model_view=np.eye(4))\n\n\nBy default, meshes render all vertex data and use GL_TRIANGLES as the primitive\ntype.\n\nThis can be changed at mesh construction time.\n\n::\n\n    from omgl.buffer import IndexBuffer\n    indices = IndexBuffer(np.array([1,2,3,4,5,6], dtype=np.uint32))\n    mesh = Mesh(pipeline, indices=indices, primitive=GL.GL_TRIANGLE_STRIP)\n\n\nIf vertex buffer's contain mixed primitive types, then use multiple meshes\nwith different pointers into the data.\nTo control which elements are rendered, use either an IndexBuffer, or render from\nthe mesh's VertexArray directly.\n\n::\n\n    mesh.vertex_array.render(GL.GL_TRIANGLE_STRIP, start=5, count=10)\n    mesh.vertex_array.render(GL.GL_TRIANGLES, start=20, count=6)\n\n\nAuthors\n=======\n\n* `Adam Griffiths <https://github.com/adamlwgriffiths>`_\n",
    "docs_url": null,
    "download_url": "UNKNOWN",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "https://github.com/adamlwgriffiths/omgl",
    "keywords": null,
    "license": "BSD",
    "maintainer": null,
    "maintainer_email": null,
    "name": "omgl",
    "platform": "any",
    "project_url": "https://pypi.org/project/omgl/",
    "release_url": "https://pypi.org/project/omgl/0.0.1/",
    "requires_python": null,
    "summary": "Pythonic OpenGL Bindings",
    "version": "0.0.1"
  },
  "releases": {
    "0.0.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "092cdbc8c59ea046811e800e5eba1813",
          "sha256": "d590804829c9f66cb41f4062a6c98aeddb6ee6e677669ee94b79cc2ba682ef34"
        },
        "downloads": 375,
        "filename": "omgl-0.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "092cdbc8c59ea046811e800e5eba1813",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 20656,
        "upload_time": "2016-07-20T00:22:30",
        "url": "https://files.pythonhosted.org/packages/68/96/d2594e8ffd22c2a8bd9a4e402c0a4d4b761078ef951e3313d5230d93d0e8/omgl-0.0.1.tar.gz"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "092cdbc8c59ea046811e800e5eba1813",
        "sha256": "d590804829c9f66cb41f4062a6c98aeddb6ee6e677669ee94b79cc2ba682ef34"
      },
      "downloads": 375,
      "filename": "omgl-0.0.1.tar.gz",
      "has_sig": false,
      "md5_digest": "092cdbc8c59ea046811e800e5eba1813",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 20656,
      "upload_time": "2016-07-20T00:22:30",
      "url": "https://files.pythonhosted.org/packages/68/96/d2594e8ffd22c2a8bd9a4e402c0a4d4b761078ef951e3313d5230d93d0e8/omgl-0.0.1.tar.gz"
    }
  ]
}