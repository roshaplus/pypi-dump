{
  "info": {
    "author": "Daniel Smith",
    "author_email": "dgasmith@icloud.com",
    "bugtrack_url": "",
    "classifiers": [
      "Development Status :: 4 - Beta",
      "Intended Audience :: Science/Research",
      "Programming Language :: Python :: 2.7",
      "Programming Language :: Python :: 3"
    ],
    "description": "Einsum is a very powerful function for contracting tensors of arbitrary\r\ndimension and index. However, it is only optimized to contract two terms\r\nat a time resulting in non-optimal scaling.\r\n\r\nFor example, consider the following index transformation:\r\n``M_{pqrs} = C_{pi} C_{qj} I_{ijkl} C_{rk} C_{sl}``\r\n\r\nConsider two different algorithms:\r\n\r\n.. code:: python\r\n\r\n    import numpy as np\r\n    N = 10\r\n    C = np.random.rand(N, N)\r\n    I = np.random.rand(N, N, N, N)\r\n\r\n    def naive(I, C):\r\n        # N^8 scaling\r\n        return np.einsum('pi,qj,ijkl,rk,sl->pqrs', C, C, I, C, C)\r\n\r\n    def optimized(I, C):\r\n        # N^5 scaling\r\n        K = np.einsum('pi,ijkl->pjkl', C, I)\r\n        K = np.einsum('qj,pjkl->pqkl', C, K)\r\n        K = np.einsum('rk,pqkl->pqrl', C, K)\r\n        K = np.einsum('sl,pqrl->pqrs', C, K)\r\n        return K\r\n\r\nThe einsum function does not consider building intermediate arrays;\r\ntherefore, helping einsum out by building these intermediate arrays can result\r\nin a considerable cost savings even for small N (N=10):\r\n\r\n.. code:: python\r\n\r\n    >> np.allclose(naive(I, C), optimized(I, C))\r\n    True\r\n\r\n    %timeit naive(I, C)\r\n    1 loops, best of 3: 1.18 s per loop\r\n\r\n    %timeit optimized(I, C)\r\n    1000 loops, best of 3: 612 \u00b5s per loop\r\n\r\nThe index transformation is a well known contraction that leads to\r\nstraightforward intermediates. This contraction can be further\r\ncomplicated by considering that the shape of the C matrices need not be\r\nthe same, in this case the ordering in which the indices are transformed\r\nmatters greatly. Logic can be built that optimizes the ordering;\r\nhowever, this is a lot of time and effort for a single expression.\r\n\r\nThe opt_einsum package is a drop in replacement for the ``np.einsum`` function and can handle all of the logic for you:\r\n\r\n.. code:: python\r\n\r\n    from opt_einsum import contract\r\n\r\n    contract('pi,qj,ijkl,rk,sl->pqrs', C, C, I, C, C)\r\n\r\nThe above will automatically find the optimal contraction order, in this case identical to that of the optimized function above, and compute the products for you. In this case, it even uses `np.dot` under the hood to exploit any vendor BLAS functionality that your NumPy build has!\r\n\r\nWe can then view more details about the optimized contraction order:\r\n\r\n.. code:: python\r\n\r\n    >>> from opt_einsum import contract_path\r\n\r\n    >>> path_info = oe.contract_path('pi,qj,ijkl,rk,sl->pqrs', C, C, I, C, C)\r\n\r\n    >>> print(path_info[0])\r\n    [(0, 2), (0, 3), (0, 2), (0, 1)]\r\n\r\n    >>> print(path_info[1])\r\n      Complete contraction:  pi,qj,ijkl,rk,sl->pqrs\r\n             Naive scaling:  8\r\n         Optimized scaling:  5\r\n          Naive FLOP count:  8.000e+08\r\n      Optimized FLOP count:  8.000e+05\r\n       Theoretical speedup:  1000.000\r\n      Largest intermediate:  1.000e+04 elements\r\n    --------------------------------------------------------------------------------\r\n    scaling   BLAS                  current                                remaining\r\n    --------------------------------------------------------------------------------\r\n       5      GEMM            ijkl,pi->jklp                      qj,rk,sl,jklp->pqrs\r\n       5      GEMM            jklp,qj->klpq                         rk,sl,klpq->pqrs\r\n       5      GEMM            klpq,rk->lpqr                            sl,lpqr->pqrs\r\n       5      GEMM            lpqr,sl->pqrs                               pqrs->pqrs",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "https://github.com/dgasmith/opt_einsum",
    "keywords": "",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "opt-einsum",
    "platform": "UNKNOWN",
    "project_url": "https://pypi.org/project/opt-einsum/",
    "release_url": "https://pypi.org/project/opt-einsum/0.2.0/",
    "requires_python": null,
    "summary": "Optimizing numpys einsum function",
    "version": "0.2.0"
  },
  "releases": {
    "0.2.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "40937646fd421a670e5e93dd21a7aa01",
          "sha256": "f2090d098388bf8a4fad20410f76ad81db16b9d4bf8c95e6539fca6aee7aa227"
        },
        "downloads": 318,
        "filename": "opt_einsum-0.2.0-py2.py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "40937646fd421a670e5e93dd21a7aa01",
        "packagetype": "bdist_wheel",
        "python_version": "py2.py3",
        "size": 12956,
        "upload_time": "2016-07-30T22:12:39",
        "url": "https://files.pythonhosted.org/packages/0a/f4/0c6e221ea86a2cdfc5e7fd2fa99cfe0002a818112d9e066244258d7675f5/opt_einsum-0.2.0-py2.py3-none-any.whl"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "40937646fd421a670e5e93dd21a7aa01",
        "sha256": "f2090d098388bf8a4fad20410f76ad81db16b9d4bf8c95e6539fca6aee7aa227"
      },
      "downloads": 318,
      "filename": "opt_einsum-0.2.0-py2.py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "40937646fd421a670e5e93dd21a7aa01",
      "packagetype": "bdist_wheel",
      "python_version": "py2.py3",
      "size": 12956,
      "upload_time": "2016-07-30T22:12:39",
      "url": "https://files.pythonhosted.org/packages/0a/f4/0c6e221ea86a2cdfc5e7fd2fa99cfe0002a818112d9e066244258d7675f5/opt_einsum-0.2.0-py2.py3-none-any.whl"
    }
  ]
}