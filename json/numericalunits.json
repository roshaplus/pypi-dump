{
  "info": {
    "author": "Steven Byrnes",
    "author_email": "steven.byrnes@gmail.com",
    "bugtrack_url": "",
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Intended Audience :: Science/Research",
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 2",
      "Programming Language :: Python :: 3",
      "Topic :: Scientific/Engineering"
    ],
    "description": "=========================================================================\nnumericalunits: Units and dimensional analysis compatible with everything\n=========================================================================\n\n`Package homepage at PyPI <http://pypi.python.org/pypi/numericalunits>`_ -- \n`Source code at github <http://github.com/sbyrnes321/numericalunits>`_ -- \nWritten by `Steve Byrnes <http://sjbyrnes.com>`_\n\nThis package implements units and dimensional analysis in an unconventional \nway that has the following unique advantages:\n\n* **Compatible with everything:** Compatible with virtually any numerical \n  calculation routine, including numpy and scipy, and even including routines \n  not written in Python! That means, for example, if you have a decades-old \n  closed-source C routine for numerical integration, you can pass it a \n  quantity with units of velocity and an integration range with units of \n  time, and the final answer will magically have units of distance. This \n  extreme compatibility is possible because if the variable ``x`` represents \n  a quantity with dimensions (like \"3.3 kg\"), ``x`` is actually stored \n  internally as an ordinary floating-point number. The dimension is \n  encoded in the value as a multiplicative factor. When two numbers are \n  multiplied, their dimensions are automatically multiplied, and so on. \n\n\n* **Modular and non-intrusive:** When you input data, you say what units \n  they are in. When you display results, you say what units you want to \n  display them in. These steps are very little trouble, and in fact help you \n  create nice, self-documenting code. Other than that, you have to do nothing \n  at all to pass dimensionful quantities into and out of any already-written \n  programs or routines.\n\n* **Powerful tool for debugging:** Not *all* calculation mistakes cause \n  violations of dimensional analysis, but *most* do--for example, if you \n  accidentally multiply two lengths instead of adding them, the result will \n  have the wrong dimension. If you use this package, it will alert you to \n  these sorts of mistakes.\n\n* **Zero storage overhead**\n\n* **Zero calculation overhead**\n\nThese great features come with the disadvantage that the interface is less  \n*slick* than other unit packages. If you have a quantity with units, you \ncannot directly see what the units are. You are supposed to already know \nwhat the units are, and then the package will tell you whether you made a \nmistake. Even worse, you only get alerted to the mistake after running a \ncalculation all the way through twice.\n\nTherefore the package is *not* suggested for students exploring how units work.\nIt *is* suggested for engineering and science professionals who want to make\ntheir code more self-documenting and self-debugging.\n\nInstallation\n============\n\nYou can install from PyPI: ::\n\n    pip install numericalunits\n\nAlternatively---since it's a single module that requires no setup or \ncompilation---you can download ``numericalunits.py`` from `PyPI \n<http://pypi.python.org/pypi/numericalunits>`_ or `github \n<http://github.com/sbyrnes321/numericalunits>`_ and use it directly.\n\nUsage and examples\n==================\n\nAt the top of the code you're working on, write::\n\n    import numericalunits as nu\n    nu.reset_units()\n\nUnit errors, like trying to add a length to a mass, will not *immediately*\nannounce themselves as unit errors. Instead, you need to run the whole\ncalculation (including the ``reset_units()`` part) twice. If you get the\nsame final answers both times, then congratulations, all your calculations\nare almost guaranteed to pass dimensional analysis! If you get different\nanswers every time you run, then you made a unit error! It is up to you to\nfigure out where and what the error is.\n\nTo assign a unit to a quantity, **multiply** by the unit, e.g.\n``my_length = 100 * mm``. (In normal text you would write \"100 mm\", but\nunfortunately Python does not have \"implied multiplication\".)\n\nTo express a dimensionful quantity in a certain unit, **divide** by that unit,\ne.g. when you see ``my_length / cm``, you pronounce it \"my_length expressed\nin cm\".\n\n**Example 1:** What is 5 mL expressed in cubic nanometers?::\n\n    import numericalunits as nu\n    nu.reset_units()\n    x = 5 * nu.mL  # \"Read: x is equal to 5 milliliters\"\n    x / nu.nm**3   # \"Read: x expressed in cubic nanometers is...\" --> 5e21\n\n**Example 2:** An electron is in a 1e5 V/cm electric field. What is its\nacceleration? (Express the answer in m/s^2.) ::\n\n    import numericalunits as nu\n    nu.reset_units()\n    efield = 1e5 * (nu.V / nu.cm)\n    force = nu.e * efield # (nu.e is the elementary charge)\n    accel = force / nu.me # (nu.me is the electron mass)\n    accel / (nu.m / nu.s**2) # Answer --> 1.7588e18\n\n**Example 3:** You measured a voltage as a function of the position of dial: \n10 volts when the dial is at 1cm, 11 volts when the dial is at 2cm, etc. \netc. Interpolate from this data to get the expected voltage when the dial is \nat 41mm, and express the answer in mV. ::\n\n    import numericalunits as nu\n    nu.reset_units()\n    from numpy import array\n    from scipy.interpolate import interp1d\n    voltage_data = array([[1 * nu.cm, 10 * nu.V],\n                          [2 * nu.cm, 11 * nu.V],\n                          [3 * nu.cm, 13 * nu.V],\n                          [4 * nu.cm, 16 * nu.V],\n                          [5 * nu.cm, 18 * nu.V]])\n    f = interp1d(voltage_data[:,0], voltage_data[:,1])\n    f(41 * nu.mm) / nu.mV # Answer --> 16200\n\t\n\n**Example 4:** A unit mistake ... what is 1 cm expressed in atmospheres? ::\n\n    import numericalunits as nu\n    nu.reset_units()\n    (1 * nu.cm) / nu.atm # --> a randomly-varying number\n    # The answer randomly varies every time you run this, indicating that you\n    # are violating dimensional analysis.\n\nHow it works\n============\n\nA complete set of independent base units (meters, kilograms, seconds, \ncoulombs, kelvins) are defined as randomly-chosen positive floating-point \nnumbers. All other units and constants are defined in terms of those. In a \ndimensionally-correct calculation, the units all cancel out, so the final \nanswer is deterministic, not random. In a dimensionally-incorrect \ncalculations, there will be random factors causing a randomly-varying final \nanswer.\n\nIncluded units and constants\n============================\n\nIncludes a variety of common units, both SI and non-SI, everything from \nfrequency to magnetic flux. Also includes common physical constants like \nPlanck's constant and the speed of light. Browse the source code to see a \ncomplete list. It is very easy to add in any extra units and constants that\nwere left out.\n\nNotes\n=====\n\nNotes on implementation and use\n-------------------------------\n\n* The units should not be reset in the *middle* of a calculation. They \n  should be randomly chosen *once* at the beginning, then carried through \n  consistently. My advice on how to do that:\n  \n  * **For little, self-contained calculations, follow the examples above.** Put\n    ``reset_units()`` at the beginning of the calculation, then check for\n    dimensional errors by re-running the whole calculation (including the\n    ``reset_units()`` part). Note that if you are using ``from``-style imports,\n    like ``from numericalunits import cm``, you need to put them *after*\n    ``reset_units()`` in the code.\n\n  * **For more complicated calculations, don't use reset_units() at all.\n    Instead, check for dimensional errors by re-running the calculation in a new\n    Python session.** (By \"complicated\" I mainly mean \"involving modules\".)\n    \n    * (Why does this work? Because the first time ``numericalunits`` is imported\n      in a given Python session, ``reset_units()`` is run automatically. That\n      happens only once, so multiple modules can ``import numericalunits``, and\n      they will all share a random, but self-consistent, set of units.)\n    \n    * (If you want to check for dimensional errors but you really really don't\n      want to open a new Python session, you need to ``reset_units()`` *and*\n      reload every module that has dimensionful variables in its namespace. It's\n      not impossible, but it's annoying and error-prone.)\n\n* While debugging a program, it may be annoying to have intermediate values \n  in the calculation that randomly vary every time you run the program. In \n  this case, you can use ``reset_units('SI')`` instead of the normal \n  ``reset_units()``. This puts all dimensionful variables in standard (MKS)\n  SI units: All times are in seconds, all lengths are in meters, all forces\n  are in newtons, etc. Alternatively, ``reset_units(123)`` uses ``123`` as\n  the seed for the random-number generator. Obviously, in these modes, you\n  will *not* get any indication of dimensional-analysis errors.\n\n* There are very rare, strange cases where the final answer does not seem to \n  randomly vary even though there was a dimensional-analysis violation: For \n  example, the expression ``(1 + 1e-50 * cm / atm)`` fails dimensional \n  analysis, so if you calculate it the answer is randomly-varying. But, it is \n  only randomly varying around the 50th decimal point, so the variation is\n  hidden from view. You would not notice it as an error.\n\n* Since units are normal Python ``float``-type numbers, they follow the normal\n  casting rules. For example, ``2 * cm`` is a python ``float``, not an ``int``.\n  This is usually what you would want and expect.\n\n* You can give a dimension to complex numbers in the same way as real \n  numbers--for example ``(2.1e3 + 3.9e4j) * ohm``.\n\n* Should be compatible with any Python version 2.x or 3.x. If you find bugs,\n  please tell me by `email <http://sjbyrnes.com>`_ or \n  `github issue board <https://github.com/sbyrnes321/numericalunits/issues>`_.\n\n* If you get overflows or underflows, you can edit the unit initializations.\n  For example, the package sets the meter to a numerical value between 0.1\n  and 10. Therefore, if you're doing molecular simulation, most lengths you\n  use will be tiny numbers. You should probably set the meter instead to be\n  between, say, 1e8 and 1e10.\n\n* Some numerical routines use a default *absolute* tolerance, rather than\n  relative tolerance, to decide convergence. This can cause the calculation\n  result to randomly vary even though there is no dimensional analysis error.\n  When this happens, you should set the absolute tolerance to a value with the\n  appropriate units. Alternatively, you can scale the data before running the\n  algorithm and scale it back afterwards. Maybe this sounds like a hassle, but\n  it's actually a benefit: If your final result is very sensitive to some\n  numerical tolerance setting, then you really want to be aware of that.\n\nNotes on unit definitions\n-------------------------\n\n* For electromagnetism, all units are intended for use in SI formulas. If \n  you plug them into cgs-gaussian electromagnetism formulas, or cgs-esu \n  electromagnetism formulas, etc., you will get nonsense results.\n\n* The package does not keep track of \"radians\" as an independent unit \n  assigned a random number. The reason is that the \"radians\" factor does not \n  always neatly cancel out of formulas.\n\n* The package does not keep track of \"moles\" as an independent unit assigned \n  a random number; instead ``mol`` is just a pure number (~6e23), like you\n  would say \"dozen\"=12. That means: (1) gram/mol is exactly the same as amu,\n  and Boltzmann constant is exactly the same as the ideal gas constant, and so\n  on. (2) You should rarely need to use Avogadro's number ``NA`` -- it is just a\n  synonym of ``mol`` (``NA = mol ~ 6e23``). Here are a few examples using moles: ::\n  \n      import numericalunits as nu\n      nu.reset_units()\n      \n      # There are eight copies of a protein inside a yeast nucleus of volume\n      # 3 cubic microns. What is the concentration of the protein, in micromolar (uM)?\n      (8. / (3 * nu.um**3)) / nu.uM   # Answer --> 0.0044\n      \n      # 5 kcal / mol is how many joules?\n      (5. * nu.kcal / nu.mol) / nu.J  # Answer --> 3.47e-20\n      \n      # How many molecules are in 2.3 femtomoles?\n      2.3 * nu.fmol  # Answer --> 1.39e9\n\n* The package cannot convert temperatures between Fahrenheit, Celsius, and \n  kelvin. The reason is that these scales have different zeros, so the units \n  cannot be treated as multiplicative factors. It is, however, possible to \n  convert temperature *intervals*, via the units ``degCinterval`` (which is a \n  synonym of kelvin, ``K``) and ``degFinterval``.\n",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "http://pypi.python.org/pypi/numericalunits",
    "keywords": "units",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "numericalunits",
    "platform": "",
    "project_url": "https://pypi.org/project/numericalunits/",
    "release_url": "https://pypi.org/project/numericalunits/1.17/",
    "requires_dist": [],
    "requires_python": "",
    "summary": "A package that lets you define quantities with units, which can then be used in almost any numerical calculation in any programming language. Checks that calculations pass dimensional analysis, performs unit conversions, and defines physical constants.",
    "version": "1.17"
  },
  "releases": {
    "1.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "c850ee381fff4f49b8f25e84310979cf",
          "sha256": "ad0047603dd1bd98a08003daa4679de35b116fe8be849afb7c86c9a1606d1959"
        },
        "downloads": 2348,
        "filename": "numericalunits-1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "c850ee381fff4f49b8f25e84310979cf",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 10737,
        "upload_time": "2012-07-09T16:50:42",
        "url": "https://files.pythonhosted.org/packages/f3/2e/b349aa3e352ceb97ccb69eb3df0bbfd4b07e5225e79a24b733f53285c2e2/numericalunits-1.0.tar.gz"
      }
    ],
    "1.01": [
      {
        "comment_text": "",
        "digests": {
          "md5": "2abc6c1c37d34a714cd232cb7b68c43a",
          "sha256": "6b5fe26e7e95bb948e5a635c0a4058363c860190b2406df78ce86e79e49d7d13"
        },
        "downloads": 2785,
        "filename": "numericalunits-1.01.tar.gz",
        "has_sig": false,
        "md5_digest": "2abc6c1c37d34a714cd232cb7b68c43a",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 10919,
        "upload_time": "2012-07-09T17:53:01",
        "url": "https://files.pythonhosted.org/packages/04/52/c17fe662206d5ee59d46bf011e39d8f7bc7756d559934da60ecd9aba9abb/numericalunits-1.01.tar.gz"
      }
    ],
    "1.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "d98822a70988dbfe909a00e5db7bfa04",
          "sha256": "a5739ad23859c6c7691bfae67ec12f39cc954a90ad814006075f9356d17681b2"
        },
        "downloads": 2100,
        "filename": "numericalunits-1.1.tar.gz",
        "has_sig": false,
        "md5_digest": "d98822a70988dbfe909a00e5db7bfa04",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 10968,
        "upload_time": "2013-02-20T19:46:55",
        "url": "https://files.pythonhosted.org/packages/81/f8/87a8caffb4fd20abdecdccbaff77932f8e4adba7dd1a7b32cf167c87ca9f/numericalunits-1.1.tar.gz"
      }
    ],
    "1.11": [
      {
        "comment_text": "",
        "digests": {
          "md5": "8baeebd01e5fda9daf861e6d5c93e195",
          "sha256": "f6b885e768d0e76babf40b3188443afefe4caed2e7afb875a3472674f30808a1"
        },
        "downloads": 2147,
        "filename": "numericalunits-1.11.tar.gz",
        "has_sig": false,
        "md5_digest": "8baeebd01e5fda9daf861e6d5c93e195",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 13401,
        "upload_time": "2013-02-21T13:02:40",
        "url": "https://files.pythonhosted.org/packages/46/68/a113821b972306050e98fc267f0d8c05c06b14f18dc641f5b3ec10680e71/numericalunits-1.11.tar.gz"
      }
    ],
    "1.12": [
      {
        "comment_text": "",
        "digests": {
          "md5": "603218e2c992b02374fa713cb683691b",
          "sha256": "ee33132a3599b57f0bd34c20db537b934e015a9ffbae6375e994a780b1abd0d5"
        },
        "downloads": 1975,
        "filename": "numericalunits-1.12.tar.gz",
        "has_sig": false,
        "md5_digest": "603218e2c992b02374fa713cb683691b",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 13450,
        "upload_time": "2013-06-23T01:47:05",
        "url": "https://files.pythonhosted.org/packages/8b/ca/e8114c7e853ce9472c87748cc66f08569f879ded8ed573435be76f0f055e/numericalunits-1.12.tar.gz"
      }
    ],
    "1.13": [
      {
        "comment_text": "",
        "digests": {
          "md5": "04f5c6df1e05e1b148ca19c01c531ec9",
          "sha256": "eda0dd7276b692e3794c21f00b9cf9ce9463db16cbf1381b813856ed6e7623a9"
        },
        "downloads": 3955,
        "filename": "numericalunits-1.13.tar.gz",
        "has_sig": false,
        "md5_digest": "04f5c6df1e05e1b148ca19c01c531ec9",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 13825,
        "upload_time": "2013-08-24T13:00:41",
        "url": "https://files.pythonhosted.org/packages/cc/5f/89a468e9dec1cd1ab39d0df5f76a79961c5e70f320d1cb70507c0b817e93/numericalunits-1.13.tar.gz"
      }
    ],
    "1.14": [
      {
        "comment_text": "",
        "digests": {
          "md5": "4bca58bd03da36bc9a9ea1deb2e68e0d",
          "sha256": "ec38bc106686a1b2c05e7b0aef8a5fef44d1b0bfbeae735d41806a8efd57bc15"
        },
        "downloads": 167,
        "filename": "numericalunits-1.14.tar.gz",
        "has_sig": false,
        "md5_digest": "4bca58bd03da36bc9a9ea1deb2e68e0d",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 12164,
        "upload_time": "2016-02-20T02:31:23",
        "url": "https://files.pythonhosted.org/packages/31/5b/7c08b389c70cf7fc4a8441dfe9219ee7eb5d3c9de3b99b2389c98ba09f82/numericalunits-1.14.tar.gz"
      }
    ],
    "1.15": [
      {
        "comment_text": "",
        "digests": {
          "md5": "9b2ceb750632f4b01d428ee08005e5a5",
          "sha256": "f423030c9fd8e7781f0b326c34d37eb7294205239e160f8a7dbe29a614937bd0"
        },
        "downloads": 293,
        "filename": "numericalunits-1.15.tar.gz",
        "has_sig": false,
        "md5_digest": "9b2ceb750632f4b01d428ee08005e5a5",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 12342,
        "upload_time": "2016-07-09T19:24:30",
        "url": "https://files.pythonhosted.org/packages/3d/6d/ac71092686e162f3d13ea8f94d3b1af1d4f61b7d02b41035c16d5b5f943d/numericalunits-1.15.tar.gz"
      }
    ],
    "1.16": [
      {
        "comment_text": "",
        "digests": {
          "md5": "b7982dea415ace75b014733d19ca2a60",
          "sha256": "71ae8e236c7a223bccefffb670dca68be476dd63b7b9009641fc64099455da25"
        },
        "downloads": 331,
        "filename": "numericalunits-1.16.tar.gz",
        "has_sig": false,
        "md5_digest": "b7982dea415ace75b014733d19ca2a60",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 13092,
        "upload_time": "2016-12-26T01:54:40",
        "url": "https://files.pythonhosted.org/packages/9f/18/05d8230bf83a710f94c362a572dc1adbaa593799b23cb480f42a6d2f52cc/numericalunits-1.16.tar.gz"
      }
    ],
    "1.17": [
      {
        "comment_text": "",
        "digests": {
          "md5": "a51f6a58e719a31cf13654cff3d47727",
          "sha256": "6cc4042cb98d1acb5130766191fa810f709d98e0b6b01fc07699a4659118cb88"
        },
        "downloads": 0,
        "filename": "numericalunits-1.17-py2.py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "a51f6a58e719a31cf13654cff3d47727",
        "packagetype": "bdist_wheel",
        "python_version": "3.6",
        "size": 18041,
        "upload_time": "2017-07-23T00:58:44",
        "url": "https://files.pythonhosted.org/packages/89/2a/950938408b4eb49649802e49646c37a7caa57364e54dc2d832a71923475d/numericalunits-1.17-py2.py3-none-any.whl"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "a51f6a58e719a31cf13654cff3d47727",
        "sha256": "6cc4042cb98d1acb5130766191fa810f709d98e0b6b01fc07699a4659118cb88"
      },
      "downloads": 0,
      "filename": "numericalunits-1.17-py2.py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "a51f6a58e719a31cf13654cff3d47727",
      "packagetype": "bdist_wheel",
      "python_version": "3.6",
      "size": 18041,
      "upload_time": "2017-07-23T00:58:44",
      "url": "https://files.pythonhosted.org/packages/89/2a/950938408b4eb49649802e49646c37a7caa57364e54dc2d832a71923475d/numericalunits-1.17-py2.py3-none-any.whl"
    }
  ]
}