{
  "info": {
    "author": "Theo Breuer-Weil",
    "author_email": "theobreuerweil@gmail.com",
    "bugtrack_url": null,
    "classifiers": [],
    "description": "bnfparsing\n==========\n\nA simple BNF parser generator for Python.\n\n\nCreating parsers\n----------------\n\nIt's recommended that you subclass the ``bnfparsing.ParserBase`` class\nwhenever you create a new parser. This makes clear the purpose of the\nparser.\n\n\nUsing a grammar\n~~~~~~~~~~~~~~~\n\nCreate a new parser using string-based grammar.\n\n.. code:: python\n\n    IF_STMT = \"\"\"\n    if_stmt     := \"if\" test\n    test        := name cmp name\n    cmp         := \"==\" | \"!=\" | \">\" | \"<\"\n    name        := alpha name | alpha\n    \"\"\"\n\n    class IfStmtParser(bnfparsing.ParserBase):\n\n        def __init__(self):\n        \n            super().__init__(ignore_whitespace=True)\n            self.grammar(IF_STMT)\n            \n    p = IfStmtParser()\n    p.parse('if x == y')   \n\n\nUsing string-based rule creation\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nSubclass the ParserBase class to create a new parser. You can create\nrules with a simple BNF (Backus-Naur Form) syntax. The first argument is\nthe name of the rule, the second is the body of the rule.\n\nRules can call other rules or capture literals, in double or single\nquotes. Recursion is permitted. Use the ``ignore_whitespace`` parameter\nto instruct the parser to skip over any whitespace between tokens.\n\n.. code:: python\n\n    class IfStmtParser(bnfparsing.ParserBase):\n\n        def __init__(self):\n            \n            super().__init__(ignore_whitespace=True)\n            \n            # add rules!\n            self.new_rule('if_stmt', ' \"if\" test ')\n            self.new_rule('test', 'name cmp name')\n            self.new_rule('cmp', ' \"==\" | \"!=\" | \">\" | \"<\" ')\n            self.new_rule('name', 'alpha name | alpha')\n            \n    p = IfStmtParser()\n    p.parse('if x == y')\n\nYou can also add rules by defining customised rules when subclassing, or\nlater on. Customised rules must accept an input string as an argument.\nIf successful, the custom rule must return a tuple containing the token\nit's created and any unconsumed characters from the input string. If it\nfails, it must return ``None`` and the original input string.\n\n\nUsing functions as rules\n~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code:: python\n\n    class CaseParser(bnfparsing.ParserBase):\n\n        # create rules as part of the class definition \n        # using the rule decorator\n        \n        @bnfparsing.rule\n        def upper(self, string):\n            \"\"\" Captures any upper-case letter. \"\"\"\n            char = string[0]\n            if char.isupper():\n                return Token('upper', char), string[1:]\n            else:\n                return None, string\n\n\n    # or create them later on...\n    def lowercase(string):\n        \"\"\" Captures any lower-case letter. \"\"\"\n        char = string[0] \n        if char.islower():\n            return Token('lower', char), string[1:]\n        else:\n            return None, string\n           \n\n    p = CaseParser()\n\n    # ... as long as you add them as follows\n    p.rule_from_function('lower', lowercase)\n\n    p.parse('a')\n    p.parse('A')\n\nThis can be useful when you don't want 26 options in a row, e.g.\n``\"A\" | \"B\" | \"C\"``.\n\nAlso see ``bnfparsing.common``. This module contains some useful\nfunctions that can be dropped in as rules. Most parsers will need one or\ntwo of the common functions, which include:\n\n-  ``alpha``, ``lower`` and ``upper``\n-  ``digit``\n-  ``whitespace``\n\n\nOutputs\n-------\n\nAs seen, you can run the parser on an input string using the ``parse``\nmethod. This raises an error if the given string does not fit the rule\nset or if there are any tokens remaining - unless you call ``parse``\nwith the optional ``allow_partial`` argument.\n\nOtherwise, the parser will consume the string and return an instance of\n``bnfparsing.Token``. This the top-most node of the syntax tree; any\nchild nodes represent the components of each node.\n\nUse the ``value`` method to generate the content of each node. For the\nnodes at the base of the tree this will return the value in the node.\nFor all others, ``value`` recursively combines the values of the tokens\nbeneath it.\n\n.. code:: python\n\n    # using the example above...\n    root = p.parse('if x == y')\n\n    assert(root.value() == 'if x == y')\n\n    for t in root.iter_under():\n        print(t.token_type, ':',  t.value())\n\nLeading to...\n\n::\n\n    >>> 'literal : if'\n    >>> 'test: x == y'\n\n\nFurther work\n------------\n\n-  Expanded set of common functions?\n-  Improved whitespace handling; for example, an option that forces the\n   parser to find whitespace between each token, rather than ignore it?\n-  Improved tools for parsing token trees?",
    "docs_url": null,
    "download_url": "UNKNOWN",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "https://www.github.com/somemarspials/bnfparsing",
    "keywords": "parsing,bnf",
    "license": "GPL-3.0",
    "maintainer": null,
    "maintainer_email": null,
    "name": "bnfparsing",
    "platform": "UNKNOWN",
    "project_url": "https://pypi.org/project/bnfparsing/",
    "release_url": "https://pypi.org/project/bnfparsing/0.1.1/",
    "requires_python": null,
    "summary": "A BNF parser generator for Python",
    "version": "0.1.1"
  },
  "releases": {
    "0.1.0": [],
    "0.1.0a0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "83072b7553edc8400d75e1360fff19e1",
          "sha256": "8164ec2c48e24e1d4d314b6c4a97139c1b0baa5672e88d57c070518e5121936c"
        },
        "downloads": 0,
        "filename": "bnfparsing-0.1.0a0.tar.gz",
        "has_sig": false,
        "md5_digest": "83072b7553edc8400d75e1360fff19e1",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 8886,
        "upload_time": "2017-05-26T22:14:46",
        "url": "https://files.pythonhosted.org/packages/17/49/62b3e5f7c60178f31c9ecd449b41b0851172b6b1963f9224cdf3c02f8dc4/bnfparsing-0.1.0a0.tar.gz"
      }
    ],
    "0.1.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "82933808bdc87b15684b90b47c92d809",
          "sha256": "74910611e5acc258f3c6a7c0a9dfa529a2316cb9d5274d1dcf1987422d09603e"
        },
        "downloads": 0,
        "filename": "bnfparsing-0.1.1.tar.gz",
        "has_sig": false,
        "md5_digest": "82933808bdc87b15684b90b47c92d809",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 8959,
        "upload_time": "2017-05-27T08:30:34",
        "url": "https://files.pythonhosted.org/packages/4d/b6/47ed48d542c2ab1a7ada51dc9df153b685454ce06a7575636f31cfd0d468/bnfparsing-0.1.1.tar.gz"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "82933808bdc87b15684b90b47c92d809",
        "sha256": "74910611e5acc258f3c6a7c0a9dfa529a2316cb9d5274d1dcf1987422d09603e"
      },
      "downloads": 0,
      "filename": "bnfparsing-0.1.1.tar.gz",
      "has_sig": false,
      "md5_digest": "82933808bdc87b15684b90b47c92d809",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 8959,
      "upload_time": "2017-05-27T08:30:34",
      "url": "https://files.pythonhosted.org/packages/4d/b6/47ed48d542c2ab1a7ada51dc9df153b685454ce06a7575636f31cfd0d468/bnfparsing-0.1.1.tar.gz"
    }
  ]
}