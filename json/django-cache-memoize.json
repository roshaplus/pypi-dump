{
  "info": {
    "author": "Peter Bengtsson",
    "author_email": "mail@peterbe.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Environment :: Web Environment :: Mozilla",
      "Framework :: Django",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: MIT License",
      "License :: OSI Approved :: Mozilla Public License 2.0 (MPL 2.0)",
      "Programming Language :: Python :: 2.7",
      "Programming Language :: Python :: 3",
      "Topic :: Internet :: WWW/HTTP"
    ],
    "description": "====================\ndjango-cache-memoize\n====================\n\n.. image:: https://travis-ci.org/peterbe/django-cache-memoize.svg?branch=master\n   :alt: Build Status\n   :target: https://travis-ci.org/peterbe/django-cache-memoize\n\n.. image:: https://readthedocs.org/projects/django-cache-memoize/badge/?version=latest\n   :alt: Documentation Status\n   :target: https://django-cache-memoize.readthedocs.io/en/latest/?badge=latest\n\n.. image:: https://codecov.io/gh/peterbe/django-cache-memoize/branch/master/graph/badge.svg\n   :alt: Code Coverage\n   :target: https://codecov.io/gh/peterbe/django-cache-memoize\n\n\nDjango utility for a memoization decorator that uses the Django cache framework.\n\nKey Features\n------------\n\n* Memoized function calls can be invalidated.\n\n* Works with non-trivial arguments and keyword arguments\n\n* Insight into cache hits and cache missed with a callback.\n\n* Ability to use as a \"guard\" for repeated execution when storing the function\n  result isn't important or needed.\n\n\nInstallation\n============\n\n.. code-block:: python\n\n    pip install django-cache-memoize\n\nUsage\n=====\n\n.. code-block:: python\n\n    # Import the decorator\n    from cache_memoize import cache_memoize\n\n    # Attach decorator to cacheable function with a timeout of 100 seconds.\n    @cache_memoize(100)\n    def expensive_function(start, end):\n        return random.randint(start, end)\n\n    # Just a regular Django view\n    def myview(request):\n        # If you run this view repeatedly you'll get the same\n        # output every time for 100 seconds.\n        return http.HttpResponse(str(expensive_function(0, 100)))\n\n\nThe caching uses `Django's default cache framework`_. Ultimately, it calls\n``django.core.cache.cache.set(cache_key, function_out, expiration)``.\nSo if you have a function that returns something that can't be pickled and\ncached it won't work.\n\n    For cases like this, Django exposes a simple, low-level cache API. You can\n    use this API to store objects in the cache with any level of granularity\n    you like. You can cache any Python object that can be pickled safely:\n    strings, dictionaries, lists of model objects, and so forth. (Most\n    common Python objects can be pickled; refer to the Python documentation\n    for more information about pickling.)\n\nSee `documentation`_.\n\n\n.. _`Django's default cache framework`: https://docs.djangoproject.com/en/1.11/topics/cache/\n.. _`documentation`: https://docs.djangoproject.com/en/1.11/topics/cache/#the-low-level-cache-api\n\n\nAdvanced Usage\n==============\n\n``args_rewrite``\n~~~~~~~~~~~~~~~~\n\nInternally the decorator rewrites every argument and keyword argument to\nthe function it wraps into a concatenated string. The first thing you\nmight want to do is help the decorator rewrite the arguments to something\nmore suitable as a cache key string. For example, suppose you have instances\nof a class whose ``__str__`` method doesn't return a unique value. For example:\n\n.. code-block:: python\n\n    class Record(models.Model):\n        name = models.CharField(max_length=100)\n        lastname = models.CharField(max_length=100)\n        friends = models.ManyToManyField(SomeOtherModel)\n\n        def __str__(self):\n            return self.name\n\n    # Example use:\n    >>> record = Record.objects.create(name='Peter', lastname='Bengtsson')\n    >>> print(record)\n    Peter\n    >>> record2 = Record.objects.create(name='Peter', lastname='Different')\n    >>> print(record2)\n    Peter\n\nThis is a contrived example, but basically *you know* that the ``str()``\nconversion of certain arguments isn't safe. Then you can pass in a callable\ncalled ``args_rewrite``. It gets the same positional and keyword arguments\nas the function you're decorating. Here's an example implementation:\n\n.. code-block:: python\n\n    from cache_memoize import cache_memoize\n\n    def count_friends_args_rewrite(record):\n        # The 'id' is always unique. Use that instead of the default __str__\n        return record.id\n\n    @cache_memoize(100, args_rewrite=count_friends_args_rewrite)\n    def count_friends(record):\n        # Assume this is an expensive function that can be memoize cached.\n        return record.friends.all().count()\n\n\n``prefix``\n~~~~~~~~~~\n\nBy default the prefix becomes the name of the function. Consider:\n\n.. code-block:: python\n\n    from cache_memoize import cache_memoize\n\n    @cache_memoize(10, prefix='randomness')\n    def function1():\n        return random.random()\n\n    @cache_memoize(10, prefix='randomness')\n    def function2():  # different name, same arguments, same functionality\n        return random.random()\n\n    # Example use\n    >>> function1()\n    0.39403406043780986\n    >>> function1()\n    0.39403406043780986\n    >>> # ^ repeated of course\n    >>> function2()\n    0.39403406043780986\n    >>> # ^ because the prefix was forcibly the same, the cache key is the same\n\n\n``hit_callable``\n~~~~~~~~~~~~~~~~\n\nIf set, a function that gets called with the original argument and keyword\narguments **if** the cache was able to find and return a cache hit.\nFor example, suppose you want to tell your ``statsd`` server every time\nthere's a cache hit.\n\n.. code-block:: python\n\n    from cache_memoize import cache_memoize\n\n    def _cache_hit(user, **kwargs):\n        statsdthing.incr(f'cachehit:{user.id}', 1)\n\n    @cache_memoize(10, hit_callable=_cache_hit)\n    def calculate_tax(user, tax=0.1):\n        return ...\n\n\n``miss_callable``\n~~~~~~~~~~~~~~~~~\n\nExact same functionality as ``hit_callable`` except the obvious difference\nthat it gets called if it was *not* a cache hit.\n\n``store_result``\n~~~~~~~~~~~~~~~~\n\nThis is useful if you have a function you want to make sure only gets called\nonce per timeout expiration but you don't actually care that much about\nwhat the function return value was. Perhaps because you know that the\nfunction returns something that would quickly fill up your ``memcached`` or\nperhaps you know it returns something that can't be pickled. Then you\ncan set ``store_result`` to ``False``.\n\n.. code-block:: python\n\n    from cache_memoize import cache_memoize\n\n    @cache_memoize(1000, store_result=False)\n    def send_tax_returns(user):\n        # something something time consuming\n        ...\n        return some_none_pickleable_thing\n\n    def myview(request):\n        # View this view as much as you like the 'send_tax_returns' function\n        # won't be called more than once every 1000 seconds.\n        send_tax_returns(request.user)\n\n\nCache invalidation\n~~~~~~~~~~~~~~~~~~\n\nWhen you want to \"undo\" some caching done, you simple call the function\nagain with the same arguments except you add ``.invalidate`` to the function.\n\n.. code-block:: python\n\n    from cache_memoize import cache_memoize\n\n    @cache_memoize(10)\n    def expensive_function(start, end):\n        return random.randint(start, end)\n\n    >>> expensive_function(1, 100)\n    65\n    >>> expensive_function(1, 100)\n    65\n    >>> expensive_function(100, 200)\n    121\n    >>> exensive_function.invalidate(1, 200)\n    >>> expensive_function(1, 100)\n    89\n    >>> expensive_function(100, 200)\n    121\n\nAn \"alias\" of doing the same thing is to pass a keyword argument called\n``_refresh=True``. Like this:\n\n.. code-block:: python\n\n    # Continuing from the code block above\n    >>> expensive_function(100, 200)\n    121\n    >>> expensive_function(100, 200, _refresh=True)\n    177\n    >>> expensive_function(100, 200)\n    177\n\nThere is no way to clear more than one cache key. In the above example,\nyou had to know the \"original arguments\" when you wanted to invalidate\nthe cache. There is no method \"search\" for all cache keys that match a\ncertain pattern.\n\n\nCompatibility\n=============\n\n* Python 2.7, 3.4, 3.5, 3.6\n\n* Django 1.8, 1.9, 1.10, 1.11\n\nCheck out the `tox.ini`_ file for more up-to-date compatibility by\ntest coverage.\n\n.. _`tox.ini`: https://github.com/peterbe/django-cache-memoize/blob/master/tox.ini\n\nPrior Art\n=========\n\nHistory\n~~~~~~~\n\n`Mozilla Symbol Server`_ is written in Django. It's a web service that\nsits between C++ debuggers and AWS S3. It shuffles symbol files in and out of\nAWS S3. Symbol files are for C++ (and other compiled languages) what\nsourcemaps are for JavaScript.\n\nThis service gets a LOT of traffic. The download traffic (proxying requests\nfor symbols in S3) gets about ~40 requests per second. Due to the nature\nof the application most of these GETs result in a 404 Not Found but instead\nof asking AWS S3 for every single file, these lookups are cached in a\nhighly configured `Redis`_ configuration. This Redis cache is also connected\nto the part of the code that uploads new files.\n\nNew uploads are arriving as zip file bundles of files, from Mozilla's build\nsystems, at a rate of about 600MB every minute, each containing on average\nabout 100 files each. When a new upload comes in we need to quickly be able\nfind out if it exists in S3 and this gets cached since often the same files\nare repeated in different uploads. But when a file does get uploaded into S3\nwe need to quickly and confidently invalidate any local caches. That way you\nget to keep a really aggressive cache without any stale periods.\n\nThis is the use case ``django-cache-memoize`` was built for and tested in.\nIt was originally written for Python 3.6 in Django 1.11 but when\nextracted, made compatible with Python 2.7 and as far back as Django 1.8.\n\n``django-cache-memoize`` is also used in `SongSear.ch`_ to cache short\nqueries in the autocomplete search input. All autocomplete is done by\nElasticsearch, which is amazingly fast, but not as fast as ``memcached``.\n\n\n.. _`Mozilla Symbol Server`: https://symbols.mozilla.org\n.. _`Redis`: https://redis.io/\n.. _`SongSear.ch`: https://songsear.ch\n\n\n\"Competition\"\n~~~~~~~~~~~~~\n\nThere is already `django-memoize`_ by `Thomas Vavrys`_.\nIt too is available as a memoization decorator you use in Django. And it\nuses the default cache framework as a storage. It used ``inspect`` on the\ndecorated function to build a cache key.\n\nIn benchmarks running both ``django-memoize`` and ``django-cache-memoize``\nI found ``django-cache-memoize`` to be **~4 times faster** on average.\n\nAnother key difference is that ``django-cache-memoize`` uses ``str()`` and\n``django-memoize`` uses ``repr()`` which in certain cases of mutable objects\n(e.g. class instances) as arguments the caching will not work. For example,\nthis does *not* work in ``django-memoize``:\n\n.. code-block:: python\n\n    from memoize import memoize\n\n    @memoize(60)\n    def count_user_groups(user):\n        return user.groups.all().count()\n\n    def myview(request):\n        # this will never be memoized\n        print(count_user_groups(request.user))\n\nHowever, this works...\n\n.. code-block:: python\n\n    from cache_memoize import cache_memoize\n\n    @cache_memoize(60)\n    def count_user_groups(user):\n        return user.groups.all().count()\n\n    def myview(request):\n        # this *will* work as expected\n        print(count_user_groups(request.user))\n\n\n.. _`django-memoize`: http://pythonhosted.org/django-memoize/\n.. _`Thomas Vavrys`: https://github.com/tvavrys\n\n\n",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "https://github.com/peterbe/django-cache-memoize",
    "keywords": "django,memoize,cache,decorator",
    "license": "MPL 2.0",
    "maintainer": "",
    "maintainer_email": "",
    "name": "django-cache-memoize",
    "platform": "",
    "project_url": "https://pypi.org/project/django-cache-memoize/",
    "release_url": "https://pypi.org/project/django-cache-memoize/0.1.1/",
    "requires_dist": [],
    "requires_python": "",
    "summary": "Django utility for a memoization decorator that uses the Django cache framework.",
    "version": "0.1.1"
  },
  "releases": {
    "0.1.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "4760496227c7a6f09268b682622abb0b",
          "sha256": "782b1b0b61c4639d1c10cfcaf6aa2c8a5f56229a0f59d67cde82c3c684842c63"
        },
        "downloads": -1,
        "filename": "django_cache_memoize-0.1.0-py2.py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "4760496227c7a6f09268b682622abb0b",
        "packagetype": "bdist_wheel",
        "python_version": "py2.py3",
        "size": 10034,
        "upload_time": "2017-10-27T19:55:01",
        "url": "https://files.pythonhosted.org/packages/86/d2/ddf6d04bf1c8c36c02c49d445fd254ec52badb6cff6e97165bb3a44ba008/django_cache_memoize-0.1.0-py2.py3-none-any.whl"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "ed7b1466c6b1c6b9e210bb2a4232819b",
          "sha256": "b4b3e6a319bd9357e6d4e44d528eac31c9d22b3ddb410d50c56ce71200def058"
        },
        "downloads": -1,
        "filename": "django-cache-memoize-0.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "ed7b1466c6b1c6b9e210bb2a4232819b",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 7256,
        "upload_time": "2017-10-27T19:55:03",
        "url": "https://files.pythonhosted.org/packages/7b/65/c2137f993b2a50366dcef1bdc420c51df1cddb049a7889944b356c77095f/django-cache-memoize-0.1.0.tar.gz"
      }
    ],
    "0.1.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "d32667691b122953f9114518ace0c017",
          "sha256": "12c3359b7f48bf34db739732eae66d9f4b6103093382fa5723774d10be4c352f"
        },
        "downloads": -1,
        "filename": "django_cache_memoize-0.1.1-py2.py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "d32667691b122953f9114518ace0c017",
        "packagetype": "bdist_wheel",
        "python_version": "py2.py3",
        "size": 11691,
        "upload_time": "2017-10-27T20:21:41",
        "url": "https://files.pythonhosted.org/packages/58/76/9e05e2cb0d647a4c0f5ddee112645cc43390972d29c047721141c4d3b40f/django_cache_memoize-0.1.1-py2.py3-none-any.whl"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "033ca668784754865e3caa8e20bc6445",
          "sha256": "e04b84b18430dd75a62da6a367b64042bbac8def8aa765d32d6eb74bc3423580"
        },
        "downloads": -1,
        "filename": "django-cache-memoize-0.1.1.tar.gz",
        "has_sig": false,
        "md5_digest": "033ca668784754865e3caa8e20bc6445",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 8543,
        "upload_time": "2017-10-27T20:21:43",
        "url": "https://files.pythonhosted.org/packages/4d/59/9c3b44b909d8ad6a1374801b081f3478dcdf7968013c445f698793270278/django-cache-memoize-0.1.1.tar.gz"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "d32667691b122953f9114518ace0c017",
        "sha256": "12c3359b7f48bf34db739732eae66d9f4b6103093382fa5723774d10be4c352f"
      },
      "downloads": -1,
      "filename": "django_cache_memoize-0.1.1-py2.py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "d32667691b122953f9114518ace0c017",
      "packagetype": "bdist_wheel",
      "python_version": "py2.py3",
      "size": 11691,
      "upload_time": "2017-10-27T20:21:41",
      "url": "https://files.pythonhosted.org/packages/58/76/9e05e2cb0d647a4c0f5ddee112645cc43390972d29c047721141c4d3b40f/django_cache_memoize-0.1.1-py2.py3-none-any.whl"
    },
    {
      "comment_text": "",
      "digests": {
        "md5": "033ca668784754865e3caa8e20bc6445",
        "sha256": "e04b84b18430dd75a62da6a367b64042bbac8def8aa765d32d6eb74bc3423580"
      },
      "downloads": -1,
      "filename": "django-cache-memoize-0.1.1.tar.gz",
      "has_sig": false,
      "md5_digest": "033ca668784754865e3caa8e20bc6445",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 8543,
      "upload_time": "2017-10-27T20:21:43",
      "url": "https://files.pythonhosted.org/packages/4d/59/9c3b44b909d8ad6a1374801b081f3478dcdf7968013c445f698793270278/django-cache-memoize-0.1.1.tar.gz"
    }
  ]
}