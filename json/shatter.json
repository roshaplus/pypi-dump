{
  "info": {
    "author": "Juan Pablo Isaza",
    "author_email": "biosolardecolombia@gmail.com",
    "bugtrack_url": null,
    "classifiers": [],
    "description": "\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\nDescription: Shatter\n        =======\n        \n        Data driven programming; input data and output nice functional code ;)\n        \n        Introduction\n        ============\n        \n        This is a `python 3.6+ project <https://pypi.python.org/pypi/shatter>`__\n        that uses algorithms to transform a set of conditions into functional\n        python code. See some\n        `examples <https://github.com/jisazaTappsi/shatter/tree/master/examples>`__.\n        \n        Package Setup\n        -------------\n        \n        Install:\n        \n        ::\n        \n                $ pip install shatter\n        \n        Dependencies\n        ------------\n        \n        ::\n        \n            pyeda==0.28.0\n            pandas==0.19.1\n            sympy==1.1\n            Keras==2.0.6\n            pypandoc==1.2.0\n            numpy==1.13.1\n            pip==9.0.1\n            setuptools==36.0.1\n            scikit_learn==0.19.0\n        \n        Examples\n        ========\n        \n        Get Started\n        -----------\n        \n        Copy paste this snippet:\n        \n        ::\n        \n            from shatter.solver import Rules\n        \n        \n            def my_func(a, b):\n                pass\n        \n            r = Rules(a=True, b=True, output=True)\n            r.solve(my_func)\n        \n        Run it and see how ``my_func`` code changes from ``pass`` to\n        ``return a and b``. We just specified that when ``a`` and ``b`` are true\n        then the output should be ``True``, that is equivalent to the logical\n        ``and`` operator.\n        \n        We can add further conditions and ``shatter`` will compute the optimal\n        function to get there.\n        \n        Adding more conditions\n        ----------------------\n        \n        Now we add 2 additional conditions with ``r.add()``:\n        \n        ::\n        \n            from shatter.solver import Rules\n        \n        \n            def my_func(a, b):\n                pass\n        \n        \n            r = Rules(a=True, b=True, output=True)\n            r.add(a=False, b=True, output=True)\n            r.add(a=True, b=False, output=True)\n            r.solve(my_func)\n        \n        In this case the solution is ``a or b``.\n        \n        If conditionals\n        ---------------\n        \n        What if the output for a given logical condition is not a boolean? In\n        that case a programmer would use an if. In the next example this package\n        solves this case:\n        \n        Change output to ``1``:\n        \n        ::\n        \n            from shatter.solver import Rules\n        \n        \n            def my_func(a, b):\n                pass\n        \n            r = Rules(a=True, b=True, output=1)\n            r.solve(my_func)\n        \n        The solution will be:\n        \n        ::\n        \n            def my_func(a, b):\n        \n                if a and b:\n                    return 1\n        \n                return False\n        \n        Returns ``1`` or ``False`` otherwise.\n        \n        Adding pieces of code\n        ---------------------\n        \n        Say you want to add a arbitrary piece of code that evaluates to boolean,\n        then:\n        \n        ::\n        \n            from shatter.solver import Rules, Code\n        \n        \n            def any_code(a):\n                pass\n        \n            r = Rules(condition=Code(code_str='isinstance(a, str)'), output=2)\n            r.solve(any_code)\n        \n        The result should be:\n        \n        ::\n        \n            def internal_code(a):\n        \n                if isinstance(a, str):\n                    return 2\n        \n                return False\n        \n        Here the piece of code ``isinstance(a, str)`` was added as the if\n        condition to output ``2``\n        \n        Iteration\n        ---------\n        \n        Run this code:\n        \n        ::\n        \n            from shatter.solver import Rules, Code, Output\n        \n        \n            def recursive(a):\n                pass\n        \n            a = Code()\n            args = {'a': a + 1}\n            out = Output(function=recursive, arguments=args)\n        \n            r = Rules(stopping_condition=  a > 2, output=a, default=out)\n            solution = r.solve(recursive)\n        \n        The result this time will be a recursive counting function :)\n        \n        ::\n        \n            def recursive(a):\n        \n                if a > 2:\n                    return a\n        \n                return recursive(a + 1)\n        \n        With ``a = Code()`` variable ``a`` is initialized as a code piece. Then\n        with\n        \n        ::\n        \n            args = {'a': a + 1}\n        \n        A dictionary for the inputs of the ``recursive`` function is declared.\n        Those inputs are fed into a ``Output`` object:\n        \n        ::\n        \n            out = Output(function=recursive, arguments=args)\n        \n        After ``out`` is passed via ``default`` keyword when initializing the\n        ``Rules`` object. This ``default`` keyword is used to override the last\n        return statement of the ``recursive`` function.\n        \n        Going deeper\n        ============\n        \n        Setup\n        -----\n        \n        Clone repository:\n        \n        ::\n        \n            `git clone git@github.com:jisazaTappsi/shatter.git`\n        \n        More examples\n        -------------\n        \n        See\n        `examples <https://github.com/jisazaTappsi/shatter/tree/master/examples>`__.\n        \n        How does shatter work?\n        ----------------------\n        \n        Takes a function and a truth table which is processed using the\n        `Quine-McCluskey\n        Algorithm <https://en.wikipedia.org/wiki/Quine%E2%80%93McCluskey_algorithm>`__.\n        Then finds an optimal boolean expression. This expression is inserted in\n        the method definition.\n        \n        Rules Class\n        ===========\n        \n        Is initialized with one rule. Other rules can be added with\n        ``Rules.add()`` method. To generate the solution call ``Rules.solve()``\n        method.\n        \n        Each rule\n        ---------\n        \n        The arguments of each rule are specified as optional arguments inside a\n        ``Rules`` constructor or inside a ``Rules.add()`` call. There are\n        reserved keywords:\n        \n        ``output``: Determines the value to be returned when the given condition\n        is True.\n        \n        ``output_args``: Dictionary with the values for the arguments when\n        output is a function.\n        \n        ``default``: Value returned when non of the rules are True.\n        \n        Arguments of ``Rules.solve()``\n        ------------------------------\n        \n        -  ``function``: passed as a callable. This function is going to be\n           filled with the solution to the present task.\n        \n        -  ``unittest=None``: Test Case to be able to run and test the code\n           generated each time the test runs. See\n           `example <https://github.com/jisazaTappsi/shatter/tree/master/examples/with_tests>`__\n           for a deeper understanding.\n        \n        Output Class\n        ------------\n        \n        ``solver.Output``: Class that helps define a function with arguments as\n        an output. Has fields:\n        \n        -  ``function``: A callable object.\n        -  ``arguments`` Dictionary with the function inputs.\n        \n        Code class\n        ----------\n        \n        ``solver.Code``: Class that helps represent pieces of code. The code is\n        fed as a string (with optional argument ``str_code``) or it can be\n        declared as variables. eg:\n        \n        ::\n        \n            from shatter.solver import Code\n        \n            a = Code()\n            b = Code()\n            print(a > b)\n        \n        This will literally print the code ``a > b`` rather than the objects or\n        any result.\n        \n        Solution class\n        --------------\n        \n        ``solver.Solution``: Class that contains the solution of the problem it\n        includes:\n        \n        -  ``rules``: The information given by the user.\n        -  ``implementation``: Plain code.\n        -  ``ast``: Abstract syntax tree\n        \nKeywords: Quine McCluskey,Machine Learning,code,automatic code generation,expression\nPlatform: UNKNOWN\nClassifier: Development Status :: 3 - Alpha\nClassifier: License :: OSI Approved :: MIT License\nClassifier: Programming Language :: Python :: 3.6\nClassifier: Intended Audience :: Developers\nClassifier: Topic :: Software Development :: Build Tools\n",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "https://github.com/jisazaTappsi/shatter",
    "keywords": "",
    "license": "Copyright (c) 2017 Juan Pablo Isaza",
    "maintainer": "",
    "maintainer_email": "",
    "name": "shatter",
    "platform": "",
    "project_url": "https://pypi.org/project/shatter/",
    "release_url": "https://pypi.org/project/shatter/0.6.0/",
    "requires_dist": [
      "sympy (==1.1)",
      "setuptools (==36.0.1)",
      "scikit-learn (==0.19.0)",
      "pypandoc (==1.2.0)",
      "pyeda (==0.28.0)",
      "pip (==9.0.1)",
      "pandas (==0.19.1)",
      "numpy (==1.13.1)",
      "Keras (==2.0.6)"
    ],
    "requires_python": "",
    "summary": "Data Driven Programming",
    "version": "0.6.0"
  },
  "releases": {
    "0.5.3": [
      {
        "comment_text": "",
        "digests": {
          "md5": "eedef73ac5745c51b9f631fb6409e707",
          "sha256": "34decea2d930ac4304d2de307091989043f3edd64208e9449146b6f032b283fb"
        },
        "downloads": 8,
        "filename": "shatter-0.5.3-py2-none-any.whl",
        "has_sig": false,
        "md5_digest": "eedef73ac5745c51b9f631fb6409e707",
        "packagetype": "bdist_wheel",
        "python_version": "py2",
        "size": 60046,
        "upload_time": "2017-02-10T05:10:35",
        "url": "https://files.pythonhosted.org/packages/83/13/a55abb600b4990bda4051c3c6111945affd0bb6651e50fae59e820bd4026/shatter-0.5.3-py2-none-any.whl"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "cc284ef4b4469a931160d45b6101e4ac",
          "sha256": "4d0ef43721319761816dc9058e6872141e22022e7ac832cb9b3c883c517dd028"
        },
        "downloads": 9,
        "filename": "shatter-0.5.3.tar.gz",
        "has_sig": false,
        "md5_digest": "cc284ef4b4469a931160d45b6101e4ac",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 42301,
        "upload_time": "2017-02-10T05:10:37",
        "url": "https://files.pythonhosted.org/packages/9a/04/a812bfb72b2b6281b0c30aa1e039f1d35d135cad7c9e71b3746fa827f9e8/shatter-0.5.3.tar.gz"
      }
    ],
    "0.6.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "9efbfd725e2f15cb9bae96eb9f948b9e",
          "sha256": "ba7aa444895002621752b45119e9a97297aa82ed61a9174ecf9acc145077d7be"
        },
        "downloads": 0,
        "filename": "shatter-0.6.0-py2-none-any.whl",
        "has_sig": false,
        "md5_digest": "9efbfd725e2f15cb9bae96eb9f948b9e",
        "packagetype": "bdist_wheel",
        "python_version": "py2",
        "size": 76316,
        "upload_time": "2017-09-26T03:19:41",
        "url": "https://files.pythonhosted.org/packages/d9/01/6056ceec359f1970958cc14d107dfafc6b945f343896fd76e3b85e5b17b8/shatter-0.6.0-py2-none-any.whl"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "f0a1d25ab41570f38265761ff77c4b8e",
          "sha256": "35b25792c1a086634050074258e0e83892afb365054bf939fadb089353bbdb55"
        },
        "downloads": 0,
        "filename": "shatter-0.6.0.tar.gz",
        "has_sig": false,
        "md5_digest": "f0a1d25ab41570f38265761ff77c4b8e",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 54139,
        "upload_time": "2017-09-26T03:19:43",
        "url": "https://files.pythonhosted.org/packages/d3/d4/e3aa31be822a54a20493b6447609ff5f953f9b506ff0cdf303f031545dbe/shatter-0.6.0.tar.gz"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "9efbfd725e2f15cb9bae96eb9f948b9e",
        "sha256": "ba7aa444895002621752b45119e9a97297aa82ed61a9174ecf9acc145077d7be"
      },
      "downloads": 0,
      "filename": "shatter-0.6.0-py2-none-any.whl",
      "has_sig": false,
      "md5_digest": "9efbfd725e2f15cb9bae96eb9f948b9e",
      "packagetype": "bdist_wheel",
      "python_version": "py2",
      "size": 76316,
      "upload_time": "2017-09-26T03:19:41",
      "url": "https://files.pythonhosted.org/packages/d9/01/6056ceec359f1970958cc14d107dfafc6b945f343896fd76e3b85e5b17b8/shatter-0.6.0-py2-none-any.whl"
    },
    {
      "comment_text": "",
      "digests": {
        "md5": "f0a1d25ab41570f38265761ff77c4b8e",
        "sha256": "35b25792c1a086634050074258e0e83892afb365054bf939fadb089353bbdb55"
      },
      "downloads": 0,
      "filename": "shatter-0.6.0.tar.gz",
      "has_sig": false,
      "md5_digest": "f0a1d25ab41570f38265761ff77c4b8e",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 54139,
      "upload_time": "2017-09-26T03:19:43",
      "url": "https://files.pythonhosted.org/packages/d3/d4/e3aa31be822a54a20493b6447609ff5f953f9b506ff0cdf303f031545dbe/shatter-0.6.0.tar.gz"
    }
  ]
}