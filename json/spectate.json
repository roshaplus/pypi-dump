{
  "info": {
    "author": "Ryan Morshead",
    "author_email": "ryan.morshead@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Intended Audience :: Developers",
      "Intended Audience :: Science/Research",
      "Programming Language :: Python",
      "Programming Language :: Python :: 2.7",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.3"
    ],
    "description": ".. image:: https://travis-ci.org/rmorshea/spectate.svg?branch=master\n    :target: https://travis-ci.org/rmorshea/spectate\n\n========\nSpectate\n========\nCreate classes whose instances have tracked methods\n\nInstalation\n-----------\n``spectate`` can be installed from GitHub using ``pip``:\n\n.. code:: text\n    \n    $ pip install git+https://github.com/rmorshea/spectate.git#egg=spectate\n\nBasic Usage\n-----------\n``spectate`` is useful for remotely tracking how an instance is modified. This means that protocols\nfor managing updates, don't need to be the outward responsibility of a user, and can instead be\ndone automagically in the background.\n\nFor example, if it were desirable to keep track of element changes in a list, ``spectate`` could be\nused to observe ``list.__setitiem__`` in order to be notified when a user sets the value of an element\nin the list. To do this, we would first create an ``elist`` type using ``expose_as``, construct an\ninstance of that type, and then store callback pairs to that instance's spectator. To access a spectator,\nregister one with ``watch`` (e.g. ``spectator = watch(the_elist)``), retrieve a preexisting one with the\n``watcher`` function. Callback pairs are stored by calling the ``watcher(the_list).callback`` method. You\ncan then specify, with keywords, whether the callback should be triggered ``before``, and/or or ``after``\na given method is called - hereafter refered to as \"beforebacks\" and \"afterbacks\" respectively.\n\nBeforebacks\n-----------\n\n+ Have a signature of ``(instance, call)``\n\n    +   ``instance`` is the owner of the method\n    +   ``call`` is a ``Bunch`` with the keys:\n\n        + ``'name'`` - the name of the method which was called\n        + ``'args'`` - the arguments which that method will call\n        + ``'kwargs'`` - the keywords which that method will call\n\n+   Can ``return`` a value which gets passed on to its respective afterback.\n\nAfterbacks\n----------\n\n+   Have a signature of ``(instance, answer)``\n\n    +   ``instance`` is the owner of the method\n    +   ``answer`` is a ``Bunch`` with the keys:\n\n        +   ``'name'`` - the name of the method which was called\n        +   ``'value'`` - the value returned by the method\n        +   ``'before'`` - the value returned by the respective beforeback\n\n+ Should not ``return``\n\nExample\n-------\n\n.. code-block:: python\n\n    from spectate import expose_as\n\n    elist = expose_as('elist', list, '__setitem__')\n\n    def pass_on_old_value(inst, call):\n        \"\"\"The beforeback\"\"\"\n        index = call.args[0]\n        old = inst[index]\n        return index, old\n\n    def print_element_change(inst, answer):\n        \"\"\"The afterback\"\"\"\n        # answer.before = pass_on_old_value(call)\n        index, old = answer.before\n        new = inst[index]\n        if new != old:\n            print(\"{%s: %s} -> {%s: %s}\" %\n                (index, old, index, new))\n\n``pass_on_old_value`` simply pulls the old value stored at the given index, and then passes\nthat value and the index on to its afterback. The afterback then checks to see if the value\nwhich is `now` stored at that index, is equal to the value which `was` stored there. If it is,\nnothing happens, however if it isn't, the change gets printed.\n\nInstances of ``EventfulList`` will behave exactly like a ``list`` in every way. The only\ndifference being that when a user decides to change the value of a preexisting element, the\nspectator is notified, and will print once the action is complete:\n\n.. code-block:: python\n    # if a WatchableType is passed to watch, any following\n    # arguments are passed to it constructor. Thus a new\n    # instance is returned along with its spectator\n    elist, spectator = watch(elist, [1, 2, 3])\n\n    spectator.callback('__setitem__',\n        before=pass_on_old_value,\n        after=print_element_change)\n\n    elist[0] = 0\n\nPrints ``{0: 1} -> {0: 0}``\n\nUnder The Hood\n--------------\nMethods are tracked by using ``expose`` or (``expose_as``) to create a new class with ``MethodSpectator``\ndescriptors in the place of specified methods. Then, a user will create a ``Spectator`` using ``watch``\nwhich is stored on the instance under the attribute ``_instance_spectator``. When a ``MethodSpectator``\nis accessed through an instance, the descriptor will return a wrapper that will redirect to\n``Spectator.wrapper``, which triggers the beforebacks and afterbacks registered to the instance.\n",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "https://github.com/rmorshea/dstruct",
    "keywords": "spectate",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "spectate",
    "platform": "Linux",
    "project_url": "https://pypi.org/project/spectate/",
    "release_url": "https://pypi.org/project/spectate/0.0.1/",
    "requires_dist": [],
    "requires_python": "",
    "summary": "Create classes whose instances have tracked methods",
    "version": "0.0.1"
  },
  "releases": {
    "0.0.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "894e849e63798cd9d67aa6550e6f71e6",
          "sha256": "b75c354439509f00e6253af197e435176761370933a2e259dc59310de76d73f3"
        },
        "downloads": 0,
        "filename": "spectate-0.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "894e849e63798cd9d67aa6550e6f71e6",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 9319,
        "upload_time": "2017-08-14T06:49:14",
        "url": "https://files.pythonhosted.org/packages/87/0e/3ed7262525c1356c6bb8ff91519c592e949040c46984d054ce5463429fbd/spectate-0.0.1.tar.gz"
      }
    ],
    "0.0.1.dev0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "a30b18318269c5726387f13814c02a7e",
          "sha256": "f16296468dadbe458b9e75fa6c4a7bc87b2c9c25f6b9a1ee935340b3d3ac9105"
        },
        "downloads": 0,
        "filename": "spectate-0.0.1.dev0.tar.gz",
        "has_sig": false,
        "md5_digest": "a30b18318269c5726387f13814c02a7e",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 9324,
        "upload_time": "2017-08-14T07:39:39",
        "url": "https://files.pythonhosted.org/packages/6d/65/c25eda8c5b5f7b28fadf03b4e37ee24c693a044117598222c1705d0d7154/spectate-0.0.1.dev0.tar.gz"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "894e849e63798cd9d67aa6550e6f71e6",
        "sha256": "b75c354439509f00e6253af197e435176761370933a2e259dc59310de76d73f3"
      },
      "downloads": 0,
      "filename": "spectate-0.0.1.tar.gz",
      "has_sig": false,
      "md5_digest": "894e849e63798cd9d67aa6550e6f71e6",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 9319,
      "upload_time": "2017-08-14T06:49:14",
      "url": "https://files.pythonhosted.org/packages/87/0e/3ed7262525c1356c6bb8ff91519c592e949040c46984d054ce5463429fbd/spectate-0.0.1.tar.gz"
    }
  ]
}