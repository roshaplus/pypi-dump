{
  "info": {
    "author": "Guillaume Paulet",
    "author_email": "guillaume.paulet@giome.fr",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 3 - Alpha",
      "Intended Audience :: Developers",
      "License :: Public Domain",
      "Natural Language :: English",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3 :: Only",
      "Topic :: Software Development :: Libraries :: Python Modules"
    ],
    "description": ".. image:: https://raw.githubusercontent.com/ducdetronquito/scalpl/master/scalpl.png\n    :target: https://github.com/ducdetronquito/scalpl\n\nScalpl\n======\n\n.. image:: https://img.shields.io/badge/license-public%20domain-ff69b4.svg\n    :target: https://github.com/ducdetronquito/scalpl#license\n\n.. image:: https://img.shields.io/badge/coverage-100%25-green.svg\n    :target: #\n\n.. image:: https://img.shields.io/badge/pypi-v0.2.3-blue.svg\n    :target: https://pypi.python.org/pypi/scalpl/\n\n\n\n**Scalpl** provides a **lightweight wrapper** that helps you to operate\non **nested dictionaries** seamlessly **through the built-in** ``dict``\n**API**, by using dot-separated string keys.\n\nIt's not a drop-in replacement for your dictionnaries, just syntactic\nsugar to avoid ``this['annoying']['kind']['of']['things']`` and\n``prefer['a.different.approach']``.\n\nNo conversion cost, a thin computation overhead: that's **Scalpl** in a\nnutshell.\n\nBenefits\n~~~~~~~~\nThere are a lot of good libraries to operate on nested dictionaries,\nsuch as `Addict <https://github.com/mewwts/addict>`_ or \n`Box <https://github.com/cdgriffith/Box>`_ , but if you give **Scalpl**\na try, you will find it:\n\n* \u26a1 Fast\n* \ud83d\ude80 Powerful as the standard dict API\n* \ud83d\udc4c Well tested\n\nInstallation\n~~~~~~~~~~~~\n\n**Scalpl** is a Python3-only module that you can install via ``pip``\n\n.. code:: sh\n\n    pip3 install scalpl\n\nUsage\n~~~~~\n\n**Scalpl** provides two classes that can wrap around your dictionaries:\n\n-  **LightCut**: a wrapper that handles operations on nested ``dict``.\n-  **Cut**: a wrapper that handles operations on nested ``dict`` and\n   that can cut accross ``list`` item.\n\nUsually, you will only need to use the ``Cut``\u00a0wrapper, but if you do\nnot need to operate through lists, you should work with the ``LightCut``\nwrapper as its computation overhead is a bit smaller.\n\nThese two wrappers strictly follow the standard ``dict``\n`API <https://docs.python.org/3/library/stdtypes.html#dict>`__, that\nmeans you can operate seamlessly on ``dict``,\n``collections.defaultdict`` or ``collections.OrderedDict``.\n\nLet's see what it looks like with a toy dictionary ! \ud83d\udc47\n\n.. code:: python\n\n    from scalpl import Cut\n\n    data = {\n        'pokemons': [\n            {\n                'name': 'Bulbasaur',\n                'type': ['Grass', 'Poison'],\n                'category': 'Seed',\n                'ability': 'Overgrow'\n            },\n            {   \n                'name': 'Charmander',\n                'type': 'Fire',\n                'category': 'Lizard',\n                'ability': 'Blaze',\n            },\n            {\n                'name': 'Squirtle',\n                'type': 'Water',\n                'category': 'Tiny Turtle',\n                'ability': 'Torrent',\n            }\n        ],\n        'trainers': [\n            {\n                'name': 'Ash',\n                'hometown': 'Pallet Town'\n            }\n        ]\n    }\n    # Just wrap your data, and you're ready to go deeper !\n    proxy = Cut(data)\n\nYou can use the built-in ``dict`` API to access its values.\n\n.. code:: python\n\n    proxy['pokemons[0].name']\n    # 'Bulbasaur'\n    proxy.get('pokemons[1].sex', 'Unknown')\n    # 'Unknown'\n    'trainers[0].hometown' in proxy\n    # True\n\nBy default, **Scalpl** uses dot as a key separator, but you are free to\nuse a different character that better suits your needs.\n\n.. code:: python\n\n    # You just have to provide one when you wrap your data.\n    proxy = Cut(data, sep='->')\n    # Yarrr!\n    proxy['pokemons[0]->name']\n\nYou can also easily create or update any key/value pair.\n\n.. code:: python\n\n    proxy['pokemons[1].weaknesses'] = ['Ground', 'Rock', 'Water']\n    proxy['pokemons[1].weaknesses']\n    # ['Ground', 'Rock', 'Water']\n    proxy.setdefault('pokemons[2].ability', 'Torrent')\n    # 'Torrent'\n    proxy.update({\n        'trainers[0].region': 'Kanto',\n    })\n\nAnd it is still possible to iterate over your data.\n\n.. code:: python\n\n    proxy.items()\n    # [('pokemons', [...]), ('trainers', [...])]\n    proxy.keys()\n    # ['pokemons', 'trainers']\n    proxy.values()\n    # [[...], [...]]\n\nBy the way, if you have to operate on a list of dictionaries, the\n``Cut.all`` method is what you are looking for.\n\n.. code:: python\n\n    pokemons = proxy['pokemons']\n    # Let's teach these pokemons some sick moves !\n    for pokemon in Cut.all(pokemons):\n        pokemon['moves.Scratch.power'] = 40\n\nAlso, you can remove a specific or an arbitrary key/value pair.\n\n.. code:: python\n\n    proxy.pop('pokemons[0].category')\n    # 'Seed'\n    proxy.popitem()\n    # ('trainers', [...])\n    del proxy['pokemons[1].type']\n\nBecause **Scalpl** is only a wrapper around your data, it means you can\nget it back at will without any conversion cost. If you use an external\nAPI that operates on dictionary, it will just work.\n\n.. code:: python\n\n    import json\n    json.dumps(proxy.data)\n    # \"{'pokemons': [...]}\"\n\nFinally, you can retrieve a shallow copy of the inner dictionary or\nremove all keys.\n\n.. code:: python\n\n    shallow_copy = proxy.copy()\n\n    proxy.clear()\n\nLicense\n~~~~~~~\n\n**Scalpl** is released into the **Public Domain**. \ud83c\udf89\n\nPs: If we meet some day, and you think this small stuff worths it, you\ncan give me a beer, a coffee or a high-five in return: I would be really\nhappy to share a moment with you ! \ud83c\udf7b\n\n\n",
    "docs_url": null,
    "download_url": "https://github.com/ducdetronquito/scalpl/archive/0.2.0.tar.gz",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "https://github.com/ducdetronquito/scalpl",
    "keywords": "dict,nested,proxy,traversable,dictionary,box,addict,munch,scalpl,scalpel,wrapper",
    "license": "Public Domain",
    "maintainer": "",
    "maintainer_email": "",
    "name": "scalpl",
    "platform": "",
    "project_url": "https://pypi.org/project/scalpl/",
    "release_url": "https://pypi.org/project/scalpl/0.2.3/",
    "requires_python": "",
    "summary": "A lightweight wrapper to operate on nested dictionaries seamlessly.",
    "version": "0.2.3"
  },
  "releases": {
    "0.2.3": [
      {
        "comment_text": "",
        "digests": {
          "md5": "3e555773ed09cde5b860c4061b036240",
          "sha256": "0316bfcd3b72d7bfcfce05ce9d2a8687c6b04afeb222979c09e5874c60ff0269"
        },
        "downloads": 0,
        "filename": "scalpl-0.2.3-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "3e555773ed09cde5b860c4061b036240",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "size": 8063,
        "upload_time": "2017-05-26T20:30:53",
        "url": "https://files.pythonhosted.org/packages/d9/84/e900922d1a1385ece4edc5e427c1828b774016dcd025728172c09cfaa418/scalpl-0.2.3-py3-none-any.whl"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "3e555773ed09cde5b860c4061b036240",
        "sha256": "0316bfcd3b72d7bfcfce05ce9d2a8687c6b04afeb222979c09e5874c60ff0269"
      },
      "downloads": 0,
      "filename": "scalpl-0.2.3-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "3e555773ed09cde5b860c4061b036240",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "size": 8063,
      "upload_time": "2017-05-26T20:30:53",
      "url": "https://files.pythonhosted.org/packages/d9/84/e900922d1a1385ece4edc5e427c1828b774016dcd025728172c09cfaa418/scalpl-0.2.3-py3-none-any.whl"
    }
  ]
}