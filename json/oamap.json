{
  "info": {
    "author": "Jim Pivarski (DIANA-HEP)",
    "author_email": "pivarski@fnal.gov",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 4 - Beta",
      "Intended Audience :: Developers",
      "Intended Audience :: Information Technology",
      "Intended Audience :: Science/Research",
      "License :: OSI Approved :: BSD License",
      "Operating System :: MacOS",
      "Operating System :: POSIX",
      "Operating System :: Unix",
      "Programming Language :: Python",
      "Programming Language :: Python :: 2.7",
      "Programming Language :: Python :: 3.4",
      "Programming Language :: Python :: 3.5",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: 3.7",
      "Topic :: Scientific/Engineering",
      "Topic :: Scientific/Engineering :: Information Analysis",
      "Topic :: Scientific/Engineering :: Mathematics",
      "Topic :: Scientific/Engineering :: Physics",
      "Topic :: Software Development",
      "Topic :: Utilities"
    ],
    "description": "OAMap: Object-Array Mapping\n===========================\n\n.. image:: https://travis-ci.org/diana-hep/oamap.svg?branch=master\n   :target: https://travis-ci.org/diana-hep/oamap\n\nPerform high-speed calculations on columnar data without creating intermediate objects.\n\nIntroduction\n------------\n\nData analysts are often faced with a choice between speed and flexibility. Tabular data, such as SQL tables, can be processed rapidly enough for a truly interactive analysis session, but hierarchically nested formats, such as JSON, are better at representing relationships in complex data models. In some domains (such as particle physics), we want to perform calculations on JSON-like structures at the speed of SQL.\n\nThe key to high throughput on large datasets, particularly ones with more attributes than are accessed in a single pass, is laying out the data in \"columns.\" All values of an attribute should be contiguous on disk or memory because data are paged from one cache to the next in locally contiguous blocks. The `ROOT <https://root.cern/>`_ and `Parquet <http://parquet.apache.org/>`_ file formats represent JSON-like data in columns on disk, but these data are usually deserialized into objects for processing in memory. Higher performance can be achieved by maintaining the columnar structure through all stages of the calculation (see `this talk <https://youtu.be/jvt4v2LTGK0>`_ and `this paper <https://arxiv.org/abs/1711.01229>`_).\n\nThe OAMap toolkit implements an Object Array Mapping in Python. Object Array Mappings, by analogy with Object Relational Mappings (ORMs) are one-to-one relationships between conceptual objects and physical arrays. You can write functions that appear to be operating on ordinary Python objects\u2014 lists, tuples, class instances\u2014 but are actually being performed on low-level, contiguous buffers (Numpy arrays). The result is fast processing of large, complex datasets with a low memory footprint.\n\nOAMap has two primary modes: (1) pure-Python object proxies, which pretend to be Python objects but actually access array data on demand, and (2) bare-metal bytecode compiled by `Numba <http://numba.pydata.org/>`_. The pure-Python form is good for low-latency, exploratory work, while the compiled form is good for high throughput. They are seamlessly interchangeable: a Python proxy converts to the compiled form when it enters a Numba-compiled function and switches back when it leaves. You can, for instance, do a fast search in compiled code and examine the results more fully by hand.\n\nAny columnar file format or database can be used as a data source: OAMap can get arrays of data from any dict-like object (any Python object implementing ``__getitem__``), even from within a Numba-compiled function. Backends to ROOT, Parquet, and HDF5 are included, as well as a Python ``shelve`` alternative. Storing and accessing a complete dataset, including metadata, requires no more infrastructure than a collection of named arrays. (Data types are encoded in the names, values in the arrays.) OAMap is intended as a middleware layer above file formats and databases but below a fully integrated analysis suite.\n\nInstallation\n------------\n\nInstall OAMap like any other Python package:\n\n.. code-block:: bash\n\n    pip install oamap --user\n\nor similar (use ``sudo``, ``virtualenv``, or ``conda`` if you wish).\n\n**Strict dependencies:**\n\n- `Python <http://docs.python-guide.org/en/latest/starting/installation/>`_ (2.6+, 3.4+)\n- `Numpy <https://scipy.org/install.html>`_\n\n**Recommended dependencies:**\n\n- `Numba and LLVM <http://numba.pydata.org/numba-doc/latest/user/installing.html>`_ to JIT-compile functions (requires a particular version of LLVM, follow instructions)\n- `thriftpy <https://pypi.python.org/pypi/thriftpy>`_ to read Parquet files (pure Python, pip is fine)\n- `uproot <https://pypi.python.org/pypi/uproot/>`_ to read ROOT files (pure Python, pip is fine)\n- `h5py <http://docs.h5py.org/en/latest/build.html>`_ to read HDF5 files (requires binary libraries; follow instructions)\n\n**Optional dependencies:** (all are bindings to binaries that can be package-installed)\n\n- `lz4 <https://anaconda.org/anaconda/lz4>`_ compression used by some ROOT and Parquet files\n- `python-snappy <https://anaconda.org/anaconda/python-snappy>`_ compression used by some Parquet files\n- `lzo <https://anaconda.org/anaconda/lzo>`_ compression used by some Parquet files\n- `brotli <https://anaconda.org/conda-forge/brotli>`_ compression used by some Parquet files\n\nDemonstration\n-------------\n\nSample dataset #1: Parquet\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\nDownload the `NASA Exoplanet Archive <https://exoplanetarchive.ipac.caltech.edu/>`_ in `Parquet form <http://diana-hep.org/oamap/examples/planets.parquet>`_.\n\n.. code-block:: bash\n\n    wget http://diana-hep.org/oamap/examples/planets.parquet\n    pip install thriftpy --user\n\nParquet is a columnar data format intended for data with deeply nested structure.\n\nLoad the Parquet dataset with its ``open`` function. If you have a large set of Parquet files, you could pass a list or glob pattern (``*`` and ``?`` wildcards), even if the total dataset is enormous, because nothing is loaded until it is needed.\n\n.. code-block:: python\n\n    >>> import oamap.source.parquet\n    >>> stars = oamap.source.parquet.open(\"planets.parquet\")\n    >>> stars\n    [<Record at index 0>, <Record at index 1>, <Record at index 2>, <Record at index 3>,\n     <Record at index 4>, ...]\n\nSample dataset #2: Numpy npz\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\nAlternatively, download the same dataset in `Numpy form <http://diana-hep.org/oamap/examples/planets.npz>`_.\n\n.. code-block:: bash\n\n    wget http://diana-hep.org/oamap/examples/planets.npz\n\nNumpy's npz format is intended for rectangular arrays, not deeply nested structure. However, OAMap effectively adds this feature. (Numpy is faster to load into OAMap but results in a larger file than Parquet, due to less aggressive packing.)\n\n.. code-block:: python\n\n    >>> import oamap.source.npz\n    >>> stars = oamap.source.npz.open(\"planets.npz\")\n    >>> stars\n    [<Star at index 0>, <Star at index 1>, <Star at index 2>, <Star at index 3>,\n     <Star at index 4>, ...]\n\nSample dataset #3: HDF5\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\nTODO\n\nSample dataset #4: ROOT\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\nTODO\n\nExploring the data\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\nThis ``stars`` object behaves like a Python list, and each element is a record (i.e. class instance or struct).\n\n.. code-block:: python\n\n    >>> stars\n    [<Record at index 0>, <Record at index 1>, <Record at index 2>, <Record at index 3>,\n     <Record at index 4>, ...]\n    >>> stars[0].fields\n    ['activity', 'age', 'color', 'dec', 'density', 'distance', 'ecliptic', 'gaia', 'galactic',\n     'luminosity', 'mass', 'metallicity', 'name', 'num_amateur_lightcurves', 'num_general_lightcurves',\n     'num_images', 'num_planets', 'num_radial_timeseries', 'num_spectra', 'num_timeseries',\n     'num_transit_lightcurves', 'opticalband', 'parallax', 'photometry', 'planets', 'propermotion',\n     'ra', 'radialvelocity', 'radius', 'rotational_velocity', 'spectraltype', 'surfacegravity',\n     'temperature', 'update']\n    # Where is the star on the sky (RA/Dec)?\n    >>> stars[0].ra, stars[0].dec\n    (293.12738, 42.320103)\n    # How hot is it?\n    >>> stars[0].temperature\n    <Record at index 0>\n    # Oh, that's another Record. What's inside of it?\n    >>> stars[0].temperature.fields\n    ['blend', 'hierr', 'lim', 'loerr', 'val']\n    # Measurement errors! Okay, get the central value with asymmetric errors.\n    >>> stars[0].temperature.val, stars[0].temperature.loerr, stars[0].temperature.hierr\n    (6564.0, -198.42, 153.47)\n\nThe elements of a record can be other records, but they can also be other lists. Stars can have an arbitrary number of planets, so this dataset can't be expressed as a rectangular table without padding or duplication.\n\nThe first star has one planet.\n\n.. code-block:: python\n\n    >>> stars[0].planets\n    [<Record at index 0>]\n    >>> stars[0].planets[0].fields\n    ['angular_separation', 'density', 'discovery', 'discovery_method', 'eccentricity',\n     'encyclopedia_link', 'equilibrium_temperature', 'explorer_link', 'has_astrometrical_variations',\n     'has_binary', 'has_image', 'has_orbital_modulations', 'has_radial_velocity', 'has_timing_variations',\n     'has_transits', 'hd_name', 'hip_name', 'impact_parameter', 'in_k2_data', 'in_kepler_data',\n     'inclination', 'isolation_flux', 'letter', 'longitude_periastron', 'mass', 'mass_best', 'mass_sini',\n     'name', 'num_notes', 'num_parameters', 'occultation_depth', 'orbital_period', 'periastron',\n     'publication_date', 'radial_velocity', 'radius', 'ratio_planetdistance_starradius',\n     'ratio_planetradius_starradius', 'reference_link', 'semimajor_axis', 'timesystem_reference',\n     'transit_depth', 'transit_duration', 'transit_midpoint']\n    # What's the planet's name?\n    >>> stars[0].planets[0].name\n    'Kepler-1239 b'\n    # Is that like the star's name? (Yup.)\n    >>> stars[0].name\n    'Kepler-1239'\n    # How was it discovered?\n    >>> stars[0].planets[0].discovery_method\n    'Transit'\n    # Oh, it's a transit. That means it should have transit information.\n    >>> stars[0].planets[0].transit_duration\n    <Record at index 0>\n    # Another record! These scientists like their measurement errors!\n    >>> stars[0].planets[0].transit_duration.fields\n    ['hierr', 'lim', 'loerr', 'val']\n    >>> (stars[0].planets[0].transit_duration.val, stars[0].planets[0].transit_duration.loerr,\n    ...  stars[0].planets[0].transit_duration.hierr)\n    (0.17783, -0.0042900001, 0.0042900001)\n\nHere's a star with five planets:\n\n.. code-block:: python\n\n    >>> stars[258].planets\n    [<Record at index 324>, <Record at index 325>, <Record at index 326>, <Record at index 327>,\n     <Record at index 328>]\n    >>> [x.name for x in stars[258].planets]\n    ['HD 40307 b', 'HD 40307 c', 'HD 40307 d', 'HD 40307 f', 'HD 40307 g']\n    >>> [x.discovery_method for x in stars[258].planets]\n    ['Radial Velocity', 'Radial Velocity', 'Radial Velocity', 'Radial Velocity', 'Radial Velocity']\n\nIf you've been working through these examples, you might have noticed that the *first* time you look at an attribute, there's a time lag. The data-fetching granularity is one *column* (attribute array) at a time. Even though the objects in this dataset have hundreds of attributes, you don't suffer the cost of loading the attributes you're not interested in, but looking at the first star's temperature loads all the stars' temperatures (per file).\n\nOne column at a time is probably the right granularity for you because you'll be analyzing all or most values of a few attributes. For instance, suppose you're interested in solar systems with extremes of orbital periods.\n\n.. code-block:: python\n\n    for star in stars:\n        best_ratio = None\n        for one in star.planets:\n            for two in star.planets:\n                if (one.orbital_period is not None and one.orbital_period.val is not None and\n                    two.orbital_period is not None and two.orbital_period.val is not None):\n                    ratio = one.orbital_period.val / two.orbital_period.val\n                    if best_ratio is None or ratio > best_ratio:\n                        best_ratio = ratio\n        if best_ratio is not None:\n            print(best_ratio)\n\nIf you're following these examples interactively, you'd have noticed that the lag occurred at the very beginning of the loop, when you asked for the first orbital period and got all of them.\n\nPeeking at OAMap's internals, we can see which arrays are actually loaded.\n\n.. code-block:: python\n\n    >>> print(\"\\n\".join(stars._generator.loaded(stars._cache)))\n    object-B\n    object-E\n    object-L-Fplanets-B\n    object-L-Fplanets-E\n    object-L-Fplanets-L-Forbital_period-M\n    object-L-Fplanets-L-Forbital_period-Fval-M\n    object-L-Fplanets-L-Forbital_period-Fval-Df4\n\nThe ``-B`` and ``-E`` arrays quantify list and sublist lengths, ``-M`` are for nullable fields (almost all of the exoplanets fields could be null, or ``None`` in the Python code), and ``-D`` is the numerical data. (Note: the listing above is from the Parquet file; the Numpy file differs only in that it preserved the record names.)\n\nPeeking further behind the scenes, we can see that these really are Numpy arrays.\n\n.. code-block:: python\n\n    >>> for name in stars._generator.loaded(stars._cache):\n    ...     print(stars._listofarrays[0][name])\n    [0]\n    [2660]\n    [   0    1    2 ... 3562 3565 3570]\n    [   1    2    3 ... 3565 3570 3572]\n    [   0    1    2 ... 3495 3496 3497]\n    [   0    1    2 ... 3487 3488 3489]\n    [ 5.19104    4.147876   3.5957696 ... 87.090195   4.425391  13.193242 ]\n\nNo objects were involved in the processing of the data.\n\nThe fact that the data are in a purely numerical form makes it a perfect fit for Numba, which optimizes number-crunching by compiling Python functions with LLVM.\n\nTry `installing Numba <http://numba.pydata.org/numba-doc/latest/user/installing.html>`_ and then running the code below. The ``@numba.njit`` decorator specifies that the function must be compiled before it runs and ``import oamap.compiler`` tells Numba how to compile OAMap types.\n\n.. code-block:: python\n\n    import numba\n    import oamap.compiler    # crucial! loads OAMap extensions!\n\n    @numba.njit\n    def period_ratio(stars):\n        out = []\n        for star in stars:\n            best_ratio = None\n            for one in star.planets:\n                for two in star.planets:\n                    if (one.orbital_period is not None and one.orbital_period.val is not None and\n                        two.orbital_period is not None and two.orbital_period.val is not None):\n                        ratio = one.orbital_period.val / two.orbital_period.val\n                        if best_ratio is None or ratio > best_ratio:\n                            best_ratio = ratio\n            if best_ratio is not None and best_ratio > 200:\n                out.append(star)\n        return out\n\n    # The benefit of compiling is lost on a small dataset like this (compilation time ~ run time),\n    # but I'm sure you can find a much bigger one.  :)\n    >>> extremes = period_ratio(stars)\n    # Now that we've filtered with compiled code, we can examine the outliers in Python.\n    >>> extremes\n    [<Record at index 284>, <Record at index 466>, <Record at index 469>, <Record at index 472>,\n     <Record at index 484>, <Record at index 502>, <Record at index 510>, <Record at index 559>,\n     <Record at index 651>, <Record at index 665>, <Record at index 674>, <Record at index 728>,\n     <Record at index 1129>, <Record at index 1464>, <Record at index 1529>, <Record at index 1567>,\n     <Record at index 1814>, <Record at index 1819>, <Record at index 1953>, <Record at index 1979>,\n     <Record at index 1980>, <Record at index 2305>, <Record at index 2332>, <Record at index 2366>,\n     <Record at index 2623>, <Record at index 2654>]\n    # These are unusual solar systems (most don't have so many planets).\n    >>> extremes[0].planets\n    [<Record at index 384>, <Record at index 385>, <Record at index 386>, <Record at index 387>,\n     <Record at index 388>, <Record at index 389>]\n    # Indeed, the orbital period ratio for this one is 2205.0 / 5.75969.\n    >>> [x.orbital_period.val for x in extremes[0].planets]\n    [5.75969, 16.357, 49.748, 122.744, 604.67, 2205.0]\n    # Including attributes that we didn't consider in the search.\n    >>> [x.mass_best.val for x in extremes[0].planets]\n    [0.0416, 0.0378, 0.0805, 0.0722, 0.0732, 0.2066]\n\nThe exploratory one-liners and the analysis functions you would write to study your data are similar to what they'd be if these were JSON or Python objects. However,\n\n- the data are stored in a binary, columnar form, which minimizes memory use and streamlines data transfers from disk or network to memory to CPU cache);\n- scans over the data can be compiled for higher throughput.\n\nThese two features speed up conventional workflows.\n\nUnconventional workflows: columnar granularity\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\nIn the demonstration above, we downloaded the file we wanted to analyze. That required us to take all of the columns, including those we aren't interested in. Object-array mapping shifts the granular unit from a file that describes a complete dataset to its individual columns. Thus,\n\n- columns do not need to be packaged together as files\u2014 they may be free-floating objects in a key-value database or object store;\n- the same columns may be used in different datasets\u2014 different versions, different structures, different filters\u2014 because datasets with substantial overlaps in content should not be allowed to waste memory.\n\nTo demonstrate this, we'll look at the same dataset with download-on-demand. We're using a simple HTTP server for this, but any key-value database or object store would work.\n\n.. code-block:: python\n\n    import numpy\n    import io\n    import codecs\n    try:\n        from urllib.request import urlopen   # Python 3\n    except ImportError:\n        from urllib2 import urlopen          # Python 2\n\n    baseurl = \"http://diana-hep.org/oamap/examples/planets/\"\n\n    # wrap the website as a dict-like object with a __getitem__ method\n    class DataSource:\n        def __getitem__(self, name):\n            ### uncomment the following line to see how it works\n            # print(name)\n            try:\n                return numpy.load(io.BytesIO(urlopen(baseurl + name + \".npy\").read()))\n            except Exception as err:\n                raise KeyError(str(err))\n\n    # download the dataset description\n    remotefile = urlopen(baseurl + \"dataset.json\")\n\n    # explicit utf-8 conversion required for Python 3\n    remotefile = codecs.getreader(\"utf-8\")(remotefile)\n\n    # the dataset description tells OAMap which arrays (URLs) to fetch\n    from oamap.schema import *\n    dataset = Dataset.fromjsonfile(remotefile)\n    stars = dataset.schema(DataSource())\n\nNow we can work with this dataset exactly as we did before. (I'm including the optional printouts from above.)\n\n.. code-block:: python\n\n    # object-B\n    # object-E\n    >>> stars\n    [<Star at index 0>, <Star at index 1>, <Star at index 2>, <Star at index 3>, <Star at index 4>, ...,\n     <Star at index 2655>, <Star at index 2656>, <Star at index 2657>, <Star at index 2658>,\n     <Star at index 2659>]\n    >>> stars[0].ra, stars[0].dec\n    # object-L-NStar-Fra-Df4\n    # object-L-NStar-Fdec-Df4\n    (293.12738, 42.320103)\n    >>> stars[258].planets\n    # object-L-NStar-Fplanets-B\n    # object-L-NStar-Fplanets-E\n    [<Planet at index 324>, <Planet at index 325>, <Planet at index 326>, <Planet at index 327>,\n     <Planet at index 328>]\n    >>> [x.name for x in stars[258].planets]\n    # object-L-NStar-Fplanets-L-NPlanet-Fname-NUTF8String-B\n    # object-L-NStar-Fplanets-L-NPlanet-Fname-NUTF8String-E\n    # object-L-NStar-Fplanets-L-NPlanet-Fname-NUTF8String-L-Du1\n    ['HD 40307 b', 'HD 40307 c', 'HD 40307 d', 'HD 40307 f', 'HD 40307 g']\n    >>> period_ratio(stars)\n    # object-L-NStar-Fplanets-L-NPlanet-Forbital_period-NValueAsymErr-Fval-M\n    # object-L-NStar-Fplanets-L-NPlanet-Forbital_period-NValueAsymErr-Fval-Df4\n    # object-L-NStar-Fplanets-L-NPlanet-Forbital_period-NValueAsymErr-M\n    [<Star at index 284>, <Star at index 466>, <Star at index 469>, <Star at index 472>, <Star at index 484>,\n     <Star at index 502>, <Star at index 510>, <Star at index 559>, <Star at index 651>, <Star at index 665>,\n     <Star at index 674>, <Star at index 728>, <Star at index 1129>, <Star at index 1464>,\n     <Star at index 1529>, <Star at index 1567>, <Star at index 1814>, <Star at index 1819>,\n     <Star at index 1953>, <Star at index 1979>, <Star at index 1980>, <Star at index 2305>,\n     <Star at index 2332>, <Star at index 2366>, <Star at index 2623>, <Star at index 2654>]\n\nWe can even modify the dataset without touching all of its elements. For instance, suppose we want to give each star an id number:\n\n.. code-block:: python\n\n    # create a data source that effectively merges the array sets\n    class DataSource2:\n        def __init__(self, arrays, fallback):\n            self.arrays = arrays\n            self.fallback = fallback\n        def __getitem__(self, name):\n            try:\n                return self.arrays[name]\n            except KeyError:\n                return self.fallback[name]\n\n    # modify the schema by adding a primitive (numerical) field\n    >>> schema = dataset.schema\n    >>> schema.content[\"id\"] = Primitive(int, data=\"id-array\")\n\n    # create a new dataset with the new schema and new source\n    >>> source = DataSource2({\"id-array\": numpy.arange(len(stars), dtype=int)}, DataSource())\n    >>> stars_v2 = schema(source)\n\n    # the new dataset has the new field and the old one doesn't, but they share 99% of the data\n    >>> stars_v2[0].id\n    0\n    >>> stars_v2[100].id\n    100\n    >>> stars_v2[-1].id\n    2659\n    >>> stars[0].id\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n      File \"oamap/proxy.py\", line 340, in __getattr__\n        raise AttributeError(\"{0} object has no attribute {1}\".format(repr(\"Record\" if\n            self._generator.name is None else self._generator.name), repr(field)))\n    AttributeError: 'Star' object has no attribute 'id'\n\nSchemas/data types\n------------------\n\nColumnar datasets must be defined by a schema and compiled functions must have static data types, so all data in OAMap has a schema. As you've seen in the previous example, the schemas are very fluid: you're not locked into an early choice of schema.\n\nYou can examine the schema of any list or record through its ``schema`` property:\n\n.. code-block:: python\n\n    >>> stars.schema.show()\n\nFor a large dataset like the exoplanets, be prepared for pages of output.\n\nThe schema expresses the nested structure of the data and optionally the names of the arrays to fetch (overriding a default naming convention, derived from the schema structure). Schemas can also document the data and carry arbitrary (JSON) metadata.\n\nSchemas are defined by seven generators: **Primitive**, **List**, **Union**, **Record**, **Tuple**, **Pointer**, and **Extension**, which together form a fairly complete programming environment.\n\nPrimitive\n\"\"\"\"\"\"\"\"\"\n\nPrimitives are fixed-width, concrete types such as booleans, numbers, and fixed-size byte strings (e.g. 6-byte MAC addresses or 16-byte UUIDs). The scope will include anything describable by a `Numpy dtype <https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.html>`_, though non-trivial dtype shapes (to describe fixed-dimension tensors) and names (to describe non-columnar, flat records) are not implemented yet.\n\n.. code-block:: python\n\n    >>> from oamap.schema import *\n    >>> schema = List(Primitive(int, data=\"p\"), starts=\"b\", stops=\"e\")\n    >>> obj = schema({\"p\": [1, 2, 3, 4, 5], \"b\": [0], \"e\": [5]})\n    >>> obj\n    [1, 2, 3, 4, 5]\n\n.. code-block:: python\n\n    >>> schema = List(Primitive(\"S4\"))\n    >>> obj = schema.fromdata([\"one\", \"two\", \"three\", \"four\", \"five\"])\n    >>> obj\n    [b'one', b'two', b'thre', b'four', b'five']\n\nNote that \"three\" is truncated (and the rest are implicitly padded) because the Numpy dtype, ``\"S4\"`` is 4-byte. See the extension type (below) for a better way to make strings.\n\nList\n\"\"\"\"\n\nLists are arbitrary length collections of any other type. Unlike dynamically typed Python, the contents of a list must all be the same type (\"homogeneous\"), though unions (below) loosen that requirement.\n\n.. code-block:: python\n\n    >>> schema = List(List(\"int\"))   # shorthand string \"int\" for Primitive(\"int\")\n    >>> obj = schema.fromdata([[1, 2, 3], [], [4, 5]])\n    >>> for n, x in obj._arrays.items():\n    ...     print(n, x)\n    object-B [0]\n    object-E [3]\n    object-L-B [0 3 3]\n    object-L-E [3 3 5]\n    object-L-L-Di8 [1 2 3 4 5]\n    >>> obj\n    [[1, 2, 3], [], [4, 5]]\n\nis a list of lists and\n\n.. code-block:: python\n\n    >>> schema = List(Tuple([\"int\", \"float\"]))\n    >>> obj = schema.fromdata([(1, 1.1), (2, 2.2), (3, 3.3)])\n    >>> for n, x in obj._arrays.items():\n    ...     print(n, x)\n    object-B [0]\n    object-E [3]\n    object-L-F0-Di8 [1 2 3]\n    object-L-F1-Df8 [1.1 2.2 3.3]\n    >>> obj\n    [(1, 1.1), (2, 2.2), (3, 3.3)]\n\nis a list of tuples.\n\nUnion\n\"\"\"\"\"\n\nUnions represent data that may be one of a given set of types (\"`sum types <https://en.wikipedia.org/wiki/Tagged_union>`_\" in type theory). For instance, the elements of the following list could *either* be a floating point number *or* be a list of integers:\n\n.. code-block:: python\n\n    >>> schema = List(Union([\"float\", List(\"int\")]))\n    >>> obj = schema({\"object-B\": [0],                     # beginning of outer list\n                      \"object-E\": [3],                     # end of outer list\n                      \"object-L-T\": [0, 1, 0],             # tags: possibility 0 (float) or 1 (list of int)?\n                      \"object-L-O\": [0, 0, 1],             # offsets: where to find the compacted contents\n                      \"object-L-U0-Df8\": [1.1, 3.3],       # data for possibility 0 (floats)\n                      \"object-L-U1-B\": [0],                # beginnings of lists for possibility 1\n                      \"object-L-U1-E\": [4],                # ends of lists for possibility 1\n                      \"object-L-U1-L-Di8\": [1, 2, 3, 4]})  # list content for possibility 1 (ints)\n    >>> obj\n    [1.1, [1, 2, 3, 4], 3.3]\n\nUnions can emulate a popular object-oriented concept: class inheritance. We can make a list of electrons (which have charge) and photons (which don't) as a union of the two types of records.\n\n.. code-block:: python\n\n    >>> schema = List(Union([\n    ...     Record(name=\"Electron\", fields={\"energy\": \"float\", \"charge\": \"int\"}),\n    ...     Record(name=\"Photon\",   fields={\"energy\": \"float\"})]))\n    ... \n    >>> obj = schema.fromdata([\n    ...     {\"energy\": 1.1, \"charge\":  1},\n    ...     {\"energy\": 2.2, \"charge\": -1},\n    ...     {\"energy\": 3.3},\n    ...     {\"energy\": 4.4, \"charge\": -1},\n    ...     {\"energy\": 5.5}\n    ...     ])\n    ... \n    >>> obj\n    [<Electron at index 0>, <Electron at index 1>, <Photon at index 0>, <Electron at index 2>,\n     <Photon at index 1>]\n    >>> for n, x in obj._arrays.items():\n    ...     print(n, x)\n    ... \n    object-B [0]\n    object-E [5]\n    object-L-T [0 0 1 0 1]\n    object-L-O [0 1 0 2 1]\n    object-L-U0-NElectron-Fenergy-Df8 [1.1 2.2 4.4]\n    object-L-U0-NElectron-Fcharge-Di8 [ 1 -1 -1]\n    object-L-U1-NPhoton-Fenergy-Df8 [3.3 5.5]\n\nRecord\n\"\"\"\"\"\"\n\nRecords represent data that contain a set of fields\u2014 names that map to types (\"`product types <https://en.wikipedia.org/wiki/Product_type>`_\" in type theory).\n\nYou've seen several examples of record types, so here's one drawn from the exoplanets:\n\n.. code-block:: python\n\n    >>> stars.schema.content[\"planets\"].content[\"discovery\"].show()\n    Record(\n      name = 'Discovery',\n      fields = {\n        'facility': Pointer(\n          doc = 'Name of facility of planet discovery observations',\n          target = List(\n            name = 'UTF8String',\n            content = Primitive(dtype('uint8'))\n          )\n        ),\n        'instrument': List(\n          name = 'UTF8String',\n          doc = 'Name of instrument of planet discovery observations',\n          content = Primitive(dtype('uint8'))\n        ),\n        'link': List(\n          name = 'UTF8String',\n          doc = 'Reference name for discovery publication',\n          content = Primitive(dtype('uint8'))\n        ),\n        'locale': Pointer(\n          doc = 'Location of observation of planet discovery (Ground or Space)',\n          target = List(\n            name = 'UTF8String',\n            content = Primitive(dtype('uint8'))\n          )\n        ),\n        'telescope': List(\n          name = 'UTF8String',\n          doc = 'Name of telescope of planet discovery observations',\n          content = Primitive(dtype('uint8'))\n        ),\n        'year': Primitive(dtype('int32'), doc='Year the planet was discovered')\n      })\n\nTuple\n\"\"\"\"\"\n\nTuples are like records, but their content fields are numbered, rather than named. They are more like records than lists because\n\n- lists may have any length, but the tuple length is fixed by the schema;\n- all elements of a list must have the same type (\"homogeneous\"), but each element of a tuple may have a different type (\"heterogeneous\").\n\n.. code-block:: python\n\n    >>> schema = List(Tuple([\"int\", \"float\", List(\"int\")]))\n    >>> obj = schema.fromdata([(1, 1.1, [1, 2, 3]), (2, 2.2, []), (3, 3.3, [4, 5])])\n    >>> obj\n    [(1, 1.1, [1, 2, 3]), (2, 2.2, []), (3, 3.3, [4, 5])]\n\nPointer\n\"\"\"\"\"\"\"\n\nPointers connect parts of the object to form trees and graphs, and they reduce memory use by minimizing the number of times a large, complex object must be represented.\n\nOAMap pointers are similar to pointers in a language like C, in that they reference an object by specifying its location with an integer, with two exceptions.\n\n1. The address is an array index, not a native memory address. This allows OAMap to be portable.\n2. OAMap pointers are `bounded pointers <https://en.wikipedia.org/wiki/Bounded_pointer>`_, limited to a specified \"target.\"\n\nPointers may be used in three topologies: (1) to point to another object in the same schema, but not its own parent, (2) to point at its parent, creating a loop (the only way to make arbitrary depth trees or graphs in OAMap), and (3) to point to an external object.\n\nThe first case is useful for provenance, so that derived collections can refer to their sources (e.g. reconstructed particles point to their raw measurements; tracks and showers in particle physics).\n\n.. code-block:: python\n\n    >>> schema = Record({\"points\": List(Tuple([\"int\", \"int\"])),\n    ...                  \"line\": List(Pointer(None))})\n    >>> schema.fields[\"line\"].content.target = schema.fields[\"points\"].content\n    >>> schema.show()\n    Record(\n      fields = {\n        'points': List(\n          content = #0: Tuple(\n            types = [\n              Primitive(dtype('int64')),\n              Primitive(dtype('int64'))\n            ])\n        ),\n        'line': List(\n          content = Pointer(\n            target = #0\n          )\n        )\n      })\n    >>> points = [(0, 0), (0, 1), (1, 1), (1, 0)]\n    >>> line = [points[0], points[2], points[1]]\n    >>> obj = schema.fromdata({\"points\": points, \"line\": line})\n    >>> for n, x in obj._arrays.items():\n    ...     print n, x\n    ... \n    object-Fline-B [0]\n    object-Fline-E [3]\n    object-Fpoints-B [0]\n    object-Fpoints-E [4]\n    object-Fpoints-L-F0-Di8 [0 0 1 1]\n    object-Fpoints-L-F1-Di8 [0 1 1 0]\n    object-Fline-L-P-object-Fpoints-L [0 2 1]  # point 0, 2, then 1\n\nThe second case builds trees and graphs.\n\n.. code-block:: python\n\n    >>> schema = Record(\n    ...     name = \"Tree\",\n    ...     fields = dict(\n    ...         label = \"float\",\n    ...         children = List(Pointer(None))\n    ...     ))\n    ... \n    >>> schema.fields[\"children\"].content.target = schema\n    >>> schema.show()\n    #0: Record(\n      name = 'Tree',\n      fields = {\n        'label': Primitive(dtype('float64')),\n        'children': List(\n          content = Pointer(\n            target = #0\n          )\n        )\n      })\n    >>> obj = schema.fromdata(\n    ...     {\"label\": 1.1,                                     # 1.1\n    ...      \"children\": [                                     #  |\n    ...          {\"label\": 2.2,                                #  \u251c\u2500\u2500 2.2\n    ...           \"children\": [                                #  |    |\n    ...               {\"label\": 4.4,                           #  \u2502    \u251c\u2500\u2500 4.4\n    ...                \"children\": [                           #  \u2502    \u2502    |\n    ...                    {\"label\": 7.7, \"children\": []}      #  \u2502    \u2502    \u2514\u2500\u2500 7.7\n    ...                            ]},                         #  |    |\n    ...               {\"label\": 5.5,                           #  \u2502    \u2514\u2500\u2500 5.5\n    ...                \"children\": [                           #  |         |\n    ...                    {\"label\": 8.8, \"children\": []}      #  \u2502         \u2514\u2500\u2500 8.8\n    ...                            ]}                          #  |\n    ...                       ]},                              #  |\n    ...          {\"label\": 3.3,                                #  \u2514\u2500\u2500 3.3\n    ...           \"children\": [                                #       |\n    ...               {\"label\": 6.6, \"children\": []}           #       \u2514\u2500\u2500 6.6\n    ...                       ]}\n    ...                  ]})\n    >>> obj\n    <Tree at index 0>\n    >>> obj.children[0].children[0].label\n    2.2\n\nThe third case effectively turns contained data into enumeration constants, good for repeated quantities (such as the strings in the exoplanets dataset).\n\n.. code-block:: python\n\n    # the schema for discovery_method is a pointer to strings, rather than strings directly\n    >>> stars.schema.content[\"planets\"].content[\"discovery_method\"].show()\n    Pointer(\n      positions = 'discovery_method-P',\n      doc = 'Discovery Method',\n      target = List(\n        starts = 'discovery_method-X-NUTF8String-B',\n        stops = 'discovery_method-X-NUTF8String-E',\n        name = 'UTF8String',\n        content = Primitive(dtype('uint8'), data='discovery_method-X-NUTF8String-L-Du1')\n      )\n    ) \n\n    # string data consists exclusively of _unique_ strings\n    >>> stars._listofarrays[0][\"discovery_method-X-NUTF8String-L-Du1\"].tostring()\n    b\"\"\"TransitRadial VelocityImagingMicrolensingEclipse Timing VariationsPulsar TimingTransit Timi\n        ng VariationsOrbital Brightness ModulationPulsation Timing VariationsAstrometry\"\"\"\n\n    # and the discovery method string for 3572 planets are referred to by pointer integers\n    >>> stars._listofarrays[0][\"discovery_method-P\"][:300]\n    array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 2, 0, 0, 0, 0, 0, 0,\n           0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1,\n           0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n           0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 2, 1, 1,\n           1, 3, 0, 1, 0, 0, 1, 1, 0, 1, 2, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,\n           0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n           0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,\n           0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n           0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0,\n           0, 0, 0, 1, 1, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,\n           0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,\n           0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n           0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0,\n           0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], dtype=int32)\n\nThis concept maps nicely onto Parquet's dictionary encoding, so Parquet dictionaries are presented as OAMap pointers.\n\nExtensions and names\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\nExtensions allow the six content-oriented type generators to be interpreted in an open-ended variety of ways. For instance, we haven't discussed strings as a distinct type, but strings are just lists of characters, and characters are primitives. Instead of introducing a string type, we allow lists of characters with a special name to be interpreted as strings.\n\n>>> schema = List(List(name=\"UTF8String\", content=\"uint8\"))\n>>> obj = schema.fromdata([\"hello there\", \"you guys\"])\n>>> obj\n['hello there', 'you guys']\n>>> for n, x in obj._arrays.items():\n...     print(n, x)\n... \nobject-B [0]\nobject-E [2]\nobject-L-NUTF8String-B [ 0 11]\nobject-L-NUTF8String-E [11 19]\nobject-L-NUTF8String-L-Du1 [104 101 108 108 111  32 116 104 101 114 101 121\n                            111 117  32 103 117 121 115]\n>>> obj._arrays[\"object-L-NUTF8String-L-Du1\"].tostring()\nb'hello thereyou guys'\n\nExtension libraries can be specified at runtime (``oamap.extension.common`` is the default, which includes the most common types) and are pattern-matched to schemas. All specified schema attributes are used in the matching, but name is the most significant discriminator.\n\nNullability\n\"\"\"\"\"\"\"\"\"\"\"\n\nEvery data type, at every level, may be \"nullable.\" A nullable value may be ``None`` at runtime, and the missing data are identified by masking arrays that also serve as offset arrays.\n\n.. code-block:: python\n\n    >>> schema = List(List(Primitive(int, nullable=True), nullable=True))\n\n    >>> obj = schema.fromdata([[1, None, 3], [], [4, 5]])\n    >>> for n, x in obj._arrays.items():\n    ...     print n, x\n    object-B [0]\n    object-E [3]\n    object-L-M [0 1 2]\n    object-L-B [0 3 3]\n    object-L-E [3 3 5]\n    object-L-L-M [ 0 -1  1  2  3]\n    object-L-L-Di8 [1 3 4 5]\n\n    >>> obj = schema.fromdata([None, [], [4, 5]])\n    >>> for n, x in obj._arrays.items():\n    ...     print n, x\n    object-B [0]\n    object-E [3]\n    object-L-M [-1  0  1]\n    object-L-B [0 0]\n    object-L-E [0 2]\n    object-L-L-M [0 1]\n    object-L-L-Di8 [4 5]\n\nUsing the flexibility of the mask-offset, the missing values may be skipped in the data (as above) or filled with placeholders (as in `Apache Arrow <https://arrow.apache.org/>`_).\n\nDatasets and partitions\n-----------------------\n\nIn the examples above, we created objects on the fly for small, handwritten schemas. Not all of these were lists, though most data processing is performed on some kind of list, often on subsequences in parallel, and often on datasets that are too large to fit into memory. We must be able to split lists up into large chunks, called partitions, to control when they're operated upon and by whom.\n\nA large schema can be wrapped up in a dataset, which we used in the exoplanet-from-HTTP example.\n\n.. code-block:: python\n\n    >>> dataset.show()\n    Dataset(\n      prefix = 'object',\n      delimiter = '-',\n      metadata = {'source': 'https://exoplanetarchive.ipac.caltech.edu/'},\n      schema = List(\n        content = Record(\n          name = 'Star',\n          fields = {\n            ...\n          })\n      )\n    )\n\nIf the dataset's schema is a list, we can specify a partitioning in the dataset description. This partitioning is a rule specifying a naming convention or an explicit lookup table to map a column name and a partition number to an array name. OAMap proxies (including those in a Numba-compiled function) load one partition at a time, flushing the previous partition from memory. More advanced processors may use partition numbers to distribute a job.\n\nTo a user, processing a whole dataset can be as simple as\n\n.. code-block:: python\n\n    >>> import numba\n    >>> import oamap.compiler\n    >>> import oamap.source.root\n    >>> events = oamap.source.root.open(\"particle_physics_data/*.root\")\n\n    # turn off Python's GIL in compiled code\n    >>> @numpy.njit(nogil=True)\n    >>> def complex_function(events):\n    ...     # action to perform on one partition of events\n    ... \n    >>> complex_function(events)\n\nto load each partition serially, holding only one partition in memory at a time, or\n\n.. code-block:: python\n\n    >>> from concurrent.futures import ThreadPoolExecutor\n    >>> executor = ThreadPoolExecutor(16)\n    >>> executor.map(complex_function, events.partitions)\n\nto run them in parallel, holding as many as 16 partitions in memory at a time.",
    "docs_url": null,
    "download_url": "https://github.com/diana-hep/oamap/releases",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "https://github.com/diana-hep/oamap",
    "keywords": "",
    "license": "BSD 3-clause",
    "maintainer": "",
    "maintainer_email": "",
    "name": "oamap",
    "platform": "Any",
    "project_url": "https://pypi.org/project/oamap/",
    "release_url": "https://pypi.org/project/oamap/0.10.8/",
    "requires_dist": [],
    "requires_python": "",
    "summary": "Perform high-speed calculations on columnar data without creating intermediate objects.",
    "version": "0.10.8"
  },
  "releases": {
    "0.1.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "66c561c5a405a26554cca28bd8d62c90",
          "sha256": "b9da8e4daa6fc2b558402bb2b9c71ec5edb7b00cc86c12c56626527836246cd8"
        },
        "downloads": -1,
        "filename": "oamap-0.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "66c561c5a405a26554cca28bd8d62c90",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 31285,
        "upload_time": "2017-12-31T15:21:23",
        "url": "https://files.pythonhosted.org/packages/0b/f3/757cc9fb315fe60bfa99fe09f72ddaa1b3992599191cf66fadb930dcd5a4/oamap-0.1.0.tar.gz"
      }
    ],
    "0.1.3": [
      {
        "comment_text": "",
        "digests": {
          "md5": "0193416e28cb42f32c2f88a933ab8c6d",
          "sha256": "c83ec7e903df0c8407e9df28519724418748f9b757eeeb424ce38eb1a91d76d1"
        },
        "downloads": -1,
        "filename": "oamap-0.1.3.tar.gz",
        "has_sig": false,
        "md5_digest": "0193416e28cb42f32c2f88a933ab8c6d",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 31019,
        "upload_time": "2017-12-31T16:27:39",
        "url": "https://files.pythonhosted.org/packages/57/e5/1de71ae4b22a77220e8decda1bf12636b3a76f1b159900d8b6c1dc196d69/oamap-0.1.3.tar.gz"
      }
    ],
    "0.1.4": [
      {
        "comment_text": "",
        "digests": {
          "md5": "eca4043f9282373ddcd099e5d065fd68",
          "sha256": "9dc3537c91a439e18482338cd35af10d333b880887559d360565d6ecdf15b8fb"
        },
        "downloads": -1,
        "filename": "oamap-0.1.4.tar.gz",
        "has_sig": false,
        "md5_digest": "eca4043f9282373ddcd099e5d065fd68",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 32700,
        "upload_time": "2017-12-31T22:09:17",
        "url": "https://files.pythonhosted.org/packages/2e/25/e5ca1b5d9d6594846ad5f5f36c1dfe19e3e43410760fa244a7e5a9670788/oamap-0.1.4.tar.gz"
      }
    ],
    "0.1.5": [
      {
        "comment_text": "",
        "digests": {
          "md5": "fe1b066d4cc31101e8b1bb3da6db270d",
          "sha256": "d44f5e350c95c65b2ae75146cfdfa03ff11025d18bef8cd2d5a5397fafbe2081"
        },
        "downloads": -1,
        "filename": "oamap-0.1.5.tar.gz",
        "has_sig": false,
        "md5_digest": "fe1b066d4cc31101e8b1bb3da6db270d",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 32718,
        "upload_time": "2017-12-31T22:21:57",
        "url": "https://files.pythonhosted.org/packages/a9/54/a8de3d4da8d50ea2409945c778bc5d6470ca615a61432abe09ec73e549ac/oamap-0.1.5.tar.gz"
      }
    ],
    "0.1.6": [
      {
        "comment_text": "",
        "digests": {
          "md5": "de9e16a26e9271b729d1282974c32826",
          "sha256": "b45cf47d619d5b5140dc235d1607046a6ec3e287ff9a032b35885f8d20bf799f"
        },
        "downloads": -1,
        "filename": "oamap-0.1.6.tar.gz",
        "has_sig": false,
        "md5_digest": "de9e16a26e9271b729d1282974c32826",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 32712,
        "upload_time": "2017-12-31T22:25:15",
        "url": "https://files.pythonhosted.org/packages/14/0d/e987dcbceaca589d015f047ac4015916325965d5e43b208f12fe6243694e/oamap-0.1.6.tar.gz"
      }
    ],
    "0.1.7": [
      {
        "comment_text": "",
        "digests": {
          "md5": "46ad829f08f1d1b844e25b8f5affbee3",
          "sha256": "3e4bec5052a9f961bce73c7600d63b4bbe2bafe67d460ac6bb8cbfeee1745a28"
        },
        "downloads": -1,
        "filename": "oamap-0.1.7.tar.gz",
        "has_sig": false,
        "md5_digest": "46ad829f08f1d1b844e25b8f5affbee3",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 32716,
        "upload_time": "2017-12-31T22:30:08",
        "url": "https://files.pythonhosted.org/packages/e4/74/e818a722078a93d99a7c0684614eb7be238cf54145f27fc6ba128c03e371/oamap-0.1.7.tar.gz"
      }
    ],
    "0.10.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "9f2eef458e1f2bf62ccb93a1ad107e75",
          "sha256": "948397c7925c9d3a88f1dd1590d3b242b92e47781ba32dfa015c9d72e48df177"
        },
        "downloads": -1,
        "filename": "oamap-0.10.0.tar.gz",
        "has_sig": false,
        "md5_digest": "9f2eef458e1f2bf62ccb93a1ad107e75",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 85505,
        "upload_time": "2018-01-31T13:23:36",
        "url": "https://files.pythonhosted.org/packages/cf/1a/b959290ab24095582a8f06b79451662d3eea0521869ea4aa79e2bec27a24/oamap-0.10.0.tar.gz"
      }
    ],
    "0.10.2": [
      {
        "comment_text": "",
        "digests": {
          "md5": "7298809994de63a345d4cd8c72bf5d21",
          "sha256": "197d8a46a22a6b1ee94fa6d01ce117afa08ab0b354595bb8168292683906d300"
        },
        "downloads": -1,
        "filename": "oamap-0.10.2.tar.gz",
        "has_sig": false,
        "md5_digest": "7298809994de63a345d4cd8c72bf5d21",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 67024,
        "upload_time": "2018-01-31T22:42:46",
        "url": "https://files.pythonhosted.org/packages/81/2a/dfae18f92a0e478d6f6920efe95d47aae1671cef5236c91e72fe4ee29f19/oamap-0.10.2.tar.gz"
      }
    ],
    "0.10.4": [
      {
        "comment_text": "",
        "digests": {
          "md5": "fe1fe382ded1d95788ccf2fbb07df4e5",
          "sha256": "80c0e3678f9cf7fd98978a46f87c09061b8a775dbbb29e86f4025cfebb901078"
        },
        "downloads": -1,
        "filename": "oamap-0.10.4.tar.gz",
        "has_sig": false,
        "md5_digest": "fe1fe382ded1d95788ccf2fbb07df4e5",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 79586,
        "upload_time": "2018-02-01T23:31:58",
        "url": "https://files.pythonhosted.org/packages/72/f2/8ad77b242ace774455acf97bd2a58556efe971a58458196fe10146af482f/oamap-0.10.4.tar.gz"
      }
    ],
    "0.10.5": [
      {
        "comment_text": "",
        "digests": {
          "md5": "4790951531a68ae719488ea68c4e48b8",
          "sha256": "c1ee0dfa2b4389bfb79dbd9ad8a596755de6129098e1a127742719fbb1135408"
        },
        "downloads": -1,
        "filename": "oamap-0.10.5.tar.gz",
        "has_sig": false,
        "md5_digest": "4790951531a68ae719488ea68c4e48b8",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 101863,
        "upload_time": "2018-02-02T12:42:08",
        "url": "https://files.pythonhosted.org/packages/31/99/2c0f737e4ae6c13e2ae10c10d5ddb0a0c07214afae43aa8833e06c7cf2d6/oamap-0.10.5.tar.gz"
      }
    ],
    "0.10.6": [
      {
        "comment_text": "",
        "digests": {
          "md5": "e2209022d92734972a242912b6230198",
          "sha256": "7ccd728898842a4b2d98f94c609bb4a46d4af1f33a8db581dae63b9867d085e3"
        },
        "downloads": -1,
        "filename": "oamap-0.10.6.tar.gz",
        "has_sig": false,
        "md5_digest": "e2209022d92734972a242912b6230198",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 101805,
        "upload_time": "2018-02-02T13:02:07",
        "url": "https://files.pythonhosted.org/packages/5d/d2/2c2e13884f592d3eb9c72f1a9998797b5867af899817ceca3296479ec97a/oamap-0.10.6.tar.gz"
      }
    ],
    "0.10.8": [
      {
        "comment_text": "",
        "digests": {
          "md5": "23d6cf8bd61f46a5eaa9d58d5b88eb4f",
          "sha256": "373d5ab35609aa9eb4f4f6a667fd54e8fe71e0bff95630d1fb668f848b69727b"
        },
        "downloads": -1,
        "filename": "oamap-0.10.8.tar.gz",
        "has_sig": false,
        "md5_digest": "23d6cf8bd61f46a5eaa9d58d5b88eb4f",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 102621,
        "upload_time": "2018-02-02T18:40:43",
        "url": "https://files.pythonhosted.org/packages/37/b2/920412b95010786dcc78846a9f80c78caac34d1e4b888680dbf08cc4341c/oamap-0.10.8.tar.gz"
      }
    ],
    "0.2.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "3b7e4395b3733471ebb9cc576473dad3",
          "sha256": "c6522877fed30a04ae3990292631cd9bd1417377fce912fe242be37eaee0af51"
        },
        "downloads": -1,
        "filename": "oamap-0.2.0.tar.gz",
        "has_sig": false,
        "md5_digest": "3b7e4395b3733471ebb9cc576473dad3",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 33279,
        "upload_time": "2018-01-01T00:48:12",
        "url": "https://files.pythonhosted.org/packages/ac/54/462e7b8325fed25e8d6a415e42890764f92863cb9576f75b280811089000/oamap-0.2.0.tar.gz"
      }
    ],
    "0.2.2": [
      {
        "comment_text": "",
        "digests": {
          "md5": "eb654cf1766626958b2f9443fd0361aa",
          "sha256": "a4c5df144bc58a147806de62375112891808b8d001341917be0e1a811524db97"
        },
        "downloads": -1,
        "filename": "oamap-0.2.2.tar.gz",
        "has_sig": false,
        "md5_digest": "eb654cf1766626958b2f9443fd0361aa",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 39427,
        "upload_time": "2018-01-02T16:29:12",
        "url": "https://files.pythonhosted.org/packages/c4/e6/73a24709d9a8bd6ba306807e246e9c99f7f2d4696e499430666718c4d15d/oamap-0.2.2.tar.gz"
      }
    ],
    "0.2.4": [
      {
        "comment_text": "",
        "digests": {
          "md5": "84972634c90154e7d92a64a4373564b3",
          "sha256": "1f3aa71d4ef7a6ee5ff74e60b6534f255994e12df0c2ee4f5249a9781639d539"
        },
        "downloads": -1,
        "filename": "oamap-0.2.4.tar.gz",
        "has_sig": false,
        "md5_digest": "84972634c90154e7d92a64a4373564b3",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 44065,
        "upload_time": "2018-01-02T23:57:29",
        "url": "https://files.pythonhosted.org/packages/40/35/10f6cab1283573ef00817d878fe2e06911784f87a39bc25f14b562bf48b9/oamap-0.2.4.tar.gz"
      }
    ],
    "0.2.5": [
      {
        "comment_text": "",
        "digests": {
          "md5": "e4d5ee8b5981a06156c7e88a27a2fe11",
          "sha256": "fcc8642603190bace0820617090aa5c78bed9c1fb78203709698dc792c97ca18"
        },
        "downloads": -1,
        "filename": "oamap-0.2.5.tar.gz",
        "has_sig": false,
        "md5_digest": "e4d5ee8b5981a06156c7e88a27a2fe11",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 45401,
        "upload_time": "2018-01-03T14:13:08",
        "url": "https://files.pythonhosted.org/packages/6c/c1/cc11eedda6b2375b6db8afa595d2c29d050bfad07162d7fc83dd36c82848/oamap-0.2.5.tar.gz"
      }
    ],
    "0.2.6": [
      {
        "comment_text": "",
        "digests": {
          "md5": "0b0b61f3eac763c5edf3a653d970855e",
          "sha256": "b29983a1cd50c49a2c4790307fd5d9485f882ac567cc6b657ccc8ef10ec30ae2"
        },
        "downloads": -1,
        "filename": "oamap-0.2.6.tar.gz",
        "has_sig": false,
        "md5_digest": "0b0b61f3eac763c5edf3a653d970855e",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 46419,
        "upload_time": "2018-01-03T14:51:23",
        "url": "https://files.pythonhosted.org/packages/0c/18/3b517764622ce7857cb6041d6b3d68035c128ab5b10c188b43d2d31ef5af/oamap-0.2.6.tar.gz"
      }
    ],
    "0.2.8": [
      {
        "comment_text": "",
        "digests": {
          "md5": "085c7becd98cdf9f77d423e32c15a5fa",
          "sha256": "5d39ee30b5b9a769d599da4f57b330c909dbfb88a44c690f6a9bc0a3ca3c3f25"
        },
        "downloads": -1,
        "filename": "oamap-0.2.8.tar.gz",
        "has_sig": false,
        "md5_digest": "085c7becd98cdf9f77d423e32c15a5fa",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 48549,
        "upload_time": "2018-01-03T16:23:23",
        "url": "https://files.pythonhosted.org/packages/8e/51/667d1a1a25ce91faa7bd3573cbe86c726ba1ac5a7fa2c1925eb0fbf846fc/oamap-0.2.8.tar.gz"
      }
    ],
    "0.3.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "d99fb95a3e2e670c8a7916b652d3eb99",
          "sha256": "9701331a2cd004c296305ce43e6e5d334508e844d2c4eb063b7e2fbd9108e2ad"
        },
        "downloads": -1,
        "filename": "oamap-0.3.1.tar.gz",
        "has_sig": false,
        "md5_digest": "d99fb95a3e2e670c8a7916b652d3eb99",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 49111,
        "upload_time": "2018-01-03T19:35:38",
        "url": "https://files.pythonhosted.org/packages/56/7b/a0810d3222ad20b3269770f3e718c6206fbb4ec34a2b204d770908758815/oamap-0.3.1.tar.gz"
      }
    ],
    "0.3.2": [
      {
        "comment_text": "",
        "digests": {
          "md5": "344a487e1c0a415433a68a2c5bb0caef",
          "sha256": "cb535d36f3e783d8f867e953b11a0832abb593d744512bfcbd98761f0eb6aa2a"
        },
        "downloads": -1,
        "filename": "oamap-0.3.2.tar.gz",
        "has_sig": false,
        "md5_digest": "344a487e1c0a415433a68a2c5bb0caef",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 49084,
        "upload_time": "2018-01-03T19:59:21",
        "url": "https://files.pythonhosted.org/packages/4d/43/dcee7e302a469db008c21ff4f04d3fe252893c7b80435739ba227d306ba8/oamap-0.3.2.tar.gz"
      }
    ],
    "0.3.3": [
      {
        "comment_text": "",
        "digests": {
          "md5": "a15274f8066a1bc8cc3aa5c1fac98a87",
          "sha256": "1f81d3204e9705669c0e13f6f689b2ca8861f4dddf5edf59aa7cd3e4254d1938"
        },
        "downloads": -1,
        "filename": "oamap-0.3.3.tar.gz",
        "has_sig": false,
        "md5_digest": "a15274f8066a1bc8cc3aa5c1fac98a87",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 52690,
        "upload_time": "2018-01-03T23:23:22",
        "url": "https://files.pythonhosted.org/packages/fd/54/3d3380a6f480bb6ec34ab95294f932d65745a46a638d8ee1c8b7a1cd9386/oamap-0.3.3.tar.gz"
      }
    ],
    "0.4.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "e3d4db65c2de17f3d013400a7b13953f",
          "sha256": "db90536a45a31faf5a3fa4293f8248c989708ffe582e2dbfa9185f7d3c78d2e2"
        },
        "downloads": -1,
        "filename": "oamap-0.4.1.tar.gz",
        "has_sig": false,
        "md5_digest": "e3d4db65c2de17f3d013400a7b13953f",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 66160,
        "upload_time": "2018-01-17T14:34:15",
        "url": "https://files.pythonhosted.org/packages/90/f9/a60c2bff54273a103441a31203724c88f3257c4ec2181fdd39df9b4c14dc/oamap-0.4.1.tar.gz"
      }
    ],
    "0.5.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "7b173ba5c1a3122e701d5de671d86b52",
          "sha256": "be21e1e03e3b613b13792d27babf2f9e15a06b0bda19645d201fafd41f9ff77d"
        },
        "downloads": -1,
        "filename": "oamap-0.5.0.tar.gz",
        "has_sig": false,
        "md5_digest": "7b173ba5c1a3122e701d5de671d86b52",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 72533,
        "upload_time": "2018-01-18T22:00:54",
        "url": "https://files.pythonhosted.org/packages/9f/68/aa57e5348ae6525c619ae945618f4a919bac926bfbfaf13b9f5d46c77cb7/oamap-0.5.0.tar.gz"
      }
    ],
    "0.6.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "51e416898d12bd6d099780b401c4d516",
          "sha256": "b546d35849399c8a0a2d21882934c246ee1c9afa415d4a5aaa01b14be2696e56"
        },
        "downloads": -1,
        "filename": "oamap-0.6.0.tar.gz",
        "has_sig": false,
        "md5_digest": "51e416898d12bd6d099780b401c4d516",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 75154,
        "upload_time": "2018-01-19T17:25:39",
        "url": "https://files.pythonhosted.org/packages/2d/8d/2ae4872c2edea0424015de70575b2dbd8a2d869eff8986a04169814af4e2/oamap-0.6.0.tar.gz"
      }
    ],
    "0.7.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "333c23a284925c4b041486a4cc8c9e74",
          "sha256": "ac1abfe2b637abcc775cd8689dd7e362a2dddbfaaca8fc523e4935bdb71c032c"
        },
        "downloads": -1,
        "filename": "oamap-0.7.0.tar.gz",
        "has_sig": false,
        "md5_digest": "333c23a284925c4b041486a4cc8c9e74",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 76764,
        "upload_time": "2018-01-19T22:29:25",
        "url": "https://files.pythonhosted.org/packages/7d/79/a20d0e7bd4fbd3dbfdfa0d364745902a86c454eb9af994a9b876358093d8/oamap-0.7.0.tar.gz"
      }
    ],
    "0.7.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "e07a60a92815e90c71a2c36ff00a0cfa",
          "sha256": "01b62a41114292e4a66974084af40dd3c6a4f3c7d57ec02420977c6afdc0187b"
        },
        "downloads": -1,
        "filename": "oamap-0.7.1.tar.gz",
        "has_sig": false,
        "md5_digest": "e07a60a92815e90c71a2c36ff00a0cfa",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 76763,
        "upload_time": "2018-01-19T22:55:14",
        "url": "https://files.pythonhosted.org/packages/c4/82/c66157ae5553efc1b19ef01960e6e3ce20996110a965ee0c726a4c495657/oamap-0.7.1.tar.gz"
      }
    ],
    "0.9.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "a2edb971f404341c61b44cbfbad9db42",
          "sha256": "9bc57f23fdf87dd006afd0900c1f202b65ef7e28ea6585b473a59d2a4ba7aff1"
        },
        "downloads": -1,
        "filename": "oamap-0.9.1.tar.gz",
        "has_sig": false,
        "md5_digest": "a2edb971f404341c61b44cbfbad9db42",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 84904,
        "upload_time": "2018-01-27T09:35:41",
        "url": "https://files.pythonhosted.org/packages/51/69/604060e5ffc6d1e912eff93c4ebae0d85b8b7a7ab8cc795e76b261ce4a29/oamap-0.9.1.tar.gz"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "23d6cf8bd61f46a5eaa9d58d5b88eb4f",
        "sha256": "373d5ab35609aa9eb4f4f6a667fd54e8fe71e0bff95630d1fb668f848b69727b"
      },
      "downloads": -1,
      "filename": "oamap-0.10.8.tar.gz",
      "has_sig": false,
      "md5_digest": "23d6cf8bd61f46a5eaa9d58d5b88eb4f",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 102621,
      "upload_time": "2018-02-02T18:40:43",
      "url": "https://files.pythonhosted.org/packages/37/b2/920412b95010786dcc78846a9f80c78caac34d1e4b888680dbf08cc4341c/oamap-0.10.8.tar.gz"
    }
  ]
}