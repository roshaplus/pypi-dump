{
  "info": {
    "author": "Edward Newell",
    "author_email": "edward.newell@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 3 - Alpha",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: MIT License",
      "Programming Language :: Python :: 2",
      "Programming Language :: Python :: 3",
      "Topic :: Software Development :: Build Tools"
    ],
    "description": "# iterable\\_queue\nPrepare to feel relaxed.  Last time was the last time you will muck around \nwith the unnecessarily messy logic of managing pools of producers and \nconsumers in multiprocessing python programs.\n\n## Install ##\n\n```bash\npip install iterable-queue\n```\n\n## Why? ##\n\nI don't know about you, but I'm sick of having to worry about managing the\ndetails of multiprocessing in python.  For example, suppose you have a \npool of *consumers* consuming tasks from a queue, which is being populated\nby a pool of *producers*.  Of course, you want the consumers to keep \npulling work from the queue as long as that queue isn't empty.\n\nThe tricky part is, if the consumers are fast, they may continually drive\nthe queue to empty even though the producers are still busy adding work.  So \nin general, the producers also need to know if the consumers are all \ndone.  This means using some kind of signalling, either within the \nqueue itself or through some side channel.  It also means keeping track, \nsomewhere,\nof how many producers are still working, and when all producers are \nfinished, notifying each consumer of that fact.\nThis means that, right inside the\nproducer and consumer code, you need to embed this signalling and tracking\nlogic, which is complicated and just feels wrong.  \n*And I'm just sick of it, I tell you.*\n\nHere's what I say: let the *queue* keep track of that stuff, so I can \nstick to writing the logic of production and consumption for\nmy producers and consumers.\n\n## Meet `IterableQueue` ##\n\n`IterableQueue` is a directed queue, which means that it has \n(arbitrarily many) *producer endpoints* and *consumer endpoints*.  This\ndirectedness enables `IterableQueue` to know how many producers and \nconsumers are still at work, and this lets it take care of the tracking\nand signalling necessary to tell the difference between being \ntemporarily empty, and being empty with no new work coming.  Because the\n`IterableQueue` knows when no new work is coming, it can be treated like\nan iterable on the consumer end, stopping iteration naturally when all work \nis complete.\n\nProducers use the queue much like a `multiprocessing.Queue`, but with one\nsmall variation: when they are done putting work on the queue, they call\n`queue.close()`:\n\n```python\nproducer_func(queue):\n\twhile some_condition:\n\t\t...\n\t\tqueue.put(some_work)\n\t\t...\n\tqueue.close()\n```\n\nThe beautiful part is in how consumers use the queue, which is somewhat\ndifferently than it is with `multiprocessing.Queue`: \nconsumers can simply treat the queue as an iterable:\n\n```python\nconsumer_func(queue):\n\tfor work in queue:\n\t\tdo_something_with(work)\n```\n\nBecause the `IterableQueue` knows how many producers and consumers are open,\nit knows when no more work will come through the queue, and so it can\nstop iteration transparently.\n\n(Although you can, if you choose, consume the queue \"manually\" by calling \n`queue.get()`, with `Queue.Empty` being raised whenever the queue is empty, and `iterable_queue.ConsumerQueueClosedException` being raised when the queue is empty with no more work coming.)\n\n## Use `IterableQueue` ##\nAs mentioned, `IterableQueue` is a directed queue, meaning that it has \nproducer and consumer endpoints.  Both wrap the same underlying \n`multiprocessing.Queue`, and expose *nearly* all of its methods.\nImportant exceptions are the `put()` and `get()` methods: you can only\n`put()` onto producer endpoints, and you can only `get()` from consumer \nendpoints.  This distinction is needed for the management of consumer \niteration to work automatically.\n\nTo see an example, let's setup a function that will be executed by \n*producers*, i.e. workers that *put onto* the queue:\n\n```python\nfrom random import random\nfrom time import sleep\n\ndef producer_func(queue, producer_id):\n\tfor i in range(10):\n\t\tsleep(random() / 100.0)\n\t\tqueue.put(producer_id)\n\tqueue.close()\n```\n\nNotice how the producer calls `queue.close()` when it's done putting\nstuff onto the queue.\n\nNow let's setup a consumer function:\n```python\ndef consumer_func(queue, consumer_id):\n\tfor item in queue:\n\t\tsleep(random() / 100.0)\n\t\tprint 'consumer %d saw item %d' % (consumer_id, item)\n```\n\nNotice again how the consumer treats the queue as an iterable&mdash;there \nis no need to worry about detecting a termination condition.\n\nNow, let's get some processes started.  First, we'll need an `IterableQueue`\nInstance:\n\n```python\nfrom iterable_queue import IterableQueue\niq = IterableQueue\n```\n\nNow, we just start an arbitrary number of producer and consumer \nprocesses.  We give *producer endpoints* to the producers, which we get\nby calling `IterableQueue.get_producer()`, and we give *consumer endpoints*\nto consumers by calling `IterableQueue.get_consumer()`:\n\n```python\nfrom multiprocessing import Process\n\n# Start a bunch of producers:\nfor producer_id in range(17):\n\t\n\t# Give each producer a \"producer-queue\"\n\tqueue = iq.get_producer()\n\tProcess(target=producer_func, args=(queue, producer_id)).start()\n\n# Start a bunch of consumers\nfor consumer_id in range(13):\n\n\t# Give each consumer a \"consumer-queue\"\n\tqueue = iq.get_consumer()\n\tProcess(target=consumer_func, args=(queue, consumer_id)).start()\n```\n\nFinally&mdash;and this is important&mdash;once we've finished making \nproducer and consumer endpoints, we close the `IterableQueue`:  \n\n```python\niq.close()\n```\n\nThis let's the `IterableQueue` know that no new producers will be coming \nonto the scene and adding more work.\n\nAnd we're done.  Notice the pleasant lack of signalling and keeping track \nof process completion, and notice the lack of `try ... except Empty` \nblocks: you just iterate through the queue, and when its done its done.\n\nYou can try the above example by running [`example.py`](https://github.com/enewe101/iterable_queue/blob/master/iterable_queue/example.py).",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "https://github.com/enewe101/iterable_queue",
    "keywords": "threading multiprocessing scheduling batch processing queue queueing",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "iterable-queue",
    "platform": "",
    "project_url": "https://pypi.org/project/iterable-queue/",
    "release_url": "https://pypi.org/project/iterable-queue/1.1.1/",
    "requires_python": "",
    "summary": "A queue for python that feels like an iterable and knows when its producers are finished",
    "version": "1.1.1"
  },
  "releases": {
    "0.1.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "4570ae332ba2e1c73dd04da84802a658",
          "sha256": "e2499fb5e1bd162c39caba7f013732031efa69f1f04646a3c7a5d07b9203f2c7"
        },
        "downloads": 556,
        "filename": "iterable-queue-0.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "4570ae332ba2e1c73dd04da84802a658",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 11491,
        "upload_time": "2016-05-04T17:09:57",
        "url": "https://files.pythonhosted.org/packages/a6/f9/66848d7fc66c742f64e450c2ab52dbff32cec389a7b4270aeb3a5f6a251b/iterable-queue-0.1.0.tar.gz"
      }
    ],
    "0.2.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "eaa123036be69979068e87a0aac1cc26",
          "sha256": "2f961ec34c4a9fd816ca801074d5272e0628b8d2e3213b4d842a1dcf2372698a"
        },
        "downloads": 46,
        "filename": "iterable-queue-0.2.0.tar.gz",
        "has_sig": false,
        "md5_digest": "eaa123036be69979068e87a0aac1cc26",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 11539,
        "upload_time": "2017-01-02T05:14:44",
        "url": "https://files.pythonhosted.org/packages/92/3e/5a276edadf9a681cb1c4ee0595a2a02d17d8f0e511bab35abccaf76b1ccb/iterable-queue-0.2.0.tar.gz"
      }
    ],
    "0.2.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "065547eea3ae942b0a276ea626254bfd",
          "sha256": "de1e61d5a35e9d070c42e89a4c9aff59c3eb78791e3c4776884af141703e35fa"
        },
        "downloads": 57,
        "filename": "iterable-queue-0.2.1.tar.gz",
        "has_sig": false,
        "md5_digest": "065547eea3ae942b0a276ea626254bfd",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 11546,
        "upload_time": "2017-01-02T05:27:22",
        "url": "https://files.pythonhosted.org/packages/4a/d1/536b9a069dfce173300ec752e152b146a09732da9f2f3e976e990481b98d/iterable-queue-0.2.1.tar.gz"
      }
    ],
    "1.0.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "3a9dac6f963d42efae241d1c281fa118",
          "sha256": "ea4f45aedafdb97154249aee1324e62908c947af5bbc25068721bbae11cded05"
        },
        "downloads": 11,
        "filename": "iterable-queue-1.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "3a9dac6f963d42efae241d1c281fa118",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 11614,
        "upload_time": "2017-01-17T02:49:49",
        "url": "https://files.pythonhosted.org/packages/94/05/2e1b03d9674b6d8576346c43b678c7269d73f3ca040bf5b4b8060ee4b53e/iterable-queue-1.0.0.tar.gz"
      }
    ],
    "1.1.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "5117437d2098c07c8f5440263de6b7fd",
          "sha256": "2aa3298ad04efbf8993bd6ff0e454a62290328fa843f99f14ce689b79633732d"
        },
        "downloads": 13,
        "filename": "iterable-queue-1.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "5117437d2098c07c8f5440263de6b7fd",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 12255,
        "upload_time": "2017-01-31T07:43:13",
        "url": "https://files.pythonhosted.org/packages/6e/4c/3f494208c6d267ad7c606354f02af52e55957cd78fefee32682d251a69b8/iterable-queue-1.1.0.tar.gz"
      }
    ],
    "1.1.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "f8eee012e6033a1fe550145514b55091",
          "sha256": "4f564bb0092ad8c069706351012c39de59ad46bec018d91cc85ecdfd1448d2bd"
        },
        "downloads": 18,
        "filename": "iterable-queue-1.1.1.tar.gz",
        "has_sig": false,
        "md5_digest": "f8eee012e6033a1fe550145514b55091",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 12249,
        "upload_time": "2017-01-31T07:48:43",
        "url": "https://files.pythonhosted.org/packages/87/7f/66108b6b3e89a3149ee9c66cc99c4aeb8c2151ff092c1999cd1a104d4a8a/iterable-queue-1.1.1.tar.gz"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "f8eee012e6033a1fe550145514b55091",
        "sha256": "4f564bb0092ad8c069706351012c39de59ad46bec018d91cc85ecdfd1448d2bd"
      },
      "downloads": 18,
      "filename": "iterable-queue-1.1.1.tar.gz",
      "has_sig": false,
      "md5_digest": "f8eee012e6033a1fe550145514b55091",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 12249,
      "upload_time": "2017-01-31T07:48:43",
      "url": "https://files.pythonhosted.org/packages/87/7f/66108b6b3e89a3149ee9c66cc99c4aeb8c2151ff092c1999cd1a104d4a8a/iterable-queue-1.1.1.tar.gz"
    }
  ]
}