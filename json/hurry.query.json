{
  "info": {
    "author": "Infrae",
    "author_email": "faassen@startifact.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Environment :: Web Environment",
      "Framework :: Zope3",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: Zope Public License",
      "Natural Language :: English",
      "Operating System :: OS Independent",
      "Programming Language :: Python",
      "Topic :: Internet :: WWW/HTTP"
    ],
    "description": "Hurry Query\n===========\n\nThe hurry query system for the zope.catalog builds on its catalog\nindexes, as well as the indexes in zc.catalog. It is in part inspired\nby AdvancedQuery for Zope 2 by Dieter Maurer, though has an independent\norigin.\n\n.. contents::\n\nSetup\n-----\n\nLet's define a simple content object. First its interface::\n\n  >>> from zope.interface import Interface, Attribute, implements\n  >>> class IContent(Interface):\n  ...     f1 = Attribute('f1')\n  ...     f2 = Attribute('f2')\n  ...     f3 = Attribute('f3')\n  ...     f4 = Attribute('f4')\n  ...     t1 = Attribute('t1')\n  ...     t2 = Attribute('t2')\n\nAnd its implementation::\n\n  >>> from zope.container.contained import Contained\n  >>> class Content(Contained):\n  ...     implements(IContent)\n  ...     def __init__(self, id, f1='', f2='', f3='', f4='', t1='', t2=''):\n  ...         self.id = id\n  ...         self.f1 = f1\n  ...         self.f2 = f2\n  ...         self.f3 = f3\n  ...         self.f4 = f4\n  ...         self.t1 = t1\n  ...         self.t2 = t2\n  ...     def __cmp__(self, other):\n  ...         return cmp(self.id, other.id)\n\nThe id attribute is just so we can identify objects we find again\neasily. By including the __cmp__ method we make sure search results\ncan be stably sorted.\n\nWe use a fake int id utility here so we can test independent of\nthe full-blown zope environment::\n\n  >>> from zope import interface\n  >>> import zope.intid.interfaces\n  >>> class DummyIntId(object):\n  ...     interface.implements(zope.intid.interfaces.IIntIds)\n  ...     MARKER = '__dummy_int_id__'\n  ...     def __init__(self):\n  ...         self.counter = 0\n  ...         self.data = {}\n  ...     def register(self, obj):\n  ...         intid = getattr(obj, self.MARKER, None)\n  ...         if intid is None:\n  ...             setattr(obj, self.MARKER, self.counter)\n  ...             self.data[self.counter] = obj\n  ...             intid = self.counter\n  ...             self.counter += 1\n  ...         return intid\n  ...     def getId(self, obj):\n  ...         return getattr(obj, self.MARKER)\n  ...     def getObject(self, intid):\n  ...         return self.data[intid]\n  ...     def __iter__(self):\n  ...         return iter(self.data)\n  >>> intid = DummyIntId()\n  >>> from zope.component import provideUtility\n  >>> provideUtility(intid, zope.intid.interfaces.IIntIds)\n\nNow let's register a catalog::\n\n  >>> from zope.catalog.interfaces import ICatalog\n  >>> from zope.catalog.catalog import Catalog\n  >>> catalog = Catalog()\n  >>> provideUtility(catalog, ICatalog, 'catalog1')\n\nAnd set it up with various indexes::\n\n  >>> from zope.catalog.field import FieldIndex\n  >>> from zope.catalog.text import TextIndex\n  >>> catalog['f1'] = FieldIndex('f1', IContent)\n  >>> catalog['f2'] = FieldIndex('f2', IContent)\n  >>> catalog['f3'] = FieldIndex('f3', IContent)\n  >>> catalog['f4'] = FieldIndex('f4', IContent)\n  >>> catalog['t1'] = TextIndex('t1', IContent)\n  >>> catalog['t2'] = TextIndex('t2', IContent)\n\nNow let's create some objects so that they'll be cataloged::\n\n  >>> content = [\n  ... Content(1, 'a', 'b', 'd'),\n  ... Content(2, 'a', 'c'),\n  ... Content(3, 'X', 'c'),\n  ... Content(4, 'a', 'b', 'e'),\n  ... Content(5, 'X', 'b', 'e'),\n  ... Content(6, 'Y', 'Z')]\n\nAnd catalog them now::\n\n  >>> for entry in content:\n  ...     catalog.index_doc(intid.register(entry), entry)\n\nNow let's register a query utility::\n\n  >>> from hurry.query.query import Query\n  >>> from hurry.query.interfaces import IQuery\n  >>> provideUtility(Query(), IQuery)\n\nSet up some code to make querying and display the result\neasy::\n\n  >>> from zope.component import getUtility\n  >>> from hurry.query.interfaces import IQuery\n  >>> def displayQuery(q, context=None):\n  ...     query = getUtility(IQuery)\n  ...     r = query.searchResults(q, context)\n  ...     return [e.id for e in sorted(list(r))]\n\nFieldIndex Queries\n------------------\n\nWe can query for all objects indexed in this index::\n\n  >>> from hurry.query import All\n  >>> f1 = ('catalog1', 'f1')\n  >>> displayQuery(All(f1))\n  [1, 2, 3, 4, 5, 6]\n\nNow for a query where f1 equals a::\n\n  >>> from hurry.query import Eq\n  >>> f1 = ('catalog1', 'f1')\n  >>> displayQuery(Eq(f1, 'a'))\n  [1, 2, 4]\n\nNot equals (this is more efficient than the generic ~ operator)::\n\n  >>> from hurry.query import NotEq\n  >>> displayQuery(NotEq(f1, 'a'))\n  [3, 5, 6]\n\nTesting whether a field is in a set::\n\n  >>> from hurry.query import In\n  >>> displayQuery(In(f1, ['a', 'X']))\n  [1, 2, 3, 4, 5]\n\nWhether documents are in a specified range::\n\n  >>> from hurry.query import Between\n  >>> displayQuery(Between(f1, 'X', 'Y'))\n  [3, 5, 6]\n\nYou can leave out one end of the range::\n\n  >>> displayQuery(Between(f1, 'X', None)) # 'X' < 'a'\n  [1, 2, 3, 4, 5, 6]\n  >>> displayQuery(Between(f1, None, 'X'))\n  [3, 5]\n\nYou can also use greater-equals and lesser-equals for the same purpose::\n\n  >>> from hurry.query import Ge, Le\n  >>> displayQuery(Ge(f1, 'X'))\n  [1, 2, 3, 4, 5, 6]\n  >>> displayQuery(Le(f1, 'X'))\n  [3, 5]\n\nIt's also possible to use not with the ~ operator::\n\n  >>> displayQuery(~Eq(f1, 'a'))\n  [3, 5, 6]\n\nUsing and (&)::\n\n  >>> f2 = ('catalog1', 'f2')\n  >>> displayQuery(Eq(f1, 'a') & Eq(f2, 'b'))\n  [1, 4]\n\nUsing or (|)::\n\n  >>> displayQuery(Eq(f1, 'a') | Eq(f2, 'b'))\n  [1, 2, 4, 5]\n\nThese can be chained::\n\n  >>> displayQuery(Eq(f1, 'a') & Eq(f2, 'b') & Between(f1, 'a', 'b'))\n  [1, 4]\n  >>> displayQuery(Eq(f1, 'a') | Eq(f1, 'X') | Eq(f2, 'b'))\n  [1, 2, 3, 4, 5]\n\nAnd nested::\n\n  >>> displayQuery((Eq(f1, 'a') | Eq(f1, 'X')) & (Eq(f2, 'b') | Eq(f2, 'c')))\n  [1, 2, 3, 4, 5]\n\n\"and\" and \"or\" can also be spelled differently::\n\n  >>> from hurry.query import And, Or\n  >>> displayQuery(And(Eq(f1, 'a'), Eq(f2, 'b')))\n  [1, 4]\n  >>> displayQuery(Or(Eq(f1, 'a'), Eq(f2, 'b')))\n  [1, 2, 4, 5]\n\nCombination of In and &\n-----------------------\n\nA combination of 'In' and '&'::\n\n  >>> displayQuery(In(f1, ['a', 'X', 'Y', 'Z']))\n  [1, 2, 3, 4, 5, 6]\n  >>> displayQuery(In(f1, ['Z']))\n  []\n  >>> displayQuery(In(f1, ['a', 'X', 'Y', 'Z']) & In(f1, ['Z']))\n  []\n\n\nSetIndex queries\n----------------\n\nThe SetIndex is defined in zc.catalog. Let's make a catalog which uses\nit::\n\n  >>> intid = DummyIntId()\n  >>> provideUtility(intid, zope.intid.interfaces.IIntIds)\n  >>> from zope.catalog.interfaces import ICatalog\n  >>> from zope.catalog.catalog import Catalog\n  >>> catalog = Catalog()\n  >>> provideUtility(catalog, ICatalog, 'catalog1')\n  >>> from zc.catalog.catalogindex import SetIndex\n  >>> catalog['f1'] = SetIndex('f1', IContent)\n  >>> catalog['f2'] = FieldIndex('f2', IContent)\n\nFirst let's set up some new data::\n\n  >>> content = [\n  ... Content(1, ['a', 'b', 'c'], 1),\n  ... Content(2, ['a'], 1),\n  ... Content(3, ['b'], 1),\n  ... Content(4, ['c', 'd'], 2),\n  ... Content(5, ['b', 'c'], 2),\n  ... Content(6, ['a', 'c'], 2),\n  ... Content(7, ['z'], 2),\n  ... Content(8, [], 2)]  # no value, so not indexed.\n\nAnd catalog them now::\n\n  >>> for entry in content:\n  ...     catalog.index_doc(intid.register(entry), entry)\n\nWe can query for all indexes objects:\n\n  >>> from hurry.query.set import All\n  >>> displayQuery(All(f1))\n  [1, 2, 3, 4, 5, 6, 7]\n\nNow do a a 'any of' query, which returns all documents that\ncontain any of the values listed::\n\n  >>> from hurry.query.set import AnyOf\n  >>> displayQuery(AnyOf(f1, ['a', 'c']))\n  [1, 2, 4, 5, 6]\n  >>> displayQuery(AnyOf(f1, ['c', 'b']))\n  [1, 3, 4, 5, 6]\n  >>> displayQuery(AnyOf(f1, ['a']))\n  [1, 2, 6]\n\nDo a 'all of' query, which returns all documents that\ncontain all of the values listed::\n\n  >>> from hurry.query.set import AllOf\n  >>> displayQuery(AllOf(f1, ['a']))\n  [1, 2, 6]\n  >>> displayQuery(AllOf(f1, ['a', 'b']))\n  [1]\n  >>> displayQuery(AllOf(f1, ['a', 'c']))\n  [1, 6]\n\nWe can combine this with other queries::\n\n  >>> displayQuery(AnyOf(f1, ['a']) & Eq(f2, 1))\n  [1, 2]\n\n\nValueIndex queries\n------------------\n\nThe ``ValueIndex`` is defined in ``zc.catalog`` and provides a generalization\nof the standard field index.\n\n  >>> from hurry.query import value\n\nLet's set up a catalog that uses this index. The ``ValueIndex`` is defined in\n``zc.catalog``. Let's make a catalog which uses it:\n\n  >>> intid = DummyIntId()\n  >>> provideUtility(intid, zope.intid.interfaces.IIntIds)\n\n  >>> from zope.catalog.interfaces import ICatalog\n  >>> from zope.catalog.catalog import Catalog\n  >>> catalog = Catalog()\n  >>> provideUtility(catalog, ICatalog, 'catalog1')\n\n  >>> from zc.catalog.catalogindex import ValueIndex\n  >>> catalog['f1'] = ValueIndex('f1', IContent)\n\nNext we set up some content data to fill the indices:\n\n  >>> content = [\n  ... Content(1, 'a'),\n  ... Content(2, 'b'),\n  ... Content(3, 'c'),\n  ... Content(4, 'd'),\n  ... Content(5, 'c'),\n  ... Content(6, 'a')]\n\nAnd catalog them now:\n\n  >>> for entry in content:\n  ...     catalog.index_doc(intid.register(entry), entry)\n\nWe query for all indexes objects::\n\n  >>> f1 = ('catalog1', 'f1')\n  >>> displayQuery(value.All(f1))\n  [1, 2, 3, 4, 5, 6]\n\nLet's now query for all objects where ``f1`` equals 'a':\n\n  >>> f1 = ('catalog1', 'f1')\n  >>> displayQuery(value.Eq(f1, 'a'))\n  [1, 6]\n\nNext, let's find all objects where ``f1`` does not equal 'a'; this is more\nefficient than the generic ``~`` operator:\n\n  >>> displayQuery(value.NotEq(f1, 'a'))\n  [2, 3, 4, 5]\n\nIf all the items in the catalog satisfy the NotEq condition, the query\ndoes not crash.\n\n  >>> displayQuery(value.NotEq(f1, 'z'))\n  [1, 2, 3, 4, 5, 6]\n\nYou can also query for all objects where the value of ``f1`` is in a set of\nvalues:\n\n  >>> displayQuery(value.In(f1, ['a', 'd']))\n  [1, 4, 6]\n\nThe next interesting set of queries allows you to make evaluations of the\nvalues. For example, you can ask for all objects between a certain set of\nvalues:\n\n  >>> displayQuery(value.Between(f1, 'a', 'c'))\n  [1, 2, 3, 5, 6]\n\n  >>> displayQuery(value.Between(f1, 'a', 'c', exclude_min=True))\n  [2, 3, 5]\n\n  >>> displayQuery(value.Between(f1, 'a', 'c', exclude_max=True))\n  [1, 2, 6]\n\n  >>> displayQuery(value.Between(f1, 'a', 'c',\n  ...                            exclude_min=True, exclude_max=True))\n  [2]\n\nYou can also leave out one end of the range:\n\n  >>> displayQuery(value.Between(f1, 'c', None))\n  [3, 4, 5]\n  >>> displayQuery(value.Between(f1, None, 'c'))\n  [1, 2, 3, 5, 6]\n\nYou can also use greater-equals and lesser-equals for the same purpose:\n\n  >>> displayQuery(value.Ge(f1, 'c'))\n  [3, 4, 5]\n  >>> displayQuery(value.Le(f1, 'c'))\n  [1, 2, 3, 5, 6]\n\nOf course, you can chain those queries with the others as demonstrated before.\n\nThe ``value`` module also supports ``zc.catalog`` extents. The first query is\n``ExtentAny``, which returns all douments matching the extent. If the the\nextent is ``None``, all document ids are returned:\n\n  >>> displayQuery(value.ExtentAny(f1, None))\n  [1, 2, 3, 4, 5, 6]\n\nIf we now create an extent that is only in the scope of the first four\ndocuments,\n\n  >>> from zc.catalog.extentcatalog import FilterExtent\n  >>> extent = FilterExtent(lambda extent, uid, obj: True)\n  >>> for i in range(4):\n  ...     extent.add(i, i)\n\nthen only the first four are returned:\n\n  >>> displayQuery(value.ExtentAny(f1, extent))\n  [1, 2, 3, 4]\n\nThe opposite query is the ``ExtentNone`` query, which returns all ids in the\nextent that are *not* in the index:\n\n  >>> id = intid.register(Content(7, 'b'))\n  >>> id = intid.register(Content(8, 'c'))\n  >>> id = intid.register(Content(9, 'a'))\n\n  >>> extent = FilterExtent(lambda extent, uid, obj: True)\n  >>> for i in range(9):\n  ...     extent.add(i, i)\n\n  >>> displayQuery(value.ExtentNone(f1, extent))\n  [7, 8, 9]\n\n\nQuerying different indexes\n--------------------------\n\nIt's possible to specify the context when creating a query. This context\ndetermines which index will be searched.\n\nFirst setup a second registry and second catalog and populate it.\n\n  >>> catalog2 = Catalog()\n  >>> from zope.component.registry import Components\n  >>> import zope.component.interfaces\n  >>> import zope.interface\n  >>> intid1 = DummyIntId()\n  >>> class MockSite(object):\n  ...     zope.interface.implements(zope.component.interfaces.IComponentLookup)\n  ...     def __init__(self):\n  ...         self.registry = Components('components')\n  ...     def queryUtility(self, interface, name='', default=None):\n  ...         if name == '': return intid1\n  ...         else: return catalog2\n  ...     def getSiteManager(self):\n  ...         return self.registry\n  >>> from zope.component.hooks import setSite\n  >>> site1 = MockSite()\n  >>> setSite(site1)\n  >>> catalog2['f1'] = FieldIndex('f1', IContent)\n  >>> content = [\n  ... Content(1,'A'),\n  ... Content(2,'B'),]\n  >>> for entry in content:\n  ...     catalog2.index_doc(intid1.register(entry), entry)\n\nNow we can query this catalog by specifying the context:\n\n  >>> query = getUtility(IQuery)\n  >>> displayQuery(Eq(f1, 'A'), context=site1)\n  [1]\n\n  >>> displayQuery(In(f1, ['A', 'B']), context=site1)\n  [1, 2]\n\nSorting and limiting the results\n--------------------------------\n\nIt's possible to have the resultset sorted on one of the fields in the query.\n\n  >>> catalog = Catalog()\n  >>> provideUtility(catalog, ICatalog, 'catalog1')\n  >>> catalog['f1'] = FieldIndex('f1', IContent)\n  >>> catalog['f2'] = FieldIndex('f2', IContent)\n  >>> catalog['t'] = TextIndex('t1', IContent)\n\nFirst let's set up some new data::\n\n  >>> content = [\n  ... Content(1, 'a', 2, t1='Beautiful is better than ugly.'),\n  ... Content(2, 'a', 3, t1='Explicit is better than implicit'),\n  ... Content(3, 'b', 9, t1='Simple is better than complex'),\n  ... Content(4, 'c', 8, t1='Complex is better than complicated'),\n  ... Content(5, 'c', 7, t1='Readability counts'),\n  ... Content(6, 'a', 1, t1='Although practicality beats purity')]\n\nAnd catalog them now::\n\n  >>> for entry in content:\n  ...     catalog.index_doc(intid.register(entry), entry)\n\nDefine a convenience function for quickly displaying a result set without\nperforming any sorting here ourselves.\n\n  >>> def displayResult(q, context=None, **kw):\n  ...     query = getUtility(IQuery)\n  ...     r = query.searchResults(q, context, **kw)\n  ...     return [e.id for e in r]\n\nWithout using sorting in the query itself, the resultset has an undefined\norder. We \"manually\" sort the results here to have something testable.\n\n  >>> f1 = ('catalog1', 'f1')\n  >>> [r for r in sorted(displayResult(Eq(f1, 'a')))]\n  [1, 2, 6]\n\nNow we sort on the f2 index.\n\n  >>> f1 = ('catalog1', 'f1')\n  >>> displayResult(Eq(f1, 'a'), sort_field=('catalog1', 'f2'))\n  [6, 1, 2]\n\nReverse the order.\n\n  >>> f1 = ('catalog1', 'f1')\n  >>> displayResult(Eq(f1, 'a'), sort_field=('catalog1', 'f2'), reverse=True)\n  [2, 1, 6]\n\nWe can limit the amount of found items.\n\n  >>> f1 = ('catalog1', 'f1')\n  >>> displayResult(Eq(f1, 'a'), sort_field=('catalog1', 'f2'), limit=2)\n  [6, 1]\n\nWe can limit the reversed resultset too.\n\n  >>> f1 = ('catalog1', 'f1')\n  >>> displayResult(\n  ...   Eq(f1, 'a'), sort_field=('catalog1', 'f2'), limit=2, reverse=True)\n  [2, 1]\n\nWhenever a field is used for sorting that does not support is, an error is\nraised.\n\n  >>> f1 = ('catalog1', 'f1')\n  >>> displayResult(Eq(f1, 'a'), sort_field=('catalog1', 't'))\n  Traceback (most recent call last):\n  ...\n  ValueError: Index t in catalog catalog1 does not support sorting.\n\nThe resultset can still be reversed and limited even if there's no sort_field\ngiven (Note that the actual order of the result set when not using explicit\nsorting is not defined. In this test it is assumed that the natural order of\nthe tested index is deterministic enough to be used as a proper test).\n\n  >>> f1 = ('catalog1', 'f1')\n  >>> displayResult(Eq(f1, 'a'), limit=2)\n  [1, 2]\n\n  >>> f1 = ('catalog1', 'f1')\n  >>> displayResult(Eq(f1, 'a'), start=1)\n  [2, 6]\n\n  >>> f1 = ('catalog1', 'f1')\n  >>> displayResult(Eq(f1, 'a'), start=1, limit=1)\n  [2]\n\n  >>> f1 = ('catalog1', 'f1')\n  >>> displayResult(Eq(f1, 'a'), limit=2, reverse=True)\n  [6, 2]\n\n\nText index\n----------\n\nYou can search on text, here all the items that contains better::\n\n  >>> from hurry.query import Text\n  >>> t1 = ('catalog1', 't')\n  >>> displayResult(Text(t1, 'better'))\n  [1, 2, 3, 4]\n\nInvalid text query returns an empty results::\n\n  >>> displayResult(Text(t1, '?*'))\n  []\n\n\nOther terms\n-----------\n\nYou can do differences, here all the items that contains better but do\nhave a as f1::\n\n  >>> from hurry.query import Difference\n  >>> displayResult(Difference(Text(t1, 'better'), Eq(f1, 'a')))\n  [3, 4]\n\n\nThere is a special term that allows to mix objects with catalog\nqueries::\n\n  >>> from hurry.query import Objects\n  >>> displayResult(Objects(content))\n  [1, 2, 3, 4, 5, 6]\n\n\nCHANGES\n=======\n\n2.4 (2017-06-22)\n----------------\n\n- Don't throw a TypeError slicing unsorted results, fixes #6\n\n2.3 (2017-04-26)\n----------------\n\n- Define a \"no result\" result object, useful for case where application code\n  has an custom API for building query terms, but this application code\n  decides there is no query. Callers might still expect a result-like\n  object.\n\n2.2 (2017-04-26)\n----------------\n\n- The caching option to searchResults now accepts a dict-like value and it\n  will use that to allow for caching results over multiple searchResults()\n  calls. The cache invalidation then is the responsibility of the caller.\n\n2.1 (2017-02-07)\n----------------\n\n- Add the possibility to time how long a query takes. It can be\n  controlled with the new ``timing`` option to ``searchResults`` or\n  the ``HURRY_QUERY_TIMING`` environment variable.\n\n2.0.1 (2016-09-08)\n------------------\n\n- Fix log line in Text term for invalid text search.\n\n2.0 (2016-09-07)\n----------------\n\n- Add new term: Difference. It does a difference between the first and\n  the following terms passed as arguments.\n\n- Add new term: Objects. It creates a result out of the objects passed\n  in arguments. It let you mix real objects with existing catalog\n  queries (with And, Or or Difference for instance).\n\n- Add an option start to searchResult to skip the first results in the\n  results set.\n\n- Extend the result from searchResult. You have addition information\n  on the result, including the total number of results without\n  start/limit restriction. A method called first() return only the\n  first result if available or none.\n\n- Add an option caching to searchResult to cache the result of each\n  terms within a Zope transaction, speeding similar queries. If\n  disabled, terms will still be cached within the same query.\n\n\n1.2 (2015-12-16)\n----------------\n\n* Add support for an All query.\n\n1.1.1 (2012-06-22)\n------------------\n\n* ExtentNone in set.py missed a parameter ``index_id``. Thanks to Danilo\n  Botelho for the bug report.\n\n1.1.0 (2010-07-12)\n------------------\n\n* Allow the searchResults method of a Query to take an additional keyword\n  argument `sort_field` that defines that defines (catalog_name, index_name) to\n  sort on. That index in that catalog should implement IIndexSort.\n\n  In addition to this keyword argument, `limit` and `reverse` keyword arguments\n  can be passed too, that will limit the sorted resultset and/or reverse its\n  order.\n\n* Allow the searchResults method of a Query object to take an additional\n  optional context argument. This context will determine which catalog\n  the search is performed on.\n\n1.0.0 (2009-11-30)\n------------------\n\n* Refresh dependencies. Use zope.catalog and zope.intid instead of\n  zope.app.catalog and zope.app.intid respectively. Don't zope.app.zapi.\n\n* Make package description more modern.\n\n* Clean up the code style.\n\n0.9.3 (2008-09-29)\n------------------\n\n* BUG: NotEq query no longer fails when all values in the index\n  satisfy the NotEq condition.\n\n0.9.2 (2006-09-22)\n------------------\n\n* First release on the cheeseshop.\n\n0.9.1 (2006-06-16)\n------------------\n\n* Make zc.catalog a dependency of hurry.query.\n\n0.9 (2006-05-16)\n----------------\n\n* Separate hurry.query from the other hurry packages. Eggification work.\n\n* Support for ValueIndex from zc.catalog.\n\n0.8 (2006-05-01)\n----------------\n\nInitial public release.\n",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "http://pypi.python.org/pypi/hurry.query",
    "keywords": "zope zope3 catalog index query",
    "license": "ZPL 2.1",
    "maintainer": "",
    "maintainer_email": "",
    "name": "hurry.query",
    "platform": "",
    "project_url": "https://pypi.org/project/hurry.query/",
    "release_url": "https://pypi.org/project/hurry.query/2.4/",
    "requires_python": "",
    "summary": "Higher level query system for the zope.catalog",
    "version": "2.4"
  },
  "releases": {
    "0.9.2": [
      {
        "comment_text": "",
        "digests": {
          "md5": "1a65812bdd91b61df08993028693edd5",
          "sha256": "23acd85a4c90f171482687dd0814eff273d586b2e3d53ba4e866a30c64f20ba3"
        },
        "downloads": 5768,
        "filename": "hurry.query-0.9.2-py2.4.egg",
        "has_sig": false,
        "md5_digest": "1a65812bdd91b61df08993028693edd5",
        "packagetype": "bdist_egg",
        "python_version": "2.4",
        "size": 15009,
        "upload_time": "2006-09-22T16:30:24",
        "url": "https://files.pythonhosted.org/packages/0b/45/9bf61bf0509ddb3f49feea1a32739d080e91ad3ddee042d4402b56c7a219/hurry.query-0.9.2-py2.4.egg"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "bf415b239fbe370eab368c604a2f4a96",
          "sha256": "bc55ca80504a1bee85dc7323a8837bf01fa1dbedc42a1b35db1c716ddd2fc501"
        },
        "downloads": 4329,
        "filename": "hurry.query-0.9.2.tar.gz",
        "has_sig": false,
        "md5_digest": "bf415b239fbe370eab368c604a2f4a96",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 7713,
        "upload_time": "2006-09-22T16:30:18",
        "url": "https://files.pythonhosted.org/packages/3e/82/8e95ed2c47f772323ccdacd43ab310f46a848d0bbed49f6acd8c727510db/hurry.query-0.9.2.tar.gz"
      }
    ],
    "1.0.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "6376819e6a1aff315d1bbca7b5e63790",
          "sha256": "07b944ddc05774e6171b3632fed967ac1a90fadff6c2c11cb2be5e464f30a1ae"
        },
        "downloads": 3765,
        "filename": "hurry.query-1.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "6376819e6a1aff315d1bbca7b5e63790",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 12699,
        "upload_time": "2009-11-30T17:08:17",
        "url": "https://files.pythonhosted.org/packages/5f/9d/459d6011a6fa91a8fd93b4447cca8851a5fb1d5d7606d552183e0420f17b/hurry.query-1.0.0.tar.gz"
      }
    ],
    "1.1.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "e5acf63d8e1ecccc7a9c02a957f05b3f",
          "sha256": "eff5b70c23038b4d8712268fb4732c9367a380f6a2721508bd1b9d106763327b"
        },
        "downloads": 4104,
        "filename": "hurry.query-1.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "e5acf63d8e1ecccc7a9c02a957f05b3f",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 17595,
        "upload_time": "2010-07-12T08:21:24",
        "url": "https://files.pythonhosted.org/packages/1f/a1/5b8411d1fa14d9a634988d6fbb88d31daafc27fd95ed43be8f9f6ba19027/hurry.query-1.1.0.tar.gz"
      }
    ],
    "1.1.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "be22c3a1b5247a3536355d084c080a62",
          "sha256": "8d3742430c51e3d5bf7b4e13c77629f9c23c51aef0cb68d9b71a00ca14ca05f6"
        },
        "downloads": 3920,
        "filename": "hurry.query-1.1.1.tar.gz",
        "has_sig": false,
        "md5_digest": "be22c3a1b5247a3536355d084c080a62",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 24129,
        "upload_time": "2012-06-22T15:19:17",
        "url": "https://files.pythonhosted.org/packages/bf/7c/2bc6f343734a3759b9bcee494941cfce5a8120b37d2b1ee22c7a8422a686/hurry.query-1.1.1.tar.gz"
      }
    ],
    "1.2": [
      {
        "comment_text": "",
        "digests": {
          "md5": "9fad10d1f6862f398b971cafe63bc4a7",
          "sha256": "bdf74ed71b5d2b4950592ed3ed620e621509ac1dd77591ffb88ae1e430761962"
        },
        "downloads": 497,
        "filename": "hurry.query-1.2.tar.gz",
        "has_sig": false,
        "md5_digest": "9fad10d1f6862f398b971cafe63bc4a7",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 22053,
        "upload_time": "2015-12-16T16:27:03",
        "url": "https://files.pythonhosted.org/packages/07/b5/52b869476ba399a972f28cfb492fbb71ea9c424389019fc80da0b78f06fd/hurry.query-1.2.tar.gz"
      }
    ],
    "2.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "161f4dc8348cf7f9ce6b74935e673052",
          "sha256": "84efbadfd69e2fc029ed8452bc74d91aea792894d680d64df76018f7735adc25"
        },
        "downloads": 143,
        "filename": "hurry.query-2.0.tar.gz",
        "has_sig": false,
        "md5_digest": "161f4dc8348cf7f9ce6b74935e673052",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 25219,
        "upload_time": "2016-09-07T15:00:11",
        "url": "https://files.pythonhosted.org/packages/73/17/37db379837a160e37771ae43e41aac3d9ac4ce8cb8c48542df1f500f8a2c/hurry.query-2.0.tar.gz"
      }
    ],
    "2.0.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "d526b524610e99fbe59c9de7f8dcf2cd",
          "sha256": "7d8340f656f2222e0bbfa74d43cbe9c03b2ff3d1dacb0ff754345c012eee3cb8"
        },
        "downloads": 214,
        "filename": "hurry.query-2.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "d526b524610e99fbe59c9de7f8dcf2cd",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 25473,
        "upload_time": "2016-09-08T07:13:58",
        "url": "https://files.pythonhosted.org/packages/b1/8b/f6c91e7a4c449670cb7ca270af691d80061858c77411085029bc499a2d9c/hurry.query-2.0.1.tar.gz"
      }
    ],
    "2.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "89f5de37268064909b744f4ab1f19c65",
          "sha256": "7a657accaba74c614d2f1bf7983ad2a21c7282691928af52ebb1e8c3aeff4d95"
        },
        "downloads": 14,
        "filename": "hurry.query-2.1.tar.gz",
        "has_sig": false,
        "md5_digest": "89f5de37268064909b744f4ab1f19c65",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 27002,
        "upload_time": "2017-02-07T08:39:47",
        "url": "https://files.pythonhosted.org/packages/cb/98/45bc67d0ad110cb038d2285ca0552a725b9e63333e7ee9b09d6d0fdfded8/hurry.query-2.1.tar.gz"
      }
    ],
    "2.2": [
      {
        "comment_text": "",
        "digests": {
          "md5": "43d6ab56c1ba063d3c96c03c30791470",
          "sha256": "13563a2ea8c70cd837007aba7120726b3c0e462597a99245680517ebbb1f103e"
        },
        "downloads": 0,
        "filename": "hurry.query-2.2.tar.gz",
        "has_sig": false,
        "md5_digest": "43d6ab56c1ba063d3c96c03c30791470",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 25568,
        "upload_time": "2017-04-26T09:15:12",
        "url": "https://files.pythonhosted.org/packages/eb/47/e5596a0db5e5b85ea6f8e8d734719bf6ecec058eccd2fd0f985e9a43cb11/hurry.query-2.2.tar.gz"
      }
    ],
    "2.3": [
      {
        "comment_text": "",
        "digests": {
          "md5": "22cf4400a74dd16bc1a3c97572fb363a",
          "sha256": "07d129ea107ddd7b68b45f248ec64bcad278d3c121d32fb8e96eb716d0016f00"
        },
        "downloads": 0,
        "filename": "hurry.query-2.3.tar.gz",
        "has_sig": false,
        "md5_digest": "22cf4400a74dd16bc1a3c97572fb363a",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 26388,
        "upload_time": "2017-04-26T09:59:22",
        "url": "https://files.pythonhosted.org/packages/0f/c3/3276944dc439795d8f711b403cab9bd3c1c729117e6b4ed7b7ca190b8154/hurry.query-2.3.tar.gz"
      }
    ],
    "2.4": [
      {
        "comment_text": "",
        "digests": {
          "md5": "b5fb3a87a4054c2a9b20c94a47abbeef",
          "sha256": "9ba2591cd745f3ed309a4a587fe8a872fb99e68fc0d3f473226c86ead1b49c8c"
        },
        "downloads": 0,
        "filename": "hurry.query-2.4.tar.gz",
        "has_sig": false,
        "md5_digest": "b5fb3a87a4054c2a9b20c94a47abbeef",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 26577,
        "upload_time": "2017-06-22T07:07:29",
        "url": "https://files.pythonhosted.org/packages/bc/af/edc639cdea624338a75b64e191a29bbc75583efe2a740c63c8972cbfe88e/hurry.query-2.4.tar.gz"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "b5fb3a87a4054c2a9b20c94a47abbeef",
        "sha256": "9ba2591cd745f3ed309a4a587fe8a872fb99e68fc0d3f473226c86ead1b49c8c"
      },
      "downloads": 0,
      "filename": "hurry.query-2.4.tar.gz",
      "has_sig": false,
      "md5_digest": "b5fb3a87a4054c2a9b20c94a47abbeef",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 26577,
      "upload_time": "2017-06-22T07:07:29",
      "url": "https://files.pythonhosted.org/packages/bc/af/edc639cdea624338a75b64e191a29bbc75583efe2a740c63c8972cbfe88e/hurry.query-2.4.tar.gz"
    }
  ]
}