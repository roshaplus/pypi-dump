{
  "info": {
    "author": "uezo",
    "author_email": "uezo@uezo.net",
    "bugtrack_url": null,
    "classifiers": [
      "Programming Language :: Python :: 3"
    ],
    "description": "# Minette for Python\nMinette is a micro Bot framework. Session and user management, Natural language analyzing and architecture for multi-skill/character bot are ready-to-use.\n\n## Installation\n\nTo install minette, simply:\n\n```\n$ pip install minette\n```\n\n## Running the echo bot\nCode like below and run.\n\n```python\nimport minette\n\n# create bot\nbot = minette.create()\n\n# start conversation\nwhile True:\n    req = input(\"user> \")\n    res = bot.execute(req)\n    for message in res:\n        print(\"minette> \" + message.text)\n```\n\n```\n$ python echo.py\nuser> hello\nminette> You said: hello\n```\n\n## Session management\nMinette provides a data store that enables your bot to continue conversasion accross the requests like HTTP Session. Default SessionStore uses Sqlite but you can make custom SessionStore and change to any database you like.\n\n## User management\nUsers are identified by internal UserIDs which are given at the first access to the bot. The UserID is determined by the channel (e.g. CONSOLE, LINE, etc) and the user_id of the channel. Minette stores the data of users in Sqlite automatically and you can get (or update) it from User object.\n\n## Natural Language Analyzing\nTaggers are the components for analyzing the text of request and the result will be set to request.words property. Minette has two built-in taggers - GoogleTagger and MeCabTagger.\n\n### Google Tagger\nGoogleTagger uses Cloud Natural Language API. This separates text into words and provides tags for each of them. (e.g. NOUN, VERB, ADJ ...)\n\n#### Usase\n```python\nfrom minette.tagger.google import GoogleTagger\nbot = minette.create(\n    tagger=GoogleTagger(api_key=\"your api key\")\n)\n```\n\n### MeCab Tagger\nMeCabTagger uses MeCab which is one of the most popular Japanese morphological analyzer. This provides all information of MeCab nodes. To use this tagger, MeCab and its binding for Python are required.\n\n#### Installing MeCab\n- Ubuntu 16.04\n```\n$ sudo apt-get install mecab libmecab-dev mecab-ipadic\n$ sudo apt-get install mecab-ipadic-utf8\n```\n- Mac OSX\n```\n$ brew install mecab mecab-ipadic git curl xz\n```\n\n#### Installing Binding\n```\npip install mecab-python3\n```\n\n#### Usase\n```python\nfrom minette.tagger.mecab import MeCabTagger\nbot = minette.create(\n    tagger=MeCabTagger\n)\n```\n\n## Adding custom conversation\nMinette detect the intention of the user in the `Classifier` and delegate to proper `DialogService` to process the application logic and compose response messages.\n\nHere is the example. RateDialogService calculate \uff04->\u00a5 exchange rate and MyClassifier has a rule to delegate when the input is numeric.\n\n```python\nimport minette\nfrom minette.dialog import Message, DialogService, Classifier\n\nclass RateDialogService(DialogService):\n    def compose_response(self, request, session, connection):\n        yen = int(request.text) * 100\n        return request.get_reply_message(\"$\" + request.text + \" = \u00a5\" + str(yen))\n\nclass MyClassifier(Classifier):\n    def classify(self, request, session, connection):\n        if request.text.isdecimal():\n            return RateDialogService\n        else:\n            return DialogService\n\nif __name__ == \"__main__\":\n    # create bot\n    bot = automata.create(classifier=MyClassifier)\n\n    # start conversation\n    while True:\n        req = input(\"user> \")\n        res = bot.execute(req)\n        for message in res:\n            print(\"minette> \" + message.text)\n```\n\nRun and say \"3\" to the bot.\n```\nuser> 3\nminette> $3 = \u00a5300\n```\nIf you say non-numeric words, bot echoes what you say.\n```\nuser> hello\nminette> You said: hello\n```\n\n## Built-in Chatting (Japanese Only)\nMinette has a DialogService for Japanese chatting using docomo API. All you have to do is just adding 2 lines in config file! (minette.ini)\n```python\n[minette]\ndefault_dialog_service = minette.dialog.chat_dialog.ChatDialogService\nchatting_api_key = YOUR_API_KEY\n```\n\n## License\nThis software is licensed under the Apache v2 License.\n\n# Sample Codes\n\n## Echo bot\nThe first bot that just echoes what you say.\n```python\nimport minette\n\n# create bot\nbot = minette.create()\n\n# start conversation\nwhile True:\n    req = input(\"user> \")\n    res = bot.execute(req)\n    for message in res:\n        print(\"minette> \" + message.text)\n```\n```\nuser> hello\nminette> You said:hello\n```\n\n## Greeting Bot\nThe simplest structure. All logic is implemented in a custom DialogService.\n```python\nfrom datetime import datetime\nimport minette\nfrom minette.dialog import Message, DialogService, Classifier\n\nclass GreetingDialogService(DialogService):\n    def compose_response(self, request, session, connection):\n        now = datetime.now()\n        if now.hour < 12:\n            phrase = \"Good morning\"\n        elif now.hour < 18:\n            phrase = \"Hello\"\n        else:\n            phrase = \"Good evening\"\n        return request.get_reply_message(text=phrase)\n\nif __name__ == \"__main__\":\n    # create bot\n    bot = minette.create(default_dialog_service=GreetingDialogService)\n    # start conversation\n    while True:\n        req = input(\"user> \")\n        res = bot.execute(req)\n        for message in res:\n            print(\"minette> \" + message.text)\n```\n```\nuser> hello\nminette> Good morning\n```\n\n## Dice Bot\nOverride process_request method to execute application logic.\n```python\nimport random\nimport minette\nfrom minette.dialog import Message, DialogService, Classifier\n\nclass DiceDialogService(DialogService):\n    def process_request(self, request, session, connection):\n        session.data = {\n            \"dice1\": random.randint(1, 6),\n            \"dice2\": random.randint(1, 6)\n        }\n\n    def compose_response(self, request, session, connection):\n        dice1 = str(session.data[\"dice1\"])\n        dice2 = str(session.data[\"dice2\"])\n        return request.get_reply_message(text=\"Dice1:\" + dice1 + \" / Dice2:\" + dice2)\n\nif __name__ == \"__main__\":\n    # create bot\n    bot = minette.create(default_dialog_service=DiceDialogService)\n    # start conversation\n    while True:\n        req = input(\"user> \")\n        res = bot.execute(req)\n        for message in res:\n            print(\"minette> \" + message.text)\n```\n\n## Dice and Greeting Bot\nSwitching DialogService by request.text.\n\n```python\nimport random\nfrom datetime import datetime\nimport minette\nfrom minette.dialog import Message, DialogService, Classifier\n\nclass GreetingDialogService(DialogService):\n    def compose_response(self, request, session, connection):\n        now = datetime.now()\n        if now.hour < 12:\n            phrase = \"Good morning\"\n        elif now.hour < 18:\n            phrase = \"Hello\"\n        else:\n            phrase = \"Good evening\"\n        return request.get_reply_message(text=phrase)\n\nclass DiceDialogService(DialogService):\n    def process_request(self, request, session, connection):\n        session.data = {\n            \"dice1\": random.randint(1, 6),\n            \"dice2\": random.randint(1, 6)\n        }\n\n    def compose_response(self, request, session, connection):\n        dice1 = str(session.data[\"dice1\"])\n        dice2 = str(session.data[\"dice2\"])\n        return request.get_reply_message(text=\"Dice1:\" + dice1 + \" / Dice2:\" + dice2)\n\nclass MyClassifier(Classifier):\n    def classify(self, request, session, connection):\n        if request.text.lower() == \"dice\":\n            return DiceDialogService\n        else:\n            return GreetingDialogService\n\nif __name__ == \"__main__\":\n    # create bot\n    bot = minette.create(classifier=MyClassifier)\n    # start conversation\n    while True:\n        req = input(\"user> \")\n        res = bot.execute(req)\n        for message in res:\n            print(\"minette> \" + message.text)\n```\n\n```\nuser> hello\nminette> Good morning\nuser> \u306f\u308d\u30fc\nminette> Good morning\nuser> dice\nminette> Dice1:2 / Dice2:4\n```\n\n## Translation Bot\nTranslation bot using Google translation API.\n\n```python\nimport requests\nimport minette\nfrom minette.dialog import Message, DialogService, Classifier\n\nclass TranslationDialogService(DialogService):\n    def process_request(self, request, session, connection):\n        res = requests.post(\"https://translation.googleapis.com/language/translate/v2\", data={\n            \"key\": \"YOUR_API_KEY\",\n            \"q\": request.text,\n            \"target\": \"en\"\n        }).json()\n        session.data = res[\"data\"][\"translations\"][0][\"translatedText\"].replace(\"&#39;\", \"'\")\n\n    def compose_response(self, request, session, connection):\n        return request.get_reply_message(\"\u82f1\u8a9e\u306b\u7ffb\u8a33\uff1a\" + session.data)\n\nif __name__ == \"__main__\":\n    # create bot\n    bot = minette.create(default_dialog_service=TranslationDialogService)\n\n    # start conversation\n    while True:\n        req = input(\"user> \")\n        res = bot.execute(req)\n        for message in res:\n            print(\"minette> \" + message.text)\n```\n```\nuser> \u3053\u3093\u306b\u3061\u306f\nminette> \u82f1\u8a9e\u306b\u7ffb\u8a33\uff1aHello\nuser> \u304a\u306a\u304b\u304c\u3059\u304d\u307e\u3057\u305f\nminette> \u82f1\u8a9e\u306b\u7ffb\u8a33\uff1aI'm hungry\n```\n\n## Translation and chatting bot\nSwitching translation and chatting using `session.mode`.\nYou can switch to the `translation` mode by saying \"\u7ffb\u8a33\u3057\u3066\" and switch back to chatting by saying \"\u7ffb\u8a33\u7d42\u308f\u308a\".\n\n```python\nimport requests\nimport minette\nfrom minette.dialog import Message, DialogService, Classifier\nfrom minette.dialog.chat_dialog import ChatDialogService\nfrom minette.session import ModeStatus\n\nclass TranslationDialogService(DialogService):\n    def process_request(self, request, session, connection):\n        if session.mode_status == ModeStatus.Start:\n            session.mode = \"translation\"\n        else:\n            if request.text == \"\u7ffb\u8a33\u7d42\u308f\u308a\":\n                session.mode_status = ModeStatus.End\n            else:\n                res = requests.post(\"https://translation.googleapis.com/language/translate/v2\", data={\n                    \"key\": \"YOUR_API_KEY\",\n                    \"q\": request.text,\n                    \"target\": \"en\"\n                }).json()\n                session.data = res[\"data\"][\"translations\"][0][\"translatedText\"].replace(\"&#39;\", \"'\")\n\n    def compose_response(self, request, session, connection):\n        if session.mode_status == ModeStatus.Start:\n            text = \"\u7ffb\u8a33\u3057\u305f\u3044\u6587\u7ae0\u3092\u5165\u529b\u3057\u3066\u304f\u3060\u3055\u3044\u3002\u300c\u7ffb\u8a33\u7d42\u308f\u308a\u300d\u3067\u7ffb\u8a33\u30e2\u30fc\u30c9\u3092\u7d42\u4e86\u3057\u307e\u3059\"\n            session.keep_mode = True\n        elif session.mode_status == ModeStatus.Continue:\n            text = \"English: \" + session.data\n            session.keep_mode = True\n        else:\n            text = \"\u306f\u3044\u3001\u7ffb\u8a33\u306f\u7d42\u308f\u308a\u306b\u3057\u307e\u3059\"\n        return request.get_reply_message(text)\n\nclass MyClassifier(Classifier):\n    def classify(self, request, session, connection):\n        if \"\u7ffb\u8a33\u3057\u3066\" in request.text or session.mode == \"translation\":\n            return TranslationDialogService\n        else:\n            return ChatDialogService(request, session, self.logger, self.config, self.timezone, connection)\n\nif __name__ == \"__main__\":\n    # create bot\n    bot = minette.create(classifier=MyClassifier)\n    # start conversation\n    while True:\n        req = input(\"user> \")\n        res = bot.execute(req)\n        for message in res:\n            print(\"minette> \" + message.text)\n```\n\n\n\n",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "https://github.com/uezo/minette-python",
    "keywords": "",
    "license": "Apache v2",
    "maintainer": "",
    "maintainer_email": "",
    "name": "minette",
    "platform": "",
    "project_url": "https://pypi.org/project/minette/",
    "release_url": "https://pypi.org/project/minette/0.1.dev4/",
    "requires_dist": [],
    "requires_python": "",
    "summary": "Minette is a micro Bot framework. Session and user management, Natural language analyzing and architecture for multi-skill/character bot are ready-to-use",
    "version": "0.1.dev4"
  },
  "releases": {
    "0.1.dev1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "653498e4cd93a74fbb129c36a7d9be98",
          "sha256": "6ded92e42069d6ef633c5aa45a726e13128eba5f292f894d058be20e9dd79299"
        },
        "downloads": 0,
        "filename": "minette-0.1.dev1.tar.gz",
        "has_sig": false,
        "md5_digest": "653498e4cd93a74fbb129c36a7d9be98",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 17199,
        "upload_time": "2017-08-16T11:28:44",
        "url": "https://files.pythonhosted.org/packages/1b/31/8a662afe86483a339ec88eac7e8989dc0cc0d63238bc0eb5c9d52c3ce4ed/minette-0.1.dev1.tar.gz"
      }
    ],
    "0.1.dev2": [
      {
        "comment_text": "",
        "digests": {
          "md5": "243c0ea09a856b9e00eba300ea410f3c",
          "sha256": "bed65d61c9763dac316ace019cc855e668d3ed54e9b1cd2aff7342c9531138e6"
        },
        "downloads": 0,
        "filename": "minette-0.1.dev2.tar.gz",
        "has_sig": false,
        "md5_digest": "243c0ea09a856b9e00eba300ea410f3c",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 17027,
        "upload_time": "2017-08-16T11:42:21",
        "url": "https://files.pythonhosted.org/packages/b5/57/a02e78dea03d04b41e19fdcd7c90babf9c4c0a0ada389dcdc36534776996/minette-0.1.dev2.tar.gz"
      }
    ],
    "0.1.dev3": [
      {
        "comment_text": "",
        "digests": {
          "md5": "8a9937c564a901a0176a913415c958b9",
          "sha256": "ffb1854dc8f330c411d96c2216c631a960a72df549d5e04b5df2e60010636a3d"
        },
        "downloads": 0,
        "filename": "minette-0.1.dev3.tar.gz",
        "has_sig": false,
        "md5_digest": "8a9937c564a901a0176a913415c958b9",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 17045,
        "upload_time": "2017-08-16T11:53:53",
        "url": "https://files.pythonhosted.org/packages/70/a8/5948af1c8fb6603e13178c26ed7f642d597d1f537881028344812e1587c4/minette-0.1.dev3.tar.gz"
      }
    ],
    "0.1.dev4": [
      {
        "comment_text": "",
        "digests": {
          "md5": "ed6af226821931b1f73fe3eb1e32f456",
          "sha256": "11460e8dd302d732654074c7ddbeb73566f882b506dadd7e0536ea7b218b2e3b"
        },
        "downloads": 0,
        "filename": "minette-0.1.dev4.tar.gz",
        "has_sig": false,
        "md5_digest": "ed6af226821931b1f73fe3eb1e32f456",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 17075,
        "upload_time": "2017-08-16T11:59:01",
        "url": "https://files.pythonhosted.org/packages/82/10/8c359e473e086fe9d6811f2e97e387cd94871a731844fb227b9a89125d59/minette-0.1.dev4.tar.gz"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "ed6af226821931b1f73fe3eb1e32f456",
        "sha256": "11460e8dd302d732654074c7ddbeb73566f882b506dadd7e0536ea7b218b2e3b"
      },
      "downloads": 0,
      "filename": "minette-0.1.dev4.tar.gz",
      "has_sig": false,
      "md5_digest": "ed6af226821931b1f73fe3eb1e32f456",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 17075,
      "upload_time": "2017-08-16T11:59:01",
      "url": "https://files.pythonhosted.org/packages/82/10/8c359e473e086fe9d6811f2e97e387cd94871a731844fb227b9a89125d59/minette-0.1.dev4.tar.gz"
    }
  ]
}