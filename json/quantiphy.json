{
  "info": {
    "author": "Ken Kundert",
    "author_email": "quantiphy@nurdletech.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Intended Audience :: Developers",
      "Intended Audience :: Science/Research",
      "License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)",
      "Natural Language :: English",
      "Operating System :: POSIX :: Linux",
      "Programming Language :: Python :: 2.7",
      "Programming Language :: Python :: 3.3",
      "Programming Language :: Python :: 3.4",
      "Programming Language :: Python :: 3.5",
      "Programming Language :: Python :: 3.6",
      "Topic :: Scientific/Engineering",
      "Topic :: Utilities"
    ],
    "description": "QuantiPhy - Physical Quantities\n===============================\n\n| Version: 1.3.0\n| Released: 2017-03-19\n|\n\n.. image:: https://img.shields.io/travis/KenKundert/quantiphy/master.svg\n    :target: https://travis-ci.org/KenKundert/quantiphy\n\n.. image:: https://img.shields.io/coveralls/KenKundert/quantiphy.svg\n    :target: https://coveralls.io/r/KenKundert/quantiphy\n\n.. image:: https://img.shields.io/pypi/v/quantiphy.svg\n    :target: https://pypi.python.org/pypi/quantiphy\n\n.. image:: https://img.shields.io/pypi/pyversions/quantiphy.svg\n    :target: https://pypi.python.org/pypi/quantiphy/\n\n.. image:: https://img.shields.io/pypi/dd/quantiphy.svg\n    :target: https://pypi.python.org/pypi/quantiphy/\n\n\nUse 'pip3 install quantiphy' to install.  Requires Python3.3 or better.\nPython2.7 is also supported, however support for unicode units is weak.\n\n\nSynopsis\n--------\n\nThe *QuantiPhy* package provides the *Quantity* class that:\n\n1. accepts real values with units in a variety of common forms, including those \n   that include SI scale factors,\n2. converts them into an object that is treated as a floating point number in \n   expressions,\n3. generally includes the units when printing and by default employs the SI \n   scale factors.\n4. Unit conversion is supported when converting to or from quantities.\n\n\nIntroduction\n------------\n\n*QuantiPhy* is a light-weight package that allows numbers to be combined with \nunits into physical quantities.  Physical quantities are very commonly \nencountered when working with real-world systems when numbers are involved. And \nwhen encountered, the numbers often use SI scale factors to make them easier to \nread and write.  Surprisingly, most computer languages do not support numbers in \nthese forms, meaning that when working with physical quantities, one often has \nto choose what form to use, one that is easy for computers to read or one that \nis easy for humans to read. For example, consider this table of critical \nfrequencies needed in jitter tolerance measurements in optical communication:\n\n.. code-block:: python\n\n    >>> table1 = \"\"\"\n    ...     SDH     | Rate          | f1      | f2       | f3      | f4\n    ...     --------+---------------+---------+----------+---------+--------\n    ...     STM-1   | 155.52 Mb/s   | 500 Hz  | 6.5 kHz  | 65 kHz  | 1.3 MHz\n    ...     STM-4   | 622.08 Mb/s   | 1 kHz   | 25 kHz   | 250 kHz | 5 MHz\n    ...     STM-16  | 2.48832 Gb/s  | 5 kHz   | 100 kHz  | 1 MHz   | 20 MHz\n    ...     STM-64  | 9.95328 Gb/s  | 20 kHz  | 400 kHz  | 4 MHz   | 80 MHz\n    ...     STM-256 | 39.81312 Gb/s | 80 kHz  | 1.92 MHz | 16 MHz  | 320 MHz\n    ... \"\"\"\n\nThis table was formatted to be easily read by humans. If it were formatted for \ncomputers, the numbers would be given without units and in exponential notation \nbecause they have dramatically different sizes. For example, it might look like \nthis:\n\n.. code-block:: python\n\n    >>> table2 = \"\"\"\n    ...     SDH     | Rate (b/s)    | f1 (Hz) | f2 (Hz)  | f3 (Hz) | f4 (Hz)\n    ...     --------+---------------+---------+----------+---------+--------\n    ...     STM-1   | 1.5552e8      | 5e2     | 6.5e3    | 6.5e3   | 1.3e6\n    ...     STM-4   | 6.2208e8      | 1e3     | 2.5e3    | 2.5e5   | 5e6\n    ...     STM-16  | 2.48832e9     | 5e3     | 1e5      | 1e6     | 2e7\n    ...     STM-64  | 9.95328e9     | 2e4     | 4e5      | 4e6     | 8e7\n    ...     STM-256 | 3.981312e10   | 8e4     | 1.92e6   | 1.6e7   | 3.20e8\n    ... \"\"\"\n\nThis contains the same information, but it is much harder for humans to read and \ninterpret.  Often the compromise of partially scaling the numbers can be used to \nmake the table easier to interpret:\n\n.. code-block:: python\n\n    >>> table3 = \"\"\"\n    ...     SDH     | Rate (Mb/s)   | f1 (kHz)| f2 (kHz) | f3 (kHz)| f4 (MHz)\n    ...     --------+---------------+---------+----------+---------+--------\n    ...     STM-1   | 155.52        | 0.5     | 6.5      | 65      | 1.3\n    ...     STM-4   | 622.08        | 1       | 2.5      | 250     | 5\n    ...     STM-16  | 2488.32       | 5       | 100      | 1000    | 20\n    ...     STM-64  | 9953.28       | 20      | 400      | 4000    | 80\n    ...     STM-256 | 39813.120     | 80      | 1920     | 16000   | 320\n    ... \"\"\"\n\nThis looks cleaner, but it is still involves some effort to interpret because \nthe values are distant from their corresponding scaling and units, because the \nlarge and small values are oddly scaled (0.5 kHz is more naturally given as \n500Hz and 39813 MHz is more naturally given as 39.8 GHz), and because each \ncolumn may have a different scaling factor. While these might seem like minor \ninconveniences on this table, they can become quite annoying as the table \nbecomes larger. Fundamentally this issue is that the eyes are naturally drawn to \nthe number, but the numbers are not complete, and so the eyes need to hunt \nfurther. This problem exists with both tables and graphs. The scaling and units \nfor the numbers may be found in the column headings, the axes, the labels, the \ntitle, the caption, or in the body of the text.  The sheer number of places to \nlook can dramatically slow the interpretation of the data. This problem does not \nexist in the first table where each number is complete as it includes both its \nscaling and its units. The eye gets the full picture on the first glance.\n\nAll these tables contain the same information, but in the second two tables the \nreadability has been traded off in order to make the data easier to read into \na computer.\n\n*QuanitiPhy* makes it easy to read and generate numbers with units and scale \nfactors so you do not have to choose between human and computer readability.  \nFor example, the above tables could be read with the following code (it must be \ntweaked somewhat to handle tables 2 and 3):\n\n.. code-block:: python\n\n    >>> from quantiphy import Quantity\n\n    >>> sdh = []\n    >>> lines = table1.strip().split('\\n')\n    >>> for line in lines[2:]:\n    ...     fields = line.split('|')\n    ...     name = fields[0].strip()\n    ...     critical_freqs = [Quantity(f) for f in fields[1:]]\n    ...     sdh.append((name, critical_freqs))\n    >>> for name, freqs in sdh:\n    ...     print('{:8s}: {:12s} {:9s} {:9s} {:9s} {}'.format(name, *freqs))\n    STM-1   : 155.52 Mb/s  500 Hz    6.5 kHz   65 kHz    1.3 MHz\n    STM-4   : 622.08 Mb/s  1 kHz     25 kHz    250 kHz   5 MHz\n    STM-16  : 2.4883 Gb/s  5 kHz     100 kHz   1 MHz     20 MHz\n    STM-64  : 9.9533 Gb/s  20 kHz    400 kHz   4 MHz     80 MHz\n    STM-256 : 39.813 Gb/s  80 kHz    1.92 MHz  16 MHz    320 MHz\n\n\n    >>> for name, freqs in sdh:\n    ...     print('{:8s}: {:.4e} {:.4e} {:.4e} {:.4e} {:.4e}'.format(\n    ...         name, *(1*f for f in freqs)))\n    STM-1   : 1.5552e+08 5.0000e+02 6.5000e+03 6.5000e+04 1.3000e+06\n    STM-4   : 6.2208e+08 1.0000e+03 2.5000e+04 2.5000e+05 5.0000e+06\n    STM-16  : 2.4883e+09 5.0000e+03 1.0000e+05 1.0000e+06 2.0000e+07\n    STM-64  : 9.9533e+09 2.0000e+04 4.0000e+05 4.0000e+06 8.0000e+07\n    STM-256 : 3.9813e+10 8.0000e+04 1.9200e+06 1.6000e+07 3.2000e+08\n\nThe first output shows that quantities can be displayed in easily readable forms \nwith their units and the second output shows that the values are easily \naccessible for computation (the use of ``1*f`` is not necessary to be able to \nsee the results in exponential notation, rather it is there to demonstrate that \nit is easy to do calculations on Quantities).\n\n*Quantity* is used to convert a number string, such as '155.52 Mb/s' into an \ninternal representation that includes the value and the units: 155.52e6 and \n'b/s'.  The scaling factor is properly included. Once a value is converted to \na Quantity, it can be treated just like a normal float. The main difference \noccurs when it is time to convert it back to a string. When doing so, the scale \nfactor and units are included by default.\n\nAlternatives\n''''''''''''\n\nThere are a considerable number of Python packages dedicated to units and \nquantities (`Alternatives <https://kdavies4.github.io/natu/seealso.html>`_).  \nHowever, as a rule, they focus on the units rather than the scale factors. In \nparticular, they build a system of units that you are expected to use throughout \nyour calculations.  These packages demand a high level of commitment from their \nusers and in turn provide unit consistency and built-in unit conversions.  In \ncontrast, *QuantiPhy* treats units basically as documentation.  They are simply \nstrings that are attached to quantities largely so they can be presented to the \nuser when the values are printed. As such, *QuantiPhy* is a light-weight package \nthat demands little from the user. It is used when inputting and outputting \nvalues, and then only when it provides value. As a result, it provides \na simplicity in use that cannot be matched by the other packages.\n\n\nQuantities\n----------\n\nThe *Quantity* class is used to create a quantity (an object with both a value \nand units). Normally, creating a quantity takes one or two arguments.  The first \nis taken to be the value, and the second, if given, is taken to be the model, \nwhich is a source of default values.  More on this in a bit, but for the time \nbeing you can assume the model is a string that contains the units for the \nquantity.  The value may be given as a float or as a string.  The string may be \nin floating point notation, in scientific notation, or use SI scale factors and \nmay include the units.  For example, any of the following ways can be used to \nspecify 1ns:\n\n.. code-block:: python\n\n    >>> period = Quantity(1e-9, 's')\n    >>> print(period)\n    1 ns\n\n    >>> period = Quantity('0.000000001 s')\n    >>> print(period)\n    1 ns\n\n    >>> period = Quantity('1e-9s')\n    >>> print(period)\n    1 ns\n\n    >>> period = Quantity('1ns')\n    >>> print(period)\n    1 ns\n\nWhen given as a string, the number may use any of the following scale factors:\n\n    |   Y (10\\ :sup:`24`)\n    |   Z (10\\ :sup:`21`)\n    |   E (10\\ :sup:`18`)\n    |   P (10\\ :sup:`15`)\n    |   T (10\\ :sup:`12`)\n    |   G (10\\ :sup:`9`)\n    |   M (10\\ :sup:`6`)\n    |   k (10\\ :sup:`3`)\n    |   _ (1)\n    |   c (10\\ :sup:`-2`)\n    |   % (10\\ :sup:`-2`)\n    |   m (10\\ :sup:`-3`)\n    |   u (10\\ :sup:`-6`)\n    |   \u03bc (10\\ :sup:`-6`)\n    |   n (10\\ :sup:`-9`)\n    |   p (10\\ :sup:`-12`)\n    |   f (10\\ :sup:`-15`)\n    |   a (10\\ :sup:`-18`)\n    |   z (10\\ :sup:`-21`)\n    |   y (10\\ :sup:`-24`)\n\nSo far our 1ns is just a value. However, you may also give a name and \ndescription.  For example:\n\n.. code-block:: python\n\n    >>> period = Quantity('Tclk = 10ns -- clock period')\n    >>> print(period.name, '=', period, ' #', period.desc)\n    Tclk = 10 ns  # clock period\n\nIf you only specify a real number for the value, then the units, name, and \ndescription do not get values. This is where the second argument, the model, \nhelps. It may be another quantity or it may be a string.  Any attributes that \nare not provided by the first argument are taken from the second if available.  \nIf the second argument is a string, it is split. If it contains one value, that \nvalue is taken to be the units, if it contains two, those values are taken to be \nthe name and units, and it it contains more than two, the remaining values are \ntaken to be the description. For example:\n\n.. code-block:: python\n\n    >>> out_period = Quantity(10*period, period)\n    >>> print(out_period.name, '=', out_period, ' #', out_period.desc)\n    Tclk = 100 ns  # clock period\n\n    >>> freq = Quantity(100e6, 'Hz')\n    >>> print(freq)\n    100 MHz\n\n    >>> freq = Quantity(100e6, 'Fin Hz')\n    >>> print(freq.name, '=', freq, ' #', freq.desc)\n    Fin = 100 MHz  # \n\n    >>> freq = Quantity(100e6, 'Fin Hz Input frequency')\n    >>> print(freq.name, '=', freq, ' #', freq.desc)\n    Fin = 100 MHz  # Input frequency\n\nIn addition, you can explicitly specify the units, the name, and the description \nusing named arguments. These values override anything specified in the value or \nthe model.\n\n.. code-block:: python\n\n    >>> out_period = Quantity(\n    ...     10*period, period, name='output period',\n    ...     desc='period at output of frequency divider'\n    ... )\n    >>> print(out_period.name, '=', out_period, ' #', out_period.desc)\n    output period = 100 ns  # period at output of frequency divider\n\nFinally, you can overwrite the quantities attributes to override the units, \nname, or description.\n\n.. code-block:: python\n\n    >>> out_period = Quantity(10*period)\n    >>> out_period.units = 's'\n    >>> out_period.name = 'output period'\n    >>> out_period.desc = 'period at output of frequency divider'\n    >>> print(out_period.name, '=', out_period, ' #', out_period.desc)\n    output period = 100 ns  # period at output of frequency divider\n\nFrom a quantity object, you access its value in various ways:\n\n.. code-block:: python\n\n    >>> h_line = Quantity('1420.405751786 MHz')\n\n    >>> h_line.as_tuple()\n    (1420405751.786, 'Hz')\n\n    >>> str(h_line)\n    '1.4204 GHz'\n\n    >>> h_line.render()\n    '1.4204 GHz'\n\n    >>> h_line.render(show_si=False)\n    '1.4204e9 Hz'\n\nYou can also access the value without the units:\n\n.. code-block:: python\n\n    >>> float(h_line)\n    1420405751.786\n\n    >>> h_line.render(False)\n    '1.4204G'\n\n    >>> h_line.render(False, show_si=False)\n    '1.4204e9'\n\nOr you can access just the units:\n\n.. code-block:: python\n\n    >>> h_line.units\n    'Hz'\n\nYou can also access the full precision of the quantity:\n\n.. code-block:: python\n\n    >>> h_line.render(prec='full')\n    '1.420405751786 GHz'\n\n    >>> h_line.render(show_si=False, prec='full')\n    '1.420405751786e9 Hz'\n\nFull precision implies whatever precision was used when specifying the quantity \nif it was specified as a string. If it was specified as a real number, then \na fixed, user controllable number of digits are used (default=12). Generally one \nuses 'full' when generating output that will be read by a machine.\n\nIf you specify *show_label* to render, it will generally include the name and \nperhaps the description if they are available. The formatting is controlled by \n'label_fmt', which is described later. With the default formatting, the \ndescription is not printed.\n\n.. code-block:: python\n\n    >>> h_line.render(show_label=True)\n    '1.4204 GHz'\n\n    >>> out_period.render(show_label=True)\n    'output period = 100 ns'\n\n\nQuantities As Reals\n-------------------\n\nYou can use a quantity in the same way that you can use a real number, meaning \nthat you can use it in expressions and it will evaluate to its real value:\n\n.. code-block:: python\n\n    >>> period = Quantity('1us')\n    >>> print(period)\n    1 us\n\n    >>> frequency = 1/period\n    >>> print(frequency)\n    1000000.0\n\n    >>> type(period)\n    <class 'quantiphy.Quantity'>\n\n    >>> type(frequency)\n    <class 'float'>\n\nNotice that when performing arithmetic operations on quantities the units are \ncompletely ignored and do not propagate in any way to the newly computed result.\n\n\nRescaling When Creating a Quantity\n----------------------------------\n\nIt may be that a value as given uses inconvenient units. For example, you are \ngiven temperature in Fahrenheit, but you would prefer it in Kelvin.  Or perhaps \nyou are given mass data in a string that contains kilograms as a simple number \n(without units or scale factor).  In this case you need to convert to grams so \nthat if the SI scale factors you don't end up with milli-kilograms. To address \nthese issues, use the *scale* argument to the Quantify class.\n\nFor example:\n\n.. code-block:: python\n\n    >>> m = Quantity('2.529', scale=1000, units='g')\n    >>> print(m)\n    2.529 kg\n\nIn this case the value is given in kilograms, and is converted to grams by \nmultiplying the given value by 1000. Finally the units are specified as 'g'.\n\nWhen specifying the scale you can also specify the units. For example:\n\n.. code-block:: python\n\n    >>> m = Quantity('2.529', scale=(1000, 'g'))\n    >>> print(m)\n    2.529 kg\n\nThis indicates that the units should be set to 'g' after the scale operation.\n\nSo far the scale operation has been a simple multiplication, but it is possible \nto pass a function in for scale to perform more complicated scale operations.  \nfor example:\n\n.. code-block:: python\n\n    >>> def f2k(f, units):\n    ...     return (f - 32)/1.8 + 273.15, 'K'\n\n    >>> t = Quantity(212, scale=f2k)\n    >>> print(t)\n    373.15 K\n\nThe function is expected to take two arguments: the value and the given units, \nand it is expected to return two values: the scaled value and the new units. In \nthis example *f2k* ignores the given units and just assumes degrees Fahrenheit.  \nBut you can write a more sophisticated function as follows:\n\n.. code-block:: python\n\n    >>> def to_kelvin(t, units):\n    ...     if units in ['F', '\u00b0F']:\n    ...         return (t - 32)/1.8 + 273.15, 'K'\n    ...     if units in ['C', '\u00b0C']:\n    ...         return t + 273.15, 'K'\n    ...     if units in ['K']:\n    ...         return t, 'K'\n    ...     raise NotImplementedError\n\n    >>> t = Quantity(212, units='\u00b0F', scale=to_kelvin)\n    >>> print(t)\n    373.15 K\n\nIn this case, you initially specify the quantity to be 212 \u00b0F, but before the \nvalue of the quantity is fixed it is rescaled to Kelvin. It was necessary to \nspecify the units to initially be '\u00b0F' so that the scaling function knows what \nto convert from.\n\n*QuantiPhy* also has a built-in unit conversion feature that is accessed by \npassing the units to convert to as the value of scale.  For example:\n\n.. code-block:: python\n\n    >>> t = Quantity('212 \u00b0F', scale='K')\n    >>> print(t)\n    373.15 K\n\n    >>> d = Quantity('d = 93 Mmiles  -- average distance from Sun to Earth', scale='m')\n    >>> print(d)\n    149.67 Gm\n\nYou can add your own unit conversions to *QuantiPhy* by using *UnitConversion*:\n\n.. code-block:: python\n\n    >>> from quantiphy import Quantity, UnitConversion\n\n    >>> UnitConversion('m', 'pc parsec', 3.0857e16)\n    <...>\n\n    >>> d = Quantity('5 upc', scale='m')\n    >>> print(d)\n    154.28 Gm\n\n*UnitConversion* accepts a scale factor and an offset, so can support \ntemperature conversions.  Also, the conversion can occur in either direction:\n\n.. code-block:: python\n\n    >>> m = Quantity('1 kg', scale='lbs')\n    >>> print(m)\n    2.2046 lbs\n\nUnit conversions between the following units are built-in:\n\n====== ===============================================================\nK:     K, F, \u00b0F, R, \u00b0R\nC, \u00b0C: K, C, \u00b0C, F, \u00b0F, R, \u00b0R\nm:     km, m, cm, mm, um, \u03bcm, micron, nm, \u00c5, angstrom, mi, mile, miles\ng:     oz, lb, lbs\ns:     s, sec, min, hour, hr , day\n====== ===============================================================\n\nWhen using unit conversions it is important to only convert to units without \nscale factors (such as those in the first column above) when creating \na quantity.  If the units used in a quantity includes a scale factor, then it is \neasy to end up with two scale factors when converting the number to a string \n(ex: 1 mkm or one milli-kilo-meter).\n\nHere is an example that uses quantity rescaling. Imagine that a table is being \nread that gives temperature versus time, but the temperature is given in \u00b0F and \nthe time is given in minutes, but for the purpose of later analysis it is \ndesired that the values be converted to the more natural units of Kelvin and \nseconds:\n\n.. code-block:: python\n\n    >>> rawdata = '''\n    ...     0 450\n    ...     10 400\n    ...     20 360\n    ... '''\n    >>> data = []\n    >>> for line in rawdata.split('\\n'):\n    ...     if line:\n    ...         time, temp = line.split()\n    ...         time = Quantity(time, 'min', scale='s')\n    ...         temp = Quantity(temp, '\u00b0F', scale='K')\n    ...         data += [(time, temp)]\n    >>> for time, temp in data:\n    ...     print('{:7s} {}'.format(time, temp))\n    0 s     505.37 K\n    600 s   477.59 K\n    1.2 ks  455.37 K\n\n\nRescaling When Rendering a Quantity\n-----------------------------------\n\nIt is also possible rescale the value of a quantity when rendering it. In this \ncase the value of the quantity is not affected by the scaling, only the rendered \nvalue is affected.  As before, *scale* can be a float, a tuple, a function, or \na string:\n\n.. code-block:: python\n\n    >>> m = Quantity('2529 g')\n    >>> print('mass in kg: %s' % m.render(False, scale=0.001))\n    mass in kg: 2.529\n\n    >>> print(m.render(scale=(0.0022046, 'lb')))\n    5.5754 lb\n\n    >>> import math\n    >>> def to_dB(value, units):\n    ...     return 20*math.log10(value), 'dB'+units\n\n    >>> T = Quantity('100mV')\n    >>> print(T.render(scale=to_dB))\n    -20 dBV\n\n    >>> print(m.render(scale='lb'))\n    5.5755 lb\n\nWhen converting to units that have scale factors, it is important to disable SI \nscale factors to avoid producing units that have two scale factors (ex: 1 mkm or \none milli-kilo-meter). For example:\n\n.. code-block:: python\n\n    >>> d = Quantity('1 mm')\n    >>> print(d.render(scale='cm'))\n    100 mcm\n\n    >>> print(d.render(scale='cm', show_si=False))\n    100e-3 cm\n\nIn an earlier example the units of time and temperature data were converted to \nnormal SI units. Presumably this make processing easier. Now, when producing \noutput, the units can be converted back if desired:\n\n.. code-block:: python\n\n    >>> for time, temp in data:\n    ...     print('%-7s %s' % (time.render(scale='min'), temp.render(scale='\u00b0F')))\n    0 min   450 \u00b0F\n    10 min  400 \u00b0F\n    20 min  360 \u00b0F\n\n\nPreferences\n-----------\n\nYou can adjust some of the behavior of these functions on a global basis using \n*set_preferences*:\n\n.. code-block:: python\n\n   >>> Quantity.set_preferences(prec=2, spacer='')\n   >>> h_line.render()\n   '1.42GHz'\n\n   >>> h_line.render(prec=4)\n   '1.4204GHz'\n\nSpecifying *prec* (precision) as 4 gives 5 digits of precision (you get one more \ndigit than the number you specify for precision). Thus, the common range for \n*prec* is from 0 to around 12 to 14 for double precision numbers.\n\nPassing *None* as a value in *set_preferences* returns that preference to its \ndefault value:\n\n.. code-block:: python\n\n   >>> Quantity.set_preferences(prec=None, spacer=None)\n   >>> h_line.render()\n   '1.4204 GHz'\n\nYou can also access the value of an existing preference:\n\n.. code-block:: python\n\n   >>> known_units = Quantity.get_preference('known_units')\n   >>> Quantity.set_preferences(known_units = known_units + ['m'])\n\nAlternately, the options are class attributes that can be read or set directly.\n\nFinally, you can override the preferences on an individual quantity by \nmonkey-patching the quantity itself. Doing so will override the global \npreferences on that quantity:\n\n.. code-block:: python\n\n   >>> boltzmann = Quantity('h')\n   >>> boltzmann.show_units = False\n   >>> boltzmann.show_si = False\n   >>> boltzmann.render()\n   '662.61e-36'\n\nThe available preferences are:\n\nshow_si (bool):\n    Use SI scale factors by default. Default is True.\n\nshow_units (bool):\n    Output units by default. Default is True.\n\nprec (int):\n    Default precision in digits where 0 corresponds to 1 digit, must\n    be nonnegative. This precision is used when full precision is not requested.\n    Default is 4 digits.\n\nfull_prec (int):\n    Default full precision in digits where 0 corresponds to 1 digit.\n    Must be nonnegative. This precision is used when full precision is requested \n    if the precision is not otherwise known. Default is 12 digits.\n\nspacer (str):\n    May be '' or ' ', use the latter if you prefer a space between\n    the number and the units. Generally using ' ' makes numbers easier to\n    read, particularly with complex units, and using '' is easier to parse.  \n    Default is ' '.\n\nunity_sf (str):\n    The output scale factor for unity, generally '' or '_'.  Default is ''.  \n    Generally '' is used if only humans are expected to read the result and '_' \n    is used if you expect to parse the numbers again. Using '_' eliminates the \n    ambiguity between units and scale factors.\n\noutput_sf (str):\n    Which scale factors to output, generally one would only use familiar scale \n    factors.  Default is 'TGMkmunpfa'.  This setting does not affect the scale \n    factors that are recognized when reading number.\n\nmap_sf (dict, func):\n    Use this to change the way individual scale factors are rendered. May be \n    a dictionary or a function. Default is empty.\n\n    For example, to replace *u* with *\u03bc*, use *map_sf* = {'u': '\u03bc'}.\n\n    .. code-block:: python\n\n        >>> period = Quantity('1\u03bcs')\n        >>> print(period)\n        1 us\n\n        >>> Quantity.set_preferences(map_sf={'u': '\u03bc'})\n        >>> print(period)\n        1 \u03bcs\n\n    To render exponential notation as traditional scientific notation, use:\n\n    .. code-block:: python\n\n        >>> sf_mapper = str.maketrans({\n        ...     'e': '\u00d710',\n        ...     '-': '\u207b',\n        ...     '0': '\u2070',\n        ...     '1': '\u00b9',\n        ...     '2': '\u00b2',\n        ...     '3': '\u00b3',\n        ...     '4': '\u2074',\n        ...     '5': '\u2075',\n        ...     '6': '\u2076',\n        ...     '7': '\u2077',\n        ...     '8': '\u2078',\n        ...     '9': '\u2079',\n        ... })\n\n        >>> def map_sf(sf):\n        ...     return sf.translate(sf_mapper)\n\n        >>> Quantity.set_preferences(map_sf=map_sf)\n        >>> h_line.render(show_si=False)\n        '1.4204\u00d710\u2079 Hz'\n\n    Both of these are common enough so that *QuantiPhy* provides these rendering \n    methods for you.\n\n    .. code-block:: python\n\n        >>> Quantity.set_preferences(map_sf=Quantity.map_sf_to_greek)\n        >>> print(period)\n        1 \u03bcs\n\n        >>> Quantity.set_preferences(map_sf=Quantity.map_sf_to_sci_notation)\n        >>> h_line.render(show_si=False)\n        '1.4204\u00d710\u2079 Hz'\n\n        >>> Quantity.set_preferences(map_sf=None)\n\nignore_sf (bool):\n    Whether scale factors should be ignored by default when converting strings \n    into numbers.  Default is False.\n\nknown_units (list of strings or string):\n    Units with a leading character that could be confused as a scale factor.\n    Default is empty.\n\nshow_label (bool):\n    Cause render() to add name and description by default if they are\n    given.  Default is False.\n\nstrip_dp (bool):\n    When rendering, strip the decimal points from numbers even if they\n    can then be mistaken for integers.  Default is True.\n\nreltol (real):\n    Relative tolerance, used by is_close() when determining equivalence. Default \n    is 10\\ :sup:`-6`.\n\nabstol (real):\n    Absolute tolerance, used by is_close() when determining equivalence. Default \n    is 10\\ :sup:`-12`.\n\nkeep_components (bool):\n    Whether components of number should be kept if the quantities' value was \n    given as string.  Doing so takes a bit of space, but allows the original \n    precision of the number to be recreated when full precision is requested.\n    Default is True.\n\nlabel_fmt (str or tuple):\n    Format string for an assignment. Will be passed through string format method \n    to generate a string that includes the quantity name.  Format string takes \n    three possible arguments named n, q, and d for the name, value and \n    description. The default is ``'{n} = {v}'``.\n\n    If two strings are given as a tuple, then the first is used if the \n    description is present and the second used otherwise. For example, an \n    alternate specification that prints the description in the form of a Python \n    comment if it is available is: ``({n} = {v}  # {d}', '{n} = {v}')``.\n\nassign_rec (str):\n    Regular expression used to recognize an assignment. Used in Quantity and\n    add_to_namespace() to convert a string to a quantity when a name is present.  \n    Default recognizes the form:\n\n        \"Temp = 300_K -- Temperature\".\n\n\nAmbiguity of Scale Factors and Units\n------------------------------------\n\nBy default, *QuantiPhy* treats both the scale factor and the units as being \noptional.  With the scale factor being optional, the meaning of some \nspecifications can be ambiguous. For example, '1m' may represent 1 milli or it \nmay represent 1 meter.  Similarly, '1meter' my represent 1 meter or \n1 milli-eter.  In this case *QuantiPhy* gives preference to the scale factor, so \n'1m' normally converts to 1e-3. To allow you to avoid this ambiguity, \n*QuantiPhy* accepts '_' as the unity scale factor.  In this way '1_m' is \nunambiguously 1 meter. You can instruct *QuantiPhy* to output '_' as the unity \nscale factor by specifying the *unity_sf* argument to *set_preferences*:\n\n.. code-block:: python\n\n   >>> Quantity.set_preferences(unity_sf='_', spacer='')\n   >>> l = Quantity(1, 'm')\n   >>> print(l)\n   1_m\n\nIf you need to interpret numbers that have units and are known not to have scale \nfactors, you can specify the *ignore_sf* preference:\n\n.. code-block:: python\n\n   >>> Quantity.set_preferences(ignore_sf=True, unity_sf='', spacer=' ')\n   >>> l = Quantity('1000m')\n   >>> l.as_tuple()\n   (1000.0, 'm')\n\n   >>> print(l)\n   1 km\n\n   >>> Quantity.set_preferences(ignore_sf=False)\n\nAlternatively, you can specify the units you wish to use whose leading character \nis a scale factor.  Once known, these units will no longer confuse *Quantiphy*.  \nThese units can be specified as a list or as a string. If specified as a string \nthe string is split to form the list. Specifying the known units replaces any \nexisting known units.\n\n.. code-block:: python\n\n   >>> d1 = Quantity('1 au')\n   >>> d2 = Quantity('1000 pc')\n   >>> print(d1.render(show_si=False), d2, sep='\\n')\n   1e-18 u\n   1 nc\n\n   >>> Quantity.set_preferences(known_units='au pc')\n   >>> d1 = Quantity('1 au')\n   >>> d2 = Quantity('1000 pc')\n   >>> print(d1.render(show_si=False), d2, sep='\\n')\n   1 au\n   1 kpc\n\n\nExceptional Values\n------------------\n\nYou can test whether the value of the quantity is infinite or is not-a-number.\n\n.. code-block:: python\n\n   >>> h_line.is_infinite()\n   False\n\n   >>> h_line.is_nan()\n   False\n\n\nEquivalence\n-----------\n\nYou can determine whether the value of a quantity or real number is equivalent \nto that of a quantity. The two values need not be identical, they just need to \nbe close to be deemed equivalent. The *reltol* and *abstol* preferences are used \nto determine if they are close.\n\n.. code-block:: python\n\n   >>> h_line.is_close(h_line)\n   True\n\n   >>> h_line.is_close(h_line + 1)\n   True\n\n   >>> h_line.is_close(h_line + 1e4)\n   False\n\nBy default, *is_close()* looks at the both the value and the units if the \nargument has units. In this way if you compare two quantities with different \nunits, the *is_close* test will always fail if their units differ.\n\n.. code-block:: python\n\n   >>> Quantity('10ns').is_close(Quantity('10nm'))\n   False\n\n\nPhysical Constants\n------------------\n\nThe Quantity class also supports a small number of predefined physical \nconstants.\n\nPlank's constant:\n\n.. code-block:: python\n\n   >>> Quantity.set_preferences(\n   ...     show_label=True, spacer=' ',\n   ...     label_fmt=('{n} = {v} -- {d}', '{n} = {v}')\n   ... )\n\n   >>> plank = Quantity('h')\n   >>> print(plank)\n   h = 662.61e-36 J-s -- Plank's constant\n\n   >>> rplank = Quantity('hbar')\n   >>> print(rplank)\n   \u0127 = 105.46e-36 J-s -- reduced Plank's constant\n\n   >>> rplank = Quantity('\u0127')\n   >>> print(rplank)\n   \u0127 = 105.46e-36 J-s -- reduced Plank's constant\n\nBoltzmann's constant:\n\n.. code-block:: python\n\n   >>> boltz = Quantity('k')\n   >>> print(boltz)\n   k = 13.806e-24 J/K -- Boltzmann's constant\n\nElementary charge:\n\n.. code-block:: python\n\n   >>> q = Quantity('q')\n   >>> print(q)\n   q = 160.22e-21 C -- elementary charge\n\nSpeed of light:\n\n.. code-block:: python\n\n   >>> c = Quantity('c')\n   >>> print(c)\n   c = 299.79 Mm/s -- speed of light\n\nZero degrees Celsius in Kelvin:\n\n.. code-block:: python\n\n   >>> zeroC = Quantity('0C')\n   >>> print(zeroC)\n   0\u00b0C = 273.15 K -- zero degrees Celsius in Kelvin\n\n*QuantiPhy* uses *k* rather than *K* to represent kilo so that you can \ndistinguish between kilo and Kelvin.\n\nElectromagnetic Constants:\n\n.. code-block:: python\n\n   >>> eps0 = Quantity('eps0')\n   >>> print(eps0)\n   \u03b5\u2080 = 8.8542 pF/m -- permittivity of free space\n\n   >>> mu0 = Quantity('mu0')\n   >>> print(mu0)\n   \u03bc\u2080 = 1.2566 uH/m -- permeability of free space\n\n   >>> Z0 = Quantity('Z0')\n   >>> print(Z0)\n   Z\u2080 = 376.73 Ohms -- characteristic impedance of free space\n\n\nUnit Systems\n''''''''''''\n\nThere are multiple versions of the built-in constants, each associated with \na different unit system. For example, there are 'mks' (SI) and 'cgs' \n(Gaussian-CGS) versions of Plank's constant, Boltzmann's constant, etc. To \nspecify which one you want, you would set the desired unit system:\n\n.. code-block:: python\n\n   >>> from quantiphy import Quantity, set_unit_system\n\n   >>> plank = Quantity('h')\n   >>> print(plank)\n   h = 662.61e-36 J-s -- Plank's constant\n\n   >>> set_unit_system('cgs')\n   >>> plank = Quantity('h')\n   >>> print(plank)\n   h = 6.6261e-27 erg-s -- Plank's constant\n\n   >>> set_unit_system('mks')\n   >>> plank = Quantity('h')\n   >>> print(plank)\n   h = 662.61e-36 J-s -- Plank's constant\n\nNot all constants exist in both unit systems. For example, the electromagnetic \nconstants are not available in cgs units.\n\nThe currently supported predefined physical constants are:\n\n\n========  =====================  =====================\nname      mks value              cgs value\n========  =====================  =====================\nh         6.626070040e-34 J-s    6.626070040e-27 erg-s\nhbar, \u0127   1.054571800e-34 J-s    1.054571800e-27 erg-s\nk         1.38064852e-23 J/K     1.38064852e-16 erg/K\nq         1.6021766208e-19 C     4.80320425e-10 Fr\nc         2.99792458e8 m/s       2.99792458e8 m/s\n0C, 0\u00b0C   273.15 K               273.15 K\neps0, \u03b5\u2080  8.854187817e-12 F/m    ---\nmu0, \u03bc\u2080   4e-7\u03c0                  ---\nZ0, Z\u2080    376.730 313 461        ---\n========  =====================  =====================\n\nNotice that c, the speed of light, is the same in both unit systems because \nQuantiPhy wants numbers given in terms of their base units rather than in scaled \nunits. So mass is given in grams even though in mks the fundamental unit of mass \nis kilograms and length is given in meters even though in cgs the fundamental \nunit of length is centimeters. If you would like the speed of light given in \ncentimeters, use the following:\n\n.. code-block:: python\n\n    >>> c = Quantity('c', scale=100, units='cm')\n    >>> c.show_si = False\n    >>> print(c)\n    c = 29.979e9 cm -- speed of light\n\n    >>> print(f'{c:e} {c:u}')\n    2.9979e+10 cm\n\n\nUser Defined Constants\n''''''''''''''''''''''\n\nYou can add additional constants using the Constant class. Instantiating this \nclass creates the constant and adds it to QuantiPhy's store of constants (the \nreturn value is generally ignored):\n\n.. code-block:: python\n\n   >>> from quantiphy import Quantity, Constant\n   >>> Constant(Quantity(\"\u03bbh = 211.061140539mm -- wavelength of hydrogen line\"))\n   <...>\n   >>> hy_wavelength = Quantity('\u03bbh')\n   >>> print(hy_wavelength)\n   \u03bbh = 211.06 mm -- wavelength of hydrogen line\n\nThe constant is accessed by name, which in this case is the name given in the \nquantity used when creating the constant. You can also specify the name as an \nargument to Constant:\n\n.. code-block:: python\n\n   >>> from quantiphy import Quantity, Constant\n   >>> Constant(\n   ...     Quantity(\"\u03bbh = 211.061140539mm -- wavelength of hydrogen line\"),\n   ...     name='lambda h'\n   ... )\n   <...>\n   >>> hy_wavelength = Quantity('lambda h')\n   >>> print(hy_wavelength)\n   \u03bbh = 211.06 mm -- wavelength of hydrogen line\n\nIt is not necessary to specify both names, one is sufficient.  Notice that the \nname specified as an argument to Constant does not actually become part of the \nconstant, it is only used for looking up the constant.\n\nBy default, user defined units are not associated with a unit system, meaning \nthat they are always available regardless of which unit system is being used.  \nHowever, when creating a constant you can specify one or more unit systems for \nthe constant. You need not limit yourself to the predefined 'mks' and 'cgs' unit \nsystems.\n\n.. code-block:: python\n\n   >>> Constant(Quantity(4.80320427e-10, 'Fr'), 'q', 'esu gaussian')\n   <...>\n   >>> Constant(Quantity(1.602176487e-20, 'abC'), name='q', unit_systems='emu')\n   <...>\n   >>> q_mks = Quantity('q')\n   >>> set_unit_system('cgs')\n   >>> q_cgs = Quantity('q')\n   >>> set_unit_system('esu')\n   >>> q_esu = Quantity('q')\n   >>> set_unit_system('gaussian')\n   >>> q_gaussian = Quantity('q')\n   >>> set_unit_system('emu')\n   >>> q_emu = Quantity('q')\n   >>> set_unit_system('mks')\n   >>> print(q_mks, q_cgs, q_esu, q_gaussian, q_emu, sep='\\n')\n   q = 160.22e-21 C -- elementary charge\n   q = 480.32 pFr -- elementary charge\n   480.32 pFr\n   480.32 pFr\n   16.022e-21 abC\n\n\nString Formatting\n-----------------\n\nQuantities can be passed into the string *format* method:\n\n.. code-block:: python\n\n   >>> print('{}'.format(h_line))\n   1.4204 GHz\n\n   >>> print('{:s}'.format(h_line))\n   1.4204 GHz\n\nIn these cases the preferences for SI scale factors, units, and precision are \nhonored.\n\nYou can override the precision as part of the format specification\n\n.. code-block:: python\n\n   >>> print('{:.6}'.format(h_line))\n   1.420406 GHz\n\nYou can also specify the width and alignment.\n\n.. code-block:: python\n\n   >>> print('|{:15.6}|'.format(h_line))\n   |1.420406 GHz   |\n\n   >>> print('|{:<15.6}|'.format(h_line))\n   |1.420406 GHz   |\n\n   >>> print('|{:>15.6}|'.format(h_line))\n   |   1.420406 GHz|\n\nThe 'q' type specifier can be used to explicitly indicate that both the number \nand the units are desired and that SI scale factors should be used, regardless \nof the current preferences.\n\n.. code-block:: python\n\n   >>> print('{:.6q}'.format(h_line))\n   1.420406 GHz\n\nAlternately, 'r' can be used to indicate just the number represented using SI \nscale factors is desired, and the units should not be included.\n\n.. code-block:: python\n\n   >>> print('{:r}'.format(h_line))\n   1.4204G\n\nYou can also use the floating point format type specifiers:\n\n.. code-block:: python\n\n   >>> print('{:f}'.format(h_line))\n   1420405751.7860\n\n   >>> print('{:e}'.format(h_line))\n   1.4204e+09\n\n   >>> print('{:g}'.format(h_line))\n   1.4204e+09\n\nUse 'u' to indicate that only the units are desired:\n\n.. code-block:: python\n\n   >>> print('{:u}'.format(h_line))\n   Hz\n\nAccess the name or description of the quantity using 'n' and 'd'.\n\n.. code-block:: python\n\n   >>> wavelength = Quantity('\u03bbh')\n   >>> print('{:n}'.format(wavelength))\n   \u03bbh\n\n   >>> print('{:d}'.format(wavelength))\n   wavelength of hydrogen line\n\nUsing the upper case versions of the format codes that print the numerical value \nof the quantity (SQRFEG) to indicate that the name and perhaps description \nshould be included as well. They are under the control of the *label_fmt* \npreference.\n\n.. code-block:: python\n\n   >>> trise = Quantity('10ns', name='trise')\n\n   >>> print('{:S}'.format(trise))\n   trise = 10 ns\n\n   >>> print('{:Q}'.format(trise))\n   trise = 10 ns\n\n   >>> print('{:R}'.format(trise))\n   trise = 10n\n\n   >>> print('{:F}'.format(trise))\n   trise = 0.0000\n\n   >>> print('{:E}'.format(trise))\n   trise = 1.0000e-08\n\n   >>> print('{:G}'.format(trise))\n   trise = 1e-08\n\n   >>> print('{0:n} = {0:q} ({0:d})'.format(wavelength))\n   \u03bbh = 211.06 mm (wavelength of hydrogen line)\n\n   >>> print('{:S}'.format(wavelength))\n   \u03bbh = 211.06 mm -- wavelength of hydrogen line\n\nYou can also specify two values to *label_fmt*, in which case the first is used \nif there is a description and the second used otherwise.\n\n.. code-block:: python\n\n   >>> Quantity.set_preferences(label_fmt=('{n} = {v} -- {d}', '{n} = {v}'))\n\n   >>> print('{:S}'.format(trise))\n   trise = 10 ns\n\n   >>> print('{:S}'.format(wavelength))\n   \u03bbh = 211.06 mm -- wavelength of hydrogen line\n\nFinally, you can add units after the format code, which will cause the number to \nbe scaled to those units if the transformation represents a known unit \nconversion.\n\n.. code-block:: python\n\n   >>> Tboil = Quantity('Boiling point = 100 \u00b0C')\n   >>> print('{:S\u00b0F}'.format(Tboil))\n   Boiling point = 212 \u00b0F\n\n   >>> eff_channel_length = Quantity('leff = 14nm')\n   >>> print('{:S\u00c5}'.format(eff_channel_length))\n   leff = 140 \u00c5\n\nThis feature can be used to simplify the conversion of the time and temperature \ninformation back into the original units:\n\n.. code-block:: python\n\n    >>> for time, temp in data:\n    ...     print('{:<7smin} {:s\u00b0F}'.format(time, temp))\n    0 min   450 \u00b0F\n    10 min  400 \u00b0F\n    20 min  360 \u00b0F\n\nAll of these features can be used with formatted strings, which are new to \nPython in version 3.6:\n\n.. code-block:: python\n\n    >>> for time, temp in data:\n    ...     print(f'{time:<7smin} {temp:s\u00b0F}')\n    0 min   450 \u00b0F\n    10 min  400 \u00b0F\n    20 min  360 \u00b0F\n\n\nExceptions\n----------\n\nA ValueError is raised if *Quantity* is passed a string it cannot convert into \na number:\n\n.. code-block:: python\n\n   >>> try:\n   ...     q = Quantity('xxx')\n   ... except ValueError as err:\n   ...     print(err)\n   xxx: not a valid number\n\nA KeyError is raised if a unit conversion is requested but no suitable unit\nconverter is available.\n\n.. code-block:: python\n\n   >>> q = Quantity('93 Mmi', scale='pc')\n   Traceback (most recent call last):\n   ...\n   KeyError: ('pc', 'mi')\n\nA NameError is raised if a constant is created without a name.\n\n.. code-block:: python\n\n   >>> q = Constant(Quantity('1ns'))\n   Traceback (most recent call last):\n   ...\n   NameError: no name specified\n\n\nSubclassing Quantity\n--------------------\n\nBy subclassing Quantity you can create different sets of default behaviors that \nare active simultaneously. For example:\n\n.. code-block:: python\n\n   >>> class ConventionalQuantity(Quantity):\n   ...     pass\n\n   >>> ConventionalQuantity.set_preferences(show_si=False, show_units=False)\n\n   >>> period1 = Quantity(1e-9, 's')\n   >>> period2 = ConventionalQuantity(1e-9, 's')\n   >>> print(period1, period2)\n   1 ns 1e-9\n\n\nAdd to Namespace\n----------------\n\nIt is possible to put a collection of quantities in a text string and then use \nthe *add_to_namespace* function to parse the quantities and add them to the \nPython namespace. For example:\n\n.. code-block:: python\n\n   >>> design_parameters = '''\n   ...     Fref = 156 MHz  -- Reference frequency\n   ...     Kdet = 88.3 uA  -- Gain of phase detector (Imax)\n   ...     Kvco = 9.07 GHz/V  -- Gain of VCO\n   ... '''\n   >>> Quantity.add_to_namespace(design_parameters)\n\n   >>> print(Fref, Kdet, Kvco, sep='\\n')\n   Fref = 156 MHz -- Reference frequency\n   Kdet = 88.3 uA -- Gain of phase detector (Imax)\n   Kvco = 9.07 GHz/V -- Gain of VCO\n\nAny number of quantities may be given, with each quantity given on its own line.  \nThe identifier given to the left '=' is the name of the variable in the local \nnamespace that is used to hold the quantity. The text after the '--' is used as \na description of the quantity.\n\nHere is an example that uses this feature to read parameters from a file. It \nalso subclasses Quantity to create a version that displays the name and \ndescription by default:\n\n.. code-block:: python\n\n   >>> from quantiphy import Quantity\n   >>> from inform import os_error, fatal, display\n\n   >>> class VerboseQuantity(Quantity):\n   ...    show_label = True\n   ...    label_fmt = ('{n} = {v} -- {d}', '{n} = {v}')\n\n   >>> filename = 'parameters'\n   >>> try:\n   ...     with open(filename) as f:\n   ...         VerboseQuantity.add_to_namespace(f.read())\n   ... except OSError as err:\n   ...     fatal(os_error(err))\n   ... except ValueError as err:\n   ...     fatal(err, culprit=filename)\n\n   >>> display(Fref, Kdet, Kvco, sep='\\n')\n   Fref = 156 MHz -- Reference frequency\n   Kdet = 88.3 uA -- Gain of phase detector (Imax)\n   Kvco = 9.07 GHz/V -- Gain of VCO\n\n\nExample\n-------\n\nHere is a simple example that uses *QuantiPhy*. It runs the *du* command, which \nprints out the disk usage of files and directories.  The results from *du* are \ngathered and then sorted by size and then the size and name of each item is \nprinted.\n\nQuantity is used to interpret the 'human' size output from *du* and convert it \nto a float, which is easily sorted, then is is converted back to a string with \nSI scale factors and units when rendered in the print statement.\n\n.. code-block:: python\n\n   #!/usr/bin/env python3\n   # runs du and sorts the output while suppressing any error messages from du\n\n   from quantiphy import Quantity\n   from inform import display, fatal, os_error\n   from shlib import Run\n   import sys\n\n   try:\n      du = Run(['du', '-h'] + sys.argv[1:], modes='WEO1')\n\n      files = []\n      for line in du.stdout.split('\\n'):\n         if line:\n             size, filename = line.split('\\t', 1)\n             files += [(Quantity(size, 'B'), filename)]\n\n      files.sort(key=lambda x: x[0])\n\n      for each in files:\n         display(*each, sep='\\t')\n\n   except OSError as err:\n      fatal(os_error(err))\n   except KeyboardInterrupt:\n      display('dus: killed by user.')\n\n\nMatPlotLib Example\n-------------------\n\nIn this example *QuantiPhy* is used to create easy to read axis labels in \nMatPlotLib. It uses NumPy to do a spectral analysis of a signal and then \nproduces an SVG version of the results using MatPlotLib.\n\n.. code-block:: python\n\n    #!/usr/bin/env python3\n\n    import numpy as np\n    from numpy.fft import fft, fftfreq, fftshift\n    import matplotlib as mpl\n    mpl.use('SVG')\n    from matplotlib.ticker import FuncFormatter\n    import matplotlib.pyplot as pl\n    from quantiphy import Quantity\n    Quantity.set_preferences(prec=2)\n\n    # define the axis formatting routines\n    def freq_fmt(val, pos):\n        return Quantity(val, 'Hz').render()\n    freq_formatter = FuncFormatter(freq_fmt)\n\n    def volt_fmt(val, pos):\n        return Quantity(val, 'V').render()\n    volt_formatter = FuncFormatter(volt_fmt)\n\n    # read the data from delta-sigma.smpl\n    data = np.fromfile('delta-sigma.smpl', sep=' ')\n    time, wave = data.reshape((2, len(data)//2), order='F')\n\n    # print out basic information about the data\n    timestep = Quantity(time[1] - time[0], 's')\n    nonperiodicity = Quantity(wave[-1] - wave[0], 'V')\n    points = Quantity(len(time))\n    period = Quantity(timestep * len(time), 's')\n    freq_res = Quantity(1/period, 'Hz')\n    print('timestep:', timestep)\n    print('nonperiodicity:', nonperiodicity)\n    print('timepoints:', points)\n    print('period:', period)\n    print('freq resolution:', freq_res)\n\n    # create the window\n    window = np.kaiser(len(time), 11)/0.37\n        # beta=11 corresponds to alpha=3.5 (beta = pi*alpha)\n        # the processing gain with alpha=3.5 is 0.37\n    windowed = window*wave\n\n    # transform the data into the frequency domain\n    spectrum = 2*fftshift(fft(windowed))/len(time)\n    freq = fftshift(fftfreq(len(wave), timestep))\n\n    # generate graphs of the resulting spectrum\n    fig = pl.figure()\n    ax = fig.add_subplot(111)\n    ax.plot(freq, np.absolute(spectrum))\n    ax.set_yscale('log')\n    ax.xaxis.set_major_formatter(freq_formatter)\n    ax.yaxis.set_major_formatter(volt_formatter)\n    pl.savefig('spectrum.svg')\n    ax.set_xlim((0, 1e6))\n    ax.set_ylim((1e-7, 1))\n    pl.savefig('spectrum-zoomed.svg')\n\nThis script produces the following textual output::\n\n    timestep: 20 ns\n    nonperiodicity: 2.3 pV\n    timepoints: 28k\n    period: 560 us\n    freq resolution: 1.79 kHz\n\nAnd the following is one of the two graphs produced:\n\n..  image:: spectrum-zoomed.png\n\nNotice the axis labels in the generated graph.  Use of *QuantiPhy* makes the \nwidely scaled units compact and easy to read.\n\n\nReleases\n--------\n\n1.0 (2016-11-26):\n    - Initial production release.\n\n1.1 (2016-11-27):\n    - Added *known_units* preference.\n    - Added *get_preference* class method.\n\n1.2 (2017-02-24):\n    - allow digits after decimal point to be optional\n    - support underscores in numbers\n    - allow options to be monkey-patched on to Quantity objects\n    - add strip_dp option\n    - fix some issues in full precision mode\n    - ranamed some options, arguments and methods\n\n1.3 (2017-03-19):\n    - reworked constants\n    - added unit systems for physical constants\n",
    "docs_url": null,
    "download_url": "https://github.com/kenkundert/quantiphy/tarball/master",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "http://nurdletech.com/linux-utilities/quantiphy",
    "keywords": "quantities",
    "license": "GPLv3+",
    "maintainer": "",
    "maintainer_email": "",
    "name": "quantiphy",
    "platform": "",
    "project_url": "https://pypi.org/project/quantiphy/",
    "release_url": "https://pypi.org/project/quantiphy/1.3.0/",
    "requires_python": "",
    "summary": "physical quantities (numbers with units)",
    "version": "1.3.0"
  },
  "releases": {
    "0.0.1": [],
    "0.2.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "ab39922c9e8025c4f4faaf566cc0a4c6",
          "sha256": "88de4942b360d4d8d734ff37159343c33ea07e56230ed733d2286cbd3c174fca"
        },
        "downloads": 314,
        "filename": "quantiphy-0.2.0.tar.gz",
        "has_sig": false,
        "md5_digest": "ab39922c9e8025c4f4faaf566cc0a4c6",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 25334,
        "upload_time": "2016-10-23T07:43:03",
        "url": "https://files.pythonhosted.org/packages/c9/cb/62ba0587386c41ce6f4f3a03cb83970a4b3a738ae9325a92d58048210c4b/quantiphy-0.2.0.tar.gz"
      }
    ],
    "0.4.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "f9ea78fc25a9b1440c072592dc3bc131",
          "sha256": "7c1b0d52dc9254ab60fe531bb9105e5d7c4c9253a7f11258973f9b0173ad7e2f"
        },
        "downloads": 128,
        "filename": "quantiphy-0.4.0.tar.gz",
        "has_sig": false,
        "md5_digest": "f9ea78fc25a9b1440c072592dc3bc131",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 26504,
        "upload_time": "2016-10-26T10:31:09",
        "url": "https://files.pythonhosted.org/packages/28/10/538a1f76e4a698ec641827d9dcfdea5d7fd0dc4e9407adcd06d2c390d756/quantiphy-0.4.0.tar.gz"
      }
    ],
    "0.5.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "c76cbc4e14186e3492a6a250ddb8bef0",
          "sha256": "3ad0e68b9043071bfa1e6543254831b27ec3be5fc9165c3c21af48ce3140e993"
        },
        "downloads": 79,
        "filename": "quantiphy-0.5.0.tar.gz",
        "has_sig": false,
        "md5_digest": "c76cbc4e14186e3492a6a250ddb8bef0",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 31247,
        "upload_time": "2016-11-04T08:16:38",
        "url": "https://files.pythonhosted.org/packages/1c/6c/a3caaa600d5c2de46dfe21b7306565a1262e0268fac83242c8f488039db9/quantiphy-0.5.0.tar.gz"
      }
    ],
    "1.0.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "b278ca6b287a7de5a9a4d3da91332659",
          "sha256": "3fc003e8352def57bc0328243f27ce28b7d3e332ca2081a7ae6730fde958a4e0"
        },
        "downloads": 303,
        "filename": "quantiphy-1.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "b278ca6b287a7de5a9a4d3da91332659",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 46035,
        "upload_time": "2016-11-27T04:44:47",
        "url": "https://files.pythonhosted.org/packages/b2/8e/0c0649ea90ffefe158e889a5376dbef1658fb4a989ab7e7dab55d0217f83/quantiphy-1.0.0.tar.gz"
      }
    ],
    "1.1.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "6e42b75b7d11f6988d746c1cfc32b5c0",
          "sha256": "53a17fb044daffc6929aec59b16a0dbcaaedc7fb568201440982f8a3fc0159d2"
        },
        "downloads": 292,
        "filename": "quantiphy-1.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "6e42b75b7d11f6988d746c1cfc32b5c0",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 47787,
        "upload_time": "2016-11-27T20:43:18",
        "url": "https://files.pythonhosted.org/packages/a6/b2/16aea19e7efbb944d3afa982da712f8eddda98d8d675ad94910fafb600d6/quantiphy-1.1.0.tar.gz"
      }
    ],
    "1.2.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "9bd823c2e4a746780bc4fe0fba8f8c1f",
          "sha256": "2478943e2798b245238f9b6ae307eef4b2a5657a4f81f8bd74aec1af6d9a8396"
        },
        "downloads": 13,
        "filename": "quantiphy-1.2.0.tar.gz",
        "has_sig": false,
        "md5_digest": "9bd823c2e4a746780bc4fe0fba8f8c1f",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 52102,
        "upload_time": "2017-02-24T20:48:59",
        "url": "https://files.pythonhosted.org/packages/f2/72/c213f9ce4b9c72b43e7af27ba6fa6dbab1024c8ef1bce9d4766e1a7dc00e/quantiphy-1.2.0.tar.gz"
      }
    ],
    "1.3.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "aa939e553b5393734602b699d76e3d5d",
          "sha256": "2bef48ccb3807ffe32a68acd2062bdd53bf74075ed0fa0b01cd7b2eddb15cbd5"
        },
        "downloads": 279,
        "filename": "quantiphy-1.3.0.tar.gz",
        "has_sig": false,
        "md5_digest": "aa939e553b5393734602b699d76e3d5d",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 56638,
        "upload_time": "2017-03-19T18:01:54",
        "url": "https://files.pythonhosted.org/packages/03/9c/c2a688021a5a501eda2edfa269dd46bed0b2ef086d99e278cfa773e9252f/quantiphy-1.3.0.tar.gz"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "aa939e553b5393734602b699d76e3d5d",
        "sha256": "2bef48ccb3807ffe32a68acd2062bdd53bf74075ed0fa0b01cd7b2eddb15cbd5"
      },
      "downloads": 279,
      "filename": "quantiphy-1.3.0.tar.gz",
      "has_sig": false,
      "md5_digest": "aa939e553b5393734602b699d76e3d5d",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 56638,
      "upload_time": "2017-03-19T18:01:54",
      "url": "https://files.pythonhosted.org/packages/03/9c/c2a688021a5a501eda2edfa269dd46bed0b2ef086d99e278cfa773e9252f/quantiphy-1.3.0.tar.gz"
    }
  ]
}