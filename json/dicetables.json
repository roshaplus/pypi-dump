{
  "info": {
    "author": "Eric Shaw",
    "author_email": "shaweric01@gmail.com",
    "bugtrack_url": "",
    "classifiers": [
      "Development Status :: 4 - Beta",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python",
      "Programming Language :: Python :: 2.7",
      "Programming Language :: Python :: 3",
      "Topic :: Games/Entertainment :: Role-Playing",
      "Topic :: Scientific/Engineering :: Mathematics"
    ],
    "description": "#################\ndicetables v2.2.0\n#################\n=========\nCHANGELOG\n=========\n\n- EventsCalculations added functions log10_points and log10_axes\n- New dice: Exploding(other_die, explosions=2), ExplodingOn(other_die, explodes_on, explosions=2)\n- see `Die Classes`_ and `EventsInformation And EventsCalculations`_ for details\n\n=====================================================\na module for statistics of die rolls and other events\n=====================================================\n\n\nThis module uses DiceTable and AdditiveEvents to combine\ndice and other events that can be added together. It is used to\nfigure out the probability of events occurring.  For instance, if you\nroll 100 six-sided dice, the chance of rolling any number between 100\nand 300 is 0.15 percent.\n\ncontents:\n\n- `THE BASICS`_\n- `Die Classes`_\n- `AdditiveEvents And IntegerEvents`_\n- `DiceTable And DetailedDiceTable`_\n- `EventsInformation And EventsCalculations`_\n- `Inheritance`_\n- `HOW TO GET ERRORS AND BUGS`_\n\n.. _Top:\n\n----------\nTHE BASICS\n----------\n| Here's a quick bit of math.  if you combine a 2-sided die and a 3-sided die,\n| you get the following combinations.\n| (1,1) / (1, 2) (2, 1) / (2, 2), (1, 3) / (2, 3):\n\n- roll - 2: 1 occurrence  (1 in 6 chance)\n- roll - 3: 2 occurrences  (2 in 6 chance)\n- roll - 4: 2 occurrences  (2 in 6 chance)\n- roll - 5: 1 occurrence  (1 in 6 chance)\n\n>>> import dicetables as dt\n>>> new = dt.DiceTable.new()\n>>> one_two_sided = new.add_die(dt.Die(2), times=1)\n>>> one_two_sided_one_three_sided = one_two_sided.add_die(dt.Die(3), 1)\n>>> one_two_sided_one_three_sided.get_dict()\n{2: 1, 3: 2, 4: 2, 5: 1}\n>>> one_two_sided.get_dict()\n{1: 1, 2: 1}\n>>> new.get_dict()\n{0: 1}\n\nHere are basic table functions. note that times added defaults to one.\nAlso note that DiceTable is immutable. adding and removing dice creates a new table. The original table is intact.\n\n\n>>> table = dt.DiceTable.new().add_die(dt.Die(2)).add_die(dt.Die(3))\n>>> str(table)\n'1D2\\n1D3'\n>>> table = table.add_die(dt.Die(2), 100)\n>>> table = table.remove_die(dt.Die(2), 99)\n>>> print(table)\n2D2\n1D3\n>>> print(table.add_die(dt.Modifier(5), 2))\n+5\n+5\n2D2\n1D3\n>>> table.get_list()  # list is sorted according to die\n[(Die(2), 2), (Die(3), 1)]\n>>> table.number_of_dice(dt.Die(10))\n0\n>>> table.number_of_dice(dt.Die(2))\n2\n>>> print(table.weights_info())\n2D2\n    No weights\n<BLANKLINE>\n1D3\n    No weights\n\nTo get useful information, use EventsInformation object and EventsCalculations object\n\n>>> table = dt.DiceTable.new()\n>>> table = table.add_die(dt.StrongDie(dt.Die(2), 3), 2)\n>>> table.get_dict() == {6: 1, 9: 2, 12: 1}\nTrue\n>>> info = dt.EventsInformation(table)\n>>> info.all_events()\n[(6, 1), (9, 2), (12, 1)]\n>>> info.all_events_include_zeroes()\n[(6, 1), (7, 0), (8, 0), (9, 2), (10, 0), (11, 0), (12, 1)]\n>>> info.events_keys()\n[6, 9, 12]\n>>> info.events_range()\n(6, 12)\n>>> info.get_event(4)\n(4, 0)\n>>> info.get_range_of_events(7, 13)\n[(7, 0), (8, 0), (9, 2), (10, 0), (11, 0), (12, 1)]\n>>> info.biggest_event()\n(9, 2)\n>>> info.total_occurrences()\n4\n>>> calc = dt.EventsCalculations(table)\n>>> calc.mean()\n9.0\n>>> calc.stddev()\n2.1213\n>>> calc.percentage_points()\n[(6, 25.0), (7, 0.0), (8, 0.0), (9, 50.0), (10, 0.0), (11, 0.0), (12, 25.0)]\n>>> print(calc.full_table_string())\n 6: 1\n 7: 0\n 8: 0\n 9: 2\n10: 0\n11: 0\n12: 1\n>>> without_zeroes = dt.EventsCalculations(table, include_zeroes=False)\n>>> print(without_zeroes.full_table_string())\n 6: 1\n 9: 2\n12: 1\n<BLANKLINE>\n>>> stats_str = \"{} occurred {} times out of {} combinations.\\nThat's a one in {} chance or {}%\"\n>>> print(stats_str.format(*without_zeroes.stats_strings([1, 2, 5, 8, 9, 10])))\n1-2, 5, 8-10 occurred 2 times out of 4 combinations.\nThat's a one in 2.000 chance or 50.00%\n>>> without_zeroes.percentage_axes()\n[(6, 9, 12), (25.0, 50.0, 25.0)]\n\nDetailedDiceTable keeps a copy of these objects at .info and .calc calc_includes_zeros defaults to True\n\n>>> d_table = dt.DetailedDiceTable.new()\n>>> d_table.info.events_range()\n(0, 0)\n>>> d_table.calc.mean()\n0.0\n>>> d_table = d_table.add_die(dt.Die(6), 100)\n>>> d_table.info.events_range()\n(100, 600)\n>>> d_table.calc.mean()\n350.0\n\nYou may also access this functionality with wrapper functions:\n\n- events_range\n- mean\n- stddev\n- stats\n- full_table_string\n- percentage_points\n- percentage_axes\n\n>>> silly_table = dt.AdditiveEvents({1: 123456, 100: 12345*10**1000})\n>>> print(dt.full_table_string(silly_table, include_zeroes=False, shown_digits=6))\n  1: 123,456\n100: 1.23450e+1004\n<BLANKLINE>\n>>> stats_info = dt.stats(silly_table, list(range(-5000, 5)))\n>>> print(stats_str.format(*stats_info))\n(-5,000)-4 occurred 123,456 times out of 1.234e+1004 combinations.\nThat's a one in 1.000e+999 chance or 1.000e-997%\n\nFinally, here are all the kinds of dice you can add\n\n- dt.Die(6)\n- dt.ModDie(6, -2)\n- dt.WeightedDie({1:1, 2:5, 3:2})\n- dt.ModWeightedDie({1:1, 2:5, 3:2}, 5)\n- dt.StrongDie(dt.Die(6), 5)\n- dt.Modifier(-6)\n- dt.Exploding(dt.Die(6), explosions=4)\n- dt.ExplodingOn(dt.Die(6), (1, 3, 6), explosions=2)\n\nThat's all of the basic implementation. The rest of this is details about base classes, details of the\ndie classes, details of dicetable classes, what causes errors and the changes from the previous version.\n\nTop_\n\n-----------\nDie Classes\n-----------\nAll dice are subclasses of dicetables.eventsbases.protodie.ProtoDie, which is a subclass of\ndicetables.eventsbases.integerevents.IntegerEvents. They all require implementations of\nget_size(), get_weight(), weight_info(), multiply_str(number), __str__(), __repr__() and\nget_dict() (the final one is a requirement of all IntegerEvents).\n\nThey are all immutable , hashable and rich-comparable. Multiple names can safely point\nto the same instance of a Die, they can be used in sets and dictionary keys and they can be\nsorted with any other kind of die. Comparisons are done by (size, weight, get_dict, __repr__(as a last resort)).\nSo:\n\n>>> dice_list = [\n... dt.ModDie(2, 0),\n... dt.WeightedDie({1: 1, 2: 1}),\n... dt.Die(2),\n... dt.ModWeightedDie({1: 1, 2: 1}, 0),\n... dt.StrongDie(dt.Die(2), 1),\n... dt.StrongDie(dt.WeightedDie({1: 1, 2: 1}), 1)\n... ]\n>>> [die.get_dict() == {1: 1, 2: 1} for die in dice_list]\n[True, True, True, True, True, True]\n>>> sorted(dice_list)\n[Die(2),\n ModDie(2, 0),\n StrongDie(Die(2), 1),\n ModWeightedDie({1: 1, 2: 1}, 0),\n StrongDie(WeightedDie({1: 1, 2: 1}), 1),\n WeightedDie({1: 1, 2: 1})]\n>>> [die == dt.Die(2) for die in sorted(dice_list)]\n[True, False, False, False, False, False]\n>>> my_set = {dt.Die(6)}\n>>> my_set.add(dt.Die(6))\n>>> my_set == {dt.Die(6)}\nTrue\n>>> my_set.add(dt.ModDie(6, 0))\n>>> my_set == {dt.Die(6), dt.ModDie(6, 0)}\nTrue\n\nThe dice:\n\nDie\n    A basic die.  dt.Die(4) rolls 1, 2, 3, 4 with equal weight\n\n    No added methods\n\n\nModDie\n    A die with a modifier.  The modifier is added to each die roll.\n    dt.ModDie(4, -2) rolls -1, 0, 1, 2 with equal weight. It is 4-sided die\n    with -2 added to each roll (D4-2)\n\n    added methods:\n\n    - .get_modifier(): returns the modifier applied to each roll\n\nWeightedDie\n    A die that rolls different rolls with different frequencies.\n    dt.WeightedDie({1:1, 3:3, 4:6}) is a 4-sided die.  It rolls 4\n    six times as often as 1, rolls 3 three times as often as 1\n    and never rolls 2\n\n    added methods:\n\n    - .get_raw_dict(): returns all values in die.get_size() even if they are zero.\n      in the above example, it will return {1: 1, 2: 0, 3: 3, 4: 4}\n\nModWeightedDie\n    A die with a modifier that rolls different rolls with different frequencies.\n    dt.ModWeightedDie({1:1, 3:3, 4:6}, 3) is a 4-sided die. 3 is added to all\n    die rolls.  The same as WeightedDie.\n\n    added methods:\n\n    - .get_raw_dict()\n    - .get_modifier()\n\nStrongDie\n    A die that is a strong version of any other die (including another StrongDie\n    if you're feeling especially silly). So a StrongDie with a multiplier of 2\n    would add 2 for each 1 that was rolled. StrongDie(Die(4), 2) rolls 2, 4, 6, and 8\n\n    >>> die = dt.Die(4)\n    >>> die.get_dict() == {1: 1, 2: 1, 3: 1, 4: 1}\n    True\n    >>> dt.StrongDie(die, 5).get_dict() == {5: 1, 10: 1, 15: 1, 20: 1}\n    True\n    >>> example = dt.StrongDie(die, -2)\n    >>> example.get_dict() == {-2: 1, -4: 1, -6: 1, -8: 1}\n    True\n    >>> example.get_input_die() == die\n    True\n    >>> example.get_multiplier()\n    -2\n\n    added methods:\n\n    - .get_multiplier()\n    - .get_input_die()\n\nModifier\n    A simple +/- modifier that adds to the total dice roll.\n\n    Modifier(-3) is a one-sided die that always rolls a -3.  size=0, weight=0.\n\n    >>> table = dt.DiceTable.new().add_die(dt.Die(4))\n    >>> table.get_dict() == {1: 1, 2: 1, 3: 1, 4: 1}\n    True\n    >>> table = table.add_die(dt.Modifier(3))\n    >>> print(table)\n    +3\n    1D4\n    >>> table.get_dict() == {4: 1, 5: 1, 6: 1, 7: 1}\n    True\n\n    added methods:\n\n    - .get_modifier(): returns the modifier value\n\nExploding\n    An exploding die is a die that has a chance to roll again. Each time the highest number is rolled, you\n    add that to the total and keep rolling. An exploding D6 rolls 1-5 as usual. When it rolls a 6, it re-rolls\n    and adds that 6. If it rolls a 6 again, this continues, adding 12 to the result. Since this is an infinite\n    but increasingly unlikely process, the \"explosions\" parameter sets the number of re-rolls allowed.\n\n    The number of explosions defaults to 2.\n\n    Here are the rolls for an exploding D4 that can explode up to 3 times. It rolls 1-3 sixty-four\n    times more often than 13-16.\n\n    >>> roll_values = dt.Exploding(dt.Die(4), explosions=3).get_dict()\n    >>> sorted(roll_values.items())\n     [(1, 64), (2, 64), (3, 64),\n      (5, 16), (6, 16), (7, 16),\n      (9, 4), (10, 4), (11, 4),\n      (13, 1), (14, 1), (15, 1), (16, 1)]\n\n    Any modifiers and multipliers are applied to each re-roll. Exploding D6+1 explodes on a 7.\n    On a \"7\" it rolls 7 + (D6 + 1). On a \"14\", it rolls 14 + (D6 + 1).\n\n    Here are the rolls for an exploding D6+1 that can explode the default times.\n\n    >>> roll_values = dt.Exploding(dt.ModDie(6, 1)).get_dict()\n    >>> sorted(roll_values.items())\n    [(2, 36), (3, 36), (4, 36), (5, 36), (6, 36),\n     (9, 6), (10, 6), (11, 6), (12, 6), (13, 6),\n     (16, 1), (17, 1), (18, 1), (19, 1), (20, 1), (21, 1)]\n\n\n    added methods:\n\n    - .get_input_die()\n    - .get_explosions(): returns the number of re-rolls allowed\n\nExplodingOn\n    This is the same as Exploding, except you also use a tuple of ints to state what values the die continues rolling on.\n    dt.ExplodingOn(dt.Die(6), (1, 6), explosions=2) continues rolling and adding the die value when either 1 or 6\n    is rolled.\n\n    The number of explosions defaults to 2.\n\n    Here are the rolls for an exploding D6 that can explode the default times and explodes on 5 and 6.\n\n    >>> roll_values = dt.ExplodingOn(dt.Die(6), (5, 6)).get_dict()\n    >>> sorted(roll_values.items())\n    [(1, 36), (2, 36), (3, 36), (4, 36),\n     (6, 6), (7, 12), (8, 12), (9, 12), (10, 6),\n     (11, 1), (12, 3), (13, 4), (14, 4), (15, 4), (16, 4), (17, 3), (18, 1)]\n\n    added methods:\n\n    - .get_input_die()\n    - .get_explosions()\n    - .get_explodes_on(): returns the tuple of roll values that the die can explode on\n\nTop_\n\n--------------------------------\nAdditiveEvents And IntegerEvents\n--------------------------------\nAll tables and dice inherit from dicetables.eventsbases.IntegerEvents.  All subclasses of IntegerEvents need the method\nget_dict() which returns {event: occurrences, ...} for each NON-ZERO occurrence.  When you instantiate\nany subclass, it checks to make sure you're get_dict() is legal.\n\nAny child of IntegerEvents has access to __eq__ and __ne__ evaluated by type and then get_dict(). It can be compared\nto any object and two events that are not the exact same class will be !=.\n\nAny of the classes that take a dictionary of events as input scrub the zero\noccurrences out of the dictionary for you.\n\n>>> dt.DiceTable({1: 1, 2:0}, {}).get_dict()\n{1: 1}\n>>> dt.AdditiveEvents({1: 2, 3: 0, 4: 1}).get_dict()\n{1: 2, 4: 1}\n>>> dt.ModWeightedDie({1: 2, 3: 0, 4: 1}, -5).get_dict()\n{-4: 2, -1: 1}\n\nAdditiveEvents is the parent of DiceTable. It has the class method new() which returns the identity. This method is\ninherited by its children. You can add and remove events using the \".combine\" method which tries\nto pick the fastest combining algorithm. You can pick it yourself by calling \".combine_by_<algorithm>\". You can\ncombine and remove DiceTable, AdditiveEvents, Die or any other IntegerEvents with the \"combine\" and \"remove\" methods,\nbut there's no record of it.  AdditiveEvents has __eq__ method that tests type and get_dict(). This is inherited\nfrom IntegerEvents.\n\n>>> three_D2 = dt.AdditiveEvents.new().combine_by_dictionary(dt.Die(2), 3)\n>>> also_three_D2 = dt.AdditiveEvents({3: 1, 4: 3, 5: 3, 6: 1})\n>>> still_three_D2 = dt.AdditiveEvents.new().combine(dt.AdditiveEvents({1: 1, 2: 1}), 3)\n>>> three_D2.get_dict() == also_three_D2.get_dict() == still_three_D2.get_dict()\nTrue\n>>> identity = three_D2.remove(dt.Die(2), 3)\n>>> identity.get_dict() == dt.AdditiveEvents.new().get_dict() == {0: 1}\nTrue\n>>> identity == dt.AdditiveEvents.new()\nTrue\n>>> print(three_D2)\ntable from 3 to 6\n>>> twenty_one_D2 = three_D2.combine_by_indexed_values(three_D2, 6)\n>>> twenty_one_D2_five_D4 = twenty_one_D2.combine_by_flattened_list(dt.Die(4), 5)\n>>> five_D4 = twenty_one_D2_five_D4.remove(dt.Die(2), 21)\n>>> dt.DiceTable.new().add_die(dt.Die(4), 5).get_dict() == five_D4.get_dict()\nTrue\n>>> dt.DiceTable.new().add_die(dt.Die(4), 5) == five_D4  # will be False since DiceTable is not AdditiveEvents\nFalse\n\nSince DiceTable is the child of AdditiveEvents, it can do all this combining and removing, but it won't be recorded\nin the dice record.\n\nTop_\n\n-------------------------------\nDiceTable And DetailedDiceTable\n-------------------------------\nYou can instantiate any DiceTable or DetailedDiceTable with any data you like.\nThis allows you to create a DiceTable from stored information or to copy.\nPlease note that the \"dice_data\" method is ambiguously named on purpose. It's\nfunction is to get correct input to instantiate a new DiceTable, whatever that\nhappens to be. To get consistent output, use \"get_list\".  Equality testing is by type, get_dict(), dice_data()\n(and calc_includes_zeroes for DetailedDiceTable).\n\n>>> old = dt.DiceTable.new()\n>>> old = old.add_die(dt.Die(6), 100)\n>>> events_record = old.get_dict()\n>>> dice_record = old.dice_data()\n>>> new = dt.DiceTable(events_record, dice_record)\n>>> print(new)\n100D6\n>>> record = dt.DiceRecord({dt.Die(6): 100})\n>>> also_new = dt.DetailedDiceTable(new.get_dict(), record, calc_includes_zeroes=False)\n>>> old.get_dict() == new.get_dict() == also_new.get_dict()\nTrue\n>>> old.get_list() == new.get_list() == also_new.get_list()\nTrue\n>>> old == new\nTrue\n>>> old == also_new  # False by type\nFalse\n>>> isinstance(also_new, dt.DiceTable)\nTrue\n>>> type(also_new) is dt.DiceTable\nFalse\n\nDetailedDiceTable.calc_includes_zeroes defaults to True. It is as follows.\n\n>>> d_table = dt.DetailedDiceTable.new()\n>>> d_table.calc_includes_zeroes\nTrue\n>>> d_table = d_table.add_die(dt.StrongDie(dt.Die(2), 2))\n>>> print(d_table.calc.full_table_string())\n2: 1\n3: 0\n4: 1\n<BLANKLINE>\n\n>>> d_table = d_table.switch_boolean()\n>>> the_same = dt.DetailedDiceTable({2: 1, 4: 1}, d_table.dice_data(), False)\n>>> d_table == the_same\nTrue\n>>> print(d_table.calc.full_table_string())\n2: 1\n4: 1\n<BLANKLINE>\n>>> d_table = d_table.add_die(dt.StrongDie(dt.Die(2), 2))\n>>> print(d_table.calc.full_table_string())\n4: 1\n6: 2\n8: 1\n<BLANKLINE>\n\n>>> d_table = d_table.switch_boolean()\n>>> d_table == the_same\nFalse\n>>> print(d_table.calc.full_table_string())\n4: 1\n5: 0\n6: 2\n7: 0\n8: 1\n<BLANKLINE>\n\nTop_\n\n----------------------------------------\nEventsInformation And EventsCalculations\n----------------------------------------\n\nThe methods are\n\nEventsInformation:\n\n* all_events\n* all_events_include_zeroes\n* biggest_event\n* biggest_events_all <- returns the list of all events that have biggest occurrence\n* events_keys\n* events_range\n* get_event\n* get_items <- returns dict.items(): a list in py2 and an iterator in py3.\n* get_range_of_events\n* total_occurrences\n\nEventsCalculations:\n\n* full_table_string\n    * can set the number of shown_digits\n\n* info\n* mean\n* percentage_axes\n    * very fast but only good to 10 decimal places\n\n* percentage_axes_exact\n* percentage_points\n    * very fast but only good to 10 decimal places\n\n* log10_axes and log10_points\n    * log10 of the combinations.\n    * any occurrence of zero is default set to -100.0 but can be assigned any number.\n\n* percentage_points_exact\n* stats_strings\n    * takes a list of events values you want information for\n    * optional parameter is shown_digits\n    * returns a namedtuple\n        * string of those events\n        * number of times those events occurred in the table\n        * total number of occurrences of all events in the table\n        * the inverse chance of those events occurring: a 1 in (number) chance\n        * the percent chance of those events occurring: (number)% chance\n* stddev\n    * defaults to 4 decimal places, but can be increased or decreased\n\n>>> table = dt.DiceTable.new().add_die(dt.Die(6), 1000)\n>>> calc = dt.EventsCalculations(table)\n>>> calc.stddev(7)\n54.0061725\n>>> calc.mean()\n3500.0\n>>> the_stats = calc.stats_strings([3500], shown_digits=6)\n>>> the_stats\nStatsStrings(query_values='3,500',\n             query_occurrences='1.04628e+776',\n             total_occurrences='1.41661e+778',\n             one_in_chance='135.395',\n             pct_chance='0.738580')\n\nThis is correct. Out of 5000 possible rolls, 3500 has a 0.7% chance of occurring.\n\n>>> the_stats.one_in_chance\n'135.395'\n>>> calc.stats_strings(list(range(1000, 3001)) + list(range(4000, 10000)))\nStatsStrings(query_values='1,000-3,000, 4,000-9,999',\n             query_occurrences='2.183e+758',\n             total_occurrences='1.417e+778',\n             one_in_chance='6.490e+19',\n             pct_chance='1.541e-18')\n\nThis is also correct. Rolls not in the middle 1000 collectively have a much smaller chance than the mean.\n\n>>> silly_table = dt.AdditiveEvents({1: 123456, 100: 1234567*10**1000})\n>>> silly_calc = dt.EventsCalculations(silly_table, include_zeroes=False)\n>>> print(silly_calc.full_table_string(shown_digits=6))\n  1: 123,456\n100: 1.23457e+1006\n<BLANKLINE>\n\nEventsCalculations.include_zeroes is only settable at instantiation. It does\nexactly what it says. EventCalculations owns an EventsInformation. So\ninstantiating EventsCalculations gets you\ntwo for the price of one. It's accessed with the property\nEventsCalculations.info .\n\n>>> table = dt.DiceTable.new().add_die(dt.StrongDie(dt.Die(3), 2))\n>>> calc = dt.EventsCalculations(table, True)\n>>> print(calc.full_table_string())\n2: 1\n3: 0\n4: 1\n5: 0\n6: 1\n<BLANKLINE>\n>>> calc = dt.EventsCalculations(table, False)\n>>> print(calc.full_table_string())\n2: 1\n4: 1\n6: 1\n<BLANKLINE>\n>>> calc.info.events_range()\n(2, 6)\n\nTop_\n\n-----------\nInheritance\n-----------\nIf you inherit from any child of AdditiveEvents and you do not load the new information\ninto EventsFactory, it will complain and give you instructions. The EventsFactory will try to create\nyour new class and if it fails, will return the closest related type\n\n>>> class A(dt.DiceTable):\n...     pass\n...\n>>> A.new()  # EventsFactory takes a stab at it, and guesses right. It returns the new class\n<...A...>\n\nBut it also issues a warning::\n\n    E:\\work\\dice_tables\\dicetables\\baseevents.py:74: EventsFactoryWarning:\n    factory: <class 'dicetables.factory.eventsfactory.EventsFactory'>\n    Warning code: CONSTRUCT\n    Failed to find/add the following class to the EventsFactory -\n    class: <class '__main__.A'>\n    ..... blah blah blah.....\n\nHere, it will fail create \"B\" class, and return its parent.\n\n>>> class B(dt.DiceTable):\n...     def __init__(self, name, number, events_dict, dice_data):\n...         self.name = name\n...         self.num = number\n...         super(B, self).__init__(events_dict, dice_data)\n...\n\n>>> B.new()\n<...DiceTable...>\n\nand give you the following warning::\n\n    E:\\work\\dice_tables\\dicetables\\baseevents.py:74: EventsFactoryWarning:\n    factory: <class 'dicetables.factory.eventsfactory.EventsFactory'>\n    Warning code: CONSTRUCT\n    Failed to find/add the following class to the EventsFactory -\n    class: <class '__main__.B'>\n    ..... blah blah blah.....\n\n| Now I will try again, but I will give the factory the info it needs.\n| The factory knows how to get 'get_dict', 'dice_data'\n| and 'calc_includes_zeroes'. If you need it to get anything else, you need tuples of\n| (<getter name>, <default value>, 'property' or 'method')\n\n>>> class B(dt.DiceTable):\n...     factory_keys = ('name', 'get_num', 'get_dict', 'dice_data')\n...     new_keys = (('name', '', 'property'), ('get_num', 0, 'method'))\n...     def __init__(self, name, number, events_dict, dice_data):\n...         self.name = name\n...         self._num = number\n...         super(B, self).__init__(events_dict, dice_data)\n...     def get_num(self):\n...         return self._num\n...\n>>> B.new()\n<...B...>\n\n>>> class C(dt.DiceTable):\n...     factory_keys = ('get_dict', 'dice_data')\n...     def fancy_add_die(self, die, times):\n...         new = self.add_die(die, times)\n...         return 'so fancy', new\n...\n>>> x = C.new().fancy_add_die(dt.Die(3), 2)\n>>> x[1].get_dict()\n{2: 1, 3: 2, 4: 3, 5: 2, 6: 1}\n>>> x\n('so fancy', <C...>)\n\nNotice that C is returned and not DiceTable\n\nThe other way to do this is to directly add the class to the EventsFactory\n\n>>> factory = dt.factory.eventsfactory.EventsFactory\n>>> factory.add_getter('get_num', 0, 'method')\n>>> class A(dt.DiceTable):\n...     def __init__(self, number, events_dict, dice):\n...         self._num = number\n...         super(A, self).__init__(events_dict, dice)\n...     def get_num(self):\n...         return self._num\n...\n>>> factory.add_class(A, ('get_num', 'get_dict', 'dice_data'))\n>>> A.new()\n<A ...>\n\n>>> factory.reset()\n>>> factory.has_class(A)\nFalse\n\nWhen creating new methods, you can generate new events dictionaries by using\ndicetables.additiveevents.EventsDictCreator.  the factory can create new instances with\nEventsFactory.from_params.  For examples see the last few test in tests.factory.test_eventsfactory\nTop_\n\n--------------------------\nHOW TO GET ERRORS AND BUGS\n--------------------------\nEvery time you instantiate any IntegerEvents, it is checked.  The get_dict() method returns a dict, and every value\nin get_dict().values() must be >=1. get_dict() may not be empty.\nsince dt.Die(-2).get_dict() returns {}\n\n>>> dt.Die(-2)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nInvalidEventsError: events may not be empty. a good alternative is the identity - {0: 1}.\n\n>>> dt.AdditiveEvents({1.0: 2})\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nInvalidEventsError: all values must be ints\n\n>>> dt.WeightedDie({1: 1, 2: -5})\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nInvalidEventsError: no negative or zero occurrences in Events.get_dict()\n\nBecause AdditiveEvents and WeightedDie specifically\nscrub the zeroes from their get_dict() methods, these will not throw errors.\n\n>>> dt.AdditiveEvents({1: 1, 2: 0}).get_dict()\n{1: 1}\n\n>>> weird = dt.WeightedDie({1: 1, 2: 0})\n>>> weird.get_dict()\n{1: 1}\n>>> weird.get_size()\n2\n>>> weird.get_raw_dict() == {1: 1, 2: 0}\nTrue\n\nSpecial rule for WeightedDie and ModWeightedDie\n\n>>> dt.WeightedDie({0: 1})\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: rolls may not be less than 1. use ModWeightedDie\n\n>>> dt.ModWeightedDie({0: 1}, 1)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: rolls may not be less than 1. use ModWeightedDie\n\nHere's how to add 0 one time (which does nothing, btw)\n\n>>> dt.ModWeightedDie({1: 1}, -1).get_dict()\n{0: 1}\n\nStrongDie also has a weird case that can be unpredictable.  Basically, don't multiply by zero\n\n>>> table = dt.DiceTable.new().add_die(dt.Die(6))\n\n>>> table = table.add_die(dt.StrongDie(dt.Die(100), 0), 100)\n\n>>> table.get_dict() == {1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}\nTrue\n\n>>> print(table)\n1D6\n(100D100)X(0)\n\n>>> stupid_die = dt.StrongDie(dt.ModWeightedDie({1: 2, 3: 4}, -1), 0)\n>>> table = table.add_die(stupid_die, 2)  # this rolls zero with weight 4\n>>> print(table)\n(2D3-2  W:6)X(0)\n1D6\n(100D100)X(0)\n>>> table.get_dict() ==  {1: 16, 2: 16, 3: 16, 4: 16, 5: 16, 6: 16}  # this is correct, it's just stupid.\nTrue\n\nExplodingOn will raise an error if the values in \"explodes_on\" are not in input_die.get_dict()\n\n>>> input_die = dt.WeightedDie({1: 2, 3: 1, 5: 1, 7: 2})\n>>> dt.ExplodingOn(input_die, ()).get_dict() == {1: 72, 3: 36, 5: 36, 7: 72}\nTrue\n>>> dt.ExplodingOn(input_die, (2,))\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: \"explodes_on\" value not present in input_die.get_dict()\n\n\"remove_die\" and \"add_die\" are safe. They raise an error if you\nremove too many dice or add or remove a negative number.\n\nIf you \"remove\" or \"combine\" with a negative number, nothing should happen,\nbut i make no guarantees.\n\nIf you use \"remove\" to remove what you haven't added,\nit may or may not raise an error, but it's guaranteed buggy.\n\nHere are \"add_die\" and \"remove_die\" failing fast:\n\n>>> table = dt.DiceTable.new().add_die(dt.Die(6))\n\n>>> table = table.remove_die(dt.Die(6), 4)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nDiceRecordError: Tried to create a DiceRecord with a negative value at Die(6): -3\n\n>>> table = table.remove_die(dt.Die(10))\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nDiceRecordError: Tried to create a DiceRecord with a negative value at Die(10): -1\n\n>>> table = table.add_die(dt.Die(6), -3)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nDiceRecordError: Tried to add_die or remove_die with a negative number.\n\n>>> table = table.remove_die(dt.Die(6), -3)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nDiceRecordError: Tried to add_die or remove_die with a negative number.\n\nAnd now, this is the trouble you can get into with \"combine\" and \"remove\"\n\n>>> table.get_dict() == {1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}\nTrue\n>>> table = table.combine(dt.Die(10000), -100)\n>>> table.get_dict() == {1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}\nTrue\n>>> table = table.remove(dt.Die(2), 10)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: min() arg is an empty sequence <-didn't know this would happen, but at least failed loudly\n\n>>> table = table.remove(dt.Die(2), 2)\n\n>>> table.get_dict() == {-1: 1, 1: 1}  # bad. this is a random answer\nTrue\n\n(I know why you're about to get wacky and inaccurate errors, and I could fix the bug, except ...\n YOU SHOULD NEVER EVER DO THIS!!!!)\n\n>>> table = table.remove(dt.AdditiveEvents({-5: 100}))\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nEventsFactoryError: Error Code: SIGNATURES DIFFERENT\nFactory:    <class 'dicetables.factory.eventsfactory.EventsFactory'>\nError At:   <class 'dicetables.dicetable.DiceTable'>\nAttempted to construct a class already present in factory, but with a different signature.\nClass: <class 'dicetables.dicetable.DiceTable'>\nSignature In Factory: ('get_dict', 'dice_data')\nTo reset the factory to its base state, use EventsFactory.reset()\n\n\nSince you can instantiate a DiceTable with any legal input,\nyou can make a table with utter nonsense. It will work horribly.\nfor instance, the dictionary for 2D6 is:\n\n{2: 1, 3: 2, 4: 3, 5: 4, 6: 5, 7: 6, 8: 5, 9: 4, 10: 3, 11: 2, 12: 1}\n\n\n>>> nonsense = dt.DiceTable({1: 1}, dt.DiceRecord({dt.Die(6): 2}))  # <- BAD DATA!!!!\n>>> print(nonsense)  # <- the dice record says it has 2D6, but the events dictionary is WRONG\n2D6\n>>> nonsense = nonsense.remove_die(dt.Die(6), 2)  # <- so here's your error. I hope you're happy.\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: min() arg is an empty sequence\n\nBut, you cannot instantiate a DiceTable with negative values for dice.\nAnd you cannot instantiate a DiceTable with non-sense values for dice.\n\n\n>>> dt.DiceTable({1: 1}, dt.DiceRecord({dt.Die(3): 3, dt.Die(5): -1}))\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nDiceRecordError: Tried to create a DiceRecord with a negative value at Die(5): -1\n\n>>> dt.DiceTable({1: 1}, dt.DiceRecord({'a': 2.0}))\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nDiceRecordError: input must be {ProtoDie: int, ...}\n\nCalling combine_by_flattened_list can be risky\n\n>>> x = dt.AdditiveEvents({1:1, 2: 5})\n>>> x = x.combine_by_flattened_list(dt.AdditiveEvents({1: 2, 3: 4}), 5)\n>>> x = x.combine_by_flattened_list(dt.AdditiveEvents({1: 2, 3: 4*10**10}), 5)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nMemoryError\n\n>>> x = x.combine_by_flattened_list(dt.AdditiveEvents({1: 2, 3: 4*10**700}))\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nOverflowError: cannot fit 'int' into an index-sized integer\n\nTop_",
    "docs_url": null,
    "download_url": "UNKNOWN",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "http://github.com/eric-s-s/dice-tables",
    "keywords": "dice,die,statistics,table,probability,combinations",
    "license": "MIT",
    "maintainer": null,
    "maintainer_email": null,
    "name": "dicetables",
    "platform": "UNKNOWN",
    "project_url": "https://pypi.org/project/dicetables/",
    "release_url": "https://pypi.org/project/dicetables/2.2.0/",
    "requires_python": null,
    "summary": "get all combinations for any set of dice",
    "version": "2.2.0"
  },
  "releases": {
    "0.3.10": [
      {
        "comment_text": "",
        "digests": {
          "md5": "3f8a839eda5b7cb76942337e301b4809",
          "sha256": "18c70cceb8a38c8c5acbccc830980bf177c31e590766ce29c8cd9fbac5dd5e97"
        },
        "downloads": 148,
        "filename": "dicetables-0.3.10.tar.gz",
        "has_sig": false,
        "md5_digest": "3f8a839eda5b7cb76942337e301b4809",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 23372,
        "upload_time": "2016-06-06T06:39:03",
        "url": "https://files.pythonhosted.org/packages/db/79/6bf1060bc3082119c63e958b390e3dcedb1052e30bd9635eea8edb0b1ffe/dicetables-0.3.10.tar.gz"
      }
    ],
    "0.3.8": [
      {
        "comment_text": "",
        "digests": {
          "md5": "b56855001aa0c5984d52db52000f7210",
          "sha256": "5a9b9e1f2122f0a8f3cb0ae9b4d3d4610f1efe77943d886745a60723ba509c3e"
        },
        "downloads": 416,
        "filename": "dicetables-0.3.8.tar.gz",
        "has_sig": false,
        "md5_digest": "b56855001aa0c5984d52db52000f7210",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 23270,
        "upload_time": "2016-05-05T11:25:24",
        "url": "https://files.pythonhosted.org/packages/a3/3a/d0a3efc45c71098d4f3dbd4be1f064644025cfedfc16e4e7a3e953136424/dicetables-0.3.8.tar.gz"
      }
    ],
    "0.3.9": [
      {
        "comment_text": "",
        "digests": {
          "md5": "5929d382b640fccfaf1a7e737145d7be",
          "sha256": "2efe58f125b170a2666df532e5f79ac34dd69ba854568ece45a41e06bcd2c658"
        },
        "downloads": 156,
        "filename": "dicetables-0.3.9.tar.gz",
        "has_sig": false,
        "md5_digest": "5929d382b640fccfaf1a7e737145d7be",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 23275,
        "upload_time": "2016-05-05T11:53:05",
        "url": "https://files.pythonhosted.org/packages/4a/7f/f6af134d195bc3006f5ca0fe6f927506b21348045cfa5bbd5e6feb3c83f3/dicetables-0.3.9.tar.gz"
      }
    ],
    "0.4.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "b95d07657e7b8be29929d75358fb0e95",
          "sha256": "f5a351df08d108e1dbdc4d27d3d572e66e8c42ca76f62161a99c594d7a88470c"
        },
        "downloads": 172,
        "filename": "dicetables-0.4.0.tar.gz",
        "has_sig": false,
        "md5_digest": "b95d07657e7b8be29929d75358fb0e95",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 23982,
        "upload_time": "2016-06-11T07:42:20",
        "url": "https://files.pythonhosted.org/packages/d3/91/49451a58a9f46d2c87bc2f0d7b62fe797b382528585330001295c4685cf9/dicetables-0.4.0.tar.gz"
      }
    ],
    "0.4.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "f6ed13ad867d6d7d4aa45a1dfe0df6a8",
          "sha256": "58c5820b66109ab61702816e4c2b6ac2ba448d4fc4bc9cd3205785891b906bb5"
        },
        "downloads": 359,
        "filename": "dicetables-0.4.1.tar.gz",
        "has_sig": false,
        "md5_digest": "f6ed13ad867d6d7d4aa45a1dfe0df6a8",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 24731,
        "upload_time": "2016-06-20T20:28:13",
        "url": "https://files.pythonhosted.org/packages/ad/9e/a1c275fdc47ff8f6c7e4d57ffe966b12dbe737ee306dde5e56d46e435713/dicetables-0.4.1.tar.gz"
      }
    ],
    "0.4.2": [
      {
        "comment_text": "",
        "digests": {
          "md5": "1a3fc7d6dc5dd3d0fa60896a992c59ee",
          "sha256": "bc2eda989781770dbde977f6e958aa8cb27dbaee2016c1230a19d011bb8c388f"
        },
        "downloads": 157,
        "filename": "dicetables-0.4.2.tar.gz",
        "has_sig": false,
        "md5_digest": "1a3fc7d6dc5dd3d0fa60896a992c59ee",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 24716,
        "upload_time": "2016-07-11T15:01:10",
        "url": "https://files.pythonhosted.org/packages/1b/72/455f252b5bc9fe56923095a4579680d01bbb13a01a60ad12417759f249db/dicetables-0.4.2.tar.gz"
      }
    ],
    "0.4.3": [
      {
        "comment_text": "",
        "digests": {
          "md5": "e8350c58cede17e4264a0901ff18a575",
          "sha256": "44ad2a4d7d29becb6118254276961c71e62e9fd3dd0e82b90ca572223760ad2e"
        },
        "downloads": 137,
        "filename": "dicetables-0.4.3.tar.gz",
        "has_sig": false,
        "md5_digest": "e8350c58cede17e4264a0901ff18a575",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 25212,
        "upload_time": "2016-07-25T15:40:03",
        "url": "https://files.pythonhosted.org/packages/03/30/f64bc046f88e61443d2157e5e1ce89a18cd78f9d3ffef2bad548337f99dd/dicetables-0.4.3.tar.gz"
      }
    ],
    "0.4.4": [
      {
        "comment_text": "",
        "digests": {
          "md5": "b33c5e0a683a8476bf7438d6f1e582fc",
          "sha256": "4b7403bf6fb1dbb8c2d658d1fd0cba5a744e65cf25b47aff6c3b09467fbe9980"
        },
        "downloads": 139,
        "filename": "dicetables-0.4.4.tar.gz",
        "has_sig": false,
        "md5_digest": "b33c5e0a683a8476bf7438d6f1e582fc",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 25241,
        "upload_time": "2016-07-29T17:51:57",
        "url": "https://files.pythonhosted.org/packages/68/85/d00932dddc7c2d47893a323bc3006a6050c0db5f55b708ce0b53dc0ecaff/dicetables-0.4.4.tar.gz"
      }
    ],
    "0.4.5": [
      {
        "comment_text": "",
        "digests": {
          "md5": "f68ea225348f009a5a0922e349f04945",
          "sha256": "a5353a89fce6fdeb8ebf6ed30cadba0ee28e775dd673cc4fd80b81d3d44851e1"
        },
        "downloads": 141,
        "filename": "dicetables-0.4.5.tar.gz",
        "has_sig": false,
        "md5_digest": "f68ea225348f009a5a0922e349f04945",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 25349,
        "upload_time": "2016-07-30T06:03:11",
        "url": "https://files.pythonhosted.org/packages/59/59/bc531791647c1f712495b1607cfa2a80a9327997770fbff7bffefb071483/dicetables-0.4.5.tar.gz"
      }
    ],
    "0.4.6": [
      {
        "comment_text": "",
        "digests": {
          "md5": "2de726360fb06adbc4f8efbf6f5c35cd",
          "sha256": "c60574b011d669684eeb5e3795b2181bfc11e7a79e6f332b4ee77f980f6dd565"
        },
        "downloads": 152,
        "filename": "dicetables-0.4.6.tar.gz",
        "has_sig": false,
        "md5_digest": "2de726360fb06adbc4f8efbf6f5c35cd",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 25420,
        "upload_time": "2016-08-13T11:25:11",
        "url": "https://files.pythonhosted.org/packages/a8/82/7e16ff730423edb658b24a7bdff62d6c9f05e824c2b3dd20799a7a438c47/dicetables-0.4.6.tar.gz"
      }
    ],
    "1.0.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "b1dd891ce682acb4fd5f292230c028d0",
          "sha256": "82f3ce016b74e4788de544c329b1d8b8dfa2f54b50c8cd5a981118b5b552a2ee"
        },
        "downloads": 252,
        "filename": "dicetables-1.0.1.zip",
        "has_sig": false,
        "md5_digest": "b1dd891ce682acb4fd5f292230c028d0",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 39503,
        "upload_time": "2017-01-05T09:38:10",
        "url": "https://files.pythonhosted.org/packages/cb/f4/a40951e9722f90bd3c46de6d5f977fb85593ea778981f31b91ea868006b3/dicetables-1.0.1.zip"
      }
    ],
    "1.0.2": [
      {
        "comment_text": "",
        "digests": {
          "md5": "bef8609407baaa65269231b20eb4f17c",
          "sha256": "7bef24881d8c9d1af40fffd81bf24fa1c2ccbab47063c7f4a81aa26f28accb0c"
        },
        "downloads": 252,
        "filename": "dicetables-1.0.2.tar.gz",
        "has_sig": false,
        "md5_digest": "bef8609407baaa65269231b20eb4f17c",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 30967,
        "upload_time": "2017-01-05T09:44:33",
        "url": "https://files.pythonhosted.org/packages/a1/e2/cb54cadfc6e24b449ad8a15218db4e3482e6970efe4fa75611d67e068377/dicetables-1.0.2.tar.gz"
      }
    ],
    "1.0.3": [
      {
        "comment_text": "",
        "digests": {
          "md5": "041d2a95410e77b11aec0575de48a1dc",
          "sha256": "3907253e453281b8b510b90db6208ad2085c57453766ef2bf8e90b0a3f9447ea"
        },
        "downloads": 245,
        "filename": "dicetables-1.0.3.tar.gz",
        "has_sig": false,
        "md5_digest": "041d2a95410e77b11aec0575de48a1dc",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 30978,
        "upload_time": "2017-01-05T10:10:22",
        "url": "https://files.pythonhosted.org/packages/ac/59/b2d36145bd62cfae1b5e287ed225114fb402fe755a88c14b580f386ed740/dicetables-1.0.3.tar.gz"
      }
    ],
    "1.0.4": [
      {
        "comment_text": "",
        "digests": {
          "md5": "1f45b02ab949cc921e53ddde10bb2a25",
          "sha256": "83b26efe2b9e1b06fa4636c9a026c73ad0da01397d4709451396c2a42ab49801"
        },
        "downloads": 252,
        "filename": "dicetables-1.0.4.tar.gz",
        "has_sig": false,
        "md5_digest": "1f45b02ab949cc921e53ddde10bb2a25",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 30979,
        "upload_time": "2017-01-05T10:22:14",
        "url": "https://files.pythonhosted.org/packages/5a/ab/c33b71059c326c923ce039b5d8062bf78b9ab554db8c7bdd62fcf8547686/dicetables-1.0.4.tar.gz"
      }
    ],
    "2.0.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "a436ea8e459e2d0d8fbd08b4c87ce515",
          "sha256": "4d2325bc44c0f5b14d290b4b76b758060778259582c1031a6c837d2c4dbb638f"
        },
        "downloads": 12,
        "filename": "dicetables-2.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "a436ea8e459e2d0d8fbd08b4c87ce515",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 44231,
        "upload_time": "2017-01-09T17:59:32",
        "url": "https://files.pythonhosted.org/packages/86/75/680fe0a7c478db479238d58a26032ddfd3ed969380ec6cb23c9f64ead46d/dicetables-2.0.1.tar.gz"
      }
    ],
    "2.1.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "ae5bd20da3d34abf2a9c883572e7558b",
          "sha256": "4b42d9f301b3d693c096dafc05e4f59e6d68f147f01c1b6c8bda85950bb1940d"
        },
        "downloads": 12,
        "filename": "dicetables-2.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "ae5bd20da3d34abf2a9c883572e7558b",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 44057,
        "upload_time": "2017-01-26T07:06:34",
        "url": "https://files.pythonhosted.org/packages/07/0b/9f18f70007d9157bcd15a5c41965bb9744f66c01f30229cedbab4814dada/dicetables-2.1.0.tar.gz"
      }
    ],
    "2.1.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "9704216ba57da353aea07f7ed44f97c0",
          "sha256": "27efcbed8b58fd5c5dc3adeb5f64159248102adb5b4b2be655ac75c0edfa96fb"
        },
        "downloads": 11,
        "filename": "dicetables-2.1.1.tar.gz",
        "has_sig": false,
        "md5_digest": "9704216ba57da353aea07f7ed44f97c0",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 44403,
        "upload_time": "2017-01-27T19:10:07",
        "url": "https://files.pythonhosted.org/packages/a7/28/09d5884fba3a70f72c6ce69d7543c52e11fed72742edeb439cbb8f7b336c/dicetables-2.1.1.tar.gz"
      }
    ],
    "2.1.2": [
      {
        "comment_text": "",
        "digests": {
          "md5": "8e11ae716ffe1c47d5517b41b2ec2e7f",
          "sha256": "89ab849e7ef75c34845c1f06ff27da3206e083a92a05e7094ab7e810b548d371"
        },
        "downloads": 10,
        "filename": "dicetables-2.1.2.tar.gz",
        "has_sig": false,
        "md5_digest": "8e11ae716ffe1c47d5517b41b2ec2e7f",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 45263,
        "upload_time": "2017-02-05T15:56:17",
        "url": "https://files.pythonhosted.org/packages/dc/e1/8b5dddbb513b0a2df2766c6937d30a970152406bb5d9ee7d18f24bf0d4d1/dicetables-2.1.2.tar.gz"
      }
    ],
    "2.1.3": [
      {
        "comment_text": "",
        "digests": {
          "md5": "0fd34aa1c3688fd154c0f6fa713f146c",
          "sha256": "846a2d3c20f565325ca2e1dea0461c2fa44f183c12c9520347eda48ffb47815c"
        },
        "downloads": 14,
        "filename": "dicetables-2.1.3.tar.gz",
        "has_sig": false,
        "md5_digest": "0fd34aa1c3688fd154c0f6fa713f146c",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 45019,
        "upload_time": "2017-03-05T16:52:12",
        "url": "https://files.pythonhosted.org/packages/c5/34/43c3d913b1f0a4c7d151401dc5baa2f4a56b35756dd834b1e20be156e693/dicetables-2.1.3.tar.gz"
      }
    ],
    "2.1.4": [
      {
        "comment_text": "",
        "digests": {
          "md5": "5812203577718584e7e5621208777188",
          "sha256": "a6f31ab74bad77e14a66f1bfc89a6356d37ee22e1f47527f3f5bcce7725a7f59"
        },
        "downloads": 0,
        "filename": "dicetables-2.1.4.tar.gz",
        "has_sig": false,
        "md5_digest": "5812203577718584e7e5621208777188",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 37115,
        "upload_time": "2017-04-27T17:22:54",
        "url": "https://files.pythonhosted.org/packages/28/53/2c6f3ceeb554f4cfc34135989460ef67f2b62ee1487157dea01e3dba12e1/dicetables-2.1.4.tar.gz"
      }
    ],
    "2.1.5": [
      {
        "comment_text": "",
        "digests": {
          "md5": "e274acc35cfa18c1342c485c3865d289",
          "sha256": "4b23f761de025aa6cb83404b0e12a0af35d101138b5abec7b338ca96bb012844"
        },
        "downloads": 0,
        "filename": "dicetables-2.1.5.tar.gz",
        "has_sig": false,
        "md5_digest": "e274acc35cfa18c1342c485c3865d289",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 37156,
        "upload_time": "2017-05-02T17:18:17",
        "url": "https://files.pythonhosted.org/packages/de/d7/956a02d2da5771d4eb2912fc93f07abaa4c9f0ffd887d36871f25bc27414/dicetables-2.1.5.tar.gz"
      }
    ],
    "2.2.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "9e92ba6981c6a4727f979db42f13d2da",
          "sha256": "8f4c2e49dbf92f5b0b99cd334b1ed47cbac3fd9ef80b0cec7bf1bb3c32cb97b0"
        },
        "downloads": 0,
        "filename": "dicetables-2.2.0.tar.gz",
        "has_sig": false,
        "md5_digest": "9e92ba6981c6a4727f979db42f13d2da",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 41785,
        "upload_time": "2017-06-01T18:38:20",
        "url": "https://files.pythonhosted.org/packages/d2/4c/a7ae50b66fda71313181c29d3675127f90ae2f7bbdd8552c6cb355dc8519/dicetables-2.2.0.tar.gz"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "9e92ba6981c6a4727f979db42f13d2da",
        "sha256": "8f4c2e49dbf92f5b0b99cd334b1ed47cbac3fd9ef80b0cec7bf1bb3c32cb97b0"
      },
      "downloads": 0,
      "filename": "dicetables-2.2.0.tar.gz",
      "has_sig": false,
      "md5_digest": "9e92ba6981c6a4727f979db42f13d2da",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 41785,
      "upload_time": "2017-06-01T18:38:20",
      "url": "https://files.pythonhosted.org/packages/d2/4c/a7ae50b66fda71313181c29d3675127f90ae2f7bbdd8552c6cb355dc8519/dicetables-2.2.0.tar.gz"
    }
  ]
}