{
  "info": {
    "author": "Louis-Dominique Dubeau",
    "author_email": "ldd@lddubeau.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 4 - Beta",
      "Environment :: Plugins",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 2.6",
      "Programming Language :: Python :: 2.7",
      "Programming Language :: Python :: 3.3",
      "Topic :: Software Development :: Quality Assurance",
      "Topic :: Software Development :: Testing"
    ],
    "description": "Fresher\n=======\n\nFresher is a fork of Freshen. As of Fall of 2013, Freshen appeared to\nno longer being maintained, so I decided to fork and make some much\nneeded changes.\n\nDifferences from Freshen:\n\n* Fresher is tested against Python 3.3, Python 2.7 and Python 2.6. (It\n  seems Freshen was tested against whatever Python happened to be\n  around. It definitely did not work on Python 3.)\n\n* The file to get Fresher to ignore a directory is ``.fresherignore``.\n\n* All arguments that are specific to Fresher begins with ``--fresher-`` so:\n\n  - ``--tags`` is now ``--fresher-tags``\n  - ``--language`` is now ``--fresher-language``\n  - ``--list-undefined`` is now ``--fresher-list-undefined``\n\n  This change allows using fresher and freshen together in the same\n  installation, and reduces the chances of conflicts with other nose\n  plugins in the future.\n\n* Undefined steps are fatal errors unless you pass --fresher-allow-undefined.\n\n* Freshen would load steps files under fake module names. Fresher\n  loads the whole shebang under ``freshen.steps``.\n\n.. warning:: Do not have a steps module loaded by Fresher also be\n             loaded by no-step modules.  (A no-step module is one which\n             does not implement steps). Here's a scenario where you\n             could run into trouble: module A ``features/steps`` loads\n             module B ``features/util`` (a nostep module) which loads\n             module C ``features/nested/steps`` which is also a steps\n             module for another set of features. We could call this an\n             S-N-S scenario (steps, no-step, steps). If you do this\n             then module C will be loaded twice: once because module B\n             imports it and a second time when fresher finds it is\n             needed for some features in the ``nested``\n             subdirectory. It will be loaded as *two different\n             modules*. If the duplicated module maintains no state,\n             you'll only incur the cost of loading the same module\n             twice. However, if it does maintain state, then good\n             luck.\n\n             Note that Freshen 0.2 also suffers from this problem due\n             to the fake module names it uses. I believe behave 1.2.3\n             also suffers from this problem. It uses ``exec`` to load\n             step definition files. In an S-N-S case like the one\n             above, module A will be exec'ed, and module B will import\n             module C so module C will show as an actual Python\n             module. Then when behave determines that C is needed for\n             step definitions, it will exec it, thereby loading it\n             again.\n\n             It is completely fine if a steps module or package loads\n             a non-steps module or package. It is highly recommended\n             to separate step definitions from broader logic.\n\n* Fresher allows duplicate function names for steps.\n\n* Fresher associates with a package the steps defined by all the\n  **modules** that are its **immediate** children. Imagine the\n  following structure::\n\n    steps/\n          __init__.py\n          caret.py\n          selection.py\n          nested/\n               __init__.py\n               log.py\n               data.py\n\n  When this ``steps`` package is loaded by Fresher, all of the steps\n  found in ``caret.py`` and ``selection.py`` will be immediately\n  accessible. **There is no need to refer to these modules\n  individually or to add anything to the ``steps/__init__.py``\n  file. However, what is in the **subpackage** named ``steps.nested``\n  will not be accessible until ``steps.nested`` is itself loaded by\n  Fresher.\n\n  With Freshen ``steps/__init__.py`` would require::\n\n    from .caret import *\n    from .selection import *\n\n  but this is *not* required when using Fresher.\n\n* Generally speaking, the ``from ... import *`` method of making steps\n  accessible in another module, which worked fine in Freshen, does not\n  work in Fresher. It worked in Freshen because Freshen would\n  determine the steps defined in a module by scanning the module's\n  *global symbols*. This cannot work with Fresher because it allows\n  duplicate function names. (If ``@given('a')`` and ``@given('b')``\n  both decorate ``foo()`` the symbol ``foo`` is still present only\n  once.)\n\n  You have to use ``fresher.stepregistry.import_steps()`` to import\n  the steps from another module. For instance::\n\n    from freshen.stepregistry import import_steps\n\n    import_steps(\".defs\")\n\n  Or if you want to import steps from a more remote location (actual\n  case in the test suite)::\n\n    from freshen.stepregistry import import_steps\n\n    import_steps(\"..nested.steps\")\n\nThe old documentation follows. Keep in mind the differences\nabove. Eventually, this will all be rewritten for Fresher.\n\nFreshen\n=======\n\n- Freshen is an acceptance testing framework for Python.\n- It is built as a plugin for Nose_.\n- It uses the (mostly) same syntax as Cucumber_.\n\nWhat's New in Version 0.2?\n--------------------------\n\n- Freshen now supports Backgrounds_ for a feature.\n- Freshen now supports the **But** keyword for steps of Scenarios_.\n- Freshen now supports the simple case of `Step Argument Transforms`_.\n- The parser now supports several natural language aliases for a keyword.\n- If a natural language translation is not found for a keyword, English will be used.\n- \"@After\" hooks are now run in the *opposite* order of which they are registered.\n- Improved error handling and reporting.\n\nThere are also some modifications that are incompatible with Cucumber.\n\n- Only the step definition module named \"steps\" is used by default.\n- Users can override this behavior with the \"Use step definitions from\" keyword.\n- Freshen distinguishes \"Given\" steps from \"When\" steps and \"Then\" steps.\n\n----------------------------------------------------------------------\n\nFreshen Documentation\n=====================\n\nMost of the information shown here can also be found on the `Cucumber wiki`_, but here it is anyway:\n\nFreshen tests are composed of two parts: `feature outlines`_ and `step definitions`_.\n\n\nFeature outlines\n----------------\n\nFeature outlines are text files with a ``.feature`` extension. The purpose of this file is to\ndescribe a feature in plain text understandable by a non-technical person such as a product manager\nor user. However, these files are specially formatted and are parsed by Freshen in order to execute\nreal tests.\n\nYou can put your feature files anywhere you want in the source tree of your project, but it is\nrecommended to place them in a dedicated \"features\" directory.\n\nA feature file contains (in this order):\n\n- the step definition modules to use (*optional*, see `specifying step definition modules`_);\n- the feature name with a free-form text description;\n- a background (*optional*, see `backgrounds`_);\n- one or more `scenarios`_ or `scenario outlines`_.\n\n\nScenarios\n---------\n\nA scenario is an example of an interaction a user would have as part of the feature. It is comprised\nof a series of *steps*. Each step has to start with a keyword: **Given**, **When**, **Then**, **But** or **And**.\nHere's an example for a calculator application (this example is included in the `source code`_)::\n\n    Scenario: Divide regular numbers\n      Given I have entered 3 into the calculator\n      And I have entered 2 into the calculator\n      When I press divide\n      Then the result should be 1.5 on the screen\n\n\nScenario Outlines\n-----------------\n\nSometimes it is useful to parametrize a scenario and run it multiple times, substituting values. For\nthis purpose, use *scenario outlines*. The format is the same as a scenario, except you can indicate\nplaces where a value should be substituted using angle brackets: < and >. You specify the values\nto be substituted using an \"Examples\" section that follows the scenario outline::\n\n    Scenario Outline: Add two numbers\n      Given I have entered <input_1> into the calculator\n      And I have entered <input_2> into the calculator\n      When I press <button>\n      Then the result should be <output> on the screen\n\n    Examples:\n      | input_1 | input_2 | button | output |\n      | 20      | 30      | add    | 50     |\n      | 2       | 5       | add    | 7      |\n      | 0       | 40      | add    | 40     |\n\nIn this case, the scenario will be executed once for each row in the table (except the first row,\nwhich indicates which variable to substitute for).\n\n\nBackgrounds\n-----------\n\nA feature may contain a background. It allows you to *add some context to the scenarios*\nin the current feature. A Background is much like a scenario containing a number of steps.\nThe difference is when it is run.\n*The background is run before each of your scenarios but after any of your \"@Before\" hooks.*\n\nHere is an example::\n\n    Feature: Befriending\n      In order to have some friends\n      As a Facebook user\n      I want to be able to manage my list of friends\n\n      Background:\n        Given I am the user Ken\n        And I have friends Barbie, Cloe\n\n      Scenario: Adding a new friend\n        When I add a new friend named Jade\n        Then I should have friends Barbie, Cloe, Jade\n\n      Scenario: Removing a friend\n        When I remove my friend Cloe\n        Then I should have friends Barbie\n\n*Note that background should be added in a feature only if it has a value for the client.*\nOtherwise, you can use tagged hooks (see Tags_ and Hooks_).\n\n\nStep Definitions\n----------------\n\nWhen presented with a feature file, Freshen will execute each scenario. This involves iterating\nover each step in turn and executing its *step definition*. Step definitions are python functions\nadorned with a special decorator. Freshen knows which step definition function to execute by\nmatching the step's text against a regular expression associated with the definition. Here's an\nexample of a step definition file, which hopefully illustrates this point::\n\n    from freshen import *\n\n    import calculator\n\n    @Before\n    def before(sc):\n        scc.calc = calculator.Calculator()\n        scc.result = None\n\n    @Given(\"I have entered (\\d+) into the calculator\")\n    def enter(num):\n        scc.calc.push(int(num))\n\n    @When(\"I press (\\w+)\")\n    def press(button):\n        op = getattr(scc.calc, button)\n        scc.result = op()\n\n    @Then(\"the result should be (.*) on the screen\")\n    def check_result(value):\n        assert_equal(str(scc.result), value)\n\nIn this example, you see a few step definitions, as well as a hook. Any captures (bits inside the\nparentheses) from the regular expression are passed to the step definition function as arguments.\n\n\nSpecifying Step Definition Modules\n-----------------------------------\n\nStep definitions are defined in python modules. By default, Freshen will try to load\na module named \"steps\" from the same directory as the ``.feature`` file. If that is not the\ndesired behavior, you can also explicitly specify which step definition modules to use\nfor a feature. To do this, use the keyword ``Using step definitions from``\n(or its abbreviation: ``Using steps``) and specify which step definition modules you\nwant to use. Each module name must be a quoted string and must be relative to the\nlocation of the feature file. You can specify one or more module names (they must be\nseparated by commas).\n\nHere is an example::\n\n    Using step definitions from: 'steps', 'step/page_steps'\n\n    Feature: Destroy a document\n      In order to take out one's anger on a document\n      As an unsatisfied reader\n      I want to be able to rip off the pages of the document\n\n      Scenario: Rip off a page\n        Given a document of 5 pages\n        And the page is 3\n        When I rip off the current page\n        Then the page is 3\n        But the document has 4 pages\n\nAlthough you have the opportunity to explicitly specify the step definition modules to use in Freshen,\nthis is not a reason to fall into the `Feature-Coupled Steps Antipattern`_!\n\nA step definition module can import other step definition modules. When doing this,\nthe actual step definition functions must be at the top level. For example::\n\n    from other_step_module import *\n\nA step definition module can be a python package, as long as all the relevant functions are imported\ninto ``__init__.py``.\n\nThe python path will automatically include the current working directory and the\ndirectory of the ``.feature`` file.\n\n\nHooks\n-----\n\nIt is often useful to do some work before each step or each scenario is executed. For this purpose,\nyou can make use of *hooks*. Identify them for Freshen by adorning them with \"@Before\", \"@After\"\n(run before or after each scenario), or \"@AfterStep\" which is run after each step.\n\n\nContext storage\n---------------\n\nSince the execution of each scenario is broken up between multiple step functions, it is often\nnecessary to share information between steps. It is possible to do this using global variables in\nthe step definition modules but, if you dislike that approach, Freshen provides three global\nstorage areas which can be imported from the `freshen` module. They are:\n\n- ``glc``: Global context, never cleared - same as using a global variable\n- ``ftc``: Feature context, cleared at the start of each feature\n- ``scc``: Scenario context, cleared at the start of each scenario\n\nThese objects are built to mimic a JavaScript/Lua-like table, where fields can be accessed with\neither the square bracket notation, or the attribute notation. They do not complain when a key\nis missing::\n\n    glc.stuff == gcc['stuff']  => True\n    glc.doesnotexist           => None\n\nRunning steps from within step definitions\n------------------------------------------\n\nYou can call out to a step definition from within another step using the same notation used in\nfeature files. To do this, use the ``run_steps`` function::\n\n    @Given('I do thing A')\n    def do_a():\n        #Do something useful.\n        pass\n\n    @Given('I have B')\n    def having_b():\n        #Do something useful.\n        pass\n\n    @Given('I do something that use both')\n    def use_both():\n        run_steps(\"\"\"\n                  Given I do thing A\n                  And I have B\n                  \"\"\")\n\n\nMulti-line arguments\n--------------------\n\nSteps can have two types of multi-line arguments: multi-line strings and tables. Multi-line strings\nlook like Python docstrings, starting and terminating with three double quotes: ``\"\"\"``.\n\nTables look like the ones in the example section in scenario outlines. They are comprised of a\nheader and one or more rows. Fields are delimited using a pipe: ``|``.\n\nBoth tables and multi-line strings should be placed on the line following the step.\n\nThey will be passed to the step definition as the first argument. Strings are presented as regular\nPython strings, whereas tables come across as a ``Table`` object. To get the rows, call\n``table.iterrows()``.\n\n\nTags\n----\n\nA feature or scenario can be adorned with one or more tags. This helps classify features and\nscenarios to the reader. Freshen makes use of tags in two ways. The first is by allowing selective\nexecution via the command line - this is described below. The second is by allowing `hooks`_ to be\nexecuted selectively. A partial example::\n\n    >> feature:\n\n    @needs_tmp_file\n    Scenario: A scenario that needs a temporary file\n        Given ...\n        When ...\n\n    >> step definition:\n\n    @Before(\"@needs_tmp_file\")\n    def needs_tmp_file(sc):\n        make_tmp_file()\n\n\nStep Argument Transforms\n------------------------\n\nStep definitions are specified as regular expressions. Freshen will pass any\ncaptured sub-expressions (i.e. the parts in parentheses) to the step definition\nfunction as a string. However, it is often necessary to convert those strings\ninto another type of object. For example, in the step::\n\n    Then user bob should be friends with user adelaide\n\nwe may need to convert \"user bob\" to the the object User(name='bob') and\n\"user adelaide\" to User(name=\"adelaide\"). To do this repeatedly would break\nthe \"Do Not Repeat Yourself (DRY)\" principle of good software development. Step\nArgument Transforms allow you to specify an automatic transformation for\narguments if they match a certain regular expression. These transforms are\ncreated in the step definition file. For example::\n\n    @Transform(r\"^user (\\w+)$\")\n    def transform_user(name):\n        return User.objects.find(name)\n\n    @Then(r\"^(user \\w+) should be friends with (user \\w+)\")\n    def check_friends(user1, user2):\n        # Here the arguments will already be User objects\n        assert user1.is_friends_with(user2)\n\nThe two arguments to the \"Then\" step will be matched in the transform above\nand converted into a User object before being passed to the step definition.\n\nNamed Step Argument Transformation\n----------------------------------\n\nAnother imperfection of step definitions from the DRY perspective is\nthat they require repeated regular expressions to read \"the same\nthing\". By keeping expressions extremely simple the damage can be\nminimized, but sometimes it can be useful to centralize the pattern\nspecifications for certain argument types. Named Step Argument\nTransforms allow the use of a unique name a substitution point for the\nregular expression associated with a transform. For example, for the\nstep::\n\n  Then these users should be friends: \"bob, adelaide, samantha\"\n\nThe following definitions can be used::\n\n from itertools import combinations\n\n  @NamedTransform( '{user list}', r'(\"[\\w\\, ]+\")', r'^\"([\\w\\, ]+)\"$' )\n  def transform_user_list( slist ):\n     return [ User.objects.find( name )\n              for name.strip() in slist.split( ',' ) ]\n\n  @Then(r\"these users should be friends: {user list}\" )\n  def check_all_friends( user_list ):\n      for user1, user2 in combinations( user_list, 2 ):\n          assert user1.is_friends_with( user2 )\n\nThe arguments to `NamedTransform` are `name`, `in_pattern` and\n`out_pattern`, respectively. `NamedTranform` is equivalent to having\n`in_pattern` substituted for all occurrences of `name` in step\nspecifications, and defining a standard `Transform` with\n`out_pattern` as its pattern.\n\nThe distinction between `in_pattern` and `out_pattern` is that the\n`in_pattern` can be used to match surrounding context to uniquely\nidentify parameters, while the `out_pattern` searches within the text\nrecognized by the `in_pattern` to pull out the semantically relevant\nparts. When this distinction is not relevant, specify only one\npattern, and it will be used for both in and out patterns.\n\nIgnoring directories\n--------------------\n\nIf a directory contains files with the extension ``.feature`` but you'd like Freshen to skip over\nit, simply place a file with the name \".freshenignore\" in that directory.\n\n\nUsing with Django\n-----------------\n\nDjango_ is a popular framework for web applications. Freshen can work in conjunction with the\n`django-sane-testing`_ library to initialize the Django environment and databases before running\ntests. This feature is enabled by using the ``--with-django`` option from django-sane-testing. You\ncan also use ``--with-djangoliveserver`` or ``--with-cherrypyliveserver`` to start a web server\nbefore the tests run for use with a UI testing tool such as `Selenium`_.\n\n\nUsing with Selenium\n-------------------\n\nSelenium is not supported until plugin support is implemented. If you need to use Selenium, try\nversion 0.1.\n\n\nRunning\n-------\n\nFreshen runs as part of the nose framework, so all options are part of the ``nosetests`` command-\nline tool.\n\nSome useful flags for ``nosetests``:\n\n- ``--with-freshen``: Enables Freshen\n- ``-v``: Verbose mode will display each feature and scenario name as they are executed\n- ``--tags``: Only run the features and scenarios with the given tags. Tags should follow this\n  option as a comma-separated list. A tag may be prefixed with a tilde (``~``) to negate it and only\n  execute features and scenarios which do *not* have the given tag.\n- ``--language``: Run the tests using the designated language. See the\n  ``Internationalization`` section for more details\n\nYou should be able to use all the other Nose features, like coverage or profiling for \"free\". You\ncan also run all your unit, doctests, and Freshen tests in one go. Please consult the `Nose manual`_\nfor more details.\n\nInternationalization\n--------------------\n\nFreshen now supports 30 languages, exactly the same as cucumber, since the\n\"language\" file was borrowed from the cucumber project. As long as your\n``.feature`` files respect the syntax, the person in charge of writing the\nacceptance tests may write it down in his/her mother tongue. The only exception is\nthe new keyword for `specifying step definition modules`_ since it is not available\nin Cucumber_. For the moment, this keyword is available only in English, French,\nand Portuguese. If you use another language, you must use the English keyword for this\nparticular keyword (or translate it and add it to the ``languages.yml`` file).\n\nThe 'examples' directory contains a French sample. It's a simple translation of\nthe English 'calc'. If you want to check the example, go to the 'calc_fr'\ndirectory, and run::\n\n    $ nosetests --with-freshen --language=fr\n\nThe default language is English.\n\n\nAdditional notes\n----------------\n\n**Why copy Cucumber?** - Because it works and lots of people use it. Life is short, so why spend it\non coming up with new syntax for something that already exists?\n\n**Why use Nose?** - Because it works and lots of people use it and it already does many useful\nthings. Life is short, so why spend it re-implementing coverage, profiling, test discovery, and\ncommand like processing again?\n\n**Can I contribute?** - Yes, please! While the tool is currently a copy of Cucumber's syntax,\nthere's no law that says it has to be that forever. If you have any ideas or suggestions (or bugs!),\nplease feel free to let me know, or simply clone the repository and play around.\n\n.. _`Source code`: http://github.com/rlisagor/freshen\n.. _`Nose`: http://somethingaboutorange.com/mrl/projects/nose/0.11.1/\n.. _`Nose manual`: http://somethingaboutorange.com/mrl/projects/nose/0.11.1/testing.html\n.. _`Cucumber`: http://cukes.info\n.. _`Cucumber wiki`: http://wiki.github.com/aslakhellesoy/cucumber/\n.. _`Feature-Coupled Steps Antipattern`: http://wiki.github.com/aslakhellesoy/cucumber/feature-coupled-steps-antipattern\n.. _`Selenium`: http://seleniumhq.org/\n.. _`Django`: http://www.djangoproject.com/\n.. _`django-sane-testing`: http://devel.almad.net/trac/django-sane-testing/\n\n..  LocalWords:  py init subpackage stepregistry defs Cloe sc scc num\n..  LocalWords:  calc getattr str Antipattern AfterStep glc ftc Lua\n..  LocalWords:  gcc doesnotexist Multi multi docstrings iterrows UI\n..  LocalWords:  adelaide samantha itertools NamedTransform slist\n..  LocalWords:  NamedTranform freshenignore Django django nosetests\n..  LocalWords:  djangoliveserver cherrypyliveserver doctests\n",
    "docs_url": null,
    "download_url": "UNKNOWN",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "http://github.com/lddubeau/fresher",
    "keywords": null,
    "license": "GPL",
    "maintainer": null,
    "maintainer_email": null,
    "name": "fresher",
    "platform": "UNKNOWN",
    "project_url": "https://pypi.org/project/fresher/",
    "release_url": "https://pypi.org/project/fresher/0.4.0/",
    "requires_python": null,
    "summary": "Clone of the Cucumber BDD framework for Python forked from Freshen",
    "version": "0.4.0"
  },
  "releases": {
    "0.3.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "87df93d2614682d36af747aa2eb2d85c",
          "sha256": "f59fb6a65bd4d28706c39837aa4023c782381fab15b980d23cd3cf11c2be34ba"
        },
        "downloads": 2022,
        "filename": "fresher-0.3.0.tar.gz",
        "has_sig": false,
        "md5_digest": "87df93d2614682d36af747aa2eb2d85c",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 48121,
        "upload_time": "2013-11-04T02:25:20",
        "url": "https://files.pythonhosted.org/packages/85/4a/3510ddda6e857f92f97b36888c355bf7001e6620953cda157149c2363b5a/fresher-0.3.0.tar.gz"
      }
    ],
    "0.3.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "f04ccf9d71fd141a04cc5c333f9454eb",
          "sha256": "2f7b67409e58c8dbd66914070078c0dbf0e9322edcffba9a84c468d84f604c64"
        },
        "downloads": 2246,
        "filename": "fresher-0.3.1.tar.gz",
        "has_sig": false,
        "md5_digest": "f04ccf9d71fd141a04cc5c333f9454eb",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 48359,
        "upload_time": "2013-11-07T02:27:40",
        "url": "https://files.pythonhosted.org/packages/86/be/31b913fbd6792f6546c9495d3c0228a163b45a4a343912915ce149c843ca/fresher-0.3.1.tar.gz"
      }
    ],
    "0.4.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "b033713a217ed2762005a519935ece1c",
          "sha256": "abd707383dc20e434364e2b4d3fd0e18393b9ab33d5d1d2a084bdf8004d41b3e"
        },
        "downloads": 3132,
        "filename": "fresher-0.4.0.tar.gz",
        "has_sig": false,
        "md5_digest": "b033713a217ed2762005a519935ece1c",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 48551,
        "upload_time": "2014-02-01T01:37:35",
        "url": "https://files.pythonhosted.org/packages/96/a5/4126036bba6edf8eb9ebb6e866cb50c44b4640ba7ee15a4116476851d93a/fresher-0.4.0.tar.gz"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "b033713a217ed2762005a519935ece1c",
        "sha256": "abd707383dc20e434364e2b4d3fd0e18393b9ab33d5d1d2a084bdf8004d41b3e"
      },
      "downloads": 3132,
      "filename": "fresher-0.4.0.tar.gz",
      "has_sig": false,
      "md5_digest": "b033713a217ed2762005a519935ece1c",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 48551,
      "upload_time": "2014-02-01T01:37:35",
      "url": "https://files.pythonhosted.org/packages/96/a5/4126036bba6edf8eb9ebb6e866cb50c44b4640ba7ee15a4116476851d93a/fresher-0.4.0.tar.gz"
    }
  ]
}