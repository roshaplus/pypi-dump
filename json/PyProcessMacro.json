{
  "info": {
    "author": "Quentin Andr\u00e9",
    "author_email": "quentin.andre@insead.edu",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 4 - Beta",
      "License :: OSI Approved",
      "Natural Language :: English",
      "Operating System :: OS Independent",
      "Programming Language :: Python",
      "Programming Language :: Python :: 3.5"
    ],
    "description": "PyProcessMacro: A Python Implementation of Andrew F. Hayes' 'Process' Macro\n===========================================================================\n\n# 1. Copyright Notice for the original Process Macro\n\nThe Process Macro for SAS and SPSS, and its associated files, are copyrighted by Andrew F. Hayes. The original code\nmust not be edited or modified, and must not be distributed outside of \n[http://www.processmacro.org](http://www.processmacro.org).\n \nBecause PyProcessMacro is a complete reimplementation of the Process Macro, and was not based on the original \ncode, permission was generously granted by Andrew F. Hayes to distribute PyProcessMacro under a MIT license.\n \n This permission is not an endorsement of PyProcessMacro: all potential errors, bugs and inaccuracies are my own, and\nAndrew F. Hayes was not involved in writing, reviewing, or debugging the code.\n\n# 2. Manifest\n\nThe Process Macro by Andrew F. Hayes has helped thousands of researchers in their analysis of moderation, mediation, and\nconditional processes. Unfortunately, Process was only available for proprietary softwares (SAS and SPSS), which means\nthat students and researchers had to purchase a license of those softwares to make use of the Macro.\n\nBecause of the growing popularity of Python in the scientific community, I decided to implement the features of the \nProcess Macro into an open-source library, that researchers will be able to use without relying on those proprietary\nsoftwaress. PyProcessMacro is released under a MIT license.\n \n# 3. Features\n\nIn the current version, PyProcessMacro replicates the following features from the original Process Macro v2.16:\n  * All models (1 to 76), with the exception of Model 6 (serial mediation) are supported, and have been numerically\n  tested for accuracy against the output of the original Process macro (see the `test_models_accuracy.py`)\n  * Estimation of binary/continuous outcome variables. The binary outcomes are estimated in Logit using the \n  Newton-Raphson convergence algorithm, the continuous variables are estimated using OLS.\n  * All statistics reported by Process: \n    * Variable parameters for outcome models\n    * (Conditional) direct and indirect effects\n    * Indices for Partial/Conditional/Moderated Moderated Mediation are always reported if the model supports them.\n  * Automatic generation of spotlight values for continuous/discrete moderators.\n  * Rich set of options to tweak the estimation and display of the different models: (almost) all the options from\n  Process exist in PyProcessMacro. Check the doc for more details.\n\nThe following changes and improvements have been made from the original Process Macro:\n  * Variable names can be of any length, and even include spaces and special characters.\n  * All mediation models support an infinite number of mediators (versus a maximum of 10 in Process).\n  * Normal theory tests for the indirect effect(s) are not reported, as the bootstrapping approach is now widely\n  accepted and in most cases more robust.\n  * Plotting capabilities: PyProcessMacro can generate the plot of direct and indirect effects at various levels\n  of the moderators. See the documentation for plot_indirect_effects() and plot_direct_effects().\n  * Fast estimation process: PyProcessMacro leverages the capabilities of NumPy to efficiently compute a large number\n  of bootstrap estimates, and dramatically speed up the estimation of complex models.\n  * Transparent bootstrapping: PyProcessMacro explicitely reports the number of bootstrap samples that have been \n  discarded because of numerical instability.\n\nIn the current version, the following features have not yet been ported to PyProcessMacro:\n  * Support for categorical independent variables.\n  * Generation of individual fixed effects for repeated measures.\n  * R\u00b2 improvement from moderators in moderation models (1, 2, 3).\n  * Estimation of serial mediation (Model 6)\n  * Some options (`normal`, `varorder`, ...). PyProcessMacro will issue a warning to tell you if an option you are \n  trying to use is not implemented.\n\n\n# 4. Installation and Usage\n\nThis section will familiarize you with the few differences that exist between Process and PyProcessMacro.\n\nYou can install PyProcessMacro with pip:\n\n    pip install pyprocessmacro\n\n## A. Minimal example\n\nThe basic syntax for PyProcessMacro is the following:\n\n````python\nfrom pyprocessmacro import Process\nimport pandas as pd\ndf = pd.read_csv(\"MyDataset.csv\")\np = Process(data=df, model=13, x=\"Effort\", y=\"Success\", w=\"Motivation\", z=\"SkillRelevance\", \n            m=[\"MediationSkills\", \"ModerationSkills\"])\np.summary()\n````\n\n[Click to see a sample output!](SampleOutput.md)\n\nAs you can see, the syntax for PyProcessMacro is (almost) identical to that of Process. Unless this documentation\n mentions otherwise, you can assume that all the options/keywords from Process exist in PyProcessMacro.\n \n A `Process` object is initialized by specifying a data source, the model number, and the mapping between the symbols \n and the variable names. \n\nOnce the object is initialized, you can call its `summary()` method to display the estimation results\n\nYou might have noticed that there is no argument `varlist` in PyProcessMacro. This is because the list of variables \nis automatically inferred from the variable names given to x, y, m.\n\n## B. Adding statistical controls\n\nIn Process, the controls are defined as \"any argument in the varlist that is not the IV, the DV, a moderator, or \na mediator.\" In PyProcessMacro, the list of variables to include as controls have to be explicitely specified in \nthe \"controls\" argument.\n\nThe equation(s) to which the controls are added is specified through the `controls_in` argument:\n  * `x_to_m` means that the controls will be added in the path from the IV to the mediator(s) only.\n  * `all_to_y` means that the controls will be added in the path from the IV and the mediators to the DV only. \n  * `both` means that the controls will be added in both equations.\n  \nThe ability to specify a different list of control for each equation is coming in the next release of PyProcessMacro.\n  \n````python\np = Process(data=df, model=13, x=\"Effort\", y=\"Success\", w=\"Motivation\", z=\"SkillRelevance\", \n            m=[\"MediationSkills\", \"ModerationSkills\"],\n            controls=[\"Control1\", \"Control2\"],\n            controls_in=\"both\")\np.summary()\n````\n\n## C. Logistic regression for binary outcomes\n\nThe original Process Macro automatically uses a Logistic (instead of OLS) regression when it detects a binary outcome.\n \nPyProcessMacro prefers a more explicit approach, and requires you to set the parameter `logit` to `True` if your DV\nshould be estimated using a Logistic regression.\n\n````python\np = Process(data=df, model=13, x=\"Effort\", y=\"Success\", w=\"Motivation\", z=\"SkillRelevance\", \n            m=[\"MediationSkills\", \"ModerationSkills\"], logit=True)\np.summary()\n````\n\nIt goes without saying that this will return an error if your DV is not dichotomous.\n\n## D. Specifying custom spotlight values for the moderator(s)\n\nIn Process as in PyProcessMacro the spotlight values of the moderators are defined as follow:\n* By default, the spotlight values are equal to M - 1SD, M and M + 1SD, where M and SD are the mean and standard \ndeviation of that variable. If the option `quantile=1` is specified, then the spotlight values for each moderator \nare the 10th, 25th, 50th, 75th and 90th percentile of that variable.\n* If a moderator is a discrete variable, the spotlight values are those discrete values.\n\nIn Process, custom spotlight values can be applied to each moderator q, v, z, ... through the arguments qmodval, \nvmodval, zmodval... \n\nIn PyProcessMacro, the user must instead supply custom values for each moderator in a dictionary\npassed to the `modval` parameter:\n\n````python\np = Process(data=df, model=13, x=\"Effort\", y=\"Success\", w=\"Motivation\", z=\"SkillRelevance\", \n            m=[\"MediationSkills\", \"ModerationSkills\"],\n            modval={\n                \"Motivation\":[-5, 0, 5], # Moderator 'Motivation' at values -5, 0 and 5\n                \"SkillRelevance\":[-1, 1] # Moderator 'SkillRelevance' at values -1 and 1\n            })\np.summary()\n````\n\n\n## E. Suppress the initialization information\n\nWhen the Process object is initialized by Python, it displays various information about the model (model number, list of\n variables, sample size, number of bootstrap samples, etc...). If you wish not to display this information, just add the\n argument `suppr_init=True` when initializing the model.\n \n````python\np = Process(data=df, model=13, x=\"Effort\", y=\"Success\", w=\"Motivation\", z=\"SkillRelevance\", \n            m=[\"MediationSkills\", \"ModerationSkills\"], suppr_init=True)\np.summary()\n````\n\n# 4. Accessing the estimation results\n\nAfter the `Process` object is initialized, you are not limited to printing the summary. PyProcessMacro implements the\nfollowing methods that allow you to conveniently recover the different estimates of interest:\n\n## A. `summary()`\n\nThis method replicates the output that you would see in Process, and displays the following information:\n* Model summaries and parameters estimates for all outcomes (i.e. the independent variable, and the mediator(s)).\n* If the model has a moderation, conditional effects at the spotlight values of the moderator(s).\n* If the model has a mediation, direct and indirect effects.\n* If the model has a moderation and a mediation, conditional direct and indirect effects at values of the moderator(s).\n* If those statistics are relevant, indices for partial, conditional, and moderated moderated mediation will be \nreported.\n\n## B. `outcome_models`\n\nThis command gives you individual access to each of the outcome models through a dictionary. This allows you to recover \nthe model and parameters estimates for each outcome.\n\nEach OutcomeModel object has the following methods:\n* `summary()` prints the full summary of the model (as Process does).\n* `model_summary()` returns a DataFrame of goodness-of-fit statistics for the model. \n* `coeff_summary()`  returns a DataFrame of estimate, standard error,  corresponding z/t, p-value, and\n confidence interval for each of the parameters in the model.\n* `estimation_results` gives you access to a dictionary containing all the statistical information of the\n model.\n \n````python\np = Process(data=df, model=13, x=\"Effort\", y=\"Success\", w=\"Motivation\", z=\"SkillRelevance\", \n            m=[\"MediationSkills\", \"ModerationSkills\"], suppr_init=True)\n\nmodel_medskills = p.outcome_models[\"MediationSkills\"] # The model for the outcome \"MediationSkills\"\n\nmodel_medskills.summary() # Print the summary for this model\n\ndf_params_med1 = model_medskills.coeff_summary() # Store the DataFrame of estimates into a variable.\n\nmed1_R2 = model_medskills.estimation_results[\"R2\"] # Store the R\u00b2 of the model into a variable.\n````\n\nNote that the methods are called from the `model_medskills` object! If you call `p.coeff_summary()`, \nyou will get an error.\n\n## C. `direct_model`\n\nWhen the Process model includes a mediation, the direct effect model can conveniently be accessed, which \ngives you access to the following methods: \n\n* `summary()` prints the full summary of the direct effects, as done in calling Process.summary().\n* `coeff_summary()` returns a DataFrame of estimate, standard error, t-value, p-value, and confidence \ninterval for each of the (conditional) direct effect(s).\n\n````python\np = Process(data=df, model=13, x=\"Effort\", y=\"Success\", w=\"Motivation\", z=\"SkillRelevance\", \n            m=[\"MediationSkills\", \"ModerationSkills\"], suppr_init=True)\n\ndirect_model = p.direct_model # The model for the direct effect\n\ndf_params_direct = direct_model.coeff_summary() # Store the DataFrame of estimates into a variable.\n````\n\nNote that the methods are called from the `direct_model` object! If you call `p.coeff_summary()`, you will get an \nerror.\n\n\n## D. `indirect_model`\n\nWhen the Process model includes a parallel mediation, the indirect effect model can be accessed as well, which \ngives you access to the following methods: \n\n* `summary()` prints the full summary of the indirect effects, and other related indices, as done in\n calling Process.summary().\n* `coeff_summary()` returns a DataFrame of indirect effect(s) and their SE/CI for each of the mediation\npaths\n* `PMM_index_summary()` returns a DataFrame of indices for Partial Moderated Mediation, and their \nSE/CI, for each of the moderators and mediation paths. If the model does not compute a PMM, this will return an error.\n* `CMM_index_summary()` returns a DataFrame of indices for Conditional Moderated Mediation, and their \nSE/CI, for each of the moderators and mediation paths. If the model does not compute a CMM, this will return an error.\n* `CMM_index_summary()` returns a DataFrame of indices for Moderated Moderated Mediation, and their \nSE/CI, for each of the mediation paths. If the model does not compute a MMM, this will return an error.\n\n````python\np = Process(data=df, model=13, x=\"Effort\", y=\"Success\", w=\"Motivation\", z=\"SkillRelevance\", \n            m=[\"MediationSkills\", \"ModerationSkills\"], suppr_init=True)\n\nindirect_model = p.indirect_model # The model for the direct effect\n\ndf_params_direct = indirect_model.coeff_summary() # Store the DataFrame of estimates into a variable.\n````\n\nNote that the methods are called from the `indirect_model` object! If you call `p.coeff_summary()`, you will get an \nerror.\n\n# 5. Bootstrap samples estimates\n\nThe original Process macro allows you to save the parameter estimates for each bootstrap sample by specifying the `save`\nkeyword. The Macro then returns a new dataset of bootstrap estimates.\n\nIn PyProcessMacro, this is done by calling the method `get_bootstrap_estimates()`, which returns a DataFrame containing \nthe parameters estimates for all variables in the model, for each outcome.\n\n````python\np = Process(data=df, model=13, x=\"Effort\", y=\"Success\", w=\"Motivation\", z=\"SkillRelevance\", \n            m=[\"MediationSkills\", \"ModerationSkills\"], suppr_init=True)\n\nboot_estimates = p.get_bootstrap_estimates() # Called from the Process object directly.\n````\n\n# 6. Plotting capabilities\n\nPyProcessMacro allows you to plot the conditional direct and indirect effect(s), at different values of the moderators.\n\nThe methods `plot_indirect_effects()` and `plot_direct_effects()` are identical in syntax, with one\nsmall exception: you must specify the name of the mediator for `plot_indirect_effects` as a first argument. They return\na `seaborn.FacetGrid` object that can be used to further tweak the appearance of the plot.\n\n## A. Basic Usage \n\nWhen plotting conditional direct (and indirect) effects, the effect is always represented on the y-axis. \n\nThe various spotlight values of the moderator(s) can be represented on several dimensions:\n* On the x-axis (moderator passed to `x`).\n* As a color-code, in which case several lines are displayed on the same plot (moderator passed to `hue`).\n* On different plots, displayed side-by-side (moderator passed to `col`).\n* On different plots, displayed one below the other (moderator passed to `row`)\n\nAt the minimum, the `x` argument is required, while the `hue`, `col` and `row` are optional.\nThe examples below are showing what the plots could look like for a model with two moderators.\n\n````python\nfrom pyprocessmacro import Process\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndf = pd.read_csv(\"MyDataset.csv\")\np = Process(data=df, model=13, x=\"Effort\", y=\"Success\", w=\"Motivation\", z=\"SkillRelevance\", \n            m=[\"MediationSkills\", \"ModerationSkills\"], suppr_init=True)\n\n# Conditional direct effects of Effort, at values of Motivation (x-axis) \ng = p.plot_direct_effects(x=\"Motivation\") \nplt.show()\n````\n![BasicExample](Images/Ex1.png)\n\n````python\n# Conditional indirect effects through MediationSkills, at values of Motivation (x-axis) and \n# SkillRelevance (color-coded)\ng = p.plot_indirect_effects(med_name=\"MediationSkills\", x=\"Motivation\", hue=\"SkillRelevance\") \ng.add_legend(title=\"\") # Add the legend for the color-coding\nplt.show()\n````\n![ColorCodedModerator](Images/Ex2.png)\n````python\n# Display the values for SkillRelevance on side-by-side plots instead.\ng = p.plot_indirect_effects(med_name=\"MediationSkills\", x=\"Motivation\", col=\"SkillRelevance\")\nplt.show()\n````\n![ColCodedModerator](Images/Ex3.png)\n````python\n# Display the values for SkillRelevance on vertical plots instead.\ng = p.plot_indirect_effects(med_name=\"MediationSkills\", x=\"Motivation\", row=\"SkillRelevance\")\nplt.show()\n````\n![RowCodedModerator](Images/Ex4.png)\n## B. Change the spotlight values\n\nBy default, the spotlight values used to plot the effects are the same as the ones passed when initializing Process.\nHowever, you can pass custom values for some, or all, the moderators through the `mods_at` argument.\n\n````python\n# Change the spotlight values for SkillRelevance\ng = p.plot_indirect_effects(med_name=\"MediationSkills\", x=\"Motivation\", hue=\"SkillRelevance\", \n                            mods_at={\"SkillRelevance\": [-5, 5]})\ng.add_legend(title=\"\")\nplt.show()\n````\n![ChangeSpotValues](Images/Ex6.png)\n\n## C. Representation of uncertainty\n\nThe display of confidence intervals for the direct/indirect effects can be customized through the `errstyle` argument:\n* `errstyle=\"band\"` (default) plots a continuous error band between the lower and higher confidence interval. This \nrepresentation works well when the moderator displayed on the x-axis is continuous (e.g. age), as it allows you to \nvisualize the error at all levels of the moderator.\n* `errstyle=\"ci\"` plots an error bar at each value of the moderator on x-axis. It works well when the moderator \n displayed on the x-axis is dichotomous or has few values (e.g. gender), as it reduces clutter.\n* `errstyle=\"none\"` does not show the error on the plot.\n \n ````python\n# CI for dichotomous moderator\ng = p.plot_indirect_effects(med_name=\"MediationSkills\", x=\"Motivation\", hue=\"SkillRelevance\", \n                            mods_at={\"Motivation\": [0, 1], \"SkillRelevance\":[-1, 0, 1]},\n                            errstyle=\"ci\")\n````\n![ErrStyleCI](Images/Ex7.png)\n\n````python                \n# Error band for continous moderator\ng = p.plot_indirect_effects(med_name=\"MediationSkills\", x=\"Motivation\", hue=\"SkillRelevance\", \n                            mods_at={\"SkillRelevance\":[-1, 0, 1]},\n                            errstyle=\"ci\")\n````\n![ErrStyleBand](Images/Ex8.png)\n````python\n# No representation of error\ng = p.plot_indirect_effects(med_name=\"MediationSkills\", x=\"Motivation\", hue=\"SkillRelevance\", \n                            mods_at={\"SkillRelevance\":[-1, 0, 1]},\n                            errstyle=\"none\")\n                            \nplt.show()\n````\n![ErrStyleNone](Images/Ex9.png)\n\n\n## D. \"Partial\" plots\n\nSo far, the number of moderators supplied as arguments to the plot function was always equal to the number of moderators\non the path of interest (1 for the direct path, 2 for the indirect path).\n\nYou can also \"omit\" some moderators, and plot \"partial\" conditional direct/indirect effects. In that case, the omitted \nmoderators  will assume a value of 0 when computing the direct/indirect effects.\n\n````python\np = Process(data=df, model=13, x=\"Effort\", y=\"Success\", w=\"Motivation\", z=\"SkillRelevance\", \n            m=[\"MediationSkills\", \"ModerationSkills\"], suppr_init=True)\n\n# SkillRelevance is a moderator of the indirect path, but is not mentioned as an argument in the plotting function!\ng = p.plot_indirect_effects(med_name=\"MediationSkills\", x=\"Motivation\") \nplt.show() # This plot represents the \"partial\" conditional indirect effect, when SkillRelevance is evaluated at 0.\n````\n![PartialPlotDefault](Images/Ex10.png)\n\n\nIf you want the omitted moderator(s) to have a different value than 0, you must pass a unique value for each moderator\nas a key in the `mods_at` dictionary:\n\n````python\ng = p.plot_indirect_effects(med_name=\"MediationSkills\", x=\"Motivation\", mods_at={\"SkillRelevance\":[-5]}) \nplt.show() # This plot represents the \"partial\" conditional indirect effect, when SkillRelevance is evaluated at -5.\n````\n![PartialPlotCustom](Images/Ex11.png)\n\nDo not pass multiple values in `mods_at` if you do not intend to represent this moderator on the plot, as the graph\nwill then not be interpretable!\n\n# E. Customize the appearance of the plots\n\nUnder the hood, the plotting functions relies on a `seaborn.FacetGrid` object, on which the following objects \nare plotted:\n * `plt.plot` when `errstyle=\"none\"`\n * `plt.plot` and `plt.fill_between` when `errstyle=\"band\"`\n * `plt.plot` and `plt.errorbar` when `errstyle=\"ci\"`\n \nYou can pass custom arguments to each of those objects to customize the appearance of the plot:\n\n````python\nfrom pyprocessmacro import Process\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndf = pd.read_csv(\"MyDataset.csv\")\np = Process(data=df, model=13, x=\"Effort\", y=\"Success\", w=\"Motivation\", z=\"SkillRelevance\", \n            m=[\"MediationSkills\", \"ModerationSkills\"], suppr_init=True)\n\nplot_kws = {'lw': 5}  # Plot:  Make the lines bolder\nerr_kws = {'capthick': 5, 'ecolor': 'black', 'elinewidth': 5, 'capsize': 5}  # Errors: Make the CI bolder and black\nfacet_kws = {'aspect': 1}  #Grid: Make the FacetGrid a square rather than a rectangle\n\n\ng = p.plot_indirect_effects(med_name=\"MediationSkills\", x=\"Motivation\", errstyle=\"ci\",\n                            plot_kws=plot_kws, err_kws=err_kws, facet_kws=facet_kws)\n````\n![PlotCustomKws](Images/Ex12.png)\n\n# 7. About\nPyProcessMacro was developed by Quentin Andr\u00e9 during his PhD in Marketing at INSEAD Business School, France. \n\nHis work on this library was made possible by Andrew F. Hayes' \n[excellent book](http://afhayes.com/introduction-to-mediation-moderation-and-conditional-process-analysis.html), \nby the financial support of INSEAD and by the ADLPartner PhD award.\n\n\n",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "https://github.com/QuentinAndre/pyprocessmacro/",
    "keywords": "mediation-analysis",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "PyProcessMacro",
    "platform": "",
    "project_url": "https://pypi.org/project/PyProcessMacro/",
    "release_url": "https://pypi.org/project/PyProcessMacro/0.9.4/",
    "requires_python": "",
    "summary": "A Python library for moderation, mediation and conditional process analysis. Based on Andrew F. Hayes Process Macro.",
    "version": "0.9.4"
  },
  "releases": {
    "0.9.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "77bb96a9c6e52b95c1b9c3222b747769",
          "sha256": "6087703f73eda4d5a372d3d26011ca0f27450a30d434ab6ce048fd5327e0c9fc"
        },
        "downloads": 17,
        "filename": "PyProcessMacro-0.9.0.zip",
        "has_sig": false,
        "md5_digest": "77bb96a9c6e52b95c1b9c3222b747769",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 40535,
        "upload_time": "2017-03-06T20:33:54",
        "url": "https://files.pythonhosted.org/packages/cb/77/4626ef1916a0ad390c040feab75e57c5cc44242487ff442a8e5eb39cf4b6/PyProcessMacro-0.9.0.zip"
      }
    ],
    "0.9.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "ee0321ba440e3fb243d26bcc90ae4635",
          "sha256": "853fe620ed3ef560720d55ae09c008260b63742f3c87753af385be29dd4e3947"
        },
        "downloads": 19,
        "filename": "PyProcessMacro-0.9.1.zip",
        "has_sig": false,
        "md5_digest": "ee0321ba440e3fb243d26bcc90ae4635",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 47789,
        "upload_time": "2017-03-06T20:54:37",
        "url": "https://files.pythonhosted.org/packages/d9/8f/936d85f1400a8502d73cc5ba67f652fbd6a8f065ce84641708ac31218412/PyProcessMacro-0.9.1.zip"
      }
    ],
    "0.9.2": [
      {
        "comment_text": "",
        "digests": {
          "md5": "df45d2291a8ceccb9959dd54c38daecd",
          "sha256": "9e5d6f4290dcfe883e00b93ba4f7b4b01b9b397b0eee987d4281f0b4812d6a76"
        },
        "downloads": 16,
        "filename": "PyProcessMacro-0.9.2.zip",
        "has_sig": false,
        "md5_digest": "df45d2291a8ceccb9959dd54c38daecd",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 47796,
        "upload_time": "2017-03-06T21:05:15",
        "url": "https://files.pythonhosted.org/packages/6e/e8/f9e3ec40f8902abdae6ae99bbf9fd0227efc1cfacbe24e35ee81fb83e53f/PyProcessMacro-0.9.2.zip"
      }
    ],
    "0.9.3": [
      {
        "comment_text": "",
        "digests": {
          "md5": "0d493f48a108ca3c0d1f406d17ddc809",
          "sha256": "34510758ba511033f2e9f23b903da94e21c7bd7061c1c205051a2145715ef983"
        },
        "downloads": 15,
        "filename": "PyProcessMacro-0.9.3.tar.gz",
        "has_sig": false,
        "md5_digest": "0d493f48a108ca3c0d1f406d17ddc809",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 39652,
        "upload_time": "2017-03-30T06:52:19",
        "url": "https://files.pythonhosted.org/packages/ff/ae/f5b922c9894d26dd2221a70af049b090a06904940b3e8f94aed513f76f9c/PyProcessMacro-0.9.3.tar.gz"
      }
    ],
    "0.9.4": [
      {
        "comment_text": "",
        "digests": {
          "md5": "8b7b1b5c7de487826b501c492555d266",
          "sha256": "f5b2dd9037b2d3498b115bcf41c50754692114722c73d23da6379add50cac14a"
        },
        "downloads": 0,
        "filename": "PyProcessMacro-0.9.4.tar.gz",
        "has_sig": false,
        "md5_digest": "8b7b1b5c7de487826b501c492555d266",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 39657,
        "upload_time": "2017-04-18T09:33:55",
        "url": "https://files.pythonhosted.org/packages/d3/6f/60233c94a585f8d045a874f44d5500ed745dc47478c989d6002662374f20/PyProcessMacro-0.9.4.tar.gz"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "8b7b1b5c7de487826b501c492555d266",
        "sha256": "f5b2dd9037b2d3498b115bcf41c50754692114722c73d23da6379add50cac14a"
      },
      "downloads": 0,
      "filename": "PyProcessMacro-0.9.4.tar.gz",
      "has_sig": false,
      "md5_digest": "8b7b1b5c7de487826b501c492555d266",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 39657,
      "upload_time": "2017-04-18T09:33:55",
      "url": "https://files.pythonhosted.org/packages/d3/6f/60233c94a585f8d045a874f44d5500ed745dc47478c989d6002662374f20/PyProcessMacro-0.9.4.tar.gz"
    }
  ]
}