{
  "info": {
    "author": "Nexedi",
    "author_email": "jondy.zhao@nexedi.com",
    "bugtrack_url": null,
    "classifiers": [
      "Framework :: Buildout",
      "Framework :: Buildout :: Recipe",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: BSD License",
      "Topic :: Software Development :: Build Tools",
      "Topic :: Software Development :: Libraries :: Python Modules"
    ],
    "description": "********************************************\nRecipe for compiling and installing software\n********************************************\n\n.. contents::\n\nThe recipe provides the means to compile and install source distributions\nusing ``configure`` and ``make`` and other similar tools. It is inspired by\nthe hexagonit.recipe.cmmi_ recipe but provides more control over the build process.\n\nUse python 2.7 to run test, at least python 2.6 results in some\nfailures in the tests.py:\n\n  TypeError: failUnlessRaises() takes at least 3 arguments (2 given)\n\nFirst, we make test environments:\n\n::\n\n  cd slapos.recipe.cmmi\n  wget http://downloads.buildout.org/2/bootstrap.py\n  wget http://svn.zope.org/*checkout*/zc.buildout/trunk/bootstrap/bootstrap.py\n\n  cat <<EOF > buildout.cfg\n  [buildout]\n  develop = .\n  parts = test\n  prefix = /tmp/test\n\n  [test]\n  recipe = zc.recipe.testrunner\n  eggs =\n    slapos.recipe.cmmi[test]\n  EOF\n\n  python -S bootstrap.py --version 1.7.0\n  bin/buildout\n\nIt will generate script bin/test, run it to do all the testcases:\n\n::\n\n  bin/test\n\nAfter source changed, run buildout to update eggs again:\n\n::\n\n  bin/buildout -v -N\n  bin/test\n\nBuild dist/slapos.recipe.cmmi-0.2-py2.7.egg\n\n::\n\n  bin/buildout setup setup.py bdist_egg\n\nBuild source package dist/slapos.recipe.cmmi-0.2.tar.gz\n\n::\n\n  python setup.py sdist\n\nRepository: http://git.erp5.org/gitweb/slapos.recipe.cmmi.git\n\nClone URL: git clone http://git.erp5.org/repos/slapos.recipe.cmmi.git\n\nIssue tracker: None\n\nSupported Python versions: 2.6, 2.7, 3.2, 3.3\n\nSupported zc.buildout versions: 1.x, 2.x\n\nTravis build: |travis|\n\n.. |travis| image:: https://api.travis-ci.org/hexagonit/hexagonit.recipe.cmmi.png\n\n.. _hexagonit.recipe.cmmi : http://pypi.python.org/pypi/hexagonit.recipe.cmmi\n\nChanges\n=======\n\n0.7 (2017-06-06)\n----------------\n\n* Fix MANIFEST.in: some files were missing.\n\n0.6 (2017-06-05)\n----------------\n\n* Add support for Python 3.\n* Optimize wrapper to scripts with long shebangs.\n\n0.5 (2017-04-07)\n----------------\n\n* Create a wrapper shell script for very long shebang scripts.\n\n0.4 (2017-03-08)\n----------------\n\n* Use slapos.recipe.build:downloadunpacked instead of hexagonit.recipe.download.\n\n0.1.1 (2013-04-12)\n------------------\n\n* Fix the wrong name 'path_filename'\n\n0.1 (2013-04-12)\n----------------\n\n* Initial release, forking from hexagonit.recipe.cmmi (https://github.com/hexagonit/hexagonit.recipe.cmmi)\n\nSupported options\n=================\n\n``url``\n\n    URL to the package that will be downloaded and extracted. The\n    supported package formats are .tar.gz, .tar.bz2, and .zip. The\n    value must be a full URL,\n    e.g. http://python.org/ftp/python/2.4.4/Python-2.4.4.tgz. The\n    ``path`` option can not be used at the same time with ``url``.\n\n``path``\n\n    Path to a local directory containing the source code to be built\n    and installed. The directory must contain the ``configure``\n    script. The ``url`` option can not be used at the same time with\n    ``path``.\n\n``prefix``\n\n    Custom installation prefix passed to the ``--prefix`` option of the\n    ``configure`` script. Defaults to the location of the part. Note that this\n    is a convenience shortcut which assumes that the default ``configure``\n    command is used to configure the package. If the ``configure-command``\n    option is used to define a custom configure command no automatic\n    ``--prefix`` injection takes place. You can also set the ``--prefix``\n    parameter explicitly in ``configure-options``.\n\n``share``\n\n    Specify the path in which this package is shared by many other\n    packages. When it's unset or blank, it means the package isn't\n    shared. Otherwise, it shared by many packages. Recipe will return\n    an empty list so that buildout will not uninstall the package when\n    uninstalling part.\n\n    In share mode, ``promises`` should be set so that recipe can tell\n    whether the package is installed. Otherwise nohting to do.\n\n    If ``share`` is not empty, ``location`` will be set to value of\n    ``share``, and remove trailing '/'. So in case ``share`` is '/',\n    ``location`` will be set to blank. Thus any reference like\n    \"${part:location}/bin\" in other parts will get the correct value.\n\n    This option is experiment now. Recipe doesn't try to set prefix\n    with the valule of this opton in the configure or make command,\n    you should specify them accordingly by yourself.\n\n``md5sum``\n\n    MD5 checksum for the package file. If available the MD5\n    checksum of the downloaded package will be compared to this value\n    and if the values do not match the execution of the recipe will\n    fail.\n\n``make-binary``\n\n    Path to the ``make`` program. Defaults to 'make' which\n    should work on any system that has the ``make`` program available\n    in the system ``PATH``.\n\n``make-options``\n\n    Extra ``KEY=VALUE`` options included in the invocation of the ``make``\n    program. Multiple options can be given on separate lines to increase\n    readability.\n\n``make-targets``\n\n    Targets for the ``make`` command. Defaults to 'install'\n    which will be enough to install most software packages. You only\n    need to use this if you want to build alternate targets. Each\n    target must be given on a separate line.\n\n``configure-command``\n\n    Name of the configure command that will be run to generate the Makefile.\n    This defaults to ``./configure`` which is fine for packages that come with\n    a configure script. You may wish to change this when compiling packages\n    with a different set up. See the ``Compiling a Perl package`` section for\n    an example.\n\n``configure-options``\n\n    Extra options to be given to the ``configure`` script. By default\n    only the ``--prefix`` option is passed which is set to the part\n    directory. Each option must be given on a separate line.\n\n``patch-binary``\n\n    Path to the ``patch`` program. Defaults to 'patch' which should\n    work on any system that has the ``patch`` program available in the\n    system ``PATH``.\n\n``patch-options``\n\n    Options passed to the ``patch`` program. Defaults to ``-p0``.\n\n``patches``\n\n    List of patch files to the applied to the extracted source. Each\n    file should be given on a separate line.\n\n.. _Python hook scripts:\n\n``pre-configure-hook``\n\n    Custom python script that will be executed before running the\n    ``configure`` script. The format of the options is::\n\n        /path/to/the/module.py:name_of_callable\n        url:name_of_callable\n        url#md5sum:name_of_callable\n\n    where the first part is a filesystem path or url to the python\n    module and the second part is the name of the callable in the\n    module that will be called.  The callable will be passed three\n    parameters in the following order:\n\n        1. The ``options`` dictionary from the recipe.\n\n        2. The global ``buildout`` dictionary.\n\n        3. A dictionary containing the current ``os.environ`` augmented with\n           the part specific overrides.\n\n    The callable is not expected to return anything.\n\n    .. note:: The ``os.environ`` is not modified so if the hook script is\n              interested in the environment variable overrides defined for the\n              part it needs to read them from the dictionary that is passed in\n              as the third parameter instead of accessing ``os.environ``\n              directly.\n\n``pre-make-hook``\n\n    Custom python script that will be executed before running\n    ``make``. The format and semantics are the same as with the\n    ``pre-configure-hook`` option.\n\n``post-make-hook``\n\n    Custom python script that will be executed after running\n    ``make``. The format and semantics are the same as with the\n    ``pre-configure-hook`` option.\n\n.. hook shell command:\n\n``pre-configure``\n\n    Shell command that will be executed before running ``configure``\n    script. It takes the same effect as ``pre-configure-hook`` option\n    except it's shell command.\n\n``pre-build``\n\n    Shell command that will be executed before running ``make``. It\n    takes the same effect as ``pre-make-hook`` option except it's\n    shell command.\n\n``pre-install``\n\n    Shell command that will be executed before running ``make``\n    install.\n\n``post-install``\n\n    Shell command that will be executed after running ``make``. It\n    takes the same effect as ``post-make-hook`` option except it's\n    shell command.\n\n``keep-compile-dir``\n\n    Switch to optionally keep the temporary directory where the\n    package was compiled. This is mostly useful for other recipes that\n    use this recipe to compile a software but wish to do some\n    additional steps not handled by this recipe. The location of the\n    compile directory is stored in ``options['compile-directory']``.\n    Accepted values are ``true`` or ``false``, defaults to ``false``.\n\n``promises``\n\n   List the pathes and files should be existed after install part. The\n   file or path must be absolute path. One line one item\n\n   If any item doesn't exist, the recipe shows a warning message. The\n   default value is empty.\n\n``dependencies``\n\n   List all the depended parts:\n\n   dependencies = part1 part2 ...\n\n   All the dependent parts will be installed before this part, besides\n   the changes in any dependent parts will trigger to reinstall\n   current part.\n\n``environment-section``\n\n    Name of a section that provides environment variables that will be used to\n    augment the variables read from ``os.environ`` before executing the\n    recipe.\n\n    This recipe does not modify ``os.environ`` directly. External commands\n    run as part of the recipe (e.g. make, configure, etc.) get an augmented\n    environment when they are forked. Python hook scripts are passed the\n    augmented as a parameter.\n\n    The values of the environment variables may contain references to other\n    existing environment variables (including themselves) in the form of\n    Python string interpolation variables using the dictionary notation. These\n    references will be expanded using values from ``os.environ``. This can be\n    used, for example, to append to the ``PATH`` variable, e.g.::\n\n        [component]\n        recipe = slapos.recipe.cmmi\n        environment-section =\n            environment\n\n        [environment]\n        PATH = %(PATH)s:${buildout:directory}/bin\n\n``environment``\n\n  A sequence of ``KEY=VALUE`` pairs separated by newlines that define\n  additional environment variables used to update ``os.environ`` before\n  executing the recipe.\n\n  The semantics of this option are the same as ``environment-section``. If\n  both ``environment-section`` and ``environment`` are provided the values from\n  the former will be overridden by the latter allowing per-part customization.\n\nThe recipe uses separated part to support custom options in different\nplatforms. These platform's part has a pattern \"part:platform\" or\n\"part:platform:arch\".\n\narch could be 'x86', 'amd64', 'ia64' ... which equals\nplatform.machine().\n\nplatform could be 'linux', 'cygwin', 'macos', 'sunos', 'freebsd',\n'netbsd', 'unixware' ... which equals a formatted sys.platform.\n\nFor example,\n\n[bzip2]\nrecipe = slapos.recipe.cmmi\n\n[bzip2:cygwin]\npatches = cygwin-bzip2-1.0.6.src.patch\n\nAll the options in the [part:platform] have high priority level.\n\nThe recipe first searches the exact match, if no found. Ignore arch\nand search again, if still found nothing. Use no platform part.\n\nAdditionally, the recipe honors the ``download-cache`` option set\nin the ``[buildout]`` section and stores the downloaded files under\nit. If the value is not set a directory called ``downloads`` will be\ncreated in the root of the buildout and the ``download-cache``\noption set accordingly.\n\nThe recipe will first check if there is a local copy of the package\nbefore downloading it from the net. Files can be shared among\ndifferent buildouts by setting the ``download-cache`` to the same\nlocation.\n\nThe recipe honors the ``prefix`` option set in the ``[buildout]``\nsection either. It implicts all the parts which recipe is\nslapos.recipe.cmmi in this buildout process will be installed in the\nsame ``prefix`` option in the ``[buildout]``. Besides, once it takes\neffects, recipe will return all the installed files in the prefix\ndirectory. The own ``prefix`` of part will disable this behaviour.\n\nIf the ``buildout`` section has a valid ``prefix`` option, the recipe\nwill add it to environmet variables as the following:\n\n  PATH=${buildout:prefix}/bin:$PATH\n  CPPFLAGS=-I${buildout:prefix} $CPPFLAGS\n  CFLAGS=-I${buildout:prefix} $CFFLAGS\n  CXXFLAGS=-I${buildout:prefix} $CXXFLAGS\n  LDFLAGS=-L${buildout:prefix}/lib\n\nBesides, the recipe changes environment variable ``TMP`` when building\nand installing, and make a corresponding directory 'tmp' in the\n``location``. This temporary directory will be removed after\ninstalling finished.\n\nExample usage\n=============\n\nWe'll use a simple tarball to demonstrate the recipe.\n\n    >>> import os.path\n    >>> src = join(os.path.dirname(__file__), 'testdata')\n    >>> ls(src)\n    - Foo-Bar-0.0.0.tar.gz\n    - haproxy-1.4.8-dummy.tar.gz\n    - package-0.0.0.tar.gz\n\nThe package contains a dummy ``configure`` script that will simply\necho the options it was called with and create a ``Makefile`` that\nwill do the same.\n\nLet's create a buildout to build and install the package.\n\n    >>> write('buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... newest = true\n    ... parts = package\n    ...\n    ... [package]\n    ... recipe = slapos.recipe.cmmi\n    ... url = file://%s/package-0.0.0.tar.gz\n    ... \"\"\" % src)\n\nThis will download, extract and build our demo package with the\ndefault build options.\n\n    >>> print(system(buildout)) #doctest: +ELLIPSIS +NORMALIZE_WHITESPACE\n    Installing package.\n    package: [ENV] TMP = /sample_buildout/parts/package/tmp\n    configure --prefix=/sample_buildout/parts/package\n    building package\n    installing package\n    ...\n    ...\n    ...\n    ...\n    <BLANKLINE>\n\nCheck option \"promises\"\n\n    >>> write('buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... newest = false\n    ... parts = packagex\n    ...\n    ... [packagex]\n    ... recipe = slapos.recipe.cmmi\n    ... url = file://%s/package-0.0.0.tar.gz\n    ... promises = /usr/bin/myfoo\n    ... \"\"\" % src)\n\nThis will download, extract and build our demo package with the\ndefault build options.\n\n    >>> print system(buildout)\n    Uninstalling package.\n    Installing packagex.\n    packagex: [ENV] TMP = /sample_buildout/parts/packagex/tmp\n    configure --prefix=/sample_buildout/parts/packagex\n    building package\n    installing package\n    packagex: could not find promise \"/usr/bin/myfoo\"\n    <BLANKLINE>\n\nAs we can see the configure script was called with the ``--prefix``\noption by default followed by calls to ``make`` and ``make install``.\n\nInstalling a Perl package\n=========================\n\nThe recipe can be used to install packages that use a slightly different build\nprocess. Perl packages often come with a ``Makefile.PL`` script that performs\nthe same task as a ``configure`` script and generates a ``Makefile``.\n\nWe can build and install such a package by overriding the ``configure-command``\noption. The following example builds a Foo::Bar perl module and installs it in\na custom location within the buildout::\n\n    >>> write('buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... newest = false\n    ... parts = foobar\n    ... perl_lib = ${buildout:directory}/perl_lib\n    ...\n    ... [foobar]\n    ... recipe = slapos.recipe.cmmi\n    ... configure-command = perl -I${buildout:perl_lib}/lib/perl5 Makefile.PL INSTALL_BASE=${buildout:perl_lib}\n    ... url = file://%s/Foo-Bar-0.0.0.tar.gz\n    ... \"\"\" % src)\n\n    >>> print(system(buildout))\n    Uninstalling packagex.\n    Installing foobar.\n    foobar: [ENV] TMP = /sample_buildout/parts/foobar/tmp\n    building package\n    installing package\n\n.. _Installing a package without an autoconf like system:\n\nInstalling a package without an ``autoconf`` like system\n========================================================\n\nSome packages do not use a configuration mechanism and simply provide a\n``Makefile`` for building. It is common in these cases that the build process\nis controlled entirely by direct options to ``make``. We can build such a\npackage by faking a configure command that does nothing and passing the\nappropriate options to ``make``. The ``true`` utility found in most shell\nenvironments is a good candidate for this although anything that returns a\nzero exit code would do.\n\nWe are using a dummy \"HAProxy\" package as an example of a package with only a\nMakefile and using explicit ``make`` options to control the build process.\n\n    >>> write('buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... newest = false\n    ... parts = haproxy\n    ...\n    ... [haproxy]\n    ... recipe = slapos.recipe.cmmi\n    ... configure-command = true\n    ... make-options =\n    ...     TARGET=linux26\n    ...     CPU=i686\n    ...     USE_PCRE=1\n    ... url = file://%s/haproxy-1.4.8-dummy.tar.gz\n    ... \"\"\" % src)\n\n    >>> print(system(buildout))\n    Uninstalling foobar.\n    Installing haproxy.\n    haproxy: [ENV] TMP = /sample_buildout/parts/haproxy/tmp\n    Building HAProxy 1.4.8 (dummy package)\n    TARGET: linux26\n    CPU: i686\n    USE_PCRE: 1\n    Installing haproxy\n\nInstalling checkouts\n====================\n\nSometimes instead of downloading and building an existing tarball we need to\nwork with code that is already available on the filesystem, for example an SVN\ncheckout.\n\nInstead of providing the ``url`` option we will provide a ``path`` option to\nthe directory containing the source code.\n\nLet's demonstrate this by first unpacking our test package to the filesystem\nand building that.\n\n    >>> checkout_dir = tmpdir('checkout')\n    >>> import setuptools.archive_util\n    >>> setuptools.archive_util.unpack_archive('%s/package-0.0.0.tar.gz' % src,\n    ...                                        checkout_dir)\n    >>> ls(checkout_dir)\n    d package-0.0.0\n\n    >>> write('buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... newest = false\n    ... parts = package\n    ...\n    ... [package]\n    ... recipe = slapos.recipe.cmmi\n    ... path = %s/package-0.0.0\n    ... \"\"\" % checkout_dir)\n\n    >>> print(system(buildout))\n    Uninstalling haproxy.\n    Installing package.\n    package: [ENV] TMP = /sample_buildout/parts/package/tmp\n    package: Using local source directory: /checkout/package-0.0.0\n    configure --prefix=/sample_buildout/parts/package\n    building package\n    installing package\n\nSince using the ``path`` implies that the source code has been acquired\noutside of the control of the recipe also the responsibility of managing it is\noutside of the recipe.\n\nDepending on the software you may need to manually run ``make clean`` etc.\nbetween buildout runs if you make changes to the code. Also, the\n``keep-compile-dir`` has no effect when ``path`` is used.\n\n\nAdvanced configuration\n======================\n\nThe above options are enough to build most packages. However, in some cases it\nis not enough and we need to control the build process more. Let's try again\nwith a new buildout and provide more options.\n\n    >>> write('buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... newest = false\n    ... parts = package\n    ...\n    ... [build-environment]\n    ... CFLAGS = -I/sw/include\n    ... LDFLAGS = -I/sw/lib\n    ...\n    ... [package]\n    ... recipe = slapos.recipe.cmmi\n    ... url = file://%(src)s/package-0.0.0.tar.gz\n    ... md5sum = 6b94295c042a91ea3203857326bc9209\n    ... prefix = /somewhere/else\n    ... environment-section = build-environment\n    ... environment =\n    ...     LDFLAGS=-L/sw/lib -L/some/extra/lib\n    ... configure-options =\n    ...     --with-threads\n    ...     --without-foobar\n    ... make-targets =\n    ...     install\n    ...     install-lib\n    ... patches =\n    ...     patches/configure.patch\n    ...     patches/Makefile.dist.patch\n    ... \"\"\" % dict(src=src))\n\nThis configuration uses custom configure options, an environment section,\nper-part customization to the environment, custom prefix, multiple make\ntargets and also patches the source code before the scripts are run.\n\n    >>> print(system(buildout))\n    Uninstalling package.\n    Installing package.\n    package: [ENV] CFLAGS = -I/sw/include\n    package: [ENV] LDFLAGS = -L/sw/lib -L/some/extra/lib\n    package: [ENV] TMP = /sample_buildout/parts/package/tmp\n    package: Applying patches\n    patching file configure\n    patching file Makefile.dist\n    patched-configure --prefix=/somewhere/else --with-threads --without-foobar\n    building patched package\n    installing patched package\n    installing patched package-lib\n    Unused options for package: 'md5sum'.\n    <BLANKLINE>\n\nCustomizing the build process\n=============================\n\nSometimes even the above is not enough and you need to be able to control the\nprocess in even more detail. One such use case would be to perform dynamic\nsubstitutions on the source code (possible based on information from the\nbuildout) which cannot be done with static patches or to simply run arbitrary\ncommands.\n\nThe recipe allows you to write custom python scripts that hook into the build\nprocess. You can define a script to be run:\n\n - before the configure script is executed (pre-configure-hook)\n - before the make process is executed (pre-make-hook)\n - after the make process is finished (post-make-hook)\n\nEach option needs to contain the following information\n\n  /full/path/to/the/python/module.py:name_of_callable\n\nwhere the callable object (here name_of_callable) is expected to take three\nparameters:\n\n    1. The ``options`` dictionary from the recipe.\n\n    2. The global ``buildout`` dictionary.\n\n    3. A dictionary containing the current ``os.environ`` augmented with\n       the part specific overrides.\n\nThese parameters should provide the callable all the necessary information to\nperform any part specific customization to the build process.\n\nLet's create a simple python script to demonstrate the functionality. You can\nnaturally have separate modules for each hook or simply use just one or two\nhooks. Here we use just a single module.\n\n    >>> hooks = tmpdir('hooks')\n    >>> write(hooks, 'customhandlers.py',\n    ... \"\"\"\n    ... import logging\n    ... log = logging.getLogger('hook')\n    ...\n    ... def preconfigure(options, buildout, environment):\n    ...     log.info('This is pre-configure-hook!')\n    ...\n    ... def premake(options, buildout, environment):\n    ...     log.info('This is pre-make-hook!')\n    ...\n    ... def postmake(options, buildout, environment):\n    ...     log.info('This is post-make-hook!')\n    ...\n    ... \"\"\")\n\nand a new buildout to try it out\n\n    >>> write('buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... newest = false\n    ... parts = package\n    ...\n    ... [package]\n    ... recipe = slapos.recipe.cmmi\n    ... url = file://%(src)s/package-0.0.0.tar.gz\n    ... pre-configure-hook = %(module)s:preconfigure\n    ... pre-make-hook = %(module)s:premake\n    ... post-make-hook = %(module)s:postmake\n    ... \"\"\" % dict(src=src, module='%s/customhandlers.py' % hooks))\n\n    >>> print(system(buildout))\n    Uninstalling package.\n    Installing package.\n    package: [ENV] TMP = /sample_buildout/parts/package/tmp\n    package: Executing pre-configure-hook\n    hook: This is pre-configure-hook!\n    configure --prefix=/sample_buildout/parts/package\n    package: Executing pre-make-hook\n    hook: This is pre-make-hook!\n    building package\n    installing package\n    package: Executing post-make-hook\n    hook: This is post-make-hook!\n\nIf you prefer to use shell script, then try these options:\n  pre-configure\n  pre-build\n  pre-install\n  post-install\n\nLet's create a buildout to use these options.\n\n    >>> write('buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... newest = false\n    ... parts = package\n    ...\n    ... [package]\n    ... recipe = slapos.recipe.cmmi\n    ... url = file://%s/package-0.0.0.tar.gz\n    ... pre-configure = echo \"Configure part: ${:_buildout_section_name_}\"\n    ... pre-build = echo \"OH OH OH\" > a.txt\n    ... pre-install = cat a.txt\n    ... post-install = rm -f a.txt && echo \"Finished.\"\n    ... \"\"\" % src)\n\nThis will run pre-configure, pre-build, pre-install, post-install as\nshell command in the corresponding stage.\n\n    >>> print system(buildout)\n    Uninstalling package.\n    Installing package.\n    package: [ENV] TMP = /sample_buildout/parts/package/tmp\n    package: Executing pre-configure\n    Configure part: package\n    configure --prefix=/sample_buildout/parts/package\n    package: Executing pre-build\n    building package\n    package: Executing pre-install\n    OH OH OH\n    installing package\n    package: Executing post-install\n    Finished.\n\nBuilding in multi-platforms\n===========================\n\nThe recipe can specify build options for each platform. For example,\n\n    >>> write('buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... newest = false\n    ... parts = package\n    ...\n    ... [package]\n    ... recipe = slapos.recipe.cmmi\n    ... url = file://%s/package-0.0.0.tar.gz\n    ... pre-configure = echo \"Configure in common platform\"\n    ... post-install = echo \"Finished.\"\n    ...\n    ... [package:cygwin]\n    ... pre-configure = echo \"Configure in the CYGWIN platform\"\n    ... pre-install = echo \"Installing in the CYGWIN\"\n    ... post-install = echo -n \"CYGWIN \" && ${package:post-install}\n    ... \"\"\" % src)\n\nIn the linux, the recipe gets the options from part 'package', there\nare only ``pre-configure`` and ``post-install``. the output will be\n\n    #>>> print system(buildout)\n    Uninstalling package.\n    Installing package.\n    package: [ENV] TMP = /sample_buildout/parts/package/tmp\n    package: Executing pre-configure\n    Configure part: Configure in common platform\n    configure --prefix=/sample_buildout/parts/package\n    building package\n    installing package\n    package: Executing post-install\n    Finished.\n\nIn the cygwin, the recipe merges the options in the parts 'package'\nand 'package:cygwin'.\n\nUnion prefix\n============\n\nIf the recipe finds ``prefix`` option in the section buildout, it will\n\n  * First, use this ``prefix`` as configure prefix, if\n    ``configure-command`` isn't set in the part, or ``make-binary``\n    equals 'make' and ``make-target`` includes pattern '\\s+install.*'\n\n  * Second, return all the new installed files in the prefix when the\n    recipe returns after intall.\n\n  * Finally, change some environment variables(See first section).\n\nLet's see what happens when set prefix in the buildout section:\n\n    >>> write('buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... newest = false\n    ... parts = package\n    ... prefix = ${buildout:directory}/mylocal\n    ...\n    ... [package]\n    ... recipe = slapos.recipe.cmmi\n    ... url = file://%s/package-0.0.0.tar.gz\n    ... pre-configure = mkdir -p \"${buildout:prefix}\"\n    ... \"\"\" % src)\n\n    >>> print system(buildout)\n    Uninstalling package.\n    Installing package.\n    package: [ENV] TMP = /sample_buildout/parts/package/tmp\n    package: Executing pre-configure\n    configure --prefix=/sample_buildout/mylocal\n    building package\n    installing package\n    <BLANKLINE>\n\nLook these environment variables and prefix's value, you know what's\nthe differences.\n\nIf part has its own ``prefix``, it will disable above behavious. For\nexample,\n\n    >>> write('buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... newest = false\n    ... parts = package\n    ... prefix = ${buildout:directory}/mylocal\n    ...\n    ... [package]\n    ... recipe = slapos.recipe.cmmi\n    ... prefix = ${buildout:parts-directory}/package\n    ... url = file://%s/package-0.0.0.tar.gz\n    ... pre-configure = rm -rf \"${buildout:prefix}\"\n    ... post-install = test -d \"${buildout:prefix}\" || echo \"None\"\n    ... \"\"\" % src)\n\n    >>> print system(buildout)\n    Uninstalling package.\n    Installing package.\n    package: [ENV] TMP = /sample_buildout/parts/package/tmp\n    package: Executing pre-configure\n    configure --prefix=/sample_buildout/parts/package\n    building package\n    installing package\n    package: Executing post-install\n    None\n\nThen no extra environment variables such as CFLAGS etc., and no\n${buildout:prefix} directory is created.\n\nThe following example shows how to install package, package-2 in one\nprefix:\n\n    >>> write('buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... newest = false\n    ... parts = package package-2\n    ... prefix = ${buildout:directory}/mylocal\n    ...\n    ... [package]\n    ... recipe = slapos.recipe.cmmi\n    ... url = file://%s/package-0.0.0.tar.gz\n    ... pre-install = sleep 2; mkdir -p \"${buildout:prefix}\" ; echo x >\"${buildout:prefix}/a.txt\"\n    ... [package-2]\n    ... recipe = slapos.recipe.cmmi\n    ... url = file://%s/package-0.0.0.tar.gz\n    ... pre-install = sleep 2; mkdir -p \"${buildout:prefix}\" ; echo x >\"${buildout:prefix}/b.txt\"; echo\n    ... \"\"\" % (src, src))\n\n    >>> print system(buildout)\n    Uninstalling package.\n    Installing package.\n    package: [ENV] TMP = /sample_buildout/parts/package/tmp\n    configure --prefix=/sample_buildout/mylocal\n    building package\n    package: Executing pre-install\n    installing package\n    Installing package-2.\n    package-2: [ENV] TMP = /sample_buildout/parts/package-2/tmp\n    configure --prefix=/sample_buildout/mylocal\n    building package\n    package-2: Executing pre-install\n    <BLANKLINE>\n    installing package\n    <BLANKLINE>\n \n    >>> ls('mylocal')\n    - a.txt\n    - b.txt\n\nNext we unintall package-2, it should only remove file b.txt (which seems broken currently\nas nothing it is removing):\n\n    >>> write('buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... newest = false\n    ... parts = package\n    ... prefix = ${buildout:directory}/mylocal\n    ...\n    ... [package]\n    ... recipe = slapos.recipe.cmmi\n    ... url = file://%s/package-0.0.0.tar.gz\n    ... pre-install = sleep 2; mkdir -p \"${buildout:prefix}\" ; echo x >\"${buildout:prefix}/a.txt\"\n    ... \"\"\" % src)\n\n    >>> print system(buildout)\n    Uninstalling package-2.\n    Updating package.\n\n    >>> ls('mylocal')\n    - a.txt\n    - b.txt\n\nMagic prefix\n============\n\nIf configure-command is set, the recipe wouldn't insert \"--prefix\"\ninto configure-options. Then it checks whether both of make-binary and\nmake-targets aren't set, if so, string \"prefix=xxx\" will be appended\nin the make-targets. xxx is the final prefix of this recipe. We call\nit Magic Prefix.\n\nIn these options magic prefix can be represented by %(prefix)s:\n\n    ``onfigure-command`` ``configure-options``\n    ``make-binary`` ``make-options`` ``make-targets``\n    ``pre-configure`` ``pre-build`` ``pre-install`` ``post-install``\n\nFor example::\n\n  [bzip2]\n  post-install = rm %(prefix)s/*.h\n\nThe other part can refer to magic prefix of this part by\n${part:prefix}, it will return the magic prefix, other than literal\nvalue in the part section. For example,\n\n    >>> write('buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... newest = false\n    ... parts = package package-2\n    ... prefix = /mytemp\n    ...\n    ... [package]\n    ... recipe = slapos.recipe.cmmi\n    ... url = file://%s/package-0.0.0.tar.gz\n    ... configure-command = true\n    ... make-binary = true\n    ...\n    ... [package-2]\n    ... recipe = slapos.recipe.cmmi\n    ... url = file://%s/package-0.0.0.tar.gz\n    ... configure-command = true\n    ... make-binary = true\n    ... post-install = echo package magic prefix is ${package:prefix}\n    ... \"\"\" % (src, src))\n\n    >>> print system(buildout)\n    Uninstalling package.\n    Installing package.\n    package: [ENV] TMP = /sample_buildout/parts/package/tmp\n    Installing package-2.\n    package-2: [ENV] TMP = /sample_buildout/parts/package-2/tmp\n    package-2: Executing post-install\n    package magic prefix is /mytemp\n    <BLANKLINE>\n    \nHere it's another sample, we change Makefile before installing so it\ncan display \"prefix\" value in the stdout.\n\n    >>> write('buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... newest = false\n    ... parts = package\n    ...\n    ... [package]\n    ... recipe = slapos.recipe.cmmi\n    ... url = file://%s/package-0.0.0.tar.gz\n    ... configure-command = ./configure\n    ... pre-install = sed -i -e \"s/installing package/installing package at \\$\\$prefix /g\" Makefile\n    ... \"\"\" % src)\n\n    >>> print system(buildout)\n    Uninstalling package-2.\n    Uninstalling package.\n    Installing package.\n    package: [ENV] TMP = /sample_buildout/parts/package/tmp\n    configure\n    building package\n    package: Executing pre-install\n    installing package at /sample_buildout/parts/package\n\nYou even can include pattern %(prefix)s in this option, it will be\nreplaced with the recipe final prefix.\n\n    >>> write('buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... newest = false\n    ... parts = package\n    ...\n    ... [package]\n    ... recipe = slapos.recipe.cmmi\n    ... url = file://%s/package-0.0.0.tar.gz\n    ... configure-command = ./configure\n    ... make-targets = install-lib prefix=%%(prefix)s\n    ... pre-install = sed -i -e \"s/installing package/installing package at \\$\\$prefix /g\" Makefile\n    ... \"\"\" % src)\n\n    >>> print system(buildout)\n    Uninstalling package.\n    Installing package.\n    package: [ENV] TMP = /sample_buildout/parts/package/tmp\n    configure\n    building package\n    package: Executing pre-install\n    installing package at /sample_buildout/parts/package -lib\n\nExtra part dependencies\n=======================\n\nThe   recipe  will   treat  all   the   parts  list   in  the   option\n``dependencies`` as dependent parts.  zc.buildout will install all the\ndependent  parts before  install this  part. For  example,\n\n    >>> write('buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... newest = false\n    ... parts = package\n    ...\n    ... [package]\n    ... recipe = slapos.recipe.cmmi\n    ... dependencies = package-2\n    ... url = file://%s/package-0.0.0.tar.gz\n    ...\n    ... [package-2]\n    ... recipe = slapos.recipe.cmmi\n    ... url = file://%s/package-0.0.0.tar.gz\n    ... \"\"\" % (src, src))\n\nHere \"package-2\" will be installed first, because it's a denpend part\nof \"package\":\n\n    >>> print system(buildout)\n    Uninstalling package.\n    Installing package-2.\n    package-2: [ENV] TMP = /sample_buildout/parts/package-2/tmp\n    configure --prefix=/sample_buildout/parts/package-2\n    building package\n    installing package\n    Installing package.\n    package: [ENV] TMP = /sample_buildout/parts/package/tmp\n    configure --prefix=/sample_buildout/parts/package\n    building package\n    installing package\n\nNow let's add a new option for \"package-2\",\n\n    >>> write('buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... newest = false\n    ... parts = package\n    ...\n    ... [package]\n    ... recipe = slapos.recipe.cmmi\n    ... dependencies = package-2\n    ... url = file://%s/package-0.0.0.tar.gz\n    ...\n    ... [package-2]\n    ... recipe = slapos.recipe.cmmi\n    ... url = file://%s/package-0.0.0.tar.gz\n    ... configure-command = ./configure\n    ... \"\"\" % (src, src))\n\nLook, \"package\" is reinstalled either:\n\n    >>> print system(buildout)\n    Uninstalling package.\n    Uninstalling package-2.\n    Installing package-2.\n    package-2: [ENV] TMP = /sample_buildout/parts/package-2/tmp\n    configure\n    building package\n    installing package\n    Installing package.\n    package: [ENV] TMP = /sample_buildout/parts/package/tmp\n    configure --prefix=/sample_buildout/parts/package\n    building package\n    installing package\n\nInstall share package\n=====================\n\nUse option ``share`` to install a share pacakge.\n    >>> write('buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... newest = false\n    ... parts = package\n    ...\n    ... [package]\n    ... recipe = slapos.recipe.cmmi\n    ... url = file://%s/package-0.0.0.tar.gz\n    ... share = /usr/local\n    ... promises = ${:share}/bin/mypackage.exe\n    ... \"\"\" % (src,))\n\n    >>> print system(buildout)\n    Uninstalling package.\n    Uninstalling package-2.\n    Installing package.\n    package: Checking whether package is installed at share path: /usr/local\n    package: could not find promise \"/usr/local/bin/mypackage.exe\"\n    package: [ENV] TMP = /sample_buildout/parts/package/tmp\n    configure --prefix=/usr/local\n    building package\n    installing package\n    package: could not find promise \"/usr/local/bin/mypackage.exe\"\n\nDo nothing if one package has been installed.\n    >>> write('buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... newest = false\n    ... parts = package\n    ...\n    ... [package]\n    ... recipe = slapos.recipe.cmmi\n    ... url = file://%s/package-0.0.0.tar.gz\n    ... share = /usr/local/bin\n    ... promises =\n    ... \"\"\" % (src,))\n\n    >>> print system(buildout)\n    Uninstalling package.\n    Installing package.\n    package: Checking whether package is installed at share path: /usr/local/bin\n    package: This shared package has been installed by other package\n\nFor even more specific needs you can write your own recipe that uses\n``slapos.recipe.cmmi`` and set the ``keep-compile-dir`` option to ``true``.\nYou can then continue from where this recipe finished by reading the location\nof the compile directory from ``options['compile-directory']`` from your own\nrecipe.\n\n\nContributors\n============\n\n* Kai Lautaportti (dokai), Author\n* C\u00e9dric de Saint Martin (desaintmartin)\n* Marc Abramowitz (msabramo)\n* Nicolas Dumazet (nicdumz)\n* Guy Rozendorn (grzn)\n* Marco Mariani (mmariani)\n* galpin\n\nDownload\n========",
    "docs_url": null,
    "download_url": "UNKNOWN",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "https://lab.nexedi.com/nexedi/slapos.recipe.cmmi",
    "keywords": "development buildout recipe",
    "license": "BSD",
    "maintainer": null,
    "maintainer_email": null,
    "name": "slapos.recipe.cmmi",
    "platform": "UNKNOWN",
    "project_url": "https://pypi.org/project/slapos.recipe.cmmi/",
    "release_url": "https://pypi.org/project/slapos.recipe.cmmi/0.7/",
    "requires_python": null,
    "summary": "zc.buildout recipe for compiling and installing source distributions.",
    "version": "0.7"
  },
  "releases": {
    "0.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "ded57ba367dffa91e8b59015761be1c5",
          "sha256": "85ef3084a38be76a08a1fc93bed3fe0a29b85a1a7fb23147c6474323ce519540"
        },
        "downloads": 2548,
        "filename": "slapos.recipe.cmmi-0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "ded57ba367dffa91e8b59015761be1c5",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 45052,
        "upload_time": "2013-04-12T16:10:04",
        "url": "https://files.pythonhosted.org/packages/c8/6b/7f943ba52edf442ea78440e4c8866dc1befa97c6e043bec38cef0c3928c4/slapos.recipe.cmmi-0.1.tar.gz"
      }
    ],
    "0.1.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "f7ef1bff9202b06bd8eefbc73f374528",
          "sha256": "0a83ffd5f16a2258f224f7be235eed8cf4a4d0d18519abdb2d9414c9d857199d"
        },
        "downloads": 2786,
        "filename": "slapos.recipe.cmmi-0.1.1.tar.gz",
        "has_sig": false,
        "md5_digest": "f7ef1bff9202b06bd8eefbc73f374528",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 45346,
        "upload_time": "2013-05-02T08:56:15",
        "url": "https://files.pythonhosted.org/packages/1f/b8/8b281afaf548f0c74083816e3410be0ffe33e344f21d55fb7d8078316056/slapos.recipe.cmmi-0.1.1.tar.gz"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "30ef08e87724ad53d1b283c1e99e61ae",
          "sha256": "3b8fe5753144422270029c805942814f0f6986b5c5ea0e8bc8adca36b62e3e2e"
        },
        "downloads": 3748,
        "filename": "slapos.recipe.cmmi-0.2.tar.gz",
        "has_sig": false,
        "md5_digest": "30ef08e87724ad53d1b283c1e99e61ae",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 47756,
        "upload_time": "2013-11-07T16:25:56",
        "url": "https://files.pythonhosted.org/packages/fc/0b/837e67dd0cdd4b615ffaf7342623084cfd4c64014720ef15e0d0ea13bd35/slapos.recipe.cmmi-0.2.tar.gz"
      }
    ],
    "0.4": [
      {
        "comment_text": "",
        "digests": {
          "md5": "e7f3e8cb73f229011b26e8be64840764",
          "sha256": "931a477f8916a60df1f88ce73286932ca97b78ca922a0179006944f7b519e41c"
        },
        "downloads": 16,
        "filename": "slapos.recipe.cmmi-0.4.tar.gz",
        "has_sig": false,
        "md5_digest": "e7f3e8cb73f229011b26e8be64840764",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 52286,
        "upload_time": "2017-03-08T16:06:51",
        "url": "https://files.pythonhosted.org/packages/e7/74/04c052d17c18f33307cdf84c56b4454dcddbb411b772f49fc7c764c5ecd8/slapos.recipe.cmmi-0.4.tar.gz"
      }
    ],
    "0.5": [
      {
        "comment_text": "",
        "digests": {
          "md5": "cc71eeadf5d2ea4044af5d644529cdf6",
          "sha256": "ce6f8ca57dae40bad8d9168adaf4ff79a87a978e1cc92b7c251ce5efcdbda080"
        },
        "downloads": 183,
        "filename": "slapos.recipe.cmmi-0.5.tar.gz",
        "has_sig": false,
        "md5_digest": "cc71eeadf5d2ea4044af5d644529cdf6",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 60278,
        "upload_time": "2017-04-07T08:41:26",
        "url": "https://files.pythonhosted.org/packages/ef/7c/69ee0b9c2fee0842650073c1af97f99a571d6dd8a57c3d63306a02c763f6/slapos.recipe.cmmi-0.5.tar.gz"
      }
    ],
    "0.6": [
      {
        "comment_text": "",
        "digests": {
          "md5": "4c5b3f5616b13621106bc194b707b281",
          "sha256": "f9e9af85a63e36b2ab0dd0cf7073731108c64c8b1136ca48bca0c4b4dd8c02a0"
        },
        "downloads": 0,
        "filename": "slapos.recipe.cmmi-0.6.tar.gz",
        "has_sig": true,
        "md5_digest": "4c5b3f5616b13621106bc194b707b281",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 38226,
        "upload_time": "2017-06-06T09:08:50",
        "url": "https://files.pythonhosted.org/packages/30/0a/384efa5d113145e9896e1ce20812e5aea9db28fc33dd7792c7ce9a4f3507/slapos.recipe.cmmi-0.6.tar.gz"
      }
    ],
    "0.7": [
      {
        "comment_text": "",
        "digests": {
          "md5": "dc0ff633f1535b19ad4c6cc37f77262b",
          "sha256": "ca7a1ae56fc56e3268c3f247ea9802e326668df88b37d13f70c7bf4eab193e62"
        },
        "downloads": 0,
        "filename": "slapos.recipe.cmmi-0.7.tar.gz",
        "has_sig": true,
        "md5_digest": "dc0ff633f1535b19ad4c6cc37f77262b",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 38439,
        "upload_time": "2017-06-06T09:25:51",
        "url": "https://files.pythonhosted.org/packages/94/75/05025b3351e5f36b26cad23d7e70bf9660462b38f6c3d9e126e2d5a83855/slapos.recipe.cmmi-0.7.tar.gz"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "dc0ff633f1535b19ad4c6cc37f77262b",
        "sha256": "ca7a1ae56fc56e3268c3f247ea9802e326668df88b37d13f70c7bf4eab193e62"
      },
      "downloads": 0,
      "filename": "slapos.recipe.cmmi-0.7.tar.gz",
      "has_sig": true,
      "md5_digest": "dc0ff633f1535b19ad4c6cc37f77262b",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 38439,
      "upload_time": "2017-06-06T09:25:51",
      "url": "https://files.pythonhosted.org/packages/94/75/05025b3351e5f36b26cad23d7e70bf9660462b38f6c3d9e126e2d5a83855/slapos.recipe.cmmi-0.7.tar.gz"
    }
  ]
}