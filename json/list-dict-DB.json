{
  "info": {
    "author": "Justin Winokur",
    "author_email": "Jwink3101@gmail.com",
    "bugtrack_url": null,
    "classifiers": [],
    "description": "# list_dict_db\n\nA simple *in memory* database like object. It is very simple and designed for\nsmall to medium databases which can exist purely in memory. It intended for situations where query speed is prioritized over memory usage and instantiation time.\n\nI built it because I was querying a list of dictionaries by multiple keys *inside* of a loop. That cause an O(N^2) complexity and made my moderately-sized 30,000 item list intractable!\n\nIt is designed to replace iterating over list of dictionary items.\n\nThere are other solutions out there that are more traditionally database focused such as [TinyDB][tinydb], [buzhug][buzhug], etc. \n\nIt passes all tests (with **100% test coverage**) on Python 2.7 and Python 3.5\n\nI am not a database expert. This simple met my needs.\n\n## Usage:\n\nFor more full example usage, including the flexible query methods, see the tests.\n\nConsider the following: (please do not argue accuracy. It is an example)\n\n    items = [\n        {'first':'John', 'last':'Lennon','born':1940,'role':'guitar'},\n        {'first':'Paul', 'last':'McCartney','born':1942,'role':'bass'},\n        {'first':'George','last':'Harrison','born':1943,'role':'guitar'},\n        {'first':'Ringo','last':'Starr','born':1940,'role':'drums'},\n        {'first':'George','last':'Martin','born':1926,'role':'producer'}\n    ]\n\nIf we want to find all members of The Beatles who's name is \"George Harrison\", we could do the following:\n\n    [item for item in items if item['first']=='George' and item['last']=='Harrison']\n\nWhich is an O(N) operation. If we are only doing it once, it is fine, but if we are doing it multiple times (especially in loops) it can cause a major bottleneck.\n\nInstead do:\n\n    from list_dict_DB import list_dict_DB\n    DB = list_dict_DB(items) # Will index them all\n\n    DB.query(first='George',last='Harrison')\n\nThe creation is O(N) but the query is O(1) and can be done many times.\n\n## Queries\n\nThere are a few different methods to perform queries. It is designed to be flexible and allow for easy construction\n\n### Basic Queries\n\nBasic queries only test equality with an `and` boolean relationship.\n\nFor example, to query band the example DB for band members with the first name 'George', you can do either of the following:\n\n    DB.query(first='George')\n    DB.query({'first':'George'})\n    DB[{'first':'George'}]      # item indecies can be queries or a number\n    DB(first='George')          # Directly calling the object is a query()\n\nTo get George Harrison, you can do the following:\n\n    DB.query(first='George',last='Harrison')\n\nOr again, you can use a dictionary or mix and match. For example:\n\n    DB.query({'first':'George'},last='Harrison')\n\nAgain, you are restricted to equality and AND relationships.\n\n### Advanced Queries\n\nAdvanced queries are a bit more complex. The require a `Qobj`. Note, a `Qobj` expires if the DB index changes (`update()`, `remove()`, `add()`, `add_attribute()`, and `reindex()`)\n\nAn advanced query is constructed as follows. **NOTE**: Python gets easily messed up with assignment. Use parentheses to separate statements!\n\nFor example, to query all elements with the first name George and the last name **not** Martin, you can do:\n\n    Q = DB.Qobj() # Instantiate it with the DB. DB.Q() will also work\n    DB.query( (Q.first=='George') & (Q.last != 'Martin') )\n\nOr\n\n    DB.query( (DB.Q().first=='George') & (DB.Q().last != 'Martin') )\n\nNotice:\n\n* Use of parentheses. The queries must be separated\n* We are checking equality so `==` and `!=` are used\n    * You can also negate with `~` but again, be careful and deliberate about parentheses\n* We instantiate the `Q` object with the DB. If the DB index is changed, the `Q` object will not be allowed to run as a precaution.\n* We used `&` for `and` and `|` for `or`\n* `<`, `<=`, `>`, `>=`, and filters are supported but these are O(N) opperations.\n\nYou can also do more advanced boolean logic such as:\n\n    DB.query( ~( (Q.role=='guitar') | (Q.role=='drums')))\n\n#### Filters\n\nA filter allows for more advanced queries of the data but, as noted below, are O(N) (as with `<`, `<=`, `>`, `>=`).\n\nFor example, to perform a simple equality, the following return the same entry. But do note that the equality version is *much faster*.\n\nEdge Case: If an attribute's name is 'filter', the filter method may be accessed through `_filter`.\n\n    # Traditional lookup:\n    DB.query(Q.first == 'George') # equality is O(1)\n\n    # Filter lookup\n    filt = lambda item: True if item['first'] == 'George' else False\n    DB.query(Q.filter(filt))\n\nThe are flexible for more advanced queries\n\n#### WARNING about speed\n\nSome of the major speed gains in this are due to the use of dictionaries and sets which are O(1) complexity. \n\nQueries with `<`, `<=`, `>`, `>=`, and `filters` are O(N) opperations and should be avoided if possible.\n\nThe time complexity of a query will depend on the number of items that match any part of the query.\n\n## Loading and Saving (Dumping)\n\nThere is *intentionally* no built in way to dump these as they are intended to be *in-memory*. Of course, the a good way to save or load is as follows:\n\nDump:\n\n    import json\n    with open('DB.json','w') as F:\n        json.dump(DB.items(),F)\n\nLoad:\n\n    from list_dict_DB import list_dict_DB\n    import json\n    with open('DB.json') as F:\n        DB = list_dict_DB(json.load(F))\n\n\n## Lists:\n\nAll attributes must be hashable. The only exception are lists in which case the list is expanded for each item. For example, an entry may be:\n\n    {'first':'George','last':'Harrison','born':1943,'role':['guitar','sitar']}\n\nand \n\n    DB.query(role='sitar')\n\nwill return him.\n\n## Benchmarks & Complexity Testing\n\nI compared the creating and querying a large database with the following methods. Note that some cache results so I recreated and re-queried from scratch. In practice, even caching the results does not help much if the queries change.\n\n* `list_dict_DB`\n* simple looping with a *copied* list (*not* `deepcopy` though)\n* [Pandas][pandas] dataframe (0.16.2)\n* [TinyDB][tinydb] (3.2.2) with in-memory storage\n* [dataset][dataset] (0.6.0) with slite3 in-memory storage\n    * dataset is a wrapper to [SQLAlchemy][sqla] that (in my words) provides a noSQL interface to SQL.\n\nI tested on my MacBook Pro (Retina, 15-inch, Mid 2014) laptop with 2.8 GHz i7 and 16 gb of ram using Python 2.7.9.\n\nThe following figure is the time to build and query the resulting data object. Note that for TinyDB, the object was deleted between tests since it caches queries\n\n[![benchmarks](benchmark.png)](benchmark.png)\n\n\n>From the slope of the plots, you can estimate the complexity. I just calculated from the final point. The order is O(N^{slope})\n\n| Tool           | Query slope | Create slope |\n|----------------|-------------|--------------|\n| `list_dict_DB` | 0.12        | 1.01         |\n| `loop_copy`    | 1.12        | 1.27         |\n| `pandas`       | 0.92        | 0.99         |\n| `TinyDB_mem`   | 1.04        | 1.00         |\n| `dataset_mem`  | 0.03        | 1.02         |\n\n[dataset][dataset] gives this tool a run for its money but it also has a lot more dependancies and was the slowest in creation time (though, if you use it with a file, once it is created, you do not have to recreate it again). Pandas also performs well and only starts to have the O(N) dependency creep in at larger sizes. Of course, this is a scaling analysis. When you look at actual query times, `list_dict_DB` is orders of magnitude faster!\n\nWhich tool is the best will be problem dependent, but these results make a strong argument for `list_dict_DB`\n\n## Known Issues\n\nNone at the moment.\n\nThere is 100% (!!!) test coverage. Of course that doesn't mean there aren't bugs. If you find any, please report them.\n\n## Limitations\n\n* The entire DB exists in memory\n* Serializing (dumping) is not included though is easy to do with JSON or the like. See above\n* The index used in the dictionary is itself a dictionary with keys as any value. Since these are all done as pointers to original list, the memory footprint should be small\n* This is **not** designed to be a database across many threads, processes, or instances. It is designed as a data-structure of sorts\n\n\n[pandas]:http://pandas.pydata.org/\n[dataset]:https://dataset.readthedocs.io/en/latest/\n[sqla]:http://www.sqlalchemy.org/\n[tinydb]:https://tinydb.readthedocs.io/en/latest/\n[buzhug]:http://buzhug.sourceforge.net/\n\n[^cpu]: Of course, Python really only uses one at a time for these tests\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "https://github.com/Jwink3101/list_dict_db",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "list-dict-DB",
    "platform": "",
    "project_url": "https://pypi.org/project/list-dict-DB/",
    "release_url": "https://pypi.org/project/list-dict-DB/20170909/",
    "requires_dist": [],
    "requires_python": "",
    "summary": "in memory database like object with O(1) queries",
    "version": "20170909"
  },
  "releases": {
    "20170909": [
      {
        "comment_text": "",
        "digests": {
          "md5": "a7d6ce002f5005c1fc0a74184c01c596",
          "sha256": "9e1c56179cfffc4601a5494b014a84af355a1b8e8102f80e6fa90db4ab383cd4"
        },
        "downloads": 0,
        "filename": "list_dict_DB-20170909-py2.py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "a7d6ce002f5005c1fc0a74184c01c596",
        "packagetype": "bdist_wheel",
        "python_version": "py2.py3",
        "size": 15579,
        "upload_time": "2017-09-09T18:48:10",
        "url": "https://files.pythonhosted.org/packages/d0/ce/b9908ae2c9a28b58df8a344db41528bee03a329c3f66aadbbffc9f6bba79/list_dict_DB-20170909-py2.py3-none-any.whl"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "a7d6ce002f5005c1fc0a74184c01c596",
        "sha256": "9e1c56179cfffc4601a5494b014a84af355a1b8e8102f80e6fa90db4ab383cd4"
      },
      "downloads": 0,
      "filename": "list_dict_DB-20170909-py2.py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "a7d6ce002f5005c1fc0a74184c01c596",
      "packagetype": "bdist_wheel",
      "python_version": "py2.py3",
      "size": 15579,
      "upload_time": "2017-09-09T18:48:10",
      "url": "https://files.pythonhosted.org/packages/d0/ce/b9908ae2c9a28b58df8a344db41528bee03a329c3f66aadbbffc9f6bba79/list_dict_DB-20170909-py2.py3-none-any.whl"
    }
  ]
}