{
  "info": {
    "author": "pbrod",
    "author_email": "per.andreas.brodtkorb@gmail.com",
    "bugtrack_url": "",
    "classifiers": [
      "Development Status :: 4 - Beta",
      "Environment :: Console",
      "Intended Audience :: Education",
      "Intended Audience :: Science/Research",
      "License :: OSI Approved :: BSD License",
      "Operating System :: MacOS",
      "Operating System :: Microsoft :: Windows",
      "Operating System :: OS Independent",
      "Operating System :: POSIX :: Linux",
      "Operating System :: Unix",
      "Programming Language :: Python",
      "Programming Language :: Python :: 2.7",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.3",
      "Programming Language :: Python :: 3.4",
      "Programming Language :: Python :: 3.5",
      "Topic :: Scientific/Engineering :: GIS",
      "Topic :: Scientific/Engineering :: Mathematics"
    ],
    "description": "=======\r\nnvector\r\n=======\r\n\r\n\r\n|nvector_img| |tests_img| |docs_img| |health_img| |coverage_img| |versions_img|\r\n\r\nNvector is a suite of tools written in Python to solve geographical position\r\ncalculations like:\r\n\r\n* Calculate the surface distance between two geographical positions.\r\n\r\n* Convert positions given in one reference frame into another reference frame.\r\n\r\n* Find the destination point given start point, azimuth/bearing and distance.\r\n\r\n* Find the mean position (center/midpoint) of several geographical positions.\r\n\r\n* Find the intersection between two paths.\r\n\r\n* Find the cross track distance between a path and a position.\r\n\r\n\r\nDescription\r\n===========\r\n\r\nIn this library, we represent position with an \"n-vector\",  which\r\nis the normal vector to the Earth model (the same reference ellipsoid that is\r\nused for latitude and longitude). When using n-vector, all Earth-positions are\r\ntreated equally, and there is no need to worry about singularities or\r\ndiscontinuities. An additional benefit with using n-vector is that many\r\nposition calculations can be solved with simple vector algebra\r\n(e.g. dot product and cross product).\r\n\r\nConverting between n-vector and latitude/longitude is unambiguous and easy\r\nusing the provided functions.\r\n\r\nn_E is n-vector in the program code, while in documents we use nE. E denotes\r\nan Earth-fixed coordinate frame, and it indicates that the three components of\r\nn-vector are along the three axes of E. More details about the notation and\r\nreference frames can be found here:\r\n\r\nDocumentation and code\r\n======================\r\n\r\nOfficial documentation:\r\n\r\nhttp://www.navlab.net/nvector/\r\n\r\nhttp://nvector.readthedocs.io/en/latest/\r\n\r\n*Kenneth Gade (2010):*\r\n    `A Nonsingular Horizontal Position Representation,\r\n    The Journal of Navigation, Volume 63, Issue 03, pp 395-417, July 2010.\r\n    <http://www.navlab.net/Publications/A_Nonsingular_Horizontal_Position_Representation.pdf>`_\r\n\r\n\r\nBleeding edge: https://github.com/pbrod/nvector.\r\n\r\nOfficial releases available at: http://pypi.python.org/pypi/nvector.\r\n\r\n\r\nInstallation\r\n============\r\n\r\nIf you have pip installed and are online, then simply type:\r\n\r\n    $ pip install nvector\r\n\r\nto get the lastest stable version. Using pip also has the advantage that all\r\nrequirements are automatically installed.\r\n\r\nYou can download nvector and all dependencies to a folder \"pkg\", by the following:\r\n\r\n   $ pip install --download=pkg nvector\r\n\r\nTo install the downloaded nvector, just type:\r\n\r\n   $ pip install --no-index --find-links=pkg nvector\r\n\r\n\r\nUnit tests\r\n===========\r\nTo test if the toolbox is working paste the following in an interactive\r\npython session::\r\n\r\n   import nvector as nv\r\n   nv.test(coverage=True, doctests=True)\r\n\r\n\r\nAcknowledgement\r\n===============\r\nThe `nvector package <http://pypi.python.org/pypi/nvector/>`_ for\r\n`Python <https://www.python.org/>`_ was written by Per A. Brodtkorb at\r\n`FFI (The Norwegian Defence Research Establishment) <http://www.ffi.no/en>`_\r\nbased on the `nvector toolbox <http://www.navlab.net/nvector/#download>`_ for\r\n`Matlab <http://www.mathworks.com>`_ written by the navigation group at\r\n`FFI <http://www.ffi.no/en>`_.\r\n\r\nMost of the content is based on the following article:\r\n\r\n*Kenneth Gade (2010):*\r\n    `A Nonsingular Horizontal Position Representation,\r\n    The Journal of Navigation, Volume 63, Issue 03, pp 395-417, July 2010.\r\n    <http://www.navlab.net/Publications/A_Nonsingular_Horizontal_Position_Representation.pdf>`_\r\n\r\nThus this article should be cited in publications using this page or the\r\ndownloaded program code.\r\n\r\n\r\nGetting Started\r\n===============\r\n\r\nBelow the object-oriented solution to some common geodesic problems are given.\r\nIn the first example the functional solution is also given.\r\nThe functional solutions to the remaining problems can be found\r\n`here\r\n<https://github.com/pbrod/nvector/blob/master/nvector/tests/test_nvector.py>`_.\r\n\r\n\r\n**Example 1: \"A and B to delta\"**\r\n---------------------------------\r\n\r\n.. image:: http://www.navlab.net/images/ex1img.png\r\n\r\nGiven two positions, A and B as latitudes, longitudes and depths relative to\r\nEarth, E.\r\n\r\nFind the exact vector between the two positions, given in meters north, east,\r\nand down, and find the direction (azimuth) to B, relative to north.\r\nAssume WGS-84 ellipsoid. The given depths are from the ellipsoid surface.\r\nUse position A to define north, east, and down directions.\r\n(Due to the curvature of Earth and different directions to the North Pole,\r\nthe north, east, and down directions will change (relative to Earth) for\r\ndifferent places.  A must be outside the poles for the north and east\r\ndirections to be defined.)\r\n\r\nSolution:\r\n    >>> import numpy as np\r\n    >>> import nvector as nv\r\n    >>> wgs84 = nv.FrameE(name='WGS84')\r\n    >>> pointA = wgs84.GeoPoint(latitude=1, longitude=2, z=3, degrees=True)\r\n    >>> pointB = wgs84.GeoPoint(latitude=4, longitude=5, z=6, degrees=True)\r\n\r\nStep 1: Find p_AB_E (delta decomposed in E).\r\n    >>> p_AB_E = nv.diff_positions(pointA, pointB)\r\n\r\nStep 2: Find p_AB_N (delta decomposed in N).\r\n    >>> frame_N = nv.FrameN(pointA)\r\n    >>> p_AB_N = p_AB_E.change_frame(frame_N)\r\n    >>> p_AB_N = p_AB_N.pvector.ravel()\r\n    >>> valtxt = '{0:8.2f}, {1:8.2f}, {2:8.2f}'.format(*p_AB_N)\r\n    >>> 'Ex1: delta north, east, down = {}'.format(valtxt)\r\n    'Ex1: delta north, east, down = 331730.23, 332997.87, 17404.27'\r\n\r\nStep3: Also find the direction (azimuth) to B, relative to north:\r\n    >>> azimuth = np.arctan2(p_AB_N[1], p_AB_N[0])\r\n    >>> 'azimuth = {0:4.2f} deg'.format(np.rad2deg(azimuth))\r\n    'azimuth = 45.11 deg'\r\n\r\nFunctional Solution:\r\n    >>> import numpy as np\r\n    >>> import nvector as nv\r\n    >>> from nvector import rad, deg\r\n\r\n    >>> lat_EA, lon_EA, z_EA = rad(1), rad(2), 3\r\n    >>> lat_EB, lon_EB, z_EB = rad(4), rad(5), 6\r\n\r\nStep1: Convert to n-vectors:\r\n    >>> n_EA_E = nv.lat_lon2n_E(lat_EA, lon_EA)\r\n    >>> n_EB_E = nv.lat_lon2n_E(lat_EB, lon_EB)\r\n\r\nStep2: Find p_AB_E (delta decomposed in E).WGS-84 ellipsoid is default:\r\n    >>> p_AB_E = nv.n_EA_E_and_n_EB_E2p_AB_E(n_EA_E, n_EB_E, z_EA, z_EB)\r\n\r\nStep3: Find R_EN for position A:\r\n    >>> R_EN = nv.n_E2R_EN(n_EA_E)\r\n\r\nStep4: Find p_AB_N (delta decomposed in N).\r\n    >>> p_AB_N = np.dot(R_EN.T, p_AB_E).ravel()\r\n    >>> valtxt = '{0:8.2f}, {1:8.2f}, {2:8.2f}'.format(*p_AB_N)\r\n    >>> 'Ex1: delta north, east, down = {}'.format(valtxt)\r\n    'Ex1: delta north, east, down = 331730.23, 332997.87, 17404.27'\r\n\r\nStep5: Also find the direction (azimuth) to B, relative to north:\r\n    >>> azimuth = np.arctan2(p_AB_N[1], p_AB_N[0])\r\n    >>> 'azimuth = {0:4.2f} deg'.format(deg(azimuth))\r\n    'azimuth = 45.11 deg'\r\n\r\nSee also\r\n    `Example 1 at www.navlab.net <http://www.navlab.net/nvector/#example_1>`_\r\n\r\n\r\n**Example 2: \"B and delta to C\"**\r\n---------------------------------\r\n\r\n.. image:: http://www.navlab.net/images/ex2img.png\r\n\r\nA radar or sonar attached to a vehicle B (Body coordinate frame) measures the\r\ndistance and direction to an object C. We assume that the distance and two\r\nangles (typically bearing and elevation relative to B) are already combined to\r\nthe vector p_BC_B (i.e. the vector from B to C, decomposed in B). The position\r\nof B is given as n_EB_E and z_EB, and the orientation (attitude) of B is given\r\nas R_NB (this rotation matrix can be found from roll/pitch/yaw by using zyx2R).\r\n\r\nFind the exact position of object C as n-vector and depth ( n_EC_E and z_EC ),\r\nassuming Earth ellipsoid with semi-major axis a and flattening f. For WGS-72,\r\nuse a = 6 378 135 m and f = 1/298.26.\r\n\r\n\r\nSolution:\r\n    >>> import nvector as nv\r\n    >>> import numpy as np\r\n    >>> wgs72 = nv.FrameE(name='WGS72')\r\n    >>> wgs72 = nv.FrameE(a=6378135, f=1.0/298.26)\r\n\r\nStep 1: Position and orientation of B is given 400m above E:\r\n    >>> n_EB_E = wgs72.Nvector(nv.unit([[1], [2], [3]]), z=-400)\r\n    >>> frame_B = nv.FrameB(n_EB_E, yaw=10, pitch=20, roll=30, degrees=True)\r\n\r\nStep 2: Delta BC decomposed in B\r\n    >>> p_BC_B = frame_B.Pvector(np.r_[3000, 2000, 100].reshape((-1, 1)))\r\n\r\nStep 3: Decompose delta BC in E\r\n    >>> p_BC_E = p_BC_B.to_ecef_vector()\r\n\r\nStep 4: Find point C by adding delta BC to EB\r\n    >>> p_EB_E = n_EB_E.to_ecef_vector()\r\n    >>> p_EC_E = p_EB_E + p_BC_E\r\n    >>> pointC = p_EC_E.to_geo_point()\r\n\r\n    >>> lat, lon, z = pointC.latitude_deg, pointC.longitude_deg, pointC.z\r\n    >>> msg = 'Ex2: PosC: lat, lon = {:4.2f}, {:4.2f} deg,  height = {:4.2f} m'\r\n    >>> msg.format(lat[0], lon[0], -z[0])\r\n    'Ex2: PosC: lat, lon = 53.33, 63.47 deg,  height = 406.01 m'\r\n\r\nSee also\r\n    `Example 2 at www.navlab.net <http://www.navlab.net/nvector/#example_2>`_\r\n\r\n\r\n**Example 3: \"ECEF-vector to geodetic latitude\"**\r\n-------------------------------------------------\r\n\r\n.. image:: http://www.navlab.net/images/ex3img.png\r\n\r\nPosition B is given as an \"ECEF-vector\" p_EB_E (i.e. a vector from E, the\r\ncenter of the Earth, to B, decomposed in E).\r\nFind the geodetic latitude, longitude and height (latEB, lonEB and hEB),\r\nassuming WGS-84 ellipsoid.\r\n\r\n\r\nSolution:\r\n    >>> import numpy as np\r\n    >>> import nvector as nv\r\n    >>> wgs84 = nv.FrameE(name='WGS84')\r\n    >>> position_B = 6371e3 * np.vstack((0.9, -1, 1.1))  # m\r\n    >>> p_EB_E = wgs84.ECEFvector(position_B)\r\n    >>> pointB = p_EB_E.to_geo_point()\r\n\r\n    >>> lat, lon, h = pointB.latitude_deg, pointB.longitude_deg, -pointB.z\r\n    >>> msg = 'Ex3: Pos B: lat, lon = {:4.2f}, {:4.2f} deg, height = {:9.2f} m'\r\n    >>> msg.format(lat[0], lon[0], h[0])\r\n    'Ex3: Pos B: lat, lon = 39.38, -48.01 deg, height = 4702059.83 m'\r\n\r\nSee also\r\n    `Example 3 at www.navlab.net <http://www.navlab.net/nvector/#example_3>`_\r\n\r\n\r\n**Example 4: \"Geodetic latitude to ECEF-vector\"**\r\n-------------------------------------------------\r\n\r\n.. image:: http://www.navlab.net/images/ex4img.png\r\n\r\nGeodetic latitude, longitude and height are given for position B as latEB,\r\nlonEB and hEB, find the ECEF-vector for this position, p_EB_E.\r\n\r\n\r\nSolution:\r\n    >>> import nvector as nv\r\n    >>> wgs84 = nv.FrameE(name='WGS84')\r\n    >>> pointB = wgs84.GeoPoint(latitude=1, longitude=2, z=-3, degrees=True)\r\n    >>> p_EB_E = pointB.to_ecef_vector()\r\n\r\n    >>> 'Ex4: p_EB_E = {} m'.format(p_EB_E.pvector.ravel())\r\n    'Ex4: p_EB_E = [ 6373290.27721828   222560.20067474   110568.82718179] m'\r\n\r\nSee also\r\n    `Example 4 at www.navlab.net <http://www.navlab.net/nvector/#example_4>`_\r\n\r\n\r\n**Example 5: \"Surface distance\"**\r\n---------------------------------\r\n\r\n.. image:: http://www.navlab.net/images/ex5img.png\r\n\r\nFind the surface distance sAB (i.e. great circle distance) between two\r\npositions A and B. The heights of A and B are ignored, i.e. if they don't have\r\nzero height, we seek the distance between the points that are at the surface of\r\nthe Earth, directly above/below A and B. The Euclidean distance (chord length)\r\ndAB should also be found. Use Earth radius 6371e3 m.\r\nCompare the results with exact calculations for the WGS-84 ellipsoid.\r\n\r\n\r\nSolution for a sphere:\r\n    >>> import numpy as np\r\n    >>> import nvector as nv\r\n    >>> frame_E = nv.FrameE(a=6371e3, f=0)\r\n    >>> positionA = frame_E.GeoPoint(latitude=88, longitude=0, degrees=True)\r\n    >>> positionB = frame_E.GeoPoint(latitude=89, longitude=-170, degrees=True)\r\n\r\n    >>> s_AB, _azia, _azib = positionA.distance_and_azimuth(positionB)\r\n    >>> p_AB_E = positionB.to_ecef_vector() - positionA.to_ecef_vector()\r\n    >>> d_AB = np.linalg.norm(p_AB_E.pvector, axis=0)[0]\r\n\r\n    >>> msg = 'Ex5: Great circle and Euclidean distance = {}'\r\n    >>> msg = msg.format('{:5.2f} km, {:5.2f} km')\r\n    >>> msg.format(s_AB / 1000, d_AB / 1000)\r\n    'Ex5: Great circle and Euclidean distance = 332.46 km, 332.42 km'\r\n\r\nAlternative sphere solution:\r\n    >>> path = nv.GeoPath(positionA, positionB)\r\n    >>> s_AB2 = path.track_distance(method='greatcircle').ravel()\r\n    >>> d_AB2 = path.track_distance(method='euclidean').ravel()\r\n    >>> msg.format(s_AB2[0] / 1000, d_AB2[0] / 1000)\r\n    'Ex5: Great circle and Euclidean distance = 332.46 km, 332.42 km'\r\n\r\nExact solution for the WGS84 ellipsoid:\r\n    >>> wgs84 = nv.FrameE(name='WGS84')\r\n    >>> point1 = wgs84.GeoPoint(latitude=88, longitude=0, degrees=True)\r\n    >>> point2 = wgs84.GeoPoint(latitude=89, longitude=-170, degrees=True)\r\n    >>> s_12, _azi1, _azi2 = point1.distance_and_azimuth(point2)\r\n\r\n    >>> p_12_E = point2.to_ecef_vector() - point1.to_ecef_vector()\r\n    >>> d_12 = np.linalg.norm(p_12_E.pvector, axis=0)[0]\r\n    >>> msg = 'Ellipsoidal and Euclidean distance = {:5.2f} km, {:5.2f} km'\r\n    >>> msg.format(s_12 / 1000, d_12 / 1000)\r\n    'Ellipsoidal and Euclidean distance = 333.95 km, 333.91 km'\r\n\r\nSee also\r\n    `Example 5 at www.navlab.net <http://www.navlab.net/nvector/#example_5>`_\r\n\r\n\r\n**Example 6 \"Interpolated position\"**\r\n-------------------------------------\r\n\r\n.. image:: http://www.navlab.net/images/ex6img.png\r\n\r\nGiven the position of B at time t0 and t1, n_EB_E(t0) and n_EB_E(t1).\r\n\r\nFind an interpolated position at time ti, n_EB_E(ti). All positions are given\r\nas n-vectors.\r\n\r\n\r\nSolution:\r\n    >>> import nvector as nv\r\n    >>> wgs84 = nv.FrameE(name='WGS84')\r\n    >>> n_EB_E_t0 = wgs84.GeoPoint(89, 0, degrees=True).to_nvector()\r\n    >>> n_EB_E_t1 = wgs84.GeoPoint(89, 180, degrees=True).to_nvector()\r\n    >>> path = nv.GeoPath(n_EB_E_t0, n_EB_E_t1)\r\n\r\n    >>> t0 = 10.\r\n    >>> t1 = 20.\r\n    >>> ti = 16.  # time of interpolation\r\n    >>> ti_n = (ti - t0) / (t1 - t0) # normalized time of interpolation\r\n\r\n    >>> g_EB_E_ti = path.interpolate(ti_n).to_geo_point()\r\n\r\n    >>> lat_ti, lon_ti = g_EB_E_ti.latitude_deg, g_EB_E_ti.longitude_deg\r\n    >>> msg = 'Ex6, Interpolated position: lat, lon = {} deg, {} deg'\r\n    >>> msg.format(lat_ti, lon_ti)\r\n    'Ex6, Interpolated position: lat, lon = [ 89.7999805] deg, [ 180.] deg'\r\n\r\nSee also\r\n    `Example 6 at www.navlab.net <http://www.navlab.net/nvector/#example_6>`_\r\n\r\n\r\n**Example 7: \"Mean position\"**\r\n------------------------------\r\n\r\n.. image:: http://www.navlab.net/images/ex7img.png\r\n\r\nThree positions A, B, and C are given as n-vectors n_EA_E, n_EB_E, and n_EC_E.\r\nFind the mean position, M, given as n_EM_E.\r\nNote that the calculation is independent of the depths of the positions.\r\n\r\n\r\nSolution:\r\n    >>> import nvector as nv\r\n    >>> points = nv.GeoPoint(latitude=[90, 60, 50],\r\n    ...                      longitude=[0, 10, -20], degrees=True)\r\n    >>> nvectors = points.to_nvector()\r\n    >>> n_EM_E = nvectors.mean_horizontal_position()\r\n    >>> g_EM_E = n_EM_E.to_geo_point()\r\n    >>> lat, lon = g_EM_E.latitude_deg, g_EM_E.longitude_deg\r\n    >>> msg = 'Ex7: Pos M: lat, lon = {:4.2f}, {:4.2f} deg'\r\n    >>> msg.format(lat[0], lon[0])\r\n    'Ex7: Pos M: lat, lon = 67.24, -6.92 deg'\r\n\r\nSee also\r\n    `Example 7 at www.navlab.net <http://www.navlab.net/nvector/#example_7>`_\r\n\r\n\r\n**Example 8: \"A and azimuth/distance to B\"**\r\n--------------------------------------------\r\n\r\n.. image:: http://www.navlab.net/images/ex8img.png\r\n\r\nWe have an initial position A, direction of travel given as an azimuth\r\n(bearing) relative to north (clockwise), and finally the\r\ndistance to travel along a great circle given as sAB.\r\nUse Earth radius 6371e3 m to find the destination point B.\r\n\r\nIn geodesy this is known as \"The first geodetic problem\" or\r\n\"The direct geodetic problem\" for a sphere, and we see that this is similar to\r\n`Example 2 <http://www.navlab.net/nvector/#example_2>`_, but now the delta is\r\ngiven as an azimuth and a great circle distance. (\"The second/inverse geodetic\r\nproblem\" for a sphere is already solved in Examples\r\n`1 <http://www.navlab.net/nvector/#example_1>`_ and\r\n`5 <http://www.navlab.net/nvector/#example_5>`_.)\r\n\r\n\r\nSolution:\r\n    >>> import nvector as nv\r\n    >>> frame = nv.FrameE(a=6371e3, f=0)\r\n    >>> pointA = frame.GeoPoint(latitude=80, longitude=-90, degrees=True)\r\n    >>> pointB, _azimuthb = pointA.geo_point(distance=1000, azimuth=200,\r\n    ...                                      degrees=True)\r\n    >>> lat, lon = pointB.latitude_deg, pointB.longitude_deg\r\n\r\n    >>> msg = 'Ex8, Destination: lat, lon = {:4.2f} deg, {:4.2f} deg'\r\n    >>> msg.format(lat, lon)\r\n    'Ex8, Destination: lat, lon = 79.99 deg, -90.02 deg'\r\n\r\nSee also\r\n    `Example 8 at www.navlab.net <http://www.navlab.net/nvector/#example_8>`_\r\n\r\n\r\n**Example 9: \"Intersection of two paths\"**\r\n------------------------------------------\r\n\r\n.. image:: http://www.navlab.net/images/ex9img.png\r\n\r\nDefine a path from two given positions (at the surface of a spherical Earth),\r\nas the great circle that goes through the two points.\r\n\r\nPath A is given by A1 and A2, while path B is given by B1 and B2.\r\n\r\nFind the position C where the two great circles intersect.\r\n\r\n\r\nSolution:\r\n    >>> import nvector as nv\r\n    >>> pointA1 = nv.GeoPoint(10, 20, degrees=True)\r\n    >>> pointA2 = nv.GeoPoint(30, 40, degrees=True)\r\n    >>> pointB1 = nv.GeoPoint(50, 60, degrees=True)\r\n    >>> pointB2 = nv.GeoPoint(70, 80, degrees=True)\r\n    >>> pathA = nv.GeoPath(pointA1, pointA2)\r\n    >>> pathB = nv.GeoPath(pointB1, pointB2)\r\n\r\n    >>> pointC = pathA.intersect(pathB)\r\n    >>> pathA.on_path(pointC), pathB.on_path(pointC)\r\n    (array([False], dtype=bool), array([False], dtype=bool))\r\n    >>> pathA.on_great_circle(pointC), pathB.on_great_circle(pointC)\r\n    (array([ True], dtype=bool), array([ True], dtype=bool))\r\n    >>> pointC = pointC.to_geo_point()\r\n    >>> lat, lon = pointC.latitude_deg, pointC.longitude_deg\r\n    >>> msg = 'Ex9, Intersection: lat, lon = {:4.2f}, {:4.2f} deg'\r\n    >>> msg.format(lat[0], lon[0])\r\n    'Ex9, Intersection: lat, lon = 40.32, 55.90 deg'\r\n\r\nSee also\r\n    `Example 9 at www.navlab.net <http://www.navlab.net/nvector/#example_9>`_\r\n\r\n\r\n**Example 10: \"Cross track distance\"**\r\n--------------------------------------\r\n\r\n.. image:: https://raw.githubusercontent.com/pbrod/Nvector/master/ex10img.png\r\n\r\nPath A is given by the two positions A1 and A2 (similar to the previous\r\nexample).\r\n\r\nFind the cross track distance sxt between the path A (i.e. the great circle\r\nthrough A1 and A2) and the position B (i.e. the shortest distance at the\r\nsurface, between the great circle and B).\r\n\r\nAlso find the Euclidean distance dxt between B and the plane defined by the\r\ngreat circle. Use Earth radius 6371e3.\r\n\r\nFinally, find the intersection point on the great circle and determine if it is\r\nbetween position A1 and A2.\r\n\r\n\r\nSolution:\r\n    >>> import nvector as nv\r\n    >>> frame = nv.FrameE(a=6371e3, f=0)\r\n    >>> pointA1 = frame.GeoPoint(0, 0, degrees=True)\r\n    >>> pointA2 = frame.GeoPoint(10, 0, degrees=True)\r\n    >>> pointB = frame.GeoPoint(1, 0.1, degrees=True)\r\n    >>> pathA = nv.GeoPath(pointA1, pointA2)\r\n\r\n    >>> s_xt = pathA.cross_track_distance(pointB, method='greatcircle').ravel()\r\n    >>> d_xt = pathA.cross_track_distance(pointB, method='euclidean').ravel()\r\n\r\n    >>> val_txt = '{:4.2f} km, {:4.2f} km'.format(s_xt[0]/1000, d_xt[0]/1000)\r\n    >>> 'Ex10: Cross track distance: s_xt, d_xt = {}'.format(val_txt)\r\n    'Ex10: Cross track distance: s_xt, d_xt = 11.12 km, 11.12 km'\r\n\r\n    >>> pointC = pathA.closest_point_on_great_circle(pointB)\r\n    >>> pathA.on_path(pointC)\r\n    array([ True], dtype=bool)\r\n\r\nSee also\r\n    `Example 10 at www.navlab.net <http://www.navlab.net/nvector/#example_10>`_\r\n\r\n\r\n\r\nSee also\r\n========\r\n`geographiclib <https://pypi.python.org/pypi/geographiclib>`_\r\n\r\n.. |nvector_img| image:: https://badge.fury.io/py/Nvector.png\r\n   :target: https://pypi.python.org/pypi/Nvector/\r\n.. |tests_img| image:: https://travis-ci.org/pbrod/Nvector.svg?branch=master\r\n   :target: https://travis-ci.org/pbrod/Nvector\r\n.. |docs_img| image:: https://readthedocs.org/projects/pip/badge/?version=latest\r\n   :target: http://Nvector.readthedocs.org/en/latest/\r\n.. |health_img| image:: https://landscape.io/github/pbrod/Nvector/master/landscape.svg?style=flat\r\n   :target: https://landscape.io/github/pbrod/Nvector/master\r\n.. |coverage_img| image:: https://coveralls.io/repos/pbrod/Nvector/badge.svg?branch=master&service=github\r\n   :target: https://coveralls.io/github/pbrod/Nvector?branch=master\r\n.. |versions_img| image:: https://img.shields.io/pypi/pyversions/Nvector.svg\r\n   :target: https://github.com/pbrod/Nvector\r\n\r\nNote\r\n====\r\n\r\nThis project has been set up using PyScaffold 2.4.4. For details and usage\r\ninformation on PyScaffold see http://pyscaffold.readthedocs.org/.\r\n\r\n\r\n\r\n",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "https://github.com/pbrod/nvector/",
    "keywords": "",
    "license": "Simplified BSD",
    "maintainer": "",
    "maintainer_email": "",
    "name": "nvector",
    "platform": "",
    "project_url": "https://pypi.org/project/nvector/",
    "release_url": "https://pypi.org/project/nvector/0.5.2/",
    "requires_python": "",
    "summary": "Solves all kinds of geographical position calculations.",
    "version": "0.5.2"
  },
  "releases": {
    "0.1.3": [
      {
        "comment_text": "",
        "digests": {
          "md5": "af284c448a72dc9660b7d05f7e191a27",
          "sha256": "b8a10f5a8a1f5a2182425df27edb42130be2b86219c74d6d86b61fda9722c6c4"
        },
        "downloads": 365,
        "filename": "nvector-0.1.3-py2.py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "af284c448a72dc9660b7d05f7e191a27",
        "packagetype": "bdist_wheel",
        "python_version": "py2.py3",
        "size": 1818962,
        "upload_time": "2016-01-01T19:01:57",
        "url": "https://files.pythonhosted.org/packages/90/da/cb328d2ef52e4c7a889c7d8b15c9b0f3ba2593770e707e85108bc7584aa2/nvector-0.1.3-py2.py3-none-any.whl"
      }
    ],
    "0.4.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "2ee662fd827c6c9bb253262ab44f3f49",
          "sha256": "8e267fbc38d780a94315d12070ce07178573bff4b2d8538369338343a2899469"
        },
        "downloads": 701,
        "filename": "nvector-0.4.1-py2.py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "2ee662fd827c6c9bb253262ab44f3f49",
        "packagetype": "bdist_wheel",
        "python_version": "py2.py3",
        "size": 2325166,
        "upload_time": "2016-01-19T02:07:23",
        "url": "https://files.pythonhosted.org/packages/93/b6/171087248d82f8202d2c05e7ed518adc13cbd4889417b896621ae25b9340/nvector-0.4.1-py2.py3-none-any.whl"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "83782e7361cb11e3089fceceed5db105",
          "sha256": "80ac5b1ab4d319180f0e6eff7a27a65a5c1eb6d9aa9f9225e0fd5ed156f89cf4"
        },
        "downloads": 334,
        "filename": "nvector-0.4.1.zip",
        "has_sig": false,
        "md5_digest": "83782e7361cb11e3089fceceed5db105",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 73487,
        "upload_time": "2016-01-19T02:07:35",
        "url": "https://files.pythonhosted.org/packages/5c/c2/5f015fc30693559f74449d2120e08f884a2fa28da103035be3d89d217b51/nvector-0.4.1.zip"
      }
    ],
    "0.5.2": [
      {
        "comment_text": "",
        "digests": {
          "md5": "9b833873cbd05ef1ec8d4c82fddff50a",
          "sha256": "f3877e3b5c1f498095a8ed05427b462d7d1e2bc21220f3cc4c5543bb24dbd33c"
        },
        "downloads": 29,
        "filename": "nvector-0.5.2-py2.py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "9b833873cbd05ef1ec8d4c82fddff50a",
        "packagetype": "bdist_wheel",
        "python_version": "py2.py3",
        "size": 2919983,
        "upload_time": "2017-03-07T13:16:05",
        "url": "https://files.pythonhosted.org/packages/9a/57/3b3b74377764f5d20b031788cb204a0b550c886f079aa54a6a3aec4f59fd/nvector-0.5.2-py2.py3-none-any.whl"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "0ac0d87333967f9b2329a7f76c5b3e76",
          "sha256": "0995540e319caaceb20d75ed57d8cf043eabd90caaf0322bb35f8e2baeeed567"
        },
        "downloads": 22,
        "filename": "nvector-0.5.2.tar.gz",
        "has_sig": false,
        "md5_digest": "0ac0d87333967f9b2329a7f76c5b3e76",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 70209,
        "upload_time": "2017-03-07T13:16:10",
        "url": "https://files.pythonhosted.org/packages/10/90/d12e55ad007bd14997473c62f0b0b447b3208a3625f2afcf0bcccb1c88f6/nvector-0.5.2.tar.gz"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "9b833873cbd05ef1ec8d4c82fddff50a",
        "sha256": "f3877e3b5c1f498095a8ed05427b462d7d1e2bc21220f3cc4c5543bb24dbd33c"
      },
      "downloads": 29,
      "filename": "nvector-0.5.2-py2.py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "9b833873cbd05ef1ec8d4c82fddff50a",
      "packagetype": "bdist_wheel",
      "python_version": "py2.py3",
      "size": 2919983,
      "upload_time": "2017-03-07T13:16:05",
      "url": "https://files.pythonhosted.org/packages/9a/57/3b3b74377764f5d20b031788cb204a0b550c886f079aa54a6a3aec4f59fd/nvector-0.5.2-py2.py3-none-any.whl"
    },
    {
      "comment_text": "",
      "digests": {
        "md5": "0ac0d87333967f9b2329a7f76c5b3e76",
        "sha256": "0995540e319caaceb20d75ed57d8cf043eabd90caaf0322bb35f8e2baeeed567"
      },
      "downloads": 22,
      "filename": "nvector-0.5.2.tar.gz",
      "has_sig": false,
      "md5_digest": "0ac0d87333967f9b2329a7f76c5b3e76",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 70209,
      "upload_time": "2017-03-07T13:16:10",
      "url": "https://files.pythonhosted.org/packages/10/90/d12e55ad007bd14997473c62f0b0b447b3208a3625f2afcf0bcccb1c88f6/nvector-0.5.2.tar.gz"
    }
  ]
}