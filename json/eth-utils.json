{
  "info": {
    "author": "Piper Merriam",
    "author_email": "pipermerriam@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Intended Audience :: Developers",
      "License :: OSI Approved :: MIT License",
      "Natural Language :: English",
      "Programming Language :: Python :: 2",
      "Programming Language :: Python :: 2.7",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.4",
      "Programming Language :: Python :: 3.5",
      "Programming Language :: Python :: 3.6"
    ],
    "description": "Ethereum Utils\n==============\n\n|Join the chat at https://gitter.im/ethereum/eth-utils|\n\n|Build Status|\n\nCommon utility functions for codebases which interact with ethereum.\n\n    This library and repository was previously located at\n    https://github.com/pipermerriam/ethereum-utils. It was transferred\n    to the Ethereum foundation github in November 2017 and renamed to\n    ``eth-utils``. The PyPi package was also renamed from\n    ``ethereum-utils`` to \\`eth-utils.\n\nInstallation\n------------\n\n.. code:: sh\n\n    pip install eth-utils\n\nDevelopment\n-----------\n\nClone the repository and then run:\n\n.. code:: sh\n\n    pip install -e . -r requirements-dev.txt\n\nRunning the tests\n~~~~~~~~~~~~~~~~~\n\nYou can run the tests with:\n\n.. code:: sh\n\n    py.test tests\n\nOr you can install ``tox`` to run the full test suite.\n\nReleasing\n~~~~~~~~~\n\nPandoc is required for transforming the markdown README to the proper\nformat to render correctly on pypi.\n\nFor Debian-like systems:\n\n::\n\n    apt install pandoc\n\nOr on OSX:\n\n.. code:: sh\n\n    brew install pandoc\n\nTo release a new version:\n\n.. code:: sh\n\n    bumpversion $$VERSION_PART_TO_BUMP$$\n    git push && git push --tags\n    make release\n\nHow to bumpversion\n^^^^^^^^^^^^^^^^^^\n\nThe version format for this repo is ``{major}.{minor}.{patch}`` for\nstable, and ``{major}.{minor}.{patch}-{stage}.{devnum}`` for unstable\n(``stage`` can be alpha or beta).\n\nTo issue the next version in line, use bumpversion and specify which\npart to bump, like ``bumpversion minor`` or ``bumpversion devnum``.\n\nIf you are in a beta version, ``bumpversion stage`` will switch to a\nstable.\n\nTo issue an unstable version when the current version is stable, specify\nthe new version explicitly, like\n``bumpversion --new-version 4.0.0-alpha.1 devnum``\n\nDocumentation\n-------------\n\nAll functions can be imported directly from the ``eth_utils`` module\n\nABI Utils\n~~~~~~~~~\n\n``event_abi_to_log_topic(event_abi)`` -> bytes\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturns the 32 byte log topic for the given event abi.\n\n.. code:: python\n\n    >>> event_abi_to_log_topic({'type': 'event', 'anonymous': False, 'name': 'MyEvent', 'inputs': []})\n    b'M\\xbf\\xb6\\x8bC\\xdd\\xdf\\xa1+Q\\xeb\\xe9\\x9a\\xb8\\xfd\\xedb\\x0f\\x9a\\n\\xc21B\\x87\\x9aO\\x19*\\x1byR\\xd2'\n\n``event_signature_to_log_topic(event_signature)`` -> bytes\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturns the 32 byte log topic for the given event signature.\n\n.. code:: python\n\n    >>> event_signature_to_log_topic('MyEvent()')\n    b'M\\xbf\\xb6\\x8bC\\xdd\\xdf\\xa1+Q\\xeb\\xe9\\x9a\\xb8\\xfd\\xedb\\x0f\\x9a\\n\\xc21B\\x87\\x9aO\\x19*\\x1byR\\xd2'\n\n``function_abi_to_4byte_selector(function_abi)`` -> bytes\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturns the 4 byte function selector for the given function abi.\n\n.. code:: python\n\n    >>> function_abi_to_4byte_selector({'type': 'function', 'name': 'myFunction', 'inputs': [], 'outputs': []})\n    b'\\xc3x\\n:'\n\n``function_signature_to_4byte_selector(function_signature)`` -> bytes\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturns the 4 byte function selector for the given function signature.\n\n.. code:: python\n\n    >>> function_signature_to_4byte_selector('myFunction()')\n    b'\\xc3x\\n:'\n\nAddress Utils\n~~~~~~~~~~~~~\n\n``is_address(value)`` -> bool\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturns ``True`` if the ``value`` is one of the following accepted\naddress formats.\n\n-  20 byte hexidecimal, upper/lower/mixed case, with or without ``0x``\n   prefix:\n\n   -  ``'d3cda913deb6f67967b99d67acdfa1712c293601'``\n   -  ``'0xd3cda913deb6f67967b99d67acdfa1712c293601'``\n   -  ``'0xD3CDA913DEB6F67967B99D67ACDFA1712C293601'``\n   -  ``'0xd3CdA913deB6f67967B99D67aCDFa1712C293601'``\n\n-  20 byte hexidecimal padded to 32 bytes with null bytes,\n   upper/lower/mixed case, with or without ``0x`` prefix:\n\n   -  ``'000000000000000000000000d3cda913deb6f67967b99d67acdfa1712c293601'``\n   -  ``'000000000000000000000000d3cda913deb6f67967b99d67acdfa1712c293601'``\n   -  ``'0x000000000000000000000000d3cda913deb6f67967b99d67acdfa1712c293601'``\n   -  ``'0x000000000000000000000000D3CDA913DEB6F67967B99D67ACDFA1712C293601'``\n   -  ``'0x000000000000000000000000d3CdA913deB6f67967B99D67aCDFa1712C293601'``\n\n-  20 text or bytes string:\n\n   -  ``'\\xd3\\xcd\\xa9\\x13\\xde\\xb6\\xf6yg\\xb9\\x9dg\\xac\\xdf\\xa1q,)6\\x01'``\n\n-  20 text or bytes string padded to 32 bytes with null bytes.\n\n   -  ``'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xd3\\xcd\\xa9\\x13\\xde\\xb6\\xf6yg\\xb9\\x9dg\\xac\\xdf\\xa1q,)6\\x01'``\n\nThis function has two special cases when it will return False:\n\n-  a 20-byte hex string that has mixed case, with an invalid checksum\n-  a 32-byte value that is all null bytes\n\n.. code:: python\n\n    >>> is_address('d3cda913deb6f67967b99d67acdfa1712c293601')\n    True\n    >>> is_address('0xd3cda913deb6f67967b99d67acdfa1712c293601')\n    True\n    >>> is_address('0xD3CDA913DEB6F67967B99D67ACDFA1712C293601')\n    True\n    >>> is_address('0xd3CdA913deB6f67967B99D67aCDFa1712C293601')\n    True\n    >>> is_address('000000000000000000000000d3cda913deb6f67967b99d67acdfa1712c293601')\n    True\n    >>> is_address('000000000000000000000000d3cda913deb6f67967b99d67acdfa1712c293601')\n    True\n    >>> is_address('0x000000000000000000000000d3cda913deb6f67967b99d67acdfa1712c293601')\n    True\n    >>> is_address('0x000000000000000000000000D3CDA913DEB6F67967B99D67ACDFA1712C293601')\n    True\n    >>> is_address('0x000000000000000000000000d3CdA913deB6f67967B99D67aCDFa1712C293601')\n    True\n    >>> is_address('\\xd3\\xcd\\xa9\\x13\\xde\\xb6\\xf6yg\\xb9\\x9dg\\xac\\xdf\\xa1q,)6\\x01')\n    True\n    >>> is_address('\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xd3\\xcd\\xa9\\x13\\xde\\xb6\\xf6yg\\xb9\\x9dg\\xac\\xdf\\xa1q,)6\\x01')\n    True\n    >>> is_address('0x0000000000000000000000000000000000000000000000000000000000000000')\n    False\n    >>> is_address('\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00')\n    False\n\n``is_hex_address(value)`` => bool\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturn ``True`` if the value is a 20 byte hexidecimal encoded string in\nany of upper/lower/mixed casing, with or without the ``0x`` prefix.\nOtherwise return ``False``\n\n-  ``'d3cda913deb6f67967b99d67acdfa1712c293601'``\n-  ``'0xd3cda913deb6f67967b99d67acdfa1712c293601'``\n-  ``'0xD3CDA913DEB6F67967B99D67ACDFA1712C293601'``\n-  ``'0xd3CdA913deB6f67967B99D67aCDFa1712C293601'``\n\n.. code:: python\n\n    >>> is_hex_address('d3cda913deb6f67967b99d67acdfa1712c293601')\n    True\n    >>> is_hex_address('0xd3cda913deb6f67967b99d67acdfa1712c293601')\n    True\n    >>> is_hex_address('0xD3CDA913DEB6F67967B99D67ACDFA1712C293601')\n    True\n    >>> is_hex_address('0xd3CdA913deB6f67967B99D67aCDFa1712C293601')\n    True\n    >>> is_hex_address('000000000000000000000000d3cda913deb6f67967b99d67acdfa1712c293601')\n    False\n    >>> is_hex_address('000000000000000000000000d3cda913deb6f67967b99d67acdfa1712c293601')\n    False\n    >>> is_hex_address('0x000000000000000000000000d3cda913deb6f67967b99d67acdfa1712c293601')\n    False\n    >>> is_hex_address('0x000000000000000000000000D3CDA913DEB6F67967B99D67ACDFA1712C293601')\n    False\n    >>> is_hex_address('0x000000000000000000000000d3CdA913deB6f67967B99D67aCDFa1712C293601')\n    False\n    >>> is_hex_address('\\xd3\\xcd\\xa9\\x13\\xde\\xb6\\xf6yg\\xb9\\x9dg\\xac\\xdf\\xa1q,)6\\x01')\n    False\n    >>> is_hex_address('\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xd3\\xcd\\xa9\\x13\\xde\\xb6\\xf6yg\\xb9\\x9dg\\xac\\xdf\\xa1q,)6\\x01')\n    False\n    >>> is_hex_address('0x0000000000000000000000000000000000000000000000000000000000000000')\n    False\n    >>> is_hex_address('\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00')\n    False\n\n``is_binary_address(value)`` -> bool\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturn ``True`` if the value is a 20 byte string.\n\n.. code:: python\n\n    >>> is_binary_address('d3cda913deb6f67967b99d67acdfa1712c293601')\n    False\n    >>> is_binary_address('0xd3cda913deb6f67967b99d67acdfa1712c293601')\n    False\n    >>> is_binary_address('0xD3CDA913DEB6F67967B99D67ACDFA1712C293601')\n    False\n    >>> is_binary_address('0xd3CdA913deB6f67967B99D67aCDFa1712C293601')\n    False\n    >>> is_binary_address('000000000000000000000000d3cda913deb6f67967b99d67acdfa1712c293601')\n    False\n    >>> is_binary_address('000000000000000000000000d3cda913deb6f67967b99d67acdfa1712c293601')\n    False\n    >>> is_binary_address('0x000000000000000000000000d3cda913deb6f67967b99d67acdfa1712c293601')\n    False\n    >>> is_binary_address('0x000000000000000000000000D3CDA913DEB6F67967B99D67ACDFA1712C293601')\n    False\n    >>> is_binary_address('0x000000000000000000000000d3CdA913deB6f67967B99D67aCDFa1712C293601')\n    False\n    >>> is_binary_address('\\xd3\\xcd\\xa9\\x13\\xde\\xb6\\xf6yg\\xb9\\x9dg\\xac\\xdf\\xa1q,)6\\x01')\n    True\n    >>> is_binary_address('\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xd3\\xcd\\xa9\\x13\\xde\\xb6\\xf6yg\\xb9\\x9dg\\xac\\xdf\\xa1q,)6\\x01')\n    False\n    >>> is_binary_address('0x0000000000000000000000000000000000000000000000000000000000000000')\n    False\n    >>> is_binary_address('\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00')\n    False\n\n``is_32byte_address(value)`` -> bool\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturn ``True`` if the value is a 20 byte address that has been padded\nto 32 bytes. This function allows both bytes or hexidecimal encoded\nstrings. Hexidecimal strings may optionally be ``0x`` prefixed. The\npadding bytes **must** be zeros.\n\n    Note: this method returns false for the zero address.\n\n.. code:: python\n\n    >>> is_32byte_address('d3cda913deb6f67967b99d67acdfa1712c293601')\n    False\n    >>> is_32byte_address('0xd3cda913deb6f67967b99d67acdfa1712c293601')\n    False\n    >>> is_32byte_address('0xD3CDA913DEB6F67967B99D67ACDFA1712C293601')\n    False\n    >>> is_32byte_address('0xd3CdA913deB6f67967B99D67aCDFa1712C293601')\n    False\n    >>> is_32byte_address('000000000000000000000000d3cda913deb6f67967b99d67acdfa1712c293601')\n    True\n    >>> is_32byte_address('000000000000000000000000d3cda913deb6f67967b99d67acdfa1712c293601')\n    True\n    >>> is_32byte_address('0x000000000000000000000000d3cda913deb6f67967b99d67acdfa1712c293601')\n    True\n    >>> is_32byte_address('0x000000000000000000000000D3CDA913DEB6F67967B99D67ACDFA1712C293601')\n    True\n    >>> is_32byte_address('0x000000000000000000000000d3CdA913deB6f67967B99D67aCDFa1712C293601')\n    True\n    >>> is_32byte_address('\\xd3\\xcd\\xa9\\x13\\xde\\xb6\\xf6yg\\xb9\\x9dg\\xac\\xdf\\xa1q,)6\\x01')\n    False\n    >>> is_32byte_address('\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xd3\\xcd\\xa9\\x13\\xde\\xb6\\xf6yg\\xb9\\x9dg\\xac\\xdf\\xa1q,)6\\x01')\n    True\n    >>> is_32byte_address('0x0000000000000000000000000000000000000000000000000000000000000000')\n    False\n    >>> is_32byte_address('\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00')\n    False\n\n``is_canonical_address(value)`` -> bool\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturns ``True`` if the ``value`` is an address in it\u2019s canonical form.\n\nThe canonical representation of an address according to ``eth_utils`` is\na 20 byte long string of bytes, eg:\n``b'\\xd3\\xcd\\xa9\\x13\\xde\\xb6\\xf6yg\\xb9\\x9dg\\xac\\xdf\\xa1q,)6\\x01'``\n\n.. code:: python\n\n    >>> is_canonical_address('0xd3cda913deb6f67967b99d67acdfa1712c293601')\n    False\n    >>> is_canonical_address(b'\\xd3\\xcd\\xa9\\x13\\xde\\xb6\\xf6yg\\xb9\\x9dg\\xac\\xdf\\xa1q,)6\\x01xd')\n    True\n    >>> is_canonical_address('\\xd3\\xcd\\xa9\\x13\\xde\\xb6\\xf6yg\\xb9\\x9dg\\xac\\xdf\\xa1q,)6\\x01xd')\n    False\n\n``is_checksum_address(value)`` -> bool\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturns ``True`` if the ``value`` is a checksummed address as specified\nby `ERC55 <https://github.com/ethereum/EIPs/issues/55>`__\n\n.. code:: python\n\n    >>> is_checksum_address('0xd3CdA913deB6f67967B99D67aCDFa1712C293601')\n    True\n    >>> is_checksum_address('0xd3cda913deb6f67967b99d67acdfa1712c293601')\n    False\n    >>> is_checksum_address('0xD3CDA913DEB6F67967B99D67ACDFA1712C293601')\n    False\n    >>> is_checksum_address('0x52908400098527886E0F7030069857D2E4169EE7')\n    True\n    >>> is_checksum_address('0xde709f2102306220921060314715629080e2fb77')\n    True\n\n``is_checksum_formatted_address(value)`` -> bool\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturns ``True`` if the ``value`` is formatted as an\n`ERC55 <https://github.com/ethereum/EIPs/issues/55>`__ checksum address.\n\n.. code:: python\n\n    >>> is_checksum_formatted_address('0xd3CdA913deB6f67967B99D67aCDFa1712C293601')\n    True\n    >>> is_checksum_formatted_address('0xd3cda913deb6f67967b99d67acdfa1712c293601')\n    False\n    >>> is_checksum_formatted_address('0xD3CDA913DEB6F67967B99D67ACDFA1712C293601')\n    False\n    >>> is_checksum_formatted_address('0x52908400098527886E0F7030069857D2E4169EE7')\n    False\n    >>> is_checksum_formatted_address('0xde709f2102306220921060314715629080e2fb77')\n    False\n\n``is_normalized_address(value)`` -> bool\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturns ``True`` if the ``value`` is an address in its normalized form.\n\nThe normalized representation of an address is the lowercased 20 byte\nhexidecimal format.\n\n.. code:: python\n\n    >>> is_normalized_address('0xd3CdA913deB6f67967B99D67aCDFa1712C293601')\n    False\n    >>> is_normalized_address('0xd3cda913deb6f67967b99d67acdfa1712c293601')\n    True\n    >>> is_normalized_address('0xD3CDA913DEB6F67967B99D67ACDFA1712C293601')\n    False\n    >>> is_normalized_address('0x52908400098527886E0F7030069857D2E4169EE7')\n    False\n    >>> is_normalized_address('0xde709f2102306220921060314715629080e2fb77')\n    True\n\n``is_same_address(a, b)`` -> bool\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturns ``True`` if both ``a`` and ``b`` are valid addresses according\nto the ``is_address`` function and that they are both representations of\nthe same address.\n\n.. code:: python\n\n    >>> is_same_address('0xd3cda913deb6f67967b99d67acdfa1712c293601', '0xD3CDA913DEB6F67967B99D67ACDFA1712C293601')\n    True\n    >>> is_same_address('0xd3cda913deb6f67967b99d67acdfa1712c293601', '0xd3CdA913deB6f67967B99D67aCDFa1712C293601')\n    True\n    >>> is_same_address('0xd3cda913deb6f67967b99d67acdfa1712c293601', '\\xd3\\xcd\\xa9\\x13\\xde\\xb6\\xf6yg\\xb9\\x9dg\\xac\\xdf\\xa1q,)6\\x01xd')\n    True\n\n``to_canonical_address(value)`` -> bytes\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nGiven any valid representation of an address return it\u2019s canonical form.\n\n.. code:: python\n\n    >>> to_canonical_address('0xd3cda913deb6f67967b99d67acdfa1712c293601')\n    b'\\xd3\\xcd\\xa9\\x13\\xde\\xb6\\xf6yg\\xb9\\x9dg\\xac\\xdf\\xa1q,)6\\x01xd'\n    >>> to_canonical_address('0xD3CDA913DEB6F67967B99D67ACDFA1712C293601')\n    b'\\xd3\\xcd\\xa9\\x13\\xde\\xb6\\xf6yg\\xb9\\x9dg\\xac\\xdf\\xa1q,)6\\x01xd'\n    >>> to_canonical_address('0xd3CdA913deB6f67967B99D67aCDFa1712C293601')\n    b'\\xd3\\xcd\\xa9\\x13\\xde\\xb6\\xf6yg\\xb9\\x9dg\\xac\\xdf\\xa1q,)6\\x01xd'\n    >>> to_canonical_address('\\xd3\\xcd\\xa9\\x13\\xde\\xb6\\xf6yg\\xb9\\x9dg\\xac\\xdf\\xa1q,)6\\x01xd')\n    b'\\xd3\\xcd\\xa9\\x13\\xde\\xb6\\xf6yg\\xb9\\x9dg\\xac\\xdf\\xa1q,)6\\x01xd'\n\n``to_checksum_address(value)`` -> text\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nGiven any valid representation of an address return the checksummed\nrepresentation.\n\n.. code:: python\n\n    >>> to_checksum_address('0xd3cda913deb6f67967b99d67acdfa1712c293601')\n    '0xd3CdA913deB6f67967B99D67aCDFa1712C293601'\n    >>> to_checksum_address('0xD3CDA913DEB6F67967B99D67ACDFA1712C293601')\n    '0xd3CdA913deB6f67967B99D67aCDFa1712C293601'\n    >>> to_checksum_address('0xd3CdA913deB6f67967B99D67aCDFa1712C293601')\n    '0xd3CdA913deB6f67967B99D67aCDFa1712C293601'\n    >>> to_checksum_address('\\xd3\\xcd\\xa9\\x13\\xde\\xb6\\xf6yg\\xb9\\x9dg\\xac\\xdf\\xa1q,)6\\x01xd')\n    '0xd3CdA913deB6f67967B99D67aCDFa1712C293601'\n\n``to_normalized_address(value)`` -> text\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nGiven any valid representation of an address return the normalized\nrepresentation.\n\n.. code:: python\n\n    >>> to_normalized_address('\\xd3\\xcd\\xa9\\x13\\xde\\xb6\\xf6yg\\xb9\\x9dg\\xac\\xdf\\xa1q,)6\\x01')  # raw bytes\n    '0xd3cda913deb6f67967b99d67acdfa1712c293601'\n    >>> to_normalized_address(b'0xc6d9d2cd449a754c494264e1809c50e34d64562b')  # hex encoded (as byte string)\n    '0xc6d9d2cd449a754c494264e1809c50e34d64562b'\n    >>> to_normalized_address('0xc6d9d2cd449a754c494264e1809c50e34d64562b')  # hex encoded\n    '0xc6d9d2cd449a754c494264e1809c50e34d64562b'\n    >>> to_normalized_address('0XC6D9D2CD449A754C494264E1809C50E34D64562B')  # cap-cased\n    '0xc6d9d2cd449a754c494264e1809c50e34d64562b'\n    >>> to_normalized_address('0x000000000000000000000000c305c901078781c232a2a521c2af7980f8385ee9')  # padded to 32 bytes\n    '0xc305c901078781c232a2a521c2af7980f8385ee9',\n\nCrypto Utils\n~~~~~~~~~~~~\n\n``keccak(value)`` -> bytes\n^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nGiven any string returns the ``sha3/keccak`` hash. If ``value`` is not a\nbyte string it will be converted using the ``force_bytes`` function.\n\n.. code:: python\n\n    >>> keccak('')\n    b\"\\xc5\\xd2F\\x01\\x86\\xf7#<\\x92~}\\xb2\\xdc\\xc7\\x03\\xc0\\xe5\\x00\\xb6S\\xca\\x82';{\\xfa\\xd8\\x04]\\x85\\xa4p\"\n\nCurrency Utils\n~~~~~~~~~~~~~~\n\n``denoms``\n^^^^^^^^^^\n\nObject with property access to all of the various denominations for\nether. Available denominations are:\n\n+--------------+---------------------------------+\n| denomination | amount in wei                   |\n+--------------+---------------------------------+\n| wei kwei     | 1 1000 1000 1000 1000000        |\n| babbage      | 1000000 1000000 1000000000      |\n| femtoether   | 1000000000 1000000000           |\n| mwei         | 1000000000 1000000000000        |\n| lovelace     | 1000000000000 1000000000000     |\n| picoether    | 1000000000000000                |\n| gwei shannon | 1000000000000000                |\n| nanoether    | 1000000000000000                |\n| nano szabo   | 1000000000000000000             |\n| microether   | 1000000000000000000000          |\n| micro finney | 1000000000000000000000          |\n| milliether   | 1000000000000000000000000       |\n| milli ether  | 1000000000000000000000000000    |\n| kether grand | 1000000000000000000000000000000 |\n| mether       |                                 |\n| gether       |                                 |\n| tether       |                                 |\n+--------------+---------------------------------+\n\n.. code:: python\n\n    >>> denoms.wei\n    1\n    >>> denoms.finney\n    1000000000000000\n    >>> denoms.ether\n    1000000000000000000\n\n``to_wei(value, denomination)`` -> integer\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nConverts ``value`` in the given ``denomination`` to its equivalent in\nthe *wei* denomination.\n\n.. code:: python\n\n    >>> to_wei(1, 'ether')\n    1000000000000000000\n\n``from_wei(value, denomination)`` -> decimal.Decimal\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nConverts the ``value`` in the *wei* denomination to its equivalent in\nthe given ``denomination``. Return value is a ``decimal.Decimal`` with\nthe appropriate precision to be a lossless conversion.\n\n.. code:: python\n\n    >>> from_wei(1000000000000000000, 'ether')\n    Decimal('1')\n    >>> from_wei(123456789, 'ether')\n    Decimal('1.23456789E-10')\n\nEncoding Utils\n~~~~~~~~~~~~~~\n\n``big_endian_to_int(value)`` -> integer\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturns ``value`` converted to an integer (from a big endian\nrepresentation).\n\n.. code:: python\n\n    >>> big_endian_to_int(b'\\x00')\n    0\n    >>> big_endian_to_int(b'\\x01')\n    1\n    >>> big_endian_to_int(b'\\x01\\x00')\n    256\n\n``int_to_big_endian(value)`` -> bytes\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturns ``value`` converted to the big endian representation.\n\n.. code:: python\n\n    >>> int_to_big_endian(0)\n    b'\\x00'\n    >>> int_to_big_endian(1)\n    b'\\x01'\n    >>> int_to_big_endian(256)\n    b'\\x01\\x00'\n\nFormatting Utils\n~~~~~~~~~~~~~~~~\n\n``pad_left(value, to_size, pad_with)`` -> string\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturns ``value`` padded to the length specified by ``to_size`` with the\nstring ``pad_with``.\n\n.. code:: python\n\n    >>> pad_left('test', 6, '0')\n    '00test'\n    >>> pad_left('testing', 6, '0')\n    'testing'\n    >>> pad_left('test', 8, '123')\n    '12312test'\n\n``pad_right(value, to_size, pad_with)`` -> string\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturns ``value`` padded to the length specified by ``to_size`` with the\nstring ``pad_with``.\n\n.. code:: python\n\n    >>> pad_right('test', 6, '0')\n    'test00'\n    >>> pad_right('testing', 6, '0')\n    'testing'\n    >>> pad_right('test', 8, '123')\n    'test12312'\n\nFunctional Utils\n~~~~~~~~~~~~~~~~\n\n``compose(*callables)`` -> callable\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n    **DEPRECATED** in 0.3.0.\n\nReturns a single function which is the composition of the given\ncallables.\n\n::\n\n    >>> def f(v):\n    ...     return v * 3\n    ...\n    >>> def g(v):\n    ...     return v + 2\n    ...\n    >>> def h(v):\n    ...     return v % 5\n    ...\n    >>> compose(f, g, h)(1)\n    0\n    >>> h(g(f(1)))\n    0\n    >>> compose(f, g, h)(2)\n    3\n    >>> h(g(f(1)))\n    3\n    >>> compose(f, g, h)(3)\n    1\n    >>> h(g(f(1)))\n    1\n    >>> compose(f, g, h)(4)\n    4\n    >>> h(g(f(1)))\n    4\n\n``flatten_return(callable)`` -> callable() -> tuple\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nDecorator which performs a non-recursive flattening of the return value\nfrom the given ``callable``.\n\n.. code:: python\n\n    >>> flatten_return(lambda: [[1, 2, 3], [4, 5], [6]])\n    (1, 2, 3, 4, 5, 6)\n\n``sort_return(callable)`` => callable() -> tuple\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nDecorator which sorts the return value from the given ``callable``.\n\n.. code:: python\n\n    >>> flatten_return(lambda: [[1, 2, 3], [4, 5], [6]])\n    (1, 2, 3, 4, 5, 6)\n\n``reversed_return(callable)`` => callable() -> tuple\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nDecorator which reverses the return value from the given ``callable``.\n\n.. code:: python\n\n    >>> reversed_return(lambda: [1, 5, 2, 4, 3])\n    (3, 4, 2, 5, 1)\n\n``to_dict(callable)`` => callable() -> dict\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nDecorator which casts the return value from the given ``callable`` to a\ndictionary.\n\n.. code:: python\n\n    >>> @to_dict\n    ... def build_thing():\n    ...     yield 'a', 1\n    ...     yield 'b', 2\n    ...     yield 'c', 3\n    ...\n    >>> build_thing()\n    {'a': 1, 'b': 2, 'c': 3}\n\n``to_list(callable)`` => callable() -> list\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nDecorator which casts the return value from the given ``callable`` to a\nlist.\n\n.. code:: python\n\n    >>> @to_list\n    ... def build_thing():\n    ...     yield 'a'\n    ...     yield 'b'\n    ...     yield 'c'\n    ...\n    >>> build_thing()\n    ['a', 'b', 'c']\n\n``to_ordered_dict(callable)`` => callable() -> collections.OrderedDict\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nDecorator which casts the return value from the given ``callable`` to an\nordered dictionary of type ``collections.OrderedDict``.\n\n.. code:: python\n\n    >>> @to_ordered_dict\n    ... def build_thing():\n    ...     yield 'd', 4\n    ...     yield 'a', 1\n    ...     yield 'b', 2\n    ...     yield 'c', 3\n    ...\n    >>> build_thing()\n    OrderedDict([('d', 4), ('a', 1), ('b', 2), ('c', 3)])\n\n``to_tuple(callable)`` => callable() -> tuple\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nDecorator which casts the return value from the given ``callable`` to a\ntuple.\n\n.. code:: python\n\n    >>> @to_tuple\n    ... def build_thing():\n    ...     yield 'a'\n    ...     yield 'b'\n    ...     yield 'c'\n    ...\n    >>> build_thing()\n    ('a', 'b', 'c')\n\n``to_set(callable)`` => callable() -> set\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nDecorator which casts the return value from the given ``callable`` to a\nset.\n\n.. code:: python\n\n    >>> @to_set\n    ... def build_thing():\n    ...     yield 'a'\n    ...     yield 'b'\n    ...     yield 'a'  # duplicate\n    ...     yield 'c'\n    ...\n    >>> build_thing()\n    {'a', 'b', 'c'}\n\n``apply_to_return_value(callable)`` => decorator_fn\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThis function takes a single callable and returns a decorator. The\nreturned decorator, when applied to a function, will incercept the\nfunction\u2019s return value, pass it to the callable, and return the value\nreturned by the callable.\n\n.. code:: python\n\n    >>> double = apply_to_return_value(lambda v: v * 2)\n    >>> @double\n    ... def f(v):\n    ...     return v\n    ...\n    >>> f(2)\n    4\n    >>> f(3)\n    6\n\nHexidecimal Utils\n~~~~~~~~~~~~~~~~~\n\n``add_0x_prefix(value)`` -> string\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturns ``value`` with a ``0x`` prefix. If the value is already prefixed\nit is returned as-is.\n\n.. code:: python\n\n    >>> add_0x_prefix('12345')\n    '0x12345'\n    >>> add_0x_prefix('0x12345')\n    '0x12345'\n\n``decode_hex(value)`` -> bytes\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturns ``value`` decoded into a byte string. Accepts any string with or\nwithout the ``0x`` prefix.\n\n.. code:: python\n\n    >>> decode_hex('0x123456')\n    b'\\x124V'\n    >>> decode_hex('123456')\n    b'\\x124V'\n\n``encode_hex(value)`` -> string\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturns ``value`` encoded into a hexidecimal representation with a\n``0x`` prefix\n\n.. code:: python\n\n    >>> encode_hex('\\x01\\x02\\x03')\n    '0x010203'\n\n``is_0x_prefixed(value)`` -> bool\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturns ``True`` if ``value`` has a ``0x`` prefix.\n\n.. code:: python\n\n    >>> is_0x_prefixed('12345')\n    False\n    >>> is_0x_prefixed('0x12345')\n    True\n    >>> is_0x_prefixed(b'0x12345')\n    True\n\n``is_hex(value)`` -> bool\n^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturns ``True`` if ``value`` is a hexidecimal encoded string.\n\n.. code:: python\n\n    >>> is_hex('')\n    False\n    >>> is_hex(b'')\n    False\n    >>> is_hex('0x')\n    True\n    >>> is_hex(b'0x')\n    True\n    >>> is_hex('0X')\n    True\n    >>> is_hex(b'0X')\n    True\n    >>> is_hex('1234567890abcdef')\n    True\n    >>> is_hex('0x1234567890abcdef')\n    True\n    >>> is_hex('0x1234567890ABCDEF')\n    True\n    >>> is_hex('0x1234567890AbCdEf')\n    True\n    >>> is_hex('12345')  # odd length is ok\n    True\n    >>> is_hex('0x12345')  # odd length is ok\n    True\n    >>> is_hex('123456__abcdef')  # non hex characters\n    False\n\n``remove_0x_prefix(value)`` -> string\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturns ``value`` with the ``0x`` prefix stripped. If the value does not\nhave a ``0x`` prefix it is returned as-is.\n\n.. code:: python\n\n    >>> remove_0x_prefix('12345')\n    '12345'\n    >>> remove_0x_prefix('0x12345')\n    '12345'\n    >>> remove_0x_prefix(b'0x12345')\n    b'12345'\n\nString Utils\n~~~~~~~~~~~~\n\n``coerce_args_to_bytes(callable)`` -> callable\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nDecorator which will convert any string arguments both positional or\nkeyword into byte strings using the ``force_bytes`` function. This is a\nrecursive operation which will reach down into mappings and list-like\nobjects as well.\n\n.. code:: python\n\n    >>> @coerce_args_to_bytes\n    ... def do_thing(*args):\n    ...     return args\n    ...\n    >>> do_thing('a', 1, b'a-byte-string', ['a', b'b', 1], {'a': 'a', 'b': ['x', b'y']})\n    (b'a', 1, b'a-byte-string', [b'a', b'b', 1], {'a': b'a', 'b': [b'x', b'y']})\n\n``coerce_args_to_text(callable)`` -> callable\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nDecorator which will convert any string arguments both positional or\nkeyword into text strings using the ``force_text`` function. This is a\nrecursive operation which will reach down into mappings and list-like\nobjects as well.\n\n.. code:: python\n\n    >>> @coerce_args_to_text\n    ... def do_thing(*args):\n    ...     return args\n    ...\n    >>> do_thing('a', 1, b'a-byte-string', ['a', b'b', 1], {'a': 'a', 'b': ['x', b'y']})\n    ('a', 1, 'a-byte-string', ['a', 'b', 1], {'a': 'a', 'b': ['x', 'y']})\n\n``coerce_return_to_bytes(callable)`` -> callable\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nDecorator which will convert any string return values into byte strings\nusing the ``force_text`` function. This is a recursive operation which\nwill reach down into mappings and list-like objects as well.\n\n.. code:: python\n\n    >>> @coerce_return_to_bytes\n    ... def do_thing(*args):\n    ...     return args\n    ...\n    >>> do_thing('a', 1, b'a-byte-string', ['a', b'b', 1], {'a': 'a', 'b': ['x', b'y']})\n    (b'a', 1, b'a-byte-string', [b'a', b'b', 1], {'a': b'a', 'b': [b'x', b'y']})\n\n``coerce_return_to_text(callable)`` -> callable\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nDecorator which will convert any string return values into text strings\nusing the ``force_text`` function. This is a recursive operation which\nwill reach down into mappings and list-like objects as well.\n\n.. code:: python\n\n    >>> @coerce_return_to_bytes\n    ... def do_thing(*args):\n    ...     return args\n    ...\n    >>> do_thing('a', 1, b'a-byte-string', ['a', b'b', 1], {'a': 'a', 'b': ['x', b'y']})\n    ('a', 1, 'a-byte-string', ['a', 'b', 1], {'a': 'a', 'b': ['x', 'y']})\n\n``force_bytes(value, encoding='iso-8859-1')`` -> text\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturns ``value`` encoded into a byte string using the provided\nencoding. By default this uses ``iso-8859-1`` as it can handle all byte\nvalues between ``0-255`` (unlike ``utf8``)\n\n.. code:: python\n\n    >>> force_bytes('abcd')\n    b'abcd'\n    >>> force_bytes(b'abcd')\n    b'abcd'\n\n``force_obj_to_bytes(value)`` -> value\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturns ``value`` with all string elements converted to byte strings by\nrecursivly traversing mappings and list-like elements.\n\n.. code:: python\n\n    >>> force_obj_to_bytes(('a', 1, b'a-byte-string', ['a', b'b', 1], {'a': 'a', 'b': ['x', b'y']}))\n    (b'a', 1, b'a-byte-string', [b'a', b'b', 1], {'a': b'a', 'b': [b'x', b'y']})\n\n``force_obj_to_text(value)`` -> value\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturns ``value`` with all string elements converted to text strings by\nrecursivly traversing mappings and list-like elements.\n\n.. code:: python\n\n    >>> force_obj_to_text(('a', 1, b'a-byte-string', ['a', b'b', 1], {'a': 'a', 'b': ['x', b'y']}))\n    ('a', 1, 'a-byte-string', ['a', 'b', 1], {'a': 'a', 'b': ['x', 'y']})\n\n``force_text(value, encoding='iso-8859-1')`` -> text\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturns ``value`` decoded into a text string using the provided\nencoding. By default this uses ``iso-8859-1`` as it can handle all byte\nvalues between ``0-255`` (unlike ``utf8``)\n\n.. code:: python\n\n    >>> force_text(b'abcd')\n    'abcd'\n    >>> force_text('abcd')\n    'abcd'\n\nType Utils\n~~~~~~~~~~\n\n``is_boolean(value)`` -> bool\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturns ``True`` if ``value`` is of type ``bool``\n\n.. code:: python\n\n    >>> is_boolean(True)\n    True\n    >>> is_boolean(False)\n    False\n    >>> is_boolean(1)\n    False\n\n``is_bytes(value)`` -> bool\n^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturns ``True`` if ``value`` is a byte string or a byte array.\n\n.. code:: python\n\n    >>> is_bytes('abcd')\n    False\n    >>> is_bytes(b'abcd')\n    True\n    >>> is_bytes(bytearray((1, 2, 3)))\n    True\n\n``is_dict(value)`` -> bool\n^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturns ``True`` if ``value`` is a mapping type.\n\n.. code:: python\n\n    >>> is_dict({'a': 1})\n    True\n    >>> is_dict([1, 2, 3])\n    False\n\n``is_integer(value)`` -> bool\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturns ``True`` if ``value`` is an integer\n\n.. code:: python\n\n    >>> is_integer(0)\n    True\n    >>> is_integer(1)\n    True\n    >>> is_integer('1')\n    False\n    >>> is_integer(1.1)\n    False\n\n``is_list_like(value)`` -> bool\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturns ``True`` if ``value`` is a non-string sequence such as a\nsequence (such as a list or tuple).\n\n.. code:: python\n\n    >>> is_list_like('abcd')\n    False\n    >>> is_list_like([])\n    True\n    >>> is_list_like(tuple())\n    True\n\n``is_list(value)`` -> bool\n^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturns ``True`` if ``value`` is a non-string sequence such as a list.\n\n.. code:: python\n\n    >>> is_list('abcd')\n    False\n    >>> is_list([])\n    True\n    >>> is_list(tuple())\n    False\n\n``is_tuple(value)`` -> bool\n^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturns ``True`` if ``value`` is a non-string sequence such as a tuple.\n\n.. code:: python\n\n    >>> is_tuple('abcd')\n    False\n    >>> is_tuple([])\n    False\n    >>> is_tuple(tuple())\n    True\n\n``is_null(value)`` -> bool\n^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturns ``True`` if ``value`` is ``None``\n\n.. code:: python\n\n    >>> is_null(None)\n    True\n    >>> is_null(False)\n    False\n\n``is_number(value)`` -> bool\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturns ``True`` if ``value`` is numeric\n\n.. code:: python\n\n    >>> is_number(1)\n    True\n    >>> is_number(1.1)\n    True\n    >>> is_number('1')\n    False\n    >>> is_number(decimal.Decimal('1'))\n    True\n\n``is_string(value)`` -> bool\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturns ``True`` if ``value`` is of any string type.\n\n.. code:: python\n\n    >>> is_string('abcd')\n    True\n    >>> is_string(b'abcd')\n    True\n    >>> is_string(bytearray((1, 2, 3)))\n    True\n\n``is_text(value)`` -> bool\n^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturns ``True`` if ``value`` is a text string.\n\n.. code:: python\n\n    >>> is_text(u'abcd')\n    True\n    >>> is_text(b'abcd')\n    False\n    >>> is_text(bytearray((1, 2, 3)))\n    False\n\n.. how-to-bumpversion-1:\n\nHow to bumpversion\n^^^^^^^^^^^^^^^^^^\n\nThe version format for this repo is ``{major}.{minor}.{patch}`` for\nstable, and ``{major}.{minor}.{patch}-{stage}.{devnum}`` for unstable\n(``stage`` can be alpha or beta).\n\nTo issue the next version in line, use bumpversion and specify which\npart to bump, like ``bumpversion minor`` or ``bumpversion devnum``.\n\nIf you are in a beta version, ``bumpversion stage`` will switch to a\nstable.\n\nTo issue an unstable version when the current version is stable, specify\nthe new version explicitly, like\n``bumpversion --new-version 4.0.0-alpha.1 devnum``\n\n.. |Join the chat at https://gitter.im/ethereum/eth-utils| image:: https://badges.gitter.im/ethereum/eth-utils.svg\n   :target: https://gitter.im/ethereum/eth-utils\n.. |Build Status| image:: https://travis-ci.org/ethereum/eth-utils.png\n   :target: https://travis-ci.org/ethereum/eth-utils\n",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "https://github.com/ethereum/eth_utils",
    "keywords": "ethereum",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "eth-utils",
    "platform": "",
    "project_url": "https://pypi.org/project/eth-utils/",
    "release_url": "https://pypi.org/project/eth-utils/0.7.4/",
    "requires_dist": [],
    "requires_python": "",
    "summary": "Common utility functions for ethereum codebases.",
    "version": "0.7.4"
  },
  "releases": {
    "0.7.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "cf71539b051d275b34772d3d97ac093b",
          "sha256": "3e1e128b709ad01fe4714623a9c2728c8e6e0be21101aafab697a5e6f05ae006"
        },
        "downloads": -1,
        "filename": "eth_utils-0.7.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "cf71539b051d275b34772d3d97ac093b",
        "packagetype": "bdist_wheel",
        "python_version": "3.5",
        "size": 20932,
        "upload_time": "2017-11-23T00:12:30",
        "url": "https://files.pythonhosted.org/packages/13/d3/43971a62019ef438323801fe743c3d69db89dd9cf20fc887a855d7487b56/eth_utils-0.7.0-py3-none-any.whl"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "8816e00ec9c5a5d969a28a706e5c0df7",
          "sha256": "7891e0c45453bb3913853bae707674af6e00c4269b31c8c4878ad3af76e82eb4"
        },
        "downloads": -1,
        "filename": "eth-utils-0.7.0.tar.gz",
        "has_sig": false,
        "md5_digest": "8816e00ec9c5a5d969a28a706e5c0df7",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 22935,
        "upload_time": "2017-11-23T00:12:22",
        "url": "https://files.pythonhosted.org/packages/cb/8d/3c9a6fad4a71f3503f9efc423b936830bbd3a9429abe8f7ada1b5b6584fa/eth-utils-0.7.0.tar.gz"
      }
    ],
    "0.7.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "072c987b8eb1a44319a3bc819cbd2195",
          "sha256": "72fb8f1dfb79a73a9a979a14f8a3c82de14cbe2abeec50ce73f312c8342a2f0f"
        },
        "downloads": -1,
        "filename": "eth_utils-0.7.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "072c987b8eb1a44319a3bc819cbd2195",
        "packagetype": "bdist_wheel",
        "python_version": "3.5",
        "size": 20922,
        "upload_time": "2017-11-23T00:18:15",
        "url": "https://files.pythonhosted.org/packages/2d/27/245f0e1bf7423c0651798be9ef15cb052b37a8b940a590fbc0788e4c9b7f/eth_utils-0.7.1-py3-none-any.whl"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "8117b5887f098273eacce768cbce7eb3",
          "sha256": "d8cb52e7e1a0570bf23f96d0076b557d6b330a9e0260038b1bdda463aa40a404"
        },
        "downloads": -1,
        "filename": "eth-utils-0.7.1.tar.gz",
        "has_sig": false,
        "md5_digest": "8117b5887f098273eacce768cbce7eb3",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 22900,
        "upload_time": "2017-11-23T00:18:08",
        "url": "https://files.pythonhosted.org/packages/a4/ef/1b680544c5285fe3492258c47df784a8b872af0fec2ba0b64af61a0814de/eth-utils-0.7.1.tar.gz"
      }
    ],
    "0.7.2": [
      {
        "comment_text": "",
        "digests": {
          "md5": "f579b030781f228e6447a158cd55cf87",
          "sha256": "7db75a9f242c24faf12edcc6d13c61aaffa605b180c90d8107c0edf5be3a9984"
        },
        "downloads": -1,
        "filename": "eth_utils-0.7.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "f579b030781f228e6447a158cd55cf87",
        "packagetype": "bdist_wheel",
        "python_version": "3.5",
        "size": 21695,
        "upload_time": "2017-12-18T16:58:12",
        "url": "https://files.pythonhosted.org/packages/a3/b4/776c94a9ee34a216605af24f68aca6a4e8797438feb465d83df56875a013/eth_utils-0.7.2-py3-none-any.whl"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "540e04ce611aa6cea0478ddb6e56e7e3",
          "sha256": "122e5189196a543776936d228cadb6968f37cc42a78bb1801f84ee738af9100d"
        },
        "downloads": -1,
        "filename": "eth-utils-0.7.2.tar.gz",
        "has_sig": false,
        "md5_digest": "540e04ce611aa6cea0478ddb6e56e7e3",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 24556,
        "upload_time": "2017-12-18T16:58:04",
        "url": "https://files.pythonhosted.org/packages/56/dd/37f886d4a260988c96f63f6e8f826e0da4ea1d96aa4cab59e9e7724e5897/eth-utils-0.7.2.tar.gz"
      }
    ],
    "0.7.3": [
      {
        "comment_text": "",
        "digests": {
          "md5": "c9270726e9208e90dc330b46b693297e",
          "sha256": "2170f63e1a29b4edbad392c36677435edfd307711423b65d8cf1982a9d57be35"
        },
        "downloads": -1,
        "filename": "eth_utils-0.7.3-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "c9270726e9208e90dc330b46b693297e",
        "packagetype": "bdist_wheel",
        "python_version": "3.5",
        "size": 21699,
        "upload_time": "2017-12-18T17:10:46",
        "url": "https://files.pythonhosted.org/packages/fe/0f/7272b4b515b4b89c0b85c370be08157c748a76c88180fdb611eec34b6ad5/eth_utils-0.7.3-py3-none-any.whl"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "f76fe7538ff62bcf9211bd16d9ad1b4f",
          "sha256": "8be9b39a8db50584086c9165740ea58e49744143a20084c5419430a37940cae6"
        },
        "downloads": -1,
        "filename": "eth-utils-0.7.3.tar.gz",
        "has_sig": false,
        "md5_digest": "f76fe7538ff62bcf9211bd16d9ad1b4f",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 24560,
        "upload_time": "2017-12-18T17:10:38",
        "url": "https://files.pythonhosted.org/packages/da/fd/db54ac3de4856285113aa093ec9823396162dd6274f49d4ce8f858f3aa08/eth-utils-0.7.3.tar.gz"
      }
    ],
    "0.7.4": [
      {
        "comment_text": "",
        "digests": {
          "md5": "824d41ac5eaaba9ed21c3683361fcfdb",
          "sha256": "202a813b5ef0812d5f0d050cb725b1f4a6212a08d0631099cbee6fd9df1bfa4f"
        },
        "downloads": -1,
        "filename": "eth_utils-0.7.4-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "824d41ac5eaaba9ed21c3683361fcfdb",
        "packagetype": "bdist_wheel",
        "python_version": "3.5",
        "size": 21724,
        "upload_time": "2017-12-29T20:26:25",
        "url": "https://files.pythonhosted.org/packages/88/56/b66f82da6d331fa7b20522bf671d4ece677925f72370c4e98a5eea658f3d/eth_utils-0.7.4-py3-none-any.whl"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "4f5fd3d8e9627e47801e49ecddc501a0",
          "sha256": "fea1953c6ae90a4f5e97745a50c1e1f5ce43d63f28c9fe1659725177c28275a1"
        },
        "downloads": -1,
        "filename": "eth-utils-0.7.4.tar.gz",
        "has_sig": false,
        "md5_digest": "4f5fd3d8e9627e47801e49ecddc501a0",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 24606,
        "upload_time": "2017-12-29T20:26:18",
        "url": "https://files.pythonhosted.org/packages/90/41/e4c03de441943895b759c78fc066553435c4bba7b478282686c16c473267/eth-utils-0.7.4.tar.gz"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "824d41ac5eaaba9ed21c3683361fcfdb",
        "sha256": "202a813b5ef0812d5f0d050cb725b1f4a6212a08d0631099cbee6fd9df1bfa4f"
      },
      "downloads": -1,
      "filename": "eth_utils-0.7.4-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "824d41ac5eaaba9ed21c3683361fcfdb",
      "packagetype": "bdist_wheel",
      "python_version": "3.5",
      "size": 21724,
      "upload_time": "2017-12-29T20:26:25",
      "url": "https://files.pythonhosted.org/packages/88/56/b66f82da6d331fa7b20522bf671d4ece677925f72370c4e98a5eea658f3d/eth_utils-0.7.4-py3-none-any.whl"
    },
    {
      "comment_text": "",
      "digests": {
        "md5": "4f5fd3d8e9627e47801e49ecddc501a0",
        "sha256": "fea1953c6ae90a4f5e97745a50c1e1f5ce43d63f28c9fe1659725177c28275a1"
      },
      "downloads": -1,
      "filename": "eth-utils-0.7.4.tar.gz",
      "has_sig": false,
      "md5_digest": "4f5fd3d8e9627e47801e49ecddc501a0",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 24606,
      "upload_time": "2017-12-29T20:26:18",
      "url": "https://files.pythonhosted.org/packages/90/41/e4c03de441943895b759c78fc066553435c4bba7b478282686c16c473267/eth-utils-0.7.4.tar.gz"
    }
  ]
}