{
  "info": {
    "author": "Bryan W. Berry",
    "author_email": "bryan.berry@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 4 - Beta",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: BSD License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 2.7",
      "Programming Language :: Python :: 3.3",
      "Programming Language :: Python :: 3.4",
      "Topic :: Software Development :: Libraries :: Python Modules"
    ],
    "description": "======================================================================\ntryme - Error handling for humans\n======================================================================\n\n\nIntroduction\n============\n\n\nWhat?\n-----\n\nTryme is a module that makes it easier to treat errors as values. Additionally,\ntryme helps you handle the absence of a value (None) in a more composable way.\n\nThe entire tryme library is contained in a single file `tryme.py` to\nmake it as easy as possible to drop into an existing project.\n\nWhy?\n----\n\nTreating errors as values makes it easier to retain information related to errors and\nlets us defer error handling until the last possible moment. In contrast, exceptions are\nfundamentally lossy in they by convention contain tracebacks and error messages not values.\nAdditionally, they require immediate handling.\n\nHere are a few tasks where we might wish to defer error handling.\n\n* Processing multiple operations in batch where one or more operations may fail\n* Executing long running operations that require multiple retries\n\nTreating failed operations as values rather than exceptions can simplify conditional logic and\nmake programs more composable.\n  \n*But c'mon that is unpythonic*\n\nA common convention for handling errors in Python is to raise exceptions. There\nis no reason however that this is always the best mechanism to handle errors,\nespecially *expected errors*. The author of this package feels strongly\nthat exceptions are best used to represent exceptional circumstances\nsuch as when undefined behavior is encountered.\n\n\nTreating Errors as Values\n------------------------------\n\nPython does not have a built-in convention for treating errors as values\nother than try/except.\n\ntryme introduces the Failure/Success convention of wrapping failed or\nsuccessful results in a container class.\n\nHere is how an error might be treated using good old ``try/except``::\n\n  import requests\n\n\n  def google_is_accessible():\n      response = requests.get('http://google.com')\n      if response.ok:\n          return response.ok\n      else:\n          raise RuntimeError(\"http request to google.com failed with status code %s\" % response.status_code)\n\n   try:\n       is_accessible = google_is_accessible()\n   except RuntimeError:\n       is_accessible = False\n\n\nHere is the same task using the ``tryme.Success`` and ``tryme.Failure``::\n\n  import requests\n\n\n  def google_is_accessible():\n      response = requests.get('http://google.com')\n      if response.ok:\n          return Success(response)\n      else:\n          return Failure(response)\n\n   result = google_is_accessible()\n   is_accessible = result.succeeded()\n   # In the result value, we still have access to all of the information about the response\n\n\nThe utility method ``try_out`` executes a callable and wraps a raised exception\nin a Failure class. If an exception was not raised, a Success is returned\n\n::\n\n  >>> from tryme import try_out\n  >>> result = try_out(lambda: 1 / 0)\n  >>> print result\n  Failure(ZeroDivisionError('integer division or modulo by zero',))\n  >>> exc = result.value\n  >>> exc\n  ZeroDivisionError('integer division or modulo by zero',)\n  >>> # the following would fail as it does not catch the correct exception, ZeroDivisionError\n  >>> # result = try_out(lambda: 1 / 0, exception=ValueError)\n  >>> result = try_out(lambda: 1 / 1)\n  >>> print result\n  Success(1)\n  >>> result.value\n  1\n\n      \nRetrying with Style\n---------------------------------------------------\n\nLet's say we want to create a single server using a new Cloud computing provider named\nHighlyVariable Inc. HighlyVariable can provision our new server in a few seconds, several minutes,\nor occasionally not at all. This author has used cloud services where the \"not at all\" is not so\nuncommon an outcome!\n\nLet's create a `server_ready` function that returns a `Success` when the server\nis ready, a `Failure` when the operation times out. A \"terminal\" state such as\n\"Ready\" or \"Failed\" will terminate retries immediately whereas a Failed will\ncontinue execution of the `server_ready` function until 300 seconds after the\nfunction was first called.\n\nIf our new server is not ready after 300 seconds, `server_ready` will return an\ninstance of `Failure`.\n\n::\n\n   from highlyvariable import create_instance, get_instance_status\n   from tryme import retry_decorator\n\n   def make_server(name):\n       create_instance(name)\n       \n   \n   @retry\n   def wait_for_server_statuses(name, statuses):\n       status = get_instance_status(name)\n       if status in statuses:\n           return Success(status)\n       else:\n           return Failure(\"Not ready yet\")\n\n           \n   def server_ready(name):\n       # the decorated function will return two values, a log accounting for the time spent retrying\n       # and the actual result\n       log, result = wait_for_server_statuses(name, ['Ready', 'Failed'])\n       # a failure here only indicates a timeout\n       if result.failed():\n           return Failure(\"Server %s not ready after %d seconds\" % (name, log.elapsed))\n\n       # unwrap the value\n       status = result.get()\n       if status == 'Ready':\n           return Success('server %s is ready after %d seconds and %d attempts!\"\n                          % (name, log.elapsed, log.count))\n       else:\n           return Failure('server %s failed after %d seconds!\"\n                          % (name, log.elapsed))\n\n   make_server('jenkins')\n   result = server_ready('jenkins')\n   assert result.succeeded()\n   # prints \"Server jenkins is ready after n seconds and n attempts!\"\n   result.to_console()\n   \n\n \nThere something a little weird about the above example. Why did we return Success when the status was\n\"Failed\"? This is because the return value of Failure in the wrapped function is a signal to the `@retry` decorator to continue retrying until the timeout is reached or an exception is raised. \n\n\n\n\nRequirements\n============\n\n- CPython >= 2.7\n\n\nBackground\n============\n\nThis package is inspired by Philip Xu's excellent `monad package <https://github.com/pyx/monad>`_.\nIt also takes some inspiration from the excellent `vavr <https://vavr.io>`_ library for java and the Scala language.\nSee this excellent `tutorial <http://danielwestheide.com/blog/2012/12/26/the-neophytes-guide-to-scala-part-6-error-handling-with-try.html>`_\non the Try utility in Scala.\n\nPssssh! While this package uses *gasp* monads as the core abstraction it does not provide\ngeneral purpose implementations of monad, applicatives, and functors. Further it does\nnot attempt to overload common Python operators to support function composition.\n\n\nInstallation\n============\n\nInstall from PyPI::\n\n  pip install smonad\n\nInstall from source, download source package, decompress, then ``cd`` into source directory, run::\n\n  make install\n\n\nLicense\n=======\n\nBSD New, see LICENSE for details.\n\n\nLinks\n=====\n\nDocumentation:\n  http://smonad.readthedocs.org/\n\nIssue Tracker:\n  https://github.com/bryanwb/smonad/issues/\n\nSource Package @ PyPI:\n  https://pypi.python.org/pypi/smonad/\n\nGit Repository @ Github:\n  https://github.com/bryanwb/smonad/",
    "docs_url": null,
    "download_url": "https://github.com/bryanwb/tryme/archive/0.0.1.zip",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "https://github.com/bryanwb/tryme/",
    "keywords": "",
    "license": "BSD-New",
    "maintainer": "",
    "maintainer_email": "",
    "name": "tryme",
    "platform": "",
    "project_url": "https://pypi.org/project/tryme/",
    "release_url": "https://pypi.org/project/tryme/0.0.1/",
    "requires_dist": [],
    "requires_python": "",
    "summary": "Error handling for humans",
    "version": "0.0.1"
  },
  "releases": {
    "0.0.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "29122c7bcf6309da08b3540629ad21d1",
          "sha256": "d9d9ef8aa702c06f5c5021560651ad86847f539f0aeaad9a863c9960790b6d24"
        },
        "downloads": 0,
        "filename": "tryme-0.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "29122c7bcf6309da08b3540629ad21d1",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 11032,
        "upload_time": "2017-09-20T05:11:53",
        "url": "https://files.pythonhosted.org/packages/a3/f0/c1571f629175e24b224bead692ee9ea690276da98727b42953f8ebe26b8e/tryme-0.0.1.tar.gz"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "29122c7bcf6309da08b3540629ad21d1",
        "sha256": "d9d9ef8aa702c06f5c5021560651ad86847f539f0aeaad9a863c9960790b6d24"
      },
      "downloads": 0,
      "filename": "tryme-0.0.1.tar.gz",
      "has_sig": false,
      "md5_digest": "29122c7bcf6309da08b3540629ad21d1",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 11032,
      "upload_time": "2017-09-20T05:11:53",
      "url": "https://files.pythonhosted.org/packages/a3/f0/c1571f629175e24b224bead692ee9ea690276da98727b42953f8ebe26b8e/tryme-0.0.1.tar.gz"
    }
  ]
}