{
  "info": {
    "author": "Richard Campen",
    "author_email": "richard@campen.co",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 4 - Beta",
      "Environment :: Win32 (MS Windows)",
      "Intended Audience :: End Users/Desktop",
      "Intended Audience :: Science/Research",
      "License :: OSI Approved :: BSD License",
      "Natural Language :: English",
      "Operating System :: Microsoft :: Windows :: Windows 10",
      "Programming Language :: Python :: 3.6",
      "Topic :: Scientific/Engineering :: Bio-Informatics"
    ],
    "description": "# Rhea\r\n\r\nv0.1.0\r\n\r\nCopyright (c) 2017, Richard Campen All rights reserved.\r\n\r\nSee LICENSE.txt for full license conditions.\r\n\r\n---\r\n\r\n### Description\r\n\r\nA python wrapper for the command line version of the bioinformatics tool \r\n[mothur](https://www.mothur.org/).\r\n\r\nRhea was inspired by the [ipython-mothurmagic](https://github.com/SchlossLab/ipython-mothurmagic) module, but with an \r\nintention to provide a more general python wrapper that would work outside of the IPython/Jupyter notebook environment, \r\nas well as provide support for mothur's `current` keyword functionality.\r\n\r\n**Note:** This module has only been tested with mothur v1.39.5 and python 3.6 on Windows 10 (64-bit). It should in \r\ntheory work with other versions of mothur, but the older the version the less likely as this module relies upon some of \r\nthe more recent mothur commands/output to function properly.\r\n\r\n### Basic Usage\r\n\r\nThe use of this module requires that mothur is in the users `PATH` environment variable.\r\n\r\nUse of this module revolves around the `Mothur` class that catches method calls and passes them off to mothur to be run \r\nas commands. An instance of the `Mothur` class needs to be created before running any commands:\r\n\r\n    # create instance of Mothur class\r\n    from rhea import Mothur\r\n    m = Mothur()\r\n    \r\nCommands in mothur can then be executed as methods of the `Mothur` class instance using the same names you would use \r\nwithin the command line version of mothur:\r\n\r\n    # run the mothur help command\r\n    m.help()\r\n\r\nUnlike the command line version, command parameters must be passed as strings, integers, or floats:\r\n\r\n    # running make contigs using str input for file parameter, and int for processor paramenter\r\n    m.make.contigs(file='stability.files', processors=2)\r\n    \r\nFailing to do so will generally result in python raising a `NameError`:\r\n\r\n    # running make contigs in an interpreter session without passing file parameter as a string\r\n    >>> m.make.contigs(file=stability.files)\r\n    Traceback (most recent call last):\r\n      File \"<stdin>\", line 1, in <module>\r\n    NameError: name 'stability' is not defined\r\n\r\nThere is also full implementation of the `current` keyword used in the command line version of mothur:    \r\n       \r\n    # run the mothur summary.seqs command using the 'current' option\r\n    # NOTE: current is being passed as a string\r\n    m.summary.seqs(fasta='current')\r\n     \r\n    # like the command line version, you don't even need to specify \r\n    # the 'current' keyword for some commands\r\n    m.summary.seqs() \r\n    \r\nBehind the scenes, the `current` keyword is enabled by appending the users command with the `get.current()` command to \r\nlist the current directories and files being used by mothur, parsing of the output to extract this information, and \r\nprepending future commands with `set.dir()` and `set.current()` to tell mothur what these should be. This is necessary \r\nas each call to mothur is executed as a separate mothur session and therefore mothur can not store this information \r\nitself.\r\n\r\n---\r\n\r\n### Advanced Usage\r\n\r\nThe current files and current directories for use in mothur are stored in dictionary attributes of the `Mothur` \r\ninstance, `current_files` and `current_dirs` respectivley. These values can be passed to mothur commands, e.g:\r\n\r\n    # passing current fasta file to summary.seqs()\r\n    m.summary.seqs(fasta=m.current_files['fasta'])\r\n       \r\nThe `current` keyword is actually just a shortcut for this functionality so it will always be easier to just pass \r\n`'current'`. However, this demonstrates that the paramters of the mothur commands can accept any variable as long as it \r\nwill resolve to something that mothur accepts, in the above example the dictionary value it resolves to a string that is\r\nthe path to a `.fasta` file. As a better example, you could perform classification of sequences at multiple defined \r\ncutoffs as follows:\r\n\r\n    # iterate over list off possible cutoff values\r\n    for cutoff in [70, 80, 90]:   \r\n        # save outputs to different folders, but keep input the same\r\n        output_dir = 'cutoff_%s' % cutoff\r\n        m.set.dir(output=output_dir, input='.')\r\n        m.classify.seqs(fasta='current', count='current', reference='reference.fasta', taxonomy='referenece.tax', cutoff=cutoff)\r\n        \r\nThis may be a convoluted example, but it demonstrates the functionality well. One note of caution with this approach is \r\nthat depending on the mothur command and the parameter you are changing, you may be overwriting your output files as you \r\ngo. This is the reason for saving each output to a different folder in the above example.\r\n\r\nYou can instantiate a `Mothur` instance with predefined current file and directory dictionaries:\r\n\r\n    m = Mothur(current_files=my_predefined_files_dict, current_dirs=my_predefined_files_dict)\r\n\r\nYou can also modify the contents of these dictionaries in between mothur commands. For example in the previous example \r\nwhere we classified at different cutoffs, we could have instead controlled the input and output directories as such:\r\n\r\n    for cutoff in [70, 80, 90]:   \r\n        # save outputs to different folders, but keep input the same\r\n        m.current_dirs['output'] = 'cutoff_%s' % cutoff\r\n        m.current_dirs['input'] = '.'\r\n\r\n---\r\n\r\n### Configuration \r\n    \r\nThe `Mothur` class stores configuration options for how mothur is executed. These options include `verbosity` to control\r\nhow much output there is, and `suppress_logfile` which suppresses the creation of the mothur logfile. \r\n\r\nWhen `verbosity` is set to `0` there is no output printed, `1` prints the normal output as would be seen with command \r\nline execution (minus the header that contains the mothur version and runtime information), and `2` displays all output\r\nincluding the commands being executed behind the scenes to enable the `current` keyword to work. The default option is \r\n`0`, with `1` being useful when you want to see the standard mothur output, and `2` being useful for debugging purposes. \r\n\r\nThe `supress_logfile` option is useful when you don't want the log files, such as when running in an Jupyter (nee \r\nIPython) notebook with `verbosity=1`, in which case you already have a record of mothur's output and the mothur logfiles\r\nare superfluous.\r\n\r\n**Note:** Currently, due to the way that mothur creates the logfiles, a logfile will always be created BUT it will be \r\ncleaned up upon successful exectuion if `suppress_logfile=True`. However, if mothur fails to successfully execute, i.e. \r\nexecution hangs or is interrupted, the logfile will not be cleaned up. For relevent discussion of this behaviour in \r\nmothur see [here](https://github.com/mothur/mothur/issues/281) and [here](https://github.com/mothur/mothur/issues/377).\r\n\r\nYou can also instantiate the `Mothur` object with your desired configuration options.\r\n\r\n    m = Mothur(verbosity=1, suppress_logfile=True)\r\n    \r\n---\r\n\r\n### ToDo:\r\n\r\n* improve unittest code coverage\r\n* test previous mothur releases\r\n* test different OS's\r\n* test older python releases, especially 2.7\r\n",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "https://github.com/campenr/rhea",
    "keywords": "bioinformatics mothur",
    "license": "Modified BSD License",
    "maintainer": "",
    "maintainer_email": "",
    "name": "Rhea",
    "platform": "",
    "project_url": "https://pypi.org/project/Rhea/",
    "release_url": "https://pypi.org/project/Rhea/0.1.0/",
    "requires_dist": [],
    "requires_python": "",
    "summary": "Python wrapper for the bioinformatics tool mothur",
    "version": "0.1.0"
  },
  "releases": {
    "0.1.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "a6050f5fc83bb9f64650ce6c8949f920",
          "sha256": "12af73095a020c987765d64b114f2e1f8d38b68127e4433503b9b1b7a9aa7be2"
        },
        "downloads": 0,
        "filename": "Rhea-0.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "a6050f5fc83bb9f64650ce6c8949f920",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 35564,
        "upload_time": "2017-10-01T01:03:06",
        "url": "https://files.pythonhosted.org/packages/73/3f/fa73e9668570fb81159838510d0348be9afc31ccb746218e0e777b35b55f/Rhea-0.1.0.tar.gz"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "a6050f5fc83bb9f64650ce6c8949f920",
        "sha256": "12af73095a020c987765d64b114f2e1f8d38b68127e4433503b9b1b7a9aa7be2"
      },
      "downloads": 0,
      "filename": "Rhea-0.1.0.tar.gz",
      "has_sig": false,
      "md5_digest": "a6050f5fc83bb9f64650ce6c8949f920",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 35564,
      "upload_time": "2017-10-01T01:03:06",
      "url": "https://files.pythonhosted.org/packages/73/3f/fa73e9668570fb81159838510d0348be9afc31ccb746218e0e777b35b55f/Rhea-0.1.0.tar.gz"
    }
  ]
}