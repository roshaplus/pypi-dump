{
  "info": {
    "author": "Lars van Gemerden",
    "author_email": "gemerden@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 4 - Beta",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: MIT License",
      "Programming Language :: Python :: 2",
      "Programming Language :: Python :: 2.7",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.3",
      "Programming Language :: Python :: 3.4",
      "Programming Language :: Python :: 3.5",
      "Programming Language :: Python :: 3.6",
      "Topic :: Software Development"
    ],
    "description": "![Travis](https://travis-ci.org/gemerden/wildpath.svg?branch=master)\r\n\r\n# WildPath\r\n\r\nA path abstraction to access items in composite (e.g. JSON) objects in python.\r\n\r\n## Introduction\r\n\r\nThis module is intended primarily as a practical tool to access data in complex data structures. Especially accessing multiple items usually requires for-loops or other constructs and there is no straightforward way to pass nested locations as single parameters. This module solves this problprecedenceoducing 2 classes: `Path` and `WildPath`:\r\n\r\n  - `Path` is optimized for speed, allowing to get, set and delete single items in the data structure,\r\n  - `WildPath` allows wildcards and boolean logic (and, or, not) in paths to get, set and delete to multiple items in one call,\r\n  -  Both have iterators (in the common baseclass) to run through all paths and values in a data structure.\r\n\r\nAs an typical example we take the JSON response of a call to `maps.googleapis.com` for the route between 2 addresses. The response is over 390 lines of JSON if nicely formatted. However we will only be interested in the geo_locations of the individual steps (turn-by-turn instructions) of the route.\r\n\r\nIn normal code this would look something like (with `json_route` the result from the call to the google API):\r\n```python\r\ndef get_geo_locations(json_route):\r\n    geo_locs = []\r\n    for json_step in json_route[\"routes\"][0][\"legs\"][0][\"steps\"]:  #  there is only 1 route and 1 leg in the response\r\n        geo_locs.append({\"start_location\": json_step[\"start_location\"],\r\n                         \"end_location\": json_step[\"end_location\"]})\r\n    return geo_locs\r\n\r\ngeo_locations = get_geo_locations(json_route)\r\n```\r\n\r\nUsing `WildPath` the same result is obtained by:\r\n\r\n```python\r\nlocation_path = WildPath(\"routes.0.legs.0.steps.*.*_location\")\r\n\r\ngeo_locations = location_path.get_in(json_route)\r\n```\r\n\r\nBoth produce the same list of items:\r\n```python\r\n[\r\n    {\r\n        \"start_location\": {\r\n            \"lat\": 52.0800134,\r\n            \"lng\": 4.3271703\r\n        },\r\n        \"end_location\": {\r\n            \"lat\": 52.0805958,\r\n            \"lng\": 4.3286669\r\n        }\r\n    }, \r\n    ...\r\n]\r\n```\r\nEssentially the function definition is replaced by a string, using `WildPath.get_in` for the correct lookup logic. This has some advantages:\r\n\r\n - Less lines of code means lower likelyhood of bugs,\r\n - Better readability and maintainablity (once you get used to the path-notation),\r\n - A `Path` or `WildPath` is easily serializable (`str(Path(\"a.b.c\")) == \"a.b.c\"`), where a function definition is not.\r\n\r\n## Prerequisites\r\nThe module `wildpaths` has been tested for both `python 2.7` and `python 3.3 - 3.6`. `wildpath` uses `boolean.py` (`pip install boolean.py`). Note the `.py`.\r\n\r\n## Functionality\r\nThe **`Path`** class supports, with e.g. `path = Path(\"a.0.b\")` and `obj = {\"a\": [{\"b\": 1}]}`:\r\n\r\n - `get_in`: getting items from data structures: `path.get_in(obj)`,\r\n - `set_in`: setting values in data structures: `path.set_in(obj, value)`,\r\n - `del_in`: deleting items from data structures: `path.del_in(obj)`,\r\n - `has_in`: checking whether a value exists at path: `path.has_in(obj)`,\r\n - `pop_in`: deleting and returning items from data structures: `path.pop_in(obj)`.\r\n\r\n It also has some iterators that run through all paths and values in a data structure:\r\n\r\n - `Path.items(obj)`: iterator over all `(path, value)` tuples in the object, \r\n - `Path.paths(obj)`: iterator over all paths in the object, \r\n - `Path.values(obj)`: iterator over all values in the object. \r\n\r\nThe **`WildPath`** class supports the same functionality as `Path`, but with the following additions:\r\n\r\n - Keys referring to mappings (e.g. `dict`) or python class objects can contain wildcards: `WildPath(\"*.a*.b?\")`, with `*` for any string and `?` for any single character. Wildcards use the standard python `fnmatch.fnmatchcase`,\r\n - Keys referring to sequences (e.g. `list`, `tuple`) can contain slices: `WildPath(\"1:3.::2\")`, with `:` from standard python slice notation `some_list[start:stop:step]`,\r\n - All keys can contain boolean logic, using `&` for AND, `|` for OR and `!` for NOT: `WildPath(\"a*&!*b\")`: keys starting with `'a'` and not ending with `'b'`.\r\n\r\nNote that:\r\n - The iterator methods of `WildPath` return paths of type `WildPath`, instead of `Path`,\r\n - If a key or index is not found in the data, a `KeyError` or `IndexError` will be raised,\r\n - `get_in` can take a `default` parameter, that is returned if no value exists at the path location: `path.get_in(obj, None)`,\r\n - Using wildpaths will return instances of the classes in the original object for mappings and sequences. For (other) python objects it will return a `dict`. For example `WildPath(\":2\").get_in((1, 2, 3))` will return `(1, 2)`.\r\n\r\n\r\n## Examples\r\nStarting with this example structure of an agenda item in some tool:\r\n\r\n ```python\r\nagenda = {\r\n    \"meeting\": \"progress on project X\",\r\n    \"date\": \"2017-8-14\",\r\n    \"start_time\": \"10:00\",\r\n    \"end_time\": \"11:00\",\r\n    \"invited\": [\"Joe\", \"Ann\", \"Boo\"],\r\n    \"items\": [\r\n        {\r\n            \"name\": \"opening\",\r\n            \"duration\": \"5 minutes\",\r\n            \"subjects\": [\"purpose of the meeting\"],\r\n        },\r\n        {\r\n            \"name\": \"progress\",\r\n            \"duration\": \"25 minutes\",\r\n            \"subjects\": [\"milestones\", \"project delays\", \"actions\"],\r\n        },\r\n        {\r\n            \"name\": \"closing\",\r\n            \"duration\": \"5 minutes\",\r\n            \"subjects\": [\"questions\", \"roundup\"],\r\n        },\r\n    ]\r\n}\r\n```\r\n\r\n\r\n### class `Path`\r\nThe 'Path' class let you get, set or delete items at a specific location:\r\n\r\n```python\r\nfrom wildpath.paths import Path\r\n\r\npath = Path(\"items.0.duration\")\r\nassert str(path) == \"items.0.duration\"  # str(..) returns the original path string\r\n\r\nduration = path.get_in(agenda)  # retrieves value at path location\r\nassert duration == \"5 minutes\"\r\n\r\npath.set_in(agenda, \"10 minutes\")  # sets value at path location\r\nassert path.get_in(agenda) == \"10 minutes\"\r\n\r\npath.del_in(agenda)  # deletes key-value at path loation\r\nassert path.has_in(agenda) == False  # has_in checks the presence of a value at the path location\r\n```\r\n\r\n### class `WildPath`\r\n`WildPath` supports the same API as `Path`, but additionally lets you use wildcards and slicing in the path definition to access multiple items in the structure (the `Path` class is there because for single lookups it is substantially faster):\r\n\r\n```python\r\nfrom wildpath.paths import WildPath\r\n\r\nwildpath = WildPath(\"items.*.duration\")  # basic 'star' notation\r\n\r\ndurations = wildpath.get_in(agenda)  # retrieves all the durations of the items on the agenda\r\nassert durations == [\"5 minutes\", \"25 minutes\", \"5 minutes\"]\r\n\r\nwildpath.set_in(agenda, [\"10 minutes\", \"50 minutes\", \"10 minutes\"])  # setting all the values, \r\nassert wildpath.get_in(agenda) == [\"10 minutes\", \"50 minutes\", \"10 minutes\"]\r\n\r\nwildpath.set_in(agenda, \"30 minutes\")  #  or replacing all with a single value, \r\nassert wildpath.get_in(agenda) == [\"30 minutes\", \"30 minutes\", \"30 minutes\"]\r\n\r\nwildpath.del_in(agenda)  # delete all the items at wildpath from the structure\r\nassert wildpath.has_in(agenda) == False  # `has_in` checks if all the items at wildpath are there\r\n```\r\nTo get the start and end time of the meeting:\r\n```python\r\nwildpath = WildPath(\"*_time\")\r\nassert wildpath.get_in(agenda) == {\"start_time\": \"10:00\", \"end_time\": \"11:00\"}\r\n```\r\nSimilarly it supports slices as wildcard like path-elements \r\n```python\r\nwildpath = WildPath(\"items.0:2.name\")\r\nassert wildpath.get_in(agenda) == [\"opening\", \"progress\"]\r\n\r\nwildpath = WildPath(\"items.!0:2.name\")  # slices can be negated\r\nassert wildpath.get_in(agenda) == [ \"closing\"]\r\n\r\nwildpath = WildPath(\"items.-1::-1.name\")  # extended slicing also works, but orders are not reversed for a negative step parameter\r\nassert wildpath.get_in(agenda) == [\"opening\", \"progress\", \"closing\"]\r\n```\r\n\r\nWildPath supports a boolean logic:\r\n```python\r\n# '|' is the OR operator\r\n\r\nassert WildPath(\"start_time|end_time\").get_in(agenda) == {\"start_time\": \"10:00\", \"end_time\": \"11:00\"}\r\n\r\n# '&' is the AND operator\r\n\r\nassert WildPath(\"start_*&*_time\").get_in(agenda) == {\"start_time\": \"10:00\"}\r\n\r\n\r\n# '!' is the NOT operator:\r\n\r\nassert WildPath(\"!item?\").get_in({\"item1\": \"chair\", \"item2\": \"table\", \"count\": 2}) == {\"count\": 2}\r\n\r\n# parentheses can be used to indicate precedence:\r\n\r\nassert WildPath(\"!(a|b)\") != WildPath(\"!a|b\")\r\n```\r\nSimilarly it supports slices as wildcard like path-elements \r\n```python\r\nwildpath = WildPath(\"items.0:2.name\")\r\nassert wildpath.get_in(agenda) == [\"opening\", \"progress\"]\r\n\r\nwildpath = WildPath(\"items.!0:2.name\")  # slices can be negated\r\nassert wildpath.get_in(agenda) == [ \"closing\"]\r\n\r\nwildpath = WildPath(\"items.-1::-1.name\")  # extended slicing also works, but orders are not reversed for a negative step parameter\r\nassert wildpath.get_in(agenda) == [\"opening\", \"progress\", \"closing\"]\r\n```\r\n**Notes**:\r\n - WildPath also supports attribute lookup in nested objects, list attributes in objects, etc.,\r\n - All the examples of `WildPath.get_in` also work for `set_in`, `del_in`, `pop_in` and `has_in`,\r\n - In `wildpath.set_in(obj, value)`, value can either be a single value (which will be used to set all target values), or a data structure with the same 'shape' as the result of `wildpath.get_in(obj)`.\r\n\r\n### Iterators\r\nThe Path classes also have some iterator classmethods defined:\r\n\r\n```python\r\nfrom wildpath.paths import Path\r\n\r\nfor path, value in Path.items(agenda):\r\n    print(\" \".join([str(path), \":\", value]))\r\n```\r\nprints\r\n```text\r\ndate : 2017-8-14\r\nend_time : 11:00\r\ninvited.0 : Joe\r\ninvited.1 : Ann\r\ninvited.2 : Boo\r\nitems.0.duration : 5 minutes\r\nitems.0.name : opening\r\nitems.0.subjects.0 : purpose of the meeting\r\nitems.1.duration : 25 minutes\r\nitems.1.name : progress\r\n\r\netc...\r\n```\r\nTo create an alternative representation of the datastructure:\r\n```python\r\nD = {str(path): value for path, value in Path.items(agenda)}\r\n```\r\nPath.items() has an optional argument `all` that if set to `True` will iterate over all path, value combination, including intermediary paths:\r\n```python\r\nfrom wildpath.paths import Path\r\n\r\nfor path, value in Path.items(agenda, all=True):\r\n    print(\" \".join([str(path), \":\", value]))\r\n```\r\nwill print:\r\n```text\r\ndate : 2017-8-14\r\nend_time : 11:00\r\ninvited : ['Joe', 'Ann', 'Boo']\r\ninvited.0 : Joe\r\ninvited.1 : Ann\r\ninvited.2 : Boo\r\nitems : [{'duration': '5 minutes', 'subjects': ['purpose of the meeting'], ...]\r\nitems.0 : {'duration': '5 minutes', 'subjects': ['purpose of the meeting'], 'name': 'opening'}\r\nitems.0.duration : 5 minutes\r\nitems.0.name : opening\r\nitems.0.subjects : ['purpose of the meeting']\r\nitems.0.subjects.0 : purpose of the meeting\r\n\r\netc...\r\n```\r\nWith the `Path.items(obj, all=True)` and the ordering the items are produced, more manipulations are possible, e.g.:\r\n````python\r\nfrom datetime import datetime\r\nfrom wildpath.paths import Path\r\n\r\nsample = {\r\n    \"name\": \"sample\",\r\n    \"times\": [datetime(1999,1,2,3), datetime(1999,1,2,4)]\r\n}\r\n\r\nnew_sample = {}\r\nfor path, value in Path.items(sample, all=True):\r\n    if isinstance(value, datetime):\r\n        value = str(value)  # all values of type datetime are converted to strings\r\n    path.set_in(new_sample, value)\r\n\r\n# new_sample is now serializable to JSON\r\n````\r\n\r\n**Notes**:\r\n - Currently these iterators cannot handle circular relationships. This will result in a RuntimeError (recursion depth) ,\r\n - The iterators return generators, not lists or dicts. To do this, use `list(Path.items(obj))`, `dict(Path.items(obj))`, \r\n - These iterators can also be useful the get an alternative view on a datastructure: a starting point to define WildPaths,\r\n - To turn the items into a `dict` with string keys, use `dct = {str(p): v for p, v in Path.items(obj)}`.\r\n\r\n### Path manipulations\r\n`Path` and `WildPath` are subclasses of tuple (via BasePath), so (almost) all tuple methods can be used with both, e.g.:\r\n```python\r\nfrom wildpath.paths import Path\r\n\r\nassert Path(\"a.b\") + Path(\"c\") == Path(\"a.b.c\")\r\nassert Path(\"a.b.c\")[1:] == Path(\"b.c\")\r\nassert repr(Path(\"a.b.c\")) == \"('a', 'b', 'c')\"\r\n\r\n# however, tuple.__str__ is overridden to return the input string for the class constructor for easy (de)serialization:\r\n\r\nassert str(Path(\"a.b.c\")) == \"a.b.c\"\r\n\r\n```\r\nNote that some methods (like `__add__` and `path[1:]`) are overridden to return the correct class (Path or WildPath)\r\n\r\n\r\n## Limitations\r\nBecause of the characters used to parse the paths, some keys in the target datastructures will cause the system to fail:\r\n - In python objects Path and WildPath will lookup keys in the instance `__dict__`. This means that some constructions like `property` and overridden `__getattr__` will not be taken into account,\r\n - for `Path` and `WildPath`: keys in Mappings (e.g. dict, OrderedDict) cannot contain a `.`,\r\n - for `WildPath`: keys in Mappings cannot contain the characters `*`, `?`, `!`, `|` and `&`, or to be precise, if they are present, they cannot be used in paths for lookups,\r\n - note that the `.` separator can easily be replaced in a subclass, allowing paths like `\"a/b/3/x\"` instead of `\"a.b.3.x\"` (and therefore path `\"a/b.c/3/x\"` with `b.c` a dictionary key):\r\n\r\n ```python\r\nfrom wildpath.paths import Path, WildPath\r\n\r\nclass SlashPath(Path):\r\n    sep = '/'\r\n\r\nclass WildSlashPath(WildPath):\r\n    sep = '/'\r\n```\r\nOverriding `!`, `|` and `&` will take a little more work: override class-attribute `tokens` in `WildPath` and override `KeyParser.DEFAULT_TOKENS`. Currently there is no way to override hte tokens `*` and `?` in `WildPath`.\r\n\r\n## Testing\r\n\r\nThe unittests are standard python unittests and can be run as such.\r\n\r\n## Authors\r\n\r\nLars van Gemerden (rational-it) - initial code and documentation.\r\n\r\n## License\r\n\r\nThis project is licensed under the license in LICENSE.txt.\r\n\r\n## Acknowledgments\r\n\r\n - For convincing me to open-source this module, a big thanks to Jasper Hartong,\r\n - For the creators of the module `boolean.py`, thanks for making boolean parsing a lot easier.\r\n\r\n\r\n",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "",
    "keywords": "access data structure getter setter deleter iterator utility tool",
    "license": "MIT License",
    "maintainer": "",
    "maintainer_email": "",
    "name": "wildpath",
    "platform": "",
    "project_url": "https://pypi.org/project/wildpath/",
    "release_url": "https://pypi.org/project/wildpath/0.1.3/",
    "requires_dist": [
      "boolean.py"
    ],
    "requires_python": "",
    "summary": "easy data structure access utility",
    "version": "0.1.3"
  },
  "releases": {
    "0.1.3": [
      {
        "comment_text": "",
        "digests": {
          "md5": "552e66ab9e6e0600247c2d7e584d0a25",
          "sha256": "761ce1ae2d559c4a8eb2fd4846f0e6eb4671404ac3dc08414581077244e098d7"
        },
        "downloads": 0,
        "filename": "wildpath-0.1.3-py2.py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "552e66ab9e6e0600247c2d7e584d0a25",
        "packagetype": "bdist_wheel",
        "python_version": "py2.py3",
        "size": 24026,
        "upload_time": "2017-07-22T10:25:25",
        "url": "https://files.pythonhosted.org/packages/11/9a/775c67e24b4b888694fd2020259fd05bb8c3f994b45799e5047da9a11ab7/wildpath-0.1.3-py2.py3-none-any.whl"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "552e66ab9e6e0600247c2d7e584d0a25",
        "sha256": "761ce1ae2d559c4a8eb2fd4846f0e6eb4671404ac3dc08414581077244e098d7"
      },
      "downloads": 0,
      "filename": "wildpath-0.1.3-py2.py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "552e66ab9e6e0600247c2d7e584d0a25",
      "packagetype": "bdist_wheel",
      "python_version": "py2.py3",
      "size": 24026,
      "upload_time": "2017-07-22T10:25:25",
      "url": "https://files.pythonhosted.org/packages/11/9a/775c67e24b4b888694fd2020259fd05bb8c3f994b45799e5047da9a11ab7/wildpath-0.1.3-py2.py3-none-any.whl"
    }
  ]
}