{
  "info": {
    "author": "Stephan Richter, Roger Ineichen and the Zope Community",
    "author_email": "zope-dev@zope.org",
    "bugtrack_url": "",
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Environment :: Web Environment",
      "Framework :: Zope3",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: Zope Public License",
      "Natural Language :: English",
      "Operating System :: OS Independent",
      "Programming Language :: Python",
      "Programming Language :: Python :: 2",
      "Programming Language :: Python :: 2.7",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.4",
      "Programming Language :: Python :: 3.5",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: Implementation :: CPython",
      "Topic :: Internet :: WWW/HTTP"
    ],
    "description": "This package provides an implementation for HTML and JSON forms and widgets. The goal\nis to provide a simple API but with the ability to easily customize any data or\nsteps.\n\n\n.. contents:: \n\n=================\nForms and Widgets\n=================\n\nThis package provides an implementation for HTML forms and widgets. The goal\nis to provide a simple API but with the ability to easily customize any data or\nsteps. This document, provides the content of this package's documentation\nfiles. The documents are ordered in the way they should be read:\n\n- ``form.txt`` [must read]\n\n  Describes the setup and usage of forms in the most common usages. Some\n  details are provided to the structure of form components.\n\n- ``group.txt`` [must read]\n\n  This document describes how widget groups are implemented within this\n  package and how they can be used.\n\n- ``subform.txt`` [must read]\n\n  Introduces the complexities surrounding sub-forms and details two classes of\n  sub-forms, including code examples.\n\n- ``field.txt`` [must read]\n\n  Provides a comprehensive explanation of the field manager API and how it is\n  to be used.\n\n- ``button.txt`` [must read]\n\n  Provides a comprehensive explanation of the button manager API. It also\n  outlines how to create buttons within schemas and how buttons are converted\n  to actions.\n\n- ``zcml.txt`` [must read]\n\n  Explains the ZCML directives defines by this package, which are designed to\n  make it easier to register new templates without writing Python code.\n\n- ``validator.txt`` [advanced users]\n\n  Validators are used to validate converted form data. This document provides\n  a comprehensive overview of the API and how to use it effectively.\n\n- ``widget.txt`` [advanced users]\n\n  Explains in detail the design goals surrounding widgets and widget managers\n  and how they were realized with the implemented API.\n\n- ``contentprovider.txt`` [advanced users]\n\n  Explains how to mix content providers in forms to render more html around\n  widgets.\n\n- ``action.txt`` [advanced users]\n\n  Explains in detail the design goals surrounding action managers and\n  actions. The execution of actions using action handlers is also covered. The\n  document demonstrates how actions can be created without the use of buttons.\n\n- ``value.txt`` [informative]\n\n  The concept of attribute value adapters is introduced and fully\n  explained. Some motivation for this new and powerful pattern is given as\n  well.\n\n- ``datamanager.txt`` [informative]\n\n  Data managers are resposnsible for accessing and writing the data. While\n  attribute access is the most common case, data managers can also manage\n  other data structures, such as dictionaries.\n\n- ``converter.txt`` [informative]\n\n  Data converters convert data between internal and widget values and vice\n  versa.\n\n- ``term.txt`` [informative]\n\n  Terms are wrappers around sources and vocabularies to provide a common\n  interface for choices in this package.\n\n- ``util.txt`` [informative]\n\n  The ``util`` module provides several helper functions and classes. The\n  components not tested otherwise are explained in this file.\n\n- ``adding.txt`` [informative]\n\n  This module provides a base class for add forms that work with the\n  ``IAdding`` interface.\n\n- ``testing.txt`` [informative]\n\n  The ``testing`` module provides helper functions that make it easier to tet\n  form-based code in unit tests. It also provides components that simplify\n  testing in testbrowser and Selenium.\n\n- ``object-caveat.txt`` [informative]\n\n  Explains the current problems of ObjectWidget.\n\n\nBrowser Documentation\n---------------------\n\nThere are several documentation files in the ``browser/`` sub-package. They\nmainly document the basic widgets provided by the package.\n\n- ``README.txt`` [advanced users]\n\n  This file contains a checklist, ensuring that all fields have a widget.\n\n- ``<fieldname>.txt``\n\n  Each field name documentation file comprehensively explains the widget and\n  how it is ensured to work properly.\n\n=====\nForms\n=====\n\nThe purpose of this package is to make development of forms as simple\nas possible, while still providing all the hooks to do customization\nat any level as required by our real-world use cases. Thus, once the\nsystem is set up with all its default registrations, it should be\ntrivial to develop a new form.\n\nThe strategy of this document is to provide the most common, and thus\nsimplest, case first and then demonstrate the available customization\noptions. In order to not overwhelm you with our set of well-chosen defaults,\nall the default component registrations have been made prior to doing those\nexamples:\n\n  >>> from z3c.form import testing\n  >>> testing.setupFormDefaults()\n\nNote, since version 2.4.2 the IFormLayer doesn't provide IBrowserRequest\nanymore. This is useful if you like to use z3c.form components for other\nrequests than the IBrowserRequest.\n\n  >>> from zope.publisher.interfaces.browser import IBrowserRequest\n  >>> import z3c.form.interfaces\n  >>> z3c.form.interfaces.IFormLayer.isOrExtends(IBrowserRequest)\n  False\n\nBefore we can start writing forms, we must have the content to work with:\n\n  >>> import zope.interface\n  >>> import zope.schema\n  >>> class IPerson(zope.interface.Interface):\n  ...\n  ...     id = zope.schema.TextLine(\n  ...         title=u'ID',\n  ...         readonly=True,\n  ...         required=True)\n  ...\n  ...     name = zope.schema.TextLine(\n  ...         title=u'Name',\n  ...         required=True)\n  ...\n  ...     gender = zope.schema.Choice(\n  ...         title=u'Gender',\n  ...         values=('male', 'female'),\n  ...         required=False)\n  ...\n  ...     age = zope.schema.Int(\n  ...         title=u'Age',\n  ...         description=u\"The person's age.\",\n  ...         min=0,\n  ...         default=20,\n  ...         required=False)\n  ...\n  ...     @zope.interface.invariant\n  ...     def ensureIdAndNameNotEqual(person):\n  ...         if person.id == person.name:\n  ...             raise zope.interface.Invalid(\n  ...                 \"The id and name cannot be the same.\")\n\n  >>> from zope.schema.fieldproperty import FieldProperty\n  >>> @zope.interface.implementer(IPerson)\n  ... class Person(object):\n  ...     id = FieldProperty(IPerson['id'])\n  ...     name = FieldProperty(IPerson['name'])\n  ...     gender = FieldProperty(IPerson['gender'])\n  ...     age = FieldProperty(IPerson['age'])\n  ...\n  ...     def __init__(self, id, name, gender=None, age=None):\n  ...         self.id = id\n  ...         self.name = name\n  ...         if gender:\n  ...             self.gender = gender\n  ...         if age:\n  ...             self.age = age\n  ...\n  ...     def __repr__(self):\n  ...         return '<%s %r>' % (self.__class__.__name__, self.name)\n\nOkay, that should suffice for now.\n\nWhat's next? Well, first things first. Let's create an add form for the\nperson. Since practice showed that the ``IAdding`` interface is overkill for\nmost projects, the default add form of ``z3c.form`` requires you to define the\ncreation and adding mechanism.\n\n**Note**:\n\n  If it is not done, ``NotImplementedError[s]`` are raised:\n\n    >>> from z3c.form.testing import TestRequest\n    >>> from z3c.form import form, field\n\n    >>> abstract = form.AddForm(None, TestRequest())\n\n    >>> abstract.create({})\n    Traceback (most recent call last):\n    ...\n    NotImplementedError\n\n    >>> abstract.add(1)\n    Traceback (most recent call last):\n    ...\n    NotImplementedError\n\n    >>> abstract.nextURL()\n    Traceback (most recent call last):\n    ...\n    NotImplementedError\n\n\nThus let's now create a working add form:\n\n  >>> class PersonAddForm(form.AddForm):\n  ...\n  ...     fields = field.Fields(IPerson)\n  ...\n  ...     def create(self, data):\n  ...         return Person(**data)\n  ...\n  ...     def add(self, object):\n  ...         self.context[object.id] = object\n  ...\n  ...     def nextURL(self):\n  ...         return 'index.html'\n\nThis is as simple as it gets. We explicitly define the pieces that\nare custom to every situation and let the default setup of the\nframework do the rest. This is intentionally similar to\n``zope.formlib``, because we really like the simplicity of\n``zope.formlib``'s way of dealing with the common use cases.\n\nLet's try to add a new person object to the root folder (which\nwas created during test setup).  For this add form, of course, the\ncontext is now the root folder:\n\n  >>> request = TestRequest()\n  >>> addForm = PersonAddForm(root, request)\n\nSince forms are not necessarily pages -- in fact often they are not --\nthey must not have a ``__call__`` method that does all the processing\nand rendering at once. Instead, we use the update/render\npattern. Thus, we first call the ``update()`` method.\n\n  >>> addForm.update()\n\nActually a lot of things happen during this stage. Let us step through it one\nby one pointing out the effects.\n\n\nFind a widget manager and update it\n-----------------------------------\n\nThe default widget manager knows to look for the ``fields`` attribute in the\nform, since it implements ``IFieldsForm``:\n\n  >>> from z3c.form import interfaces\n  >>> interfaces.IFieldsForm.providedBy(addForm)\n  True\n\nThe widget manager is then stored in the ``widgets`` attribute as promised by\nthe ``IForm`` interface:\n\n  >>> addForm.widgets\n  <z3c.form.field.FieldWidgets object at ...>\n\nThe widget manager will have four widgets, one for each field:\n\n  >>> addForm.widgets.keys()\n  ['id', 'name', 'gender', 'age']\n\nWhen the widget manager updates itself, several sub-tasks are processed. The\nmanager goes through each field, trying to create a fully representative\nwidget for the field.\n\nField Availability\n~~~~~~~~~~~~~~~~~~\n\nJust because a field is requested in the field manager, does not mean that a\nwidget has to be created for the field. There are cases when a field\ndeclaration might be ignored. The following reasons come to mind:\n\n* No widget is created if the data are not accessible in the content.\n* A custom widget manager has been registered to specifically ignore a field.\n\nIn our simple example, all fields will be converted to widgets.\n\nWidget Creation\n~~~~~~~~~~~~~~~\n\nDuring the widget creation process, several pieces of information are\ntransferred from the field to the widget:\n\n  >>> age = addForm.widgets['age']\n\n  # field.title -> age.label\n\n  >>> age.label\n  u'Age'\n\n  # field.required -> age.required\n\n  >>> age.required\n  False\n\nAll these values can be overridden at later stages of the updating\nprocess.\n\nWidget Value\n~~~~~~~~~~~~\n\nThe next step is to determine the value that should be displayed by the\nwidget. This value could come from three places (looked up in this order):\n\n1. The field's default value.\n2. The content object that the form is representing.\n3. The request in case a form has not been submitted or an error occurred.\n\nSince we are currently building an add form and not an edit form,\nthere is no content object to represent, so the second step is not\napplicable. The third step is also not applicable as we do not have\nanything in the request. Therefore, the value should be the field's\ndefault value, or be empty. In this case the field provides a default\nvalue:\n\n  >>> age.value\n  u'20'\n\nWhile the default of the age field is actually the integer ``20``, the\nwidget has converted the value to the output-ready string ``'20'``\nusing a data converter.\n\nWidget Mode\n~~~~~~~~~~~\n\nNow the widget manager looks at the field to determine the widget mode -- in\nother words whether the widget is a display or edit widget. In this case all\nfields are input fields:\n\n  >>> age.mode\n  'input'\n\nDeciding which mode to use, however, might not be a trivial operation. It\nmight depend on several factors (items listed later override earlier ones):\n\n* The global ``mode`` flag of the widget manager\n* The permission to the content's data value\n* The ``readonly`` flag in the schema field\n* The ``mode`` flag in the field\n\n\nWidget Attribute Values\n~~~~~~~~~~~~~~~~~~~~~~~\n\nAs mentioned before, several widget attributes are optionally overridden when\nthe widget updates itself:\n\n* label\n* required\n* mode\n\nSince we have no customization components registered, all of those fields will\nremain as set before.\n\n\nFind an action manager, update and execute it\n---------------------------------------------\n\nAfter all widgets have been instantiated and the ``update()`` method has been\ncalled successfully, the actions are set up. By default, the form machinery\nuses the button declaration on the form to create its actions. For the add\nform, an add button is defined by default, so that we did not need to create\nour own. Thus, there should be one action:\n\n  >>> len(addForm.actions)\n  1\n\nThe add button is an action and a widget at the same time:\n\n  >>> addAction = addForm.actions['add']\n  >>> addAction.title\n  u'Add'\n  >>> addAction.value\n  u'Add'\n\nAfter everything is set up, all pressed buttons are executed. Once a submitted\naction is detected, a special action handler adapter is used to determine the\nactions to take. Since the add button has not been pressed yet, no action\noccurred.\n\n\nRendering the form\n------------------\n\nOnce the update is complete we can render the form using one of two methods reder or json.\nIf we want to generate json data to be consumed by the client all we need to do is call json()::\n\n >>> import json\n >>> from pprint import pprint\n >>> pprint(json.loads(addForm.json()))\n {'errors': [],\n  'fields': [{'error': '',\n              'id': 'form-widgets-id',\n              'label': 'ID',\n              'mode': 'input',\n              'name': 'form.widgets.id',\n              'required': True,\n              'type': 'text',\n              'value': ''},\n             {'error': '',\n              'id': 'form-widgets-name',\n              'label': 'Name',\n              'mode': 'input',\n              'name': 'form.widgets.name',\n              'required': True,\n              'type': 'text',\n              'value': ''},\n             {'error': '',\n              'id': 'form-widgets-gender',\n              'label': 'Gender',\n              'mode': 'input',\n              'name': 'form.widgets.gender',\n              'options': [{'content': 'No value',\n                           'id': 'form-widgets-gender-novalue',\n                           'selected': True,\n                           'value': '--NOVALUE--'},\n                          {'content': 'male',\n                           'id': 'form-widgets-gender-0',\n                           'selected': False,\n                           'value': 'male'},\n                          {'content': 'female',\n                           'id': 'form-widgets-gender-1',\n                           'selected': False,\n                           'value': 'female'}],\n              'required': False,\n              'type': 'select',\n              'value': []},\n             {'error': '',\n              'id': 'form-widgets-age',\n              'label': 'Age',\n              'mode': 'input',\n              'name': 'form.widgets.age',\n              'required': False,\n              'type': 'text',\n              'value': '20'}],\n  'label': '',\n  'mode': 'input',\n  'prefix': 'form.',\n  'status': ''}\n\n\nThe other way we can render the form is using the render() method.\n\nThe render method requires us to specify a template, we have to do this now.\nWe have prepared a small and very simple template as part of this example:\n\n  >>> import os\n  >>> from zope.browserpage.viewpagetemplatefile import BoundPageTemplate\n  >>> from zope.browserpage.viewpagetemplatefile import ViewPageTemplateFile\n  >>> from z3c.form import tests\n  >>> def addTemplate(form):\n  ...     form.template = BoundPageTemplate(\n  ...         ViewPageTemplateFile(\n  ...             'simple_edit.pt', os.path.dirname(tests.__file__)), form)\n  >>> addTemplate(addForm)\n\nLet's now render the page:\n\n  >>> print(addForm.render())\n  <html xmlns=\"http://www.w3.org/1999/xhtml\">\n    <body>\n      <form action=\".\">\n        <div class=\"row\">\n          <label for=\"form-widgets-id\">ID</label>\n          <input type=\"text\" id=\"form-widgets-id\"\n                 name=\"form.widgets.id\"\n                 class=\"text-widget required textline-field\"\n                 value=\"\" />\n        </div>\n        <div class=\"row\">\n          <label for=\"form-widgets-name\">Name</label>\n          <input type=\"text\" id=\"form-widgets-name\" name=\"form.widgets.name\"\n                 class=\"text-widget required textline-field\"\n                 value=\"\" />\n        </div>\n        <div class=\"row\">\n          <label for=\"form-widgets-gender\">Gender</label>\n          <select id=\"form-widgets-gender\" name=\"form.widgets.gender:list\"\n                  class=\"select-widget choice-field\" size=\"1\">\n            <option id=\"form-widgets-gender-novalue\" selected=\"selected\"\n                    value=\"--NOVALUE--\">No value</option>\n            <option id=\"form-widgets-gender-0\" value=\"male\">male</option>\n            <option id=\"form-widgets-gender-1\" value=\"female\">female</option>\n          </select>\n          <input name=\"form.widgets.gender-empty-marker\" type=\"hidden\"\n                 value=\"1\" />\n        </div>\n        <div class=\"row\">\n          <label for=\"form-widgets-age\">Age</label>\n          <input type=\"text\" id=\"form-widgets-age\" name=\"form.widgets.age\"\n                 class=\"text-widget int-field\" value=\"20\" />\n        </div>\n        <div class=\"action\">\n          <input type=\"submit\" id=\"form-buttons-add\" name=\"form.buttons.add\"\n                 class=\"submit-widget button-field\" value=\"Add\" />\n        </div>\n      </form>\n    </body>\n  </html>\n\nThe update()/render() cycle is what happens when the form is called, i.e.\nwhen it is published:\n\n  >>> print(addForm())\n  <html xmlns=\"http://www.w3.org/1999/xhtml\">\n    <body>\n      <form action=\".\">\n        <div class=\"row\">\n          <label for=\"form-widgets-id\">ID</label>\n          <input type=\"text\" id=\"form-widgets-id\"\n                 name=\"form.widgets.id\"\n                 class=\"text-widget required textline-field\"\n                 value=\"\" />\n        </div>\n        <div class=\"row\">\n          <label for=\"form-widgets-name\">Name</label>\n          <input type=\"text\" id=\"form-widgets-name\" name=\"form.widgets.name\"\n                 class=\"text-widget required textline-field\"\n                 value=\"\" />\n        </div>\n        <div class=\"row\">\n          <label for=\"form-widgets-gender\">Gender</label>\n          <select id=\"form-widgets-gender\" name=\"form.widgets.gender:list\"\n                  class=\"select-widget choice-field\" size=\"1\">\n            <option id=\"form-widgets-gender-novalue\" selected=\"selected\"\n                    value=\"--NOVALUE--\">No value</option>\n            <option id=\"form-widgets-gender-0\" value=\"male\">male</option>\n            <option id=\"form-widgets-gender-1\" value=\"female\">female</option>\n          </select>\n          <input name=\"form.widgets.gender-empty-marker\" type=\"hidden\"\n                 value=\"1\" />\n        </div>\n        <div class=\"row\">\n          <label for=\"form-widgets-age\">Age</label>\n          <input type=\"text\" id=\"form-widgets-age\" name=\"form.widgets.age\"\n                 class=\"text-widget int-field\" value=\"20\" />\n        </div>\n        <div class=\"action\">\n          <input type=\"submit\" id=\"form-buttons-add\" name=\"form.buttons.add\"\n                 class=\"submit-widget button-field\" value=\"Add\" />\n        </div>\n      </form>\n    </body>\n  </html>\n\nNote that we don't actually call render if the response has been set to a 3xx\ntype status code (e.g. a redirect or not modified response), since the browser\nwould not render it anyway:\n\n  >>> request.response.setStatus(304)\n  >>> print(addForm())\n\nLet's go back to a normal status to continue the test.\n\n  >>> request.response.setStatus(200)\n\n\nRegistering a custom event handler for the DataExtractedEvent\n--------------------------------------------------------------\n\n  >>> data_extracted_eventlog = []\n  >>> from z3c.form.events import DataExtractedEvent\n  >>> @zope.component.adapter(DataExtractedEvent)\n  ... def data_extracted_logger(event):\n  ...     data_extracted_eventlog.append(event)\n  >>> zope.component.provideHandler(data_extracted_logger)\n\n\nSubmitting an add form successfully\n-----------------------------------\n\nInitially the root folder of the application is empty:\n\n  >>> sorted(root)\n  []\n\nLet's now fill the request with all the right values so that upon submitting\nthe form with the \"Add\" button, the person should be added to the root folder:\n\n  >>> request = TestRequest(form={\n  ...     'form.widgets.id': u'srichter',\n  ...     'form.widgets.name': u'Stephan Richter',\n  ...     'form.widgets.gender': ['male'],\n  ...     'form.widgets.age': u'20',\n  ...     'form.buttons.add': u'Add'}\n  ...     )\n\n  >>> addForm = PersonAddForm(root, request)\n  >>> addForm.update()\n\n  >>> sorted(root)\n  [u'srichter']\n  >>> stephan = root[u'srichter']\n  >>> stephan.id\n  u'srichter'\n  >>> stephan.name\n  u'Stephan Richter'\n  >>> stephan.gender\n  'male'\n  >>> stephan.age\n  20\n\n\nCheck, if DataExtractedEvent was thrown\n-----------------------------------------\n\n  >>> event = data_extracted_eventlog[0]\n  >>> 'name' in event.data\n  True\n\n  >>> event.errors\n  ()\n\n  >>> event.form\n  <PersonAddForm object at ...\n\n\nSubmitting an add form with invalid data\n----------------------------------------\n\nNext we try to submit the add form with the required name missing. Thus, the\nadd form should not complete with the addition, but return with the add form\npointing out the error.\n\n  >>> request = TestRequest(form={\n  ...     'form.widgets.id': u'srichter',\n  ...     'form.widgets.gender': ['male'],\n  ...     'form.widgets.age': u'23',\n  ...     'form.buttons.add': u'Add'}\n  ...     )\n\n  >>> addForm = PersonAddForm(root, request)\n  >>> addForm.update()\n\nThe widget manager and the widget causing the error should have an error\nmessage:\n\n  >>> [(error.widget.__name__, error) for error in addForm.widgets.errors]\n  [('name', <ErrorViewSnippet for RequiredMissing>)]\n\n  >>> addForm.widgets['name'].error\n  <ErrorViewSnippet for RequiredMissing>\n\n\nCheck, if event was thrown:\n\n  >>> event = data_extracted_eventlog[-1]\n  >>> 'id' in event.data\n  True\n\n  >>> event.errors\n  (<ErrorViewSnippet for RequiredMissing>,)\n\n  >>> event.form\n  <PersonAddForm object at ...\n\n\nLet's now render the form:\n\n  >>> addTemplate(addForm)\n  >>> print(addForm.render())\n  <html xmlns=\"http://www.w3.org/1999/xhtml\">\n    <body>\n      <i>There were some errors.</i>\n      <ul>\n        <li>\n          Name: <div class=\"error\">Required input is missing.</div>\n        </li>\n      </ul>\n      <form action=\".\">\n        <div class=\"row\">\n          <label for=\"form-widgets-id\">ID</label>\n          <input type=\"text\" id=\"form-widgets-id\"\n                 name=\"form.widgets.id\"\n                 class=\"text-widget required textline-field\"\n                 value=\"srichter\" />\n        </div>\n        <div class=\"row\">\n          <b><div class=\"error\">Required input is missing.</div>\n          </b><label for=\"form-widgets-name\">Name</label>\n          <input type=\"text\" id=\"form-widgets-name\" name=\"form.widgets.name\"\n                 class=\"text-widget required textline-field\" value=\"\" />\n        </div>\n        <div class=\"row\">\n          <label for=\"form-widgets-gender\">Gender</label>\n          <select id=\"form-widgets-gender\" name=\"form.widgets.gender:list\"\n                  class=\"select-widget choice-field\" size=\"1\">\n            <option id=\"form-widgets-gender-novalue\"\n                    value=\"--NOVALUE--\">No value</option>\n            <option id=\"form-widgets-gender-0\" value=\"male\"\n                    selected=\"selected\">male</option>\n            <option id=\"form-widgets-gender-1\" value=\"female\">female</option>\n          </select>\n          <input name=\"form.widgets.gender-empty-marker\" type=\"hidden\"\n                 value=\"1\" />\n        </div>\n        <div class=\"row\">\n          <label for=\"form-widgets-age\">Age</label>\n          <input type=\"text\" id=\"form-widgets-age\" name=\"form.widgets.age\"\n                 class=\"text-widget int-field\" value=\"23\" />\n        </div>\n        <div class=\"action\">\n          <input type=\"submit\" id=\"form-buttons-add\" name=\"form.buttons.add\"\n                 class=\"submit-widget button-field\" value=\"Add\" />\n        </div>\n      </form>\n    </body>\n  </html>\n\nNotice the errors are present in the json output of the form as well\n  >>> import json\n  >>> from pprint import pprint\n  >>> pprint(json.loads(addForm.json()))\n  {'errors': [],\n   'fields': [{'error': '',\n                'id': 'form-widgets-id',\n                'label': 'ID',\n                'mode': 'input',\n                'name': 'form.widgets.id',\n                'required': True,\n                'type': 'text',\n                'value': 'srichter'},\n               {'error': 'Required input is missing.',\n                'id': 'form-widgets-name',\n                'label': 'Name',\n                'mode': 'input',\n                'name': 'form.widgets.name',\n                'required': True,\n                'type': 'text',\n                'value': ''},\n               {'error': '',\n                'id': 'form-widgets-gender',\n                'label': 'Gender',\n                'mode': 'input',\n                'name': 'form.widgets.gender',\n                'options': [{'content': 'No value',\n                              'id': 'form-widgets-gender-novalue',\n                              'selected': False,\n                              'value': '--NOVALUE--'},\n                             {'content': 'male',\n                              'id': 'form-widgets-gender-0',\n                              'selected': True,\n                              'value': 'male'},\n                             {'content': 'female',\n                              'id': 'form-widgets-gender-1',\n                              'selected': False,\n                              'value': 'female'}],\n                'required': False,\n                'type': 'select',\n                'value': ['male']},\n               {'error': '',\n                'id': 'form-widgets-age',\n                'label': 'Age',\n                'mode': 'input',\n                'name': 'form.widgets.age',\n                'required': False,\n                'type': 'text',\n                'value': '23'}],\n   'label': '',\n   'mode': 'input',\n   'prefix': 'form.',\n   'status': 'There were some errors.'}\n\n\nNote that the values of the field are now extracted from the request.\n\nAnother way to receive an error is by not fulfilling the invariants of the\nschema. In our case, the id and name cannot be the same. So let's provoke the\nerror now:\n\n  >>> request = TestRequest(form={\n  ...     'form.widgets.id': u'Stephan',\n  ...     'form.widgets.name': u'Stephan',\n  ...     'form.widgets.gender': ['male'],\n  ...     'form.widgets.age': u'23',\n  ...     'form.buttons.add': u'Add'}\n  ...     )\n\n  >>> addForm = PersonAddForm(root, request)\n  >>> addTemplate(addForm)\n  >>> addForm.update()\n\nand see how the form looks like:\n\n  >>> print(addForm.render()) # doctest: +NOPARSE_MARKUP\n  <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n  <html xmlns=\"http://www.w3.org/1999/xhtml\">\n    <body>\n      <i>There were some errors.</i>\n      <ul>\n        <li>\n          <div class=\"error\">The id and name cannot be the same.</div>\n        </li>\n      </ul>\n      ...\n    </body>\n  </html>\n\nand through as json:\n  >>> import json\n  >>> from pprint import pprint\n  >>> pprint(json.loads(addForm.json()))\n   {'errors': ['The id and name cannot be the same.'],\n    'fields': [{'error': '',\n                'id': 'form-widgets-id',\n                'label': 'ID',\n                'mode': 'input',\n                'name': 'form.widgets.id',\n                'required': True,\n                'type': 'text',\n                'value': 'Stephan'},\n               {'error': '',\n                'id': 'form-widgets-name',\n                'label': 'Name',\n                'mode': 'input',\n                'name': 'form.widgets.name',\n                'required': True,\n                'type': 'text',\n                'value': 'Stephan'},\n               {'error': '',\n                'id': 'form-widgets-gender',\n                'label': 'Gender',\n                'mode': 'input',\n                'name': 'form.widgets.gender',\n                'options': [{'content': 'No value',\n                              'id': 'form-widgets-gender-novalue',\n                              'selected': False,\n                              'value': '--NOVALUE--'},\n                             {'content': 'male',\n                              'id': 'form-widgets-gender-0',\n                              'selected': True,\n                              'value': 'male'},\n                             {'content': 'female',\n                              'id': 'form-widgets-gender-1',\n                              'selected': False,\n                              'value': 'female'}],\n                'required': False,\n                'type': 'select',\n                'value': ['male']},\n               {'error': '',\n                'id': 'form-widgets-age',\n                'label': 'Age',\n                'mode': 'input',\n                'name': 'form.widgets.age',\n                'required': False,\n                'type': 'text',\n                'value': '23'}],\n    'label': '',\n    'mode': 'input',\n    'prefix': 'form.',\n    'status': 'There were some errors.'}\n\nLet's try to provide a negative age, which is not possible either:\n\n  >>> request = TestRequest(form={\n  ...     'form.widgets.id': u'srichter',\n  ...     'form.widgets.gender': ['male'],\n  ...     'form.widgets.age': u'-5',\n  ...     'form.buttons.add': u'Add'}\n  ...     )\n\n  >>> addForm = PersonAddForm(root, request)\n  >>> addForm.update()\n\n  >>> [(view.widget.label, view) for view in addForm.widgets.errors]\n  [(u'Name', <ErrorViewSnippet for RequiredMissing>),\n   (u'Age', <ErrorViewSnippet for TooSmall>)]\n\nBut the error message for a negative age is too generic:\n\n  >>> print(addForm.widgets['age'].error.render())\n  <div class=\"error\">Value is too small</div>\n\nIt would be better to say that negative values are disallowed. So let's\nregister a new error view snippet for the ``TooSmall`` error:\n\n  >>> from z3c.form import error\n\n  >>> class TooSmallView(error.ErrorViewSnippet):\n  ...     zope.component.adapts(\n  ...         zope.schema.interfaces.TooSmall, None, None, None, None, None)\n  ...\n  ...     def update(self):\n  ...         super(TooSmallView, self).update()\n  ...         if self.field.min == 0:\n  ...             self.message = u'The value cannot be a negative number.'\n\n  >>> zope.component.provideAdapter(TooSmallView)\n\n  >>> addForm = PersonAddForm(root, request)\n  >>> addForm.update()\n  >>> print(addForm.widgets['age'].error.render())\n  <div class=\"error\">The value cannot be a negative number.</div>\n\nNote: The ``adapts()`` declaration might look strange. An error view\nsnippet is actually a multiadapter that adapts a combination of 6\nobjects -- error, request, widget, field, form, content. By specifying\nonly the error, we tell the system that we do not care about the other\ndiscriminators, which then can be anything. We could also have used\n``zope.interface.Interface`` instead, which would be equivalent.\n\n\nAdditional Form Attributes and API\n----------------------------------\n\nSince we are talking about HTML forms here, add and edit forms support all\nrelevant FORM element attributes as attributes on the class.\n\n  >>> addForm.method\n  'post'\n  >>> addForm.enctype\n  'multipart/form-data'\n  >>> addForm.acceptCharset\n  >>> addForm.accept\n\nThe ``action`` attribute is computed. By default it is the current URL:\n\n  >>> addForm.action\n  'http://127.0.0.1'\n\nThe name is also computed. By default it takes the prefix and removes any\ntrailing \".\".\n\n  >>> addForm.name\n  'form'\n\nThe id is computed from the name, replacing dots with hyphens. Let's set\nthe prefix to something containing more than one final dot and check how\nit works.\n\n  >>> addForm.prefix = 'person.form.add.'\n  >>> addForm.id\n  'person-form-add'\n\nThe template can then use those attributes, if it likes to.\n\nIn the examples previously we set the template manually. If no\ntemplate is specified, the system tries to find an adapter. Without\nany special configuration, there is no adapter, so rendering the form\nfails:\n\n  >>> addForm.template = None\n  >>> addForm.render()\n  Traceback (most recent call last):\n  ...\n  ComponentLookupError: ((...), <InterfaceClass ...IPageTemplate>, u'')\n\nThe form module provides a simple component to create adapter\nfactories from templates:\n\n  >>> factory = form.FormTemplateFactory(\n  ...     testing.getPath('../tests/simple_edit.pt'), form=PersonAddForm)\n\nLet's register our new template-based adapter factory:\n\n  >>> zope.component.provideAdapter(factory)\n\nNow the factory will be used to provide a template:\n\n  >>> print(addForm.render()) # doctest: +NOPARSE_MARKUP\n  <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n  <html xmlns=\"http://www.w3.org/1999/xhtml\">\n  ...\n  </html>\n\nSince a form can also be used as a page itself, it is callable. When\nyou call it will invoke both the ``update()`` and ``render()``\nmethods:\n\n  >>> print(addForm()) # doctest: +NOPARSE_MARKUP\n  <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n  <html xmlns=\"http://www.w3.org/1999/xhtml\">\n  ...\n  </html>\n\nThe form also provides a label for rendering a required info. This required\ninfo depends by default on the given requiredInfo label and if at least one\nfield is required:\n\n  >>> addForm.requiredInfo\n  u'<span class=\"required\">*</span>&ndash; required'\n\nIf we set the labelRequired to None, we do not get a requiredInfo label:\n\n  >>> addForm.labelRequired = None\n  >>> addForm.requiredInfo is None\n  True\n\n\nChanging Widget Attribute Values\n--------------------------------\n\nIt frequently happens that a customer comes along and wants to\nslightly or totally change some of the text shown in forms or make\noptional fields required. It does not make sense to always have to\nadjust the schema or implement a custom schema for these use\ncases. With the z3c.form framework all attributes -- for which it is\nsensible to replace a value without touching the code -- are\ncustomizable via an attribute value adapter.\n\nTo demonstrate this feature, let's change the label of the name widget\nfrom \"Name\" to \"Full Name\":\n\n  >>> from z3c.form import widget\n  >>> NameLabel = widget.StaticWidgetAttribute(\n  ...     u'Full Name', field=IPerson['name'])\n  >>> zope.component.provideAdapter(NameLabel, name='label')\n\nWhen the form renders, the label has now changed:\n\n  >>> addForm = PersonAddForm(root, TestRequest())\n  >>> addTemplate(addForm)\n  >>> addForm.update()\n  >>> print(testing.render(addForm, './/xmlns:div[2][@class=\"row\"]'))\n  <div class=\"row\">\n    <label for=\"form-widgets-name\">Full Name</label>\n    <input class=\"text-widget required textline-field\"\n           id=\"form-widgets-name\" name=\"form.widgets.name\" type=\"text\" value=\"\">\n  </div>\n\n\nAdding a \"Cancel\" button\n------------------------\n\nLet's say a client requests that all add forms should have a \"Cancel\"\nbutton. When the button is pressed, the user is forwarded to the next URL of\nthe add form. As always, the goal is to not touch the core implementation of\nthe code, but make those changes externally.\n\nAdding a button/action is a little bit more involved than changing a value,\nbecause you have to insert the additional action and customize the action\nhandler. Based on your needs of flexibility, multiple approaches could be\nchosen. Here we demonstrate the simplest one.\n\nThe first step is to create a custom action manager that always inserts a\ncancel action:\n\n  >>> from z3c.form import button\n  >>> class AddActions(button.ButtonActions):\n  ...     zope.component.adapts(\n  ...         interfaces.IAddForm,\n  ...         zope.interface.Interface,\n  ...         zope.interface.Interface)\n  ...\n  ...     def update(self):\n  ...         self.form.buttons = button.Buttons(\n  ...             self.form.buttons,\n  ...             button.Button('cancel', u'Cancel'))\n  ...         super(AddActions, self).update()\n\nAfter registering the new action manager,\n\n  >>> zope.component.provideAdapter(AddActions)\n\nthe add form should display a cancel button:\n\n  >>> addForm.update()\n  >>> print(testing.render(addForm, './/xmlns:div[@class=\"action\"]'))\n  <div class=\"action\">\n    <input type=\"submit\" id=\"form-buttons-add\" name=\"form.buttons.add\"\n           class=\"submit-widget button-field\" value=\"Add\" />\n  </div>\n  <div class=\"action\">\n    <input type=\"submit\" id=\"form-buttons-cancel\" name=\"form.buttons.cancel\"\n           class=\"submit-widget button-field\" value=\"Cancel\" />\n  </div>\n\nBut showing the button does not mean it does anything. So we also need a\ncustom action handler to handle the cancel action:\n\n  >>> class AddActionHandler(button.ButtonActionHandler):\n  ...     zope.component.adapts(\n  ...         interfaces.IAddForm,\n  ...         zope.interface.Interface,\n  ...         zope.interface.Interface,\n  ...         button.ButtonAction)\n  ...\n  ...     def __call__(self):\n  ...         if self.action.name == 'form.buttons.cancel':\n  ...            self.form._finishedAdd = True\n  ...            return\n  ...         super(AddActionHandler, self).__call__()\n\nAfter registering the action handler,\n\n  >>> zope.component.provideAdapter(AddActionHandler)\n\nwe can press the cancel button and we will be forwarded:\n\n  >>> request = TestRequest(form={'form.buttons.cancel': u'Cancel'})\n\n  >>> addForm = PersonAddForm(root, request)\n  >>> addTemplate(addForm)\n  >>> addForm.update()\n  >>> addForm.render()\n  ''\n\n  >>> request.response.getStatus()\n  302\n  >>> request.response.getHeader('Location')\n  'index.html'\n\nEventually, we might have action managers and handlers that are much more\npowerful and some of the manual labor in this example would become\nunnecessary.\n\n\nCreating an Edit Form\n---------------------\n\nNow that we have exhaustively covered the customization possibilities of add\nforms, let's create an edit form. Edit forms are even simpler than add forms,\nsince all actions are completely automatic:\n\n  >>> class PersonEditForm(form.EditForm):\n  ...\n  ...     fields = field.Fields(IPerson)\n\nWe can use the created person from the successful addition above.\n\n  >>> editForm = PersonEditForm(root[u'srichter'], TestRequest())\n\nAfter adding a template, we can look at the form:\n\n  >>> addTemplate(editForm)\n  >>> editForm.update()\n  >>> print(editForm.render())\n  <html xmlns=\"http://www.w3.org/1999/xhtml\">\n    <body>\n      <form action=\".\">\n        <div class=\"row\">\n            <label for=\"form-widgets-id\">ID</label>\n            <span id=\"form-widgets-id\"\n                  class=\"text-widget textline-field\">srichter</span>\n        </div>\n        <div class=\"row\">\n          <label for=\"form-widgets-name\">Full Name</label>\n          <input type=\"text\" id=\"form-widgets-name\" name=\"form.widgets.name\"\n                 class=\"text-widget required textline-field\"\n                 value=\"Stephan Richter\" />\n        </div>\n        <div class=\"row\">\n          <label for=\"form-widgets-gender\">Gender</label>\n          <select id=\"form-widgets-gender\" name=\"form.widgets.gender:list\"\n                  class=\"select-widget choice-field\" size=\"1\">\n            <option id=\"form-widgets-gender-novalue\"\n                    value=\"--NOVALUE--\">No value</option>\n            <option id=\"form-widgets-gender-0\" value=\"male\"\n                    selected=\"selected\">male</option>\n            <option id=\"form-widgets-gender-1\" value=\"female\">female</option>\n          </select>\n          <input name=\"form.widgets.gender-empty-marker\" type=\"hidden\"\n                 value=\"1\" />\n        </div>\n        <div class=\"row\">\n          <label for=\"form-widgets-age\">Age</label>\n          <input type=\"text\" id=\"form-widgets-age\" name=\"form.widgets.age\"\n                 class=\"text-widget int-field\" value=\"20\" />\n        </div>\n        <div class=\"action\">\n          <input type=\"submit\" id=\"form-buttons-apply\" name=\"form.buttons.apply\"\n                 class=\"submit-widget button-field\" value=\"Apply\" />\n        </div>\n      </form>\n    </body>\n  </html>\n\nAs you can see, the data are being pulled in from the context for the edit\nform. Next we will look at the behavior when submitting the form.\n\n\nFailure Upon Submission of Edit Form\n------------------------------------\n\nLet's now submit the form having some invalid data.\n\n  >>> request = TestRequest(form={\n  ...     'form.widgets.name': u'Claudia Richter',\n  ...     'form.widgets.gender': ['female'],\n  ...     'form.widgets.age': u'-1',\n  ...     'form.buttons.apply': u'Apply'}\n  ...     )\n\n  >>> editForm = PersonEditForm(root[u'srichter'], request)\n  >>> addTemplate(editForm)\n  >>> editForm.update()\n  >>> print(editForm.render())\n  <html xmlns=\"http://www.w3.org/1999/xhtml\">\n    <body>\n      <i>There were some errors.</i>\n      <ul>\n        <li>\n          Age: <div class=\"error\">The value cannot be a negative number.</div>\n        </li>\n      </ul>\n      <form action=\".\">\n        <div class=\"row\">\n            <label for=\"form-widgets-id\">ID</label>\n            <span id=\"form-widgets-id\"\n                  class=\"text-widget textline-field\">srichter</span>\n        </div>\n        <div class=\"row\">\n          <label for=\"form-widgets-name\">Full Name</label>\n          <input type=\"text\" id=\"form-widgets-name\" name=\"form.widgets.name\"\n                 class=\"text-widget required textline-field\"\n                 value=\"Claudia Richter\" />\n        </div>\n        <div class=\"row\">\n          <label for=\"form-widgets-gender\">Gender</label>\n          <select id=\"form-widgets-gender\" name=\"form.widgets.gender:list\"\n                  class=\"select-widget choice-field\" size=\"1\">\n            <option id=\"form-widgets-gender-novalue\"\n                    value=\"--NOVALUE--\">No value</option>\n            <option id=\"form-widgets-gender-0\" value=\"male\">male</option>\n            <option id=\"form-widgets-gender-1\" value=\"female\"\n                    selected=\"selected\">female</option>\n          </select>\n          <input name=\"form.widgets.gender-empty-marker\" type=\"hidden\"\n                 value=\"1\" />\n        </div>\n        <div class=\"row\">\n          <b><div class=\"error\">The value cannot be a negative number.</div>\n          </b><label for=\"form-widgets-age\">Age</label>\n          <input type=\"text\" id=\"form-widgets-age\" name=\"form.widgets.age\"\n                 class=\"text-widget int-field\" value=\"-1\" />\n        </div>\n        <div class=\"action\">\n          <input type=\"submit\" id=\"form-buttons-apply\" name=\"form.buttons.apply\"\n                 class=\"submit-widget button-field\" value=\"Apply\" />\n        </div>\n      </form>\n    </body>\n  </html>\n\n\nSuccessfully Editing Content\n----------------------------\n\nLet's now resubmit the form with valid data, so the data should be updated.\n\n  >>> request = TestRequest(form={\n  ...     'form.widgets.name': u'Claudia Richter',\n  ...     'form.widgets.gender': ['female'],\n  ...     'form.widgets.age': u'27',\n  ...     'form.buttons.apply': u'Apply'}\n  ...     )\n\n  >>> editForm = PersonEditForm(root[u'srichter'], request)\n  >>> addTemplate(editForm)\n  >>> editForm.update()\n  >>> print(testing.render(editForm, './/xmlns:i'))\n  <i>Data successfully updated.</i>\n\n  >>> stephan = root[u'srichter']\n  >>> stephan.name\n  u'Claudia Richter'\n  >>> stephan.gender\n  'female'\n  >>> stephan.age\n  27\n\nWhen an edit form is successfully committed, a detailed object-modified event\nis sent out telling the system about the changes. To see the error, let's\ncreate an event subscriber for object-modified events:\n\n  >>> eventlog = []\n  >>> import zope.lifecycleevent\n  >>> @zope.component.adapter(zope.lifecycleevent.ObjectModifiedEvent)\n  ... def logEvent(event):\n  ...     eventlog.append(event)\n  >>> zope.component.provideHandler(logEvent)\n\nLet's now submit the form again, successfully changing the age:\n\n  >>> request = TestRequest(form={\n  ...     'form.widgets.name': u'Claudia Richter',\n  ...     'form.widgets.gender': ['female'],\n  ...     'form.widgets.age': u'29',\n  ...     'form.buttons.apply': u'Apply'}\n  ...     )\n\n  >>> editForm = PersonEditForm(root[u'srichter'], request)\n  >>> addTemplate(editForm)\n  >>> editForm.update()\n\nWe can now look at the event:\n\n  >>> event = eventlog[-1]\n  >>> event\n  <zope...ObjectModifiedEvent object at ...>\n\n  >>> attrs = event.descriptions[0]\n  >>> attrs.interface\n  <InterfaceClass __builtin__.IPerson>\n  >>> attrs.attributes\n  ('age',)\n\n\nSuccessful Action with No Changes\n---------------------------------\n\nWhen submitting the form without any changes, the form will tell you so.\n\n  >>> request = TestRequest(form={\n  ...     'form.widgets.name': u'Claudia Richter',\n  ...     'form.widgets.gender': ['female'],\n  ...     'form.widgets.age': u'29',\n  ...     'form.buttons.apply': u'Apply'}\n  ...     )\n\n  >>> editForm = PersonEditForm(root[u'srichter'], request)\n  >>> addTemplate(editForm)\n  >>> editForm.update()\n  >>> print(testing.render(editForm, './/xmlns:i'))\n  <i>No changes were applied.</i>\n\n\nChanging Status Messages\n------------------------\n\nDepending on the project, it is often desirable to change the status messages\nto fit the application. In ``zope.formlib`` this was hard to do, since the\nmessages were buried within fairly complex methods that one did not want to\ntouch. In this package all those messages are exposed as form attributes.\n\nThere are three messages for the edit form:\n\n* ``formErrorsMessage`` -- Indicates that an error occurred while\n  applying the changes. This message is also available for the add form.\n\n* ``successMessage`` -- The form data was successfully applied.\n\n* ``noChangesMessage`` -- No changes were found in the form data.\n\nLet's now change the ``noChangesMessage``:\n\n  >>> editForm.noChangesMessage = u'No changes were detected in the form data.'\n  >>> editForm.update()\n  >>> print(testing.render(editForm, './/xmlns:i'))\n  <i>No changes were detected in the form data.</i>\n\nWhen even more flexibility is required within a project, one could also\nimplement these messages as properties looking up an attribute value. However,\nwe have found this to be a rare case.\n\n\nCreating Edit Forms for Dictionaries\n------------------------------------\n\nSometimes it is not desirable to edit a class instance that implements the\nfields, but other types of object. A good example is the need to modify a\nsimple dictionary, where the field names are the keys. To do that, a special\ndata manager for dictionaries is available:\n\n  >>> from z3c.form import datamanager\n  >>> zope.component.provideAdapter(datamanager.DictionaryField)\n\nThe only step the developer has to complete is to re-implement the form's\n``getContent()`` method to return the dictionary:\n\n  >>> personDict = {'id': u'rineichen', 'name': u'Roger Ineichen',\n  ...               'gender': None, 'age': None}\n  >>> class PersonDictEditForm(PersonEditForm):\n  ...     def getContent(self):\n  ...         return personDict\n\nWe can now use the form as usual:\n\n  >>> editForm = PersonDictEditForm(None, TestRequest())\n  >>> addTemplate(editForm)\n  >>> editForm.update()\n  >>> print(editForm.render())\n  <html xmlns=\"http://www.w3.org/1999/xhtml\">\n    <body>\n      <form action=\".\">\n        <div class=\"row\">\n          <label for=\"form-widgets-id\">ID</label>\n          <span id=\"form-widgets-id\"\n                class=\"text-widget textline-field\">rineichen</span>\n        </div>\n        <div class=\"row\">\n          <label for=\"form-widgets-name\">Full Name</label>\n          <input type=\"text\" id=\"form-widgets-name\"\n                 name=\"form.widgets.name\"\n                 class=\"text-widget required textline-field\"\n         value=\"Roger Ineichen\" />\n        </div>\n        <div class=\"row\">\n          <label for=\"form-widgets-gender\">Gender</label>\n          <select id=\"form-widgets-gender\" name=\"form.widgets.gender:list\"\n                  class=\"select-widget choice-field\" size=\"1\">\n            <option id=\"form-widgets-gender-novalue\"\n                    value=\"--NOVALUE--\" selected=\"selected\">No value</option>\n            <option id=\"form-widgets-gender-0\" value=\"male\">male</option>\n            <option id=\"form-widgets-gender-1\" value=\"female\">female</option>\n          </select>\n          <input name=\"form.widgets.gender-empty-marker\" type=\"hidden\"\n                 value=\"1\" />\n        </div>\n        <div class=\"row\">\n          <label for=\"form-widgets-age\">Age</label>\n          <input type=\"text\" id=\"form-widgets-age\"\n                 name=\"form.widgets.age\" class=\"text-widget int-field\"\n                 value=\"20\" />\n        </div>\n        <div class=\"action\">\n          <input type=\"submit\" id=\"form-buttons-apply\"\n                 name=\"form.buttons.apply\" class=\"submit-widget button-field\"\n                 value=\"Apply\" />\n        </div>\n      </form>\n    </body>\n  </html>\n\nNote that the name displayed in the form is identical to the one in the\ndictionary. Let's now submit a form to ensure that the data are also written to\nthe dictionary:\n\n  >>> request = TestRequest(form={\n  ...     'form.widgets.name': u'Jesse Ineichen',\n  ...     'form.widgets.gender': ['male'],\n  ...     'form.widgets.age': u'5',\n  ...     'form.buttons.apply': u'Apply'}\n  ...     )\n  >>> editForm = PersonDictEditForm(None, request)\n  >>> editForm.update()\n\n  >>> len(personDict)\n  4\n  >>> personDict['age']\n  5\n  >>> personDict['gender']\n  'male'\n  >>> personDict['id']\n  u'rineichen'\n  >>> personDict['name']\n  u'Jesse Ineichen'\n\n\nCreating a Display Form\n-----------------------\n\nCreating a display form is simple; just instantiate, update and render it:\n\n  >>> class PersonDisplayForm(form.DisplayForm):\n  ...     fields = field.Fields(IPerson)\n  ...     template = ViewPageTemplateFile(\n  ...         'simple_display.pt', os.path.dirname(tests.__file__))\n\n  >>> display = PersonDisplayForm(stephan, TestRequest())\n  >>> display.update()\n  >>> print(display.render())\n  <html xmlns=\"http://www.w3.org/1999/xhtml\">\n    <body>\n      <div class=\"row\">\n        <span id=\"form-widgets-id\"\n              class=\"text-widget textline-field\">srichter</span>\n      </div>\n      <div class=\"row\">\n        <span id=\"form-widgets-name\"\n              class=\"text-widget textline-field\">Claudia Richter</span>\n      </div>\n      <div class=\"row\">\n        <span id=\"form-widgets-gender\"\n              class=\"select-widget choice-field\"><span\n            class=\"selected-option\">female</span></span>\n      </div>\n      <div class=\"row\">\n        <span id=\"form-widgets-age\" class=\"text-widget int-field\">29</span>\n      </div>\n    </body>\n  </html>\n\n\nSimple Form Customization\n-------------------------\n\nThe form exposes several of the widget manager's attributes as attributes on\nthe form. They are: ``mode``, ``ignoreContext``, ``ignoreRequest``, and\n``ignoreReadonly``.\n\nHere are the values for the display form we just created:\n\n  >>> display.mode\n  'display'\n  >>> display.ignoreContext\n  False\n  >>> display.ignoreRequest\n  True\n  >>> display.ignoreReadonly\n  False\n\nThese values should be equal to the ones of the widget manager:\n\n  >>> display.widgets.mode\n  'display'\n  >>> display.widgets.ignoreContext\n  False\n  >>> display.widgets.ignoreRequest\n  True\n  >>> display.widgets.ignoreReadonly\n  False\n\nNow, if we change those values before updating the widgets, ...\n\n  >>> display.mode = interfaces.INPUT_MODE\n  >>> display.ignoreContext = True\n  >>> display.ignoreRequest = False\n  >>> display.ignoreReadonly = True\n\n... the widget manager will have the same values after updating the widgets:\n\n  >>> display.updateWidgets()\n\n  >>> display.widgets.mode\n  'input'\n  >>> display.widgets.ignoreContext\n  True\n  >>> display.widgets.ignoreRequest\n  False\n  >>> display.widgets.ignoreReadonly\n  True\n\nWe can also set the widget prefix when we update the widgets:\n\n  >>> display.updateWidgets(prefix=\"person\")\n  >>> display.widgets.prefix\n  'person'\n\nThis will affect the individual widgets' names:\n\n  >>> display.widgets['id'].name\n  'form.person.id'\n\nTo use unqualified names, we must clear both the form prefix and the\nwidgets prefix:\n\n  >>> display.prefix = \"\"\n  >>> display.updateWidgets(prefix=\"\")\n  >>> display.widgets['id'].name\n  'id'\n\nExtending Forms\n---------------\n\nOne very common use case is to extend forms. For example, you would like to\nuse the edit form and its defined \"Apply\" button, but add another button\nyourself. Unfortunately, just inheriting the form is not enough, because the\nnew button and handler declarations will override the inherited ones. Let me\ndemonstrate the problem:\n\n  >>> class BaseForm(form.Form):\n  ...     fields = field.Fields(IPerson).select('name')\n  ...\n  ...     @button.buttonAndHandler(u'Apply')\n  ...     def handleApply(self, action):\n  ...         print('success')\n\n  >>> BaseForm.fields.keys()\n  ['name']\n  >>> BaseForm.buttons.keys()\n  ['apply']\n  >>> BaseForm.handlers\n  <Handlers [<Handler for <Button 'apply' u'Apply'>>]>\n\nLet's now derive a form from the base form:\n\n  >>> class DerivedForm(BaseForm):\n  ...     fields = field.Fields(IPerson).select('gender')\n  ...\n  ...     @button.buttonAndHandler(u'Cancel')\n  ...     def handleCancel(self, action):\n  ...         print('cancel')\n\n  >>> DerivedForm.fields.keys()\n  ['gender']\n  >>> DerivedForm.buttons.keys()\n  ['cancel']\n  >>> DerivedForm.handlers\n  <Handlers [<Handler for <Button 'cancel' u'Cancel'>>]>\n\nThe obvious method to \"inherit\" the base form's information is to copy it\nover:\n\n  >>> class DerivedForm(BaseForm):\n  ...     fields = BaseForm.fields.copy()\n  ...     buttons = BaseForm.buttons.copy()\n  ...     handlers = BaseForm.handlers.copy()\n  ...\n  ...     fields += field.Fields(IPerson).select('gender')\n  ...\n  ...     @button.buttonAndHandler(u'Cancel')\n  ...     def handleCancel(self, action):\n  ...         print('cancel')\n\n  >>> DerivedForm.fields.keys()\n  ['name', 'gender']\n  >>> DerivedForm.buttons.keys()\n  ['apply', 'cancel']\n  >>> DerivedForm.handlers\n  <Handlers\n      [<Handler for <Button 'apply' u'Apply'>>,\n       <Handler for <Button 'cancel' u'Cancel'>>]>\n\nBut this is pretty clumsy. Instead, the ``form`` module provides a helper\nmethod that will do the extending for you:\n\n  >>> class DerivedForm(BaseForm):\n  ...     form.extends(BaseForm)\n  ...\n  ...     fields += field.Fields(IPerson).select('gender')\n  ...\n  ...     @button.buttonAndHandler(u'Cancel')\n  ...     def handleCancel(self, action):\n  ...         print('cancel')\n\n  >>> DerivedForm.fields.keys()\n  ['name', 'gender']\n  >>> DerivedForm.buttons.keys()\n  ['apply', 'cancel']\n  >>> DerivedForm.handlers\n  <Handlers\n      [<Handler for <Button 'apply' u'Apply'>>,\n       <Handler for <Button 'cancel' u'Cancel'>>]>\n\nIf you, for example do not want to extend the buttons, you can turn that off:\n\n  >>> class DerivedForm(BaseForm):\n  ...     form.extends(BaseForm, ignoreButtons=True)\n  ...\n  ...     fields += field.Fields(IPerson).select('gender')\n  ...\n  ...     @button.buttonAndHandler(u'Cancel')\n  ...     def handleCancel(self, action):\n  ...         print('cancel')\n\n  >>> DerivedForm.fields.keys()\n  ['name', 'gender']\n  >>> DerivedForm.buttons.keys()\n  ['cancel']\n  >>> DerivedForm.handlers\n  <Handlers\n      [<Handler for <Button 'apply' u'Apply'>>,\n       <Handler for <Button 'cancel' u'Cancel'>>]>\n\nIf you, for example do not want to extend the handlers, you can turn that off:\n\n  >>> class DerivedForm(BaseForm):\n  ...     form.extends(BaseForm, ignoreHandlers=True)\n  ...\n  ...     fields += field.Fields(IPerson).select('gender')\n  ...\n  ...     @button.buttonAndHandler(u'Cancel')\n  ...     def handleCancel(self, action):\n  ...         print('cancel')\n\n  >>> DerivedForm.fields.keys()\n  ['name', 'gender']\n  >>> DerivedForm.buttons.keys()\n  ['apply', 'cancel']\n  >>> DerivedForm.handlers\n  <Handlers [<Handler for <Button 'cancel' u'Cancel'>>]>\n\n\nCustom widget factories\n-----------------------\n\nAnother important part of a form is that we can use custom widgets. We can do\nthis in a form by defining a widget factory for a field. We can get the field\nfrom the fields collection e.g. ``fields['foo']``. This means, we can define\nnew widget factories by defining ``fields['foo'].widgetFactory = MyWidget``.\nLet's show a sample and define a custom widget:\n\n  >>> from z3c.form.browser import text\n  >>> class MyWidget(text.TextWidget):\n  ...     \"\"\"My new widget.\"\"\"\n  ...     klass = u'MyCSS'\n\nNow we can define a field widget factory:\n\n  >>> def MyFieldWidget(field, request):\n  ...     \"\"\"IFieldWidget factory for MyWidget.\"\"\"\n  ...     return widget.FieldWidget(field, MyWidget(request))\n\nWe register the ``MyWidget`` in a form like:\n\n  >>> class MyEditForm(form.EditForm):\n  ...\n  ...     fields = field.Fields(IPerson)\n  ...     fields['name'].widgetFactory = MyFieldWidget\n\nWe can see that the custom widget gets used in the rendered form:\n\n  >>> myEdit = MyEditForm(root[u'srichter'], TestRequest())\n  >>> addTemplate(myEdit)\n  >>> myEdit.update()\n  >>> print(testing.render(myEdit, './/xmlns:input[@id=\"form-widgets-name\"]'))\n  <input type=\"text\" id=\"form-widgets-name\"\n         name=\"form.widgets.name\" class=\"MyCSS required textline-field\"\n         value=\"Claudia Richter\" />\n\n\nHidden fields\n-------------\n\nAnother important part of a form is that we can generate hidden widgets. We can\ndo this in a form by defining a widget mode. We can do this by override the\nsetUpWidgets method.\n\n  >>> class HiddenFieldEditForm(form.EditForm):\n  ...\n  ...     fields = field.Fields(IPerson)\n  ...     fields['name'].widgetFactory = MyFieldWidget\n  ...\n  ...     def updateWidgets(self):\n  ...         super(HiddenFieldEditForm, self).updateWidgets()\n  ...         self.widgets['age'].mode = interfaces.HIDDEN_MODE\n\nWe can see that the widget gets rendered as hidden:\n\n  >>> hiddenEdit = HiddenFieldEditForm(root[u'srichter'], TestRequest())\n  >>> addTemplate(hiddenEdit)\n  >>> hiddenEdit.update()\n  >>> print(testing.render(hiddenEdit, './/xmlns:input[@id=\"form-widgets-age\"]'))\n  <input type=\"hidden\" id=\"form-widgets-age\"\n         name=\"form.widgets.age\" class=\"hidden-widget\"\n         value=\"29\" />\n\n\nActions with Errors\n-------------------\n\nEven though the data might be validated correctly, it sometimes happens that\ndata turns out to be invalid while the action is executed. In those cases a\nspecial action execution error can be raised that wraps the original error.\n\n  >>> class PersonAddForm(form.AddForm):\n  ...\n  ...     fields = field.Fields(IPerson).select('id')\n  ...\n  ...     @button.buttonAndHandler(u'Check')\n  ...     def handleCheck(self, action):\n  ...         data, errors = self.extractData()\n  ...         if data['id'] in self.getContent():\n  ...             raise interfaces.WidgetActionExecutionError(\n  ...                 'id', zope.interface.Invalid('Id already exists'))\n\nIn this case the action execution error is specific to a widget. The framework\nwill attach a proper error view to the widget and the widget manager:\n\n  >>> request = TestRequest(form={\n  ...     'form.widgets.id': u'srichter',\n  ...     'form.buttons.check': u'Check'}\n  ...     )\n\n  >>> addForm = PersonAddForm(root, request)\n  >>> addForm.update()\n\n  >>> addForm.widgets.errors\n  (<InvalidErrorViewSnippet for Invalid>,)\n  >>> addForm.widgets['id'].error\n  <InvalidErrorViewSnippet for Invalid>\n  >>> addForm.status\n  u'There were some errors.'\n\nIf the error is non-widget specific, then we can simply use the generic action\nexecution error:\n\n  >>> class PersonAddForm(form.AddForm):\n  ...\n  ...     fields = field.Fields(IPerson).select('id')\n  ...\n  ...     @button.buttonAndHandler(u'Check')\n  ...     def handleCheck(self, action):\n  ...         raise interfaces.ActionExecutionError(\n  ...             zope.interface.Invalid('Some problem occurred.'))\n\nLet's have a look at the result:\n\n  >>> addForm = PersonAddForm(root, request)\n  >>> addForm.update()\n\n  >>> addForm.widgets.errors\n  (<InvalidErrorViewSnippet for Invalid>,)\n  >>> addForm.status\n  u'There were some errors.'\n\n**Note**:\n\n  The action execution errors are connected to the form via an event\n  listener called ``handlerActionError``. This event listener listens for\n  ``IActionErrorEvent`` events. If the event is called for an action associated\n  with a form, the listener does its work as seen above. If the action is not\n  coupled to a form, then event listener does nothing:\n\n    >>> from z3c.form import action\n\n    >>> cancel = action.Action(request, u'Cancel')\n    >>> event = action.ActionErrorOccurred(cancel, ValueError(3))\n\n    >>> form.handleActionError(event)\n\n\nApplying Changes\n----------------\n\nWhen applying the data of a form to a content component, the function\n``applyChanges()`` is called. It simply iterates through the fields of the\nform and uses the data managers to store the values. The output of the\nfunction is a list of changes:\n\n  >>> roger = Person(u'roger', u'Roger')\n  >>> roger\n  <Person u'Roger'>\n\n  >>> class BaseForm(form.Form):\n  ...     fields = field.Fields(IPerson).select('name')\n  >>> myForm = BaseForm(roger, TestRequest())\n\n  >>> form.applyChanges(myForm, roger, {'name': u'Roger Ineichen'})\n  {<InterfaceClass __builtin__.IPerson>: ['name']}\n\n  >>> roger\n  <Person u'Roger Ineichen'>\n\nWhen a field is missing from the data, it is simply skipped:\n\n  >>> form.applyChanges(myForm, roger, {})\n  {}\n\nIf the new and old value are identical, storing the data is skipped as well:\n\n  >>> form.applyChanges(myForm, roger, {'name': u'Roger Ineichen'})\n  {}\n\nIn some cases the data converter for a field-widget pair returns the\n``NOT_CHANGED`` value. In this case, the field is skipped as well:\n\n  >>> form.applyChanges(myForm, roger, {'name': interfaces.NOT_CHANGED})\n  {}\n\n  >>> roger\n  <Person u'Roger Ineichen'>\n\n\nRefreshing actions\n------------------\n\nSometimes, it's useful to update actions again after executing them,\nbecause some conditions could have changed. For example, imagine\nwe have a sequence edit form that has a delete button. We don't\nwant to show delete button when the sequence is empty. The button\ncondition would handle this, but what if the sequence becomes empty\nas a result of execution of the delete action that was available?\nIn that case we want to refresh our actions to new conditions to make\nour delete button not visible anymore. The ``refreshActions`` form\nvariable is intended to handle this case.\n\nLet's create a simple form with an action that clears our context\nsequence.\n\n  >>> class SequenceForm(form.Form):\n  ...\n  ...     @button.buttonAndHandler(u'Empty', condition=lambda form:bool(form.context))\n  ...     def handleEmpty(self, action):\n  ...         self.context[:] = []\n  ...         self.refreshActions = True\n\nFirst, let's illustrate simple cases, when no button is pressed.\nThe button will be available when context is not empty.\n\n  >>> context = [1, 2, 3, 4]\n  >>> request = TestRequest()\n  >>> myForm = SequenceForm(context, request)\n  >>> myForm.update()\n  >>> addTemplate(myForm)\n  >>> print(testing.render(myForm, './/xmlns:div[@class=\"action\"]'))\n  <div class=\"action\">\n    <input type=\"submit\" id=\"form-buttons-empty\" name=\"form.buttons.empty\"\n           class=\"submit-widget button-field\" value=\"Empty\" />\n  </div>\n\nThe button will not be available when the context is empty.\n\n  >>> context = []\n  >>> request = TestRequest()\n  >>> myForm = SequenceForm(context, request)\n  >>> myForm.update()\n  >>> addTemplate(myForm)\n  >>> print(testing.render(myForm, './/xmlns:form'))\n  <form action=\".\">\n  </form>\n\nNow, the most interesting case when context is not empty, but becomes\nempty as a result of pressing the \"empty\" button. We set the\n``refreshActions`` flag in the action handler, so our actions should\nbe updated to new conditions.\n\n  >>> context = [1, 2, 3, 4, 5]\n  >>> request = TestRequest(form={\n  ...     'form.buttons.empty': u'Empty'}\n  ...     )\n  >>> myForm = SequenceForm(context, request)\n  >>> myForm.update()\n  >>> addTemplate(myForm)\n  >>> print(testing.render(myForm, './/xmlns:form'))\n  <form action=\".\">\n  </form>\n\nIntegration tests\n-----------------\n\nIdentifying the different forms can be important if it comes to layout\ntemplate lookup. Let's ensure that we support the right interfaces for the\ndifferent forms.\n\n\nForm\n~~~~\n\n  >>> from zope.interface.verify import verifyObject\n  >>> from z3c.form import interfaces\n  >>> obj = form.Form(None, None)\n  >>> verifyObject(interfaces.IForm, obj)\n  True\n\n  >>> interfaces.IForm.providedBy(obj)\n  True\n\n  >>> from z3c.form import interfaces\n  >>> interfaces.IDisplayForm.providedBy(obj)\n  False\n\n  >>> from z3c.form import interfaces\n  >>> interfaces.IEditForm.providedBy(obj)\n  False\n\n  >>> from z3c.form import interfaces\n  >>> interfaces.IAddForm.providedBy(obj)\n  False\n\n\nDisplayForm\n~~~~~~~~~~~\n\n  >>> from z3c.form import interfaces\n  >>> obj = form.DisplayForm(None, None)\n  >>> verifyObject(interfaces.IDisplayForm, obj)\n  True\n\n  >>> interfaces.IForm.providedBy(obj)\n  True\n\n  >>> from z3c.form import interfaces\n  >>> interfaces.IDisplayForm.providedBy(obj)\n  True\n\n  >>> from z3c.form import interfaces\n  >>> interfaces.IEditForm.providedBy(obj)\n  False\n\n  >>> from z3c.form import interfaces\n  >>> interfaces.IAddForm.providedBy(obj)\n  False\n\n\nEditForm\n~~~~~~~~\n\n  >>> from z3c.form import interfaces\n  >>> obj = form.EditForm(None, None)\n  >>> verifyObject(interfaces.IEditForm, obj)\n  True\n\n  >>> interfaces.IForm.providedBy(obj)\n  True\n\n  >>> from z3c.form import interfaces\n  >>> interfaces.IDisplayForm.providedBy(obj)\n  False\n\n  >>> from z3c.form import interfaces\n  >>> interfaces.IEditForm.providedBy(obj)\n  True\n\n  >>> from z3c.form import interfaces\n  >>> interfaces.IAddForm.providedBy(obj)\n  False\n\n\nAddForm\n~~~~~~~\n\n  >>> from z3c.form import interfaces\n  >>> obj = form.AddForm(None, None)\n  >>> verifyObject(interfaces.IAddForm, obj)\n  True\n\n  >>> interfaces.IForm.providedBy(obj)\n  True\n\n  >>> from z3c.form import interfaces\n  >>> interfaces.IDisplayForm.providedBy(obj)\n  False\n\n  >>> from z3c.form import interfaces\n  >>> interfaces.IEditForm.providedBy(obj)\n  False\n\n  >>> from z3c.form import interfaces\n  >>> interfaces.IAddForm.providedBy(obj)\n  True\n\n===========\nGroup Forms\n===========\n\nGroup forms allow you to split up a form into several logical units without\nmuch overhead. To the parent form, groups should be only dealt with during\ncoding and be transparent on the data extraction level.\n\nFor the examples to work, we have to bring up most of the form framework:\n\n  >>> from z3c.form import testing\n  >>> testing.setupFormDefaults()\n\nSo let's first define a complex content component that warrants setting up\nmultiple groups:\n\n  >>> import zope.interface\n  >>> import zope.schema\n\n  >>> class IVehicleRegistration(zope.interface.Interface):\n  ...     firstName = zope.schema.TextLine(title=u'First Name')\n  ...     lastName = zope.schema.TextLine(title=u'Last Name')\n  ...\n  ...     license = zope.schema.TextLine(title=u'License')\n  ...     address = zope.schema.TextLine(title=u'Address')\n  ...\n  ...     model = zope.schema.TextLine(title=u'Model')\n  ...     make = zope.schema.TextLine(title=u'Make')\n  ...     year = zope.schema.TextLine(title=u'Year')\n\n  >>> @zope.interface.implementer(IVehicleRegistration)\n  ... class VehicleRegistration(object):\n  ...\n  ...     def __init__(self, **kw):\n  ...         for name, value in kw.items():\n  ...             setattr(self, name, value)\n\nThe schema above can be separated into basic, license, and car information,\nwhere the latter two will be placed into groups. First we create the two\ngroups:\n\n  >>> from z3c.form import field, group\n\n  >>> class LicenseGroup(group.Group):\n  ...     label = u'License'\n  ...     fields = field.Fields(IVehicleRegistration).select(\n  ...         'license', 'address')\n\n  >>> class CarGroup(group.Group):\n  ...     label = u'Car'\n  ...     fields = field.Fields(IVehicleRegistration).select(\n  ...         'model', 'make', 'year')\n\nMost of the group is setup like any other (sub)form. Additionally, you can\nspecify a label, which is a human-readable string that can be used for layout\npurposes.\n\nLet's now create an add form for the entire vehicle registration. In\ncomparison to a regular add form, you only need to add the ``GroupForm`` as\none of the base classes. The groups are specified in a simple tuple:\n\n  >>> import os\n  >>> from zope.browserpage.viewpagetemplatefile import ViewPageTemplateFile\n  >>> from z3c.form import form, tests\n\n  >>> class RegistrationAddForm(group.GroupForm, form.AddForm):\n  ...     fields = field.Fields(IVehicleRegistration).select(\n  ...         'firstName', 'lastName')\n  ...     groups = (LicenseGroup, CarGroup)\n  ...\n  ...     template = ViewPageTemplateFile(\n  ...         'simple_groupedit.pt', os.path.dirname(tests.__file__))\n  ...\n  ...     def create(self, data):\n  ...         return VehicleRegistration(**data)\n  ...\n  ...     def add(self, object):\n  ...         self.getContent()['obj1'] = object\n  ...         return object\n\n\nNote: The order of the base classes is very important here. The ``GroupForm``\nclass must be left of the ``AddForm`` class, because the ``GroupForm`` class\noverrides some methods of the ``AddForm`` class.\n\nNow we can instantiate the form:\n\n  >>> request = testing.TestRequest()\n\n  >>> add = RegistrationAddForm(None, request)\n  >>> add.update()\n\nAfter the form is updated the tuple of group classes is converted to group\ninstances:\n\n  >>> add.groups\n  (<LicenseGroup object at ...>, <CarGroup object at ...>)\n\nIf we happen to update the add form again, the groups that have\nalready been converted to instances ares skipped.\n\n  >>> add.update()\n  >>> add.groups\n  (<LicenseGroup object at ...>, <CarGroup object at ...>)\n\nWe can now render the form:\n\n  >>> print(add.render())\n  <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n  <html xmlns=\"http://www.w3.org/1999/xhtml\">\n    <body>\n      <form action=\".\">\n        <div class=\"row\">\n          <label for=\"form-widgets-firstName\">First Name</label>\n          <input type=\"text\" id=\"form-widgets-firstName\"\n                 name=\"form.widgets.firstName\"\n                 class=\"text-widget required textline-field\"\n                 value=\"\" />\n        </div>\n        <div class=\"row\">\n          <label for=\"form-widgets-lastName\">Last Name</label>\n          <input type=\"text\" id=\"form-widgets-lastName\"\n                 name=\"form.widgets.lastName\"\n                 class=\"text-widget required textline-field\"\n                 value=\"\" />\n        </div>\n        <fieldset>\n          <legend>License</legend>\n          <div class=\"row\">\n            <label for=\"form-widgets-license\">License</label>\n            <input type=\"text\" id=\"form-widgets-license\"\n                   name=\"form.widgets.license\"\n                   class=\"text-widget required textline-field\"\n                   value=\"\" />\n          </div>\n          <div class=\"row\">\n            <label for=\"form-widgets-address\">Address</label>\n            <input type=\"text\" id=\"form-widgets-address\"\n                   name=\"form.widgets.address\"\n                   class=\"text-widget required textline-field\"\n                   value=\"\" />\n          </div>\n        </fieldset>\n        <fieldset>\n          <legend>Car</legend>\n          <div class=\"row\">\n            <label for=\"form-widgets-model\">Model</label>\n            <input type=\"text\" id=\"form-widgets-model\"\n                   name=\"form.widgets.model\"\n                   class=\"text-widget required textline-field\"\n                   value=\"\" />\n          </div>\n          <div class=\"row\">\n            <label for=\"form-widgets-make\">Make</label>\n            <input type=\"text\" id=\"form-widgets-make\"\n                   name=\"form.widgets.make\"\n                   class=\"text-widget required textline-field\"\n                   value=\"\" />\n          </div>\n          <div class=\"row\">\n            <label for=\"form-widgets-year\">Year</label>\n            <input type=\"text\" id=\"form-widgets-year\"\n                   name=\"form.widgets.year\"\n                   class=\"text-widget required textline-field\"\n                   value=\"\" />\n          </div>\n        </fieldset>\n        <div class=\"action\">\n          <input type=\"submit\" id=\"form-buttons-add\"\n                 name=\"form.buttons.add\" class=\"submit-widget button-field\"\n                 value=\"Add\" />\n        </div>\n      </form>\n    </body>\n  </html>\n\n\nRegistering a custom event handler for the DataExtractedEvent\n--------------------------------------------------------------\n\n  >>> data_extracted_eventlog = []\n  >>> from z3c.form.events import DataExtractedEvent\n  >>> @zope.component.adapter(DataExtractedEvent)\n  ... def data_extracted_logger(event):\n  ...     data_extracted_eventlog.append(event)\n  >>> zope.component.provideHandler(data_extracted_logger)\n\n\nLet's now submit the form, but forgetting to enter the address:\n\n  >>> request = testing.TestRequest(form={\n  ...     'form.widgets.firstName': u'Stephan',\n  ...     'form.widgets.lastName': u'Richter',\n  ...     'form.widgets.license': u'MA 40387',\n  ...     'form.widgets.model': u'BMW',\n  ...     'form.widgets.make': u'325',\n  ...     'form.widgets.year': u'2005',\n  ...     'form.buttons.add': u'Add'\n  ...     })\n\n  >>> add = RegistrationAddForm(None, request)\n  >>> add.update()\n  >>> print(testing.render(add, './/xmlns:i'))\n  <i>There were some errors.</i>\n\n  >>> print(testing.render(add, './/xmlns:fieldset[1]/xmlns:ul'))\n  <ul>\n    <li>\n      Address: <div class=\"error\">Required input is missing.</div>\n    </li>\n  </ul>\n\nAs you can see, the template is clever enough to just report the errors at the\ntop of the form, but still report the actual problem within the group.\n\n\nCheck, if DataExtractedEvent was thrown:\n\n  >>> len(data_extracted_eventlog) > 0\n  True\n\n\nSo what happens, if errors happen inside and outside a group?\n\n  >>> request = testing.TestRequest(form={\n  ...     'form.widgets.firstName': u'Stephan',\n  ...     'form.widgets.license': u'MA 40387',\n  ...     'form.widgets.model': u'BMW',\n  ...     'form.widgets.make': u'325',\n  ...     'form.widgets.year': u'2005',\n  ...     'form.buttons.add': u'Add'\n  ...     })\n\n  >>> add = RegistrationAddForm(None, request)\n  >>> add.update()\n  >>> print(testing.render(add, './/xmlns:i'))\n  <i>There were some errors.</i>\n\n  >>> print(testing.render(add, './/xmlns:ul'))\n  <ul>\n    <li>\n    Last Name:\n      <div class=\"error\">Required input is missing.</div>\n    </li>\n  </ul>\n  <ul>\n    <li>\n    Address:\n      <div class=\"error\">Required input is missing.</div>\n    </li>\n  </ul>\n\n  >>> print(testing.render(add, './/xmlns:fieldset[1]/xmlns:ul'))\n  <ul>\n    <li>\n      Address: <div class=\"error\">Required input is missing.</div>\n    </li>\n  </ul>\n\nLet's now successfully complete the add form.\n\n  >>> from zope.container import btree\n  >>> context = btree.BTreeContainer()\n\n  >>> request = testing.TestRequest(form={\n  ...     'form.widgets.firstName': u'Stephan',\n  ...     'form.widgets.lastName': u'Richter',\n  ...     'form.widgets.license': u'MA 40387',\n  ...     'form.widgets.address': u'10 Main St, Maynard, MA',\n  ...     'form.widgets.model': u'BMW',\n  ...     'form.widgets.make': u'325',\n  ...     'form.widgets.year': u'2005',\n  ...     'form.buttons.add': u'Add'\n  ...     })\n\n  >>> add = RegistrationAddForm(context, request)\n  >>> add.update()\n\nThe object is now added to the container and all attributes should be set:\n\n  >>> reg = context['obj1']\n  >>> reg.firstName\n  u'Stephan'\n  >>> reg.lastName\n  u'Richter'\n  >>> reg.license\n  u'MA 40387'\n  >>> reg.address\n  u'10 Main St, Maynard, MA'\n  >>> reg.model\n  u'BMW'\n  >>> reg.make\n  u'325'\n  >>> reg.year\n  u'2005'\n\nLet's now have a look at an edit form for the vehicle registration:\n\n  >>> class RegistrationEditForm(group.GroupForm, form.EditForm):\n  ...     fields = field.Fields(IVehicleRegistration).select(\n  ...         'firstName', 'lastName')\n  ...     groups = (LicenseGroup, CarGroup)\n  ...\n  ...     template = ViewPageTemplateFile(\n  ...         'simple_groupedit.pt', os.path.dirname(tests.__file__))\n\n  >>> request = testing.TestRequest()\n\n  >>> edit = RegistrationEditForm(reg, request)\n  >>> edit.update()\n\nAfter updating the form, we can render the HTML:\n\n  >>> print(edit.render())\n  <html xmlns=\"http://www.w3.org/1999/xhtml\">\n    <body>\n      <form action=\".\">\n        <div class=\"row\">\n          <label for=\"form-widgets-firstName\">First Name</label>\n          <input type=\"text\" id=\"form-widgets-firstName\"\n                 name=\"form.widgets.firstName\"\n                 class=\"text-widget required textline-field\"\n                 value=\"Stephan\" />\n        </div>\n        <div class=\"row\">\n          <label for=\"form-widgets-lastName\">Last Name</label>\n          <input type=\"text\" id=\"form-widgets-lastName\"\n                 name=\"form.widgets.lastName\"\n                 class=\"text-widget required textline-field\"\n                 value=\"Richter\" />\n         </div>\n        <fieldset>\n          <legend>License</legend>\n          <div class=\"row\">\n            <label for=\"form-widgets-license\">License</label>\n            <input type=\"text\" id=\"form-widgets-license\"\n                   name=\"form.widgets.license\"\n                   class=\"text-widget required textline-field\"\n                   value=\"MA 40387\" />\n          </div>\n          <div class=\"row\">\n            <label for=\"form-widgets-address\">Address</label>\n            <input type=\"text\" id=\"form-widgets-address\"\n                   name=\"form.widgets.address\"\n                   class=\"text-widget required textline-field\"\n                   value=\"10 Main St, Maynard, MA\" />\n          </div>\n        </fieldset>\n        <fieldset>\n          <legend>Car</legend>\n          <div class=\"row\">\n            <label for=\"form-widgets-model\">Model</label>\n            <input type=\"text\" id=\"form-widgets-model\"\n                   name=\"form.widgets.model\"\n                   class=\"text-widget required textline-field\"\n                   value=\"BMW\" />\n          </div>\n          <div class=\"row\">\n            <label for=\"form-widgets-make\">Make</label>\n            <input type=\"text\" id=\"form-widgets-make\"\n                   name=\"form.widgets.make\"\n                   class=\"text-widget required textline-field\"\n                   value=\"325\" />\n          </div>\n          <div class=\"row\">\n            <label for=\"form-widgets-year\">Year</label>\n            <input type=\"text\" id=\"form-widgets-year\"\n                   name=\"form.widgets.year\"\n                   class=\"text-widget required textline-field\"\n                   value=\"2005\" />\n          </div>\n        </fieldset>\n        <div class=\"action\">\n          <input type=\"submit\" id=\"form-buttons-apply\"\n                 name=\"form.buttons.apply\" class=\"submit-widget button-field\"\n                 value=\"Apply\" />\n        </div>\n      </form>\n    </body>\n  </html>\n\nThe behavior when an error occurs is identical to that of the add form:\n\n  >>> request = testing.TestRequest(form={\n  ...     'form.widgets.firstName': u'Stephan',\n  ...     'form.widgets.lastName': u'Richter',\n  ...     'form.widgets.license': u'MA 40387',\n  ...     'form.widgets.model': u'BMW',\n  ...     'form.widgets.make': u'325',\n  ...     'form.widgets.year': u'2005',\n  ...     'form.buttons.apply': u'Apply'\n  ...     })\n\n  >>> edit = RegistrationEditForm(reg, request)\n  >>> edit.update()\n  >>> print(testing.render(edit, './/xmlns:i'))\n  <i>There were some errors.</i>\n\n  >>> print(testing.render(edit, './/xmlns:ul'))\n  <ul>\n    <li>\n    Address:\n      <div class=\"error\">Required input is missing.</div>\n    </li>\n  </ul>\n\n  >>> print(testing.render(edit, './/xmlns:fieldset/xmlns:ul'))\n  <ul>\n    <li>\n      Address: <div class=\"error\">Required input is missing.</div>\n    </li>\n  </ul>\n\nWhen an edit form with groups is successfully committed, a detailed\nobject-modified event is sent out telling the system about the changes.\nTo see the error, let's create an event subscriber for object-modified events:\n\n  >>> eventlog = []\n  >>> import zope.lifecycleevent\n  >>> @zope.component.adapter(zope.lifecycleevent.ObjectModifiedEvent)\n  ... def logEvent(event):\n  ...     eventlog.append(event)\n  >>> zope.component.provideHandler(logEvent)\n\n\nLet's now complete the form successfully:\n\n  >>> request = testing.TestRequest(form={\n  ...     'form.widgets.firstName': u'Stephan',\n  ...     'form.widgets.lastName': u'Richter',\n  ...     'form.widgets.license': u'MA 4038765',\n  ...     'form.widgets.address': u'11 Main St, Maynard, MA',\n  ...     'form.widgets.model': u'Ford',\n  ...     'form.widgets.make': u'F150',\n  ...     'form.widgets.year': u'2006',\n  ...     'form.buttons.apply': u'Apply'\n  ...     })\n\n  >>> edit = RegistrationEditForm(reg, request)\n  >>> edit.update()\n\nThe success message will be shown on the form, ...\n\n  >>> print(testing.render(edit, './/xmlns:i'))\n  <i>Data successfully updated.</i>\n\nand the data are correctly updated:\n\n  >>> reg.firstName\n  u'Stephan'\n  >>> reg.lastName\n  u'Richter'\n  >>> reg.license\n  u'MA 4038765'\n  >>> reg.address\n  u'11 Main St, Maynard, MA'\n  >>> reg.model\n  u'Ford'\n  >>> reg.make\n  u'F150'\n  >>> reg.year\n  u'2006'\n\nLet's look at the event:\n\n  >>> event = eventlog[-1]\n  >>> event\n  <zope...ObjectModifiedEvent object at ...>\n\nThe event's description contains the changed Interface and the names of\nall changed fields, even if they where in different groups:\n\n  >>> attrs = event.descriptions[0]\n  >>> attrs.interface\n  <InterfaceClass __builtin__.IVehicleRegistration>\n  >>> attrs.attributes\n  ('license', 'address', 'model', 'make', 'year')\n\n\nGroup form as instance\n----------------------\n\nIt is also possible to use group instances in forms. Let's setup our previous\nform and assing a group instance:\n\n  >>> class RegistrationEditForm(group.GroupForm, form.EditForm):\n  ...     fields = field.Fields(IVehicleRegistration).select(\n  ...         'firstName', 'lastName')\n  ...\n  ...     template = ViewPageTemplateFile(\n  ...         'simple_groupedit.pt', os.path.dirname(tests.__file__))\n\n  >>> request = testing.TestRequest()\n\n  >>> edit = RegistrationEditForm(reg, request)\n\nInstanciate the form and use a group class and a group instance:\n\n  >>> carGroupInstance = CarGroup(edit.context, request, edit)\n  >>> edit.groups = (LicenseGroup, carGroupInstance)\n  >>> edit.update()\n  >>> print(edit.render())\n  <html xmlns=\"http://www.w3.org/1999/xhtml\">\n    <body>\n      <form action=\".\">\n        <div class=\"row\">\n          <label for=\"form-widgets-firstName\">First Name</label>\n          <input id=\"form-widgets-firstName\"\n                 name=\"form.widgets.firstName\"\n                 class=\"text-widget required textline-field\"\n                 value=\"Stephan\" type=\"text\" />\n        </div>\n        <div class=\"row\">\n          <label for=\"form-widgets-lastName\">Last Name</label>\n          <input id=\"form-widgets-lastName\"\n                 name=\"form.widgets.lastName\"\n                 class=\"text-widget required textline-field\"\n                 value=\"Richter\" type=\"text\" />\n        </div>\n        <fieldset>\n          <legend>License</legend>\n        <div class=\"row\">\n          <label for=\"form-widgets-license\">License</label>\n          <input id=\"form-widgets-license\"\n                 name=\"form.widgets.license\"\n                 class=\"text-widget required textline-field\"\n                 value=\"MA 4038765\" type=\"text\" />\n        </div>\n        <div class=\"row\">\n          <label for=\"form-widgets-address\">Address</label>\n          <input id=\"form-widgets-address\"\n                 name=\"form.widgets.address\"\n                 class=\"text-widget required textline-field\"\n                 value=\"11 Main St, Maynard, MA\" type=\"text\" />\n        </div>\n        </fieldset>\n        <fieldset>\n          <legend>Car</legend>\n        <div class=\"row\">\n          <label for=\"form-widgets-model\">Model</label>\n          <input id=\"form-widgets-model\" name=\"form.widgets.model\"\n                 class=\"text-widget required textline-field\"\n                 value=\"Ford\" type=\"text\" />\n        </div>\n        <div class=\"row\">\n          <label for=\"form-widgets-make\">Make</label>\n          <input id=\"form-widgets-make\" name=\"form.widgets.make\"\n                 class=\"text-widget required textline-field\"\n                 value=\"F150\" type=\"text\" />\n        </div>\n        <div class=\"row\">\n          <label for=\"form-widgets-year\">Year</label>\n          <input id=\"form-widgets-year\" name=\"form.widgets.year\"\n                 class=\"text-widget required textline-field\"\n                 value=\"2006\" type=\"text\" />\n            </div>\n        </fieldset>\n        <div class=\"action\">\n          <input id=\"form-buttons-apply\" name=\"form.buttons.apply\"\n                 class=\"submit-widget button-field\" value=\"Apply\"\n                 type=\"submit\" />\n        </div>\n      </form>\n    </body>\n  </html>\n\nGroups with Different Content\n-----------------------------\n\nYou can customize the content for a group by overriding a group's\n``getContent`` method.  This is a very easy way to get around not\nhaving object widgets.  For example, suppose we want to maintain the\nvehicle owner's information in a separate class than the vehicle.  We\nmight have an ``IVehicleOwner`` interface like so.\n\n  >>> class IVehicleOwner(zope.interface.Interface):\n  ...     firstName = zope.schema.TextLine(title=u'First Name')\n  ...     lastName = zope.schema.TextLine(title=u'Last Name')\n\nThen out ``IVehicleRegistration`` interface would include an object\nfield for the owner instead of the ``firstName`` and ``lastName``\nfields.\n\n  >>> class IVehicleRegistration(zope.interface.Interface):\n  ...     owner = zope.schema.Object(title=u'Owner', schema=IVehicleOwner)\n  ...\n  ...     license = zope.schema.TextLine(title=u'License')\n  ...     address = zope.schema.TextLine(title=u'Address')\n  ...\n  ...     model = zope.schema.TextLine(title=u'Model')\n  ...     make = zope.schema.TextLine(title=u'Make')\n  ...     year = zope.schema.TextLine(title=u'Year')\n\nNow let's create simple implementations of these two interfaces.\n\n  >>> @zope.interface.implementer(IVehicleOwner)\n  ... class VehicleOwner(object):\n  ...\n  ...     def __init__(self, **kw):\n  ...         for name, value in kw.items():\n  ...             setattr(self, name, value)\n\n  >>> @zope.interface.implementer(IVehicleRegistration)\n  ... class VehicleRegistration(object):\n  ...\n  ...     def __init__(self, **kw):\n  ...         for name, value in kw.items():\n  ...             setattr(self, name, value)\n\nNow we can create a group just for the owner with its own\n``getContent`` method that simply returns the ``owner`` object field\nof the ``VehicleRegistration`` instance.\n\n  >>> class OwnerGroup(group.Group):\n  ...     label = u'Owner'\n  ...     fields = field.Fields(IVehicleOwner, prefix='owner')\n  ...\n  ...     def getContent(self):\n  ...         return self.context.owner\n\nWhen we create an Edit form for example, we should omit the ``owner``\nfield which is taken care of with the group.\n\n  >>> class RegistrationEditForm(group.GroupForm, form.EditForm):\n  ...     fields = field.Fields(IVehicleRegistration).omit(\n  ...         'owner')\n  ...     groups = (OwnerGroup,)\n  ...\n  ...     template = ViewPageTemplateFile(\n  ...         'simple_groupedit.pt', os.path.dirname(tests.__file__))\n\n  >>> reg = VehicleRegistration(\n  ...               license=u'MA 40387',\n  ...               address=u'10 Main St, Maynard, MA',\n  ...               model=u'BMW',\n  ...               make=u'325',\n  ...               year=u'2005',\n  ...               owner=VehicleOwner(firstName=u'Stephan',\n  ...                                  lastName=u'Richter'))\n  >>> request = testing.TestRequest()\n\n  >>> edit = RegistrationEditForm(reg, request)\n  >>> edit.update()\n\nWhen we render the form, the group appears as we would expect but with\nthe ``owner`` prefix for the fields.\n\n  >>> print(edit.render())\n  <html xmlns=\"http://www.w3.org/1999/xhtml\">\n    <body>\n      <form action=\".\">\n        <div class=\"row\">\n          <label for=\"form-widgets-license\">License</label>\n          <input type=\"text\" id=\"form-widgets-license\"\n                 name=\"form.widgets.license\"\n                 class=\"text-widget required textline-field\"\n                 value=\"MA 40387\" />\n        </div>\n        <div class=\"row\">\n          <label for=\"form-widgets-address\">Address</label>\n          <input type=\"text\" id=\"form-widgets-address\"\n                 name=\"form.widgets.address\"\n                 class=\"text-widget required textline-field\"\n                 value=\"10 Main St, Maynard, MA\" />\n        </div>\n        <div class=\"row\">\n          <label for=\"form-widgets-model\">Model</label>\n          <input type=\"text\" id=\"form-widgets-model\"\n                 name=\"form.widgets.model\"\n                 class=\"text-widget required textline-field\"\n                 value=\"BMW\" />\n        </div>\n        <div class=\"row\">\n          <label for=\"form-widgets-make\">Make</label>\n          <input type=\"text\" id=\"form-widgets-make\"\n                 name=\"form.widgets.make\"\n                 class=\"text-widget required textline-field\"\n                 value=\"325\" />\n        </div>\n        <div class=\"row\">\n          <label for=\"form-widgets-year\">Year</label>\n          <input type=\"text\" id=\"form-widgets-year\"\n                 name=\"form.widgets.year\"\n                 class=\"text-widget required textline-field\" value=\"2005\" />\n        </div>\n        <fieldset>\n          <legend>Owner</legend>\n          <div class=\"row\">\n            <label for=\"form-widgets-owner-firstName\">First Name</label>\n            <input type=\"text\" id=\"form-widgets-owner-firstName\"\n                   name=\"form.widgets.owner.firstName\"\n                   class=\"text-widget required textline-field\"\n                   value=\"Stephan\" />\n          </div>\n          <div class=\"row\">\n            <label for=\"form-widgets-owner-lastName\">Last Name</label>\n            <input type=\"text\" id=\"form-widgets-owner-lastName\"\n                   name=\"form.widgets.owner.lastName\"\n                   class=\"text-widget required textline-field\"\n                   value=\"Richter\" />\n          </div>\n        </fieldset>\n        <div class=\"action\">\n          <input type=\"submit\" id=\"form-buttons-apply\"\n                 name=\"form.buttons.apply\"\n                 class=\"submit-widget button-field\" value=\"Apply\" />\n        </div>\n      </form>\n    </body>\n  </html>\n\nNow let's try and edit the owner.  For example, suppose that Stephan\nRichter gave his BMW to Paul Carduner because he is such a nice guy.\n\n  >>> request = testing.TestRequest(form={\n  ...     'form.widgets.owner.firstName': u'Paul',\n  ...     'form.widgets.owner.lastName': u'Carduner',\n  ...     'form.widgets.license': u'MA 4038765',\n  ...     'form.widgets.address': u'Berkeley',\n  ...     'form.widgets.model': u'BMW',\n  ...     'form.widgets.make': u'325',\n  ...     'form.widgets.year': u'2005',\n  ...     'form.buttons.apply': u'Apply'\n  ...     })\n  >>> edit = RegistrationEditForm(reg, request)\n  >>> edit.update()\n\nWe'll see if everything worked on the form side.\n\n  >>> print(testing.render(edit, './/xmlns:i'))\n  <i>Data successfully updated.</i>\n\nNow the owner object should have updated fields.\n\n  >>> reg.owner.firstName\n  u'Paul'\n  >>> reg.owner.lastName\n  u'Carduner'\n  >>> reg.license\n  u'MA 4038765'\n  >>> reg.address\n  u'Berkeley'\n  >>> reg.model\n  u'BMW'\n  >>> reg.make\n  u'325'\n  >>> reg.year\n  u'2005'\n\n\nNested Groups\n-------------\n\nThe group can contains groups. Let's adapt the previous RegistrationEditForm:\n\n  >>> class OwnerGroup(group.Group):\n  ...     label = u'Owner'\n  ...     fields = field.Fields(IVehicleOwner, prefix='owner')\n  ...\n  ...     def getContent(self):\n  ...         return self.context.owner\n\n  >>> class VehicleRegistrationGroup(group.Group):\n  ...     label = u'Registration'\n  ...     fields = field.Fields(IVehicleRegistration).omit(\n  ...         'owner')\n  ...     groups = (OwnerGroup,)\n  ...\n  ...     template = ViewPageTemplateFile(\n  ...         'simple_groupedit.pt', os.path.dirname(tests.__file__))\n\n  >>> class RegistrationEditForm(group.GroupForm, form.EditForm):\n  ...     groups = (VehicleRegistrationGroup,)\n  ...\n  ...     template = ViewPageTemplateFile(\n  ...         'simple_nested_groupedit.pt', os.path.dirname(tests.__file__))\n\n  >>> reg = VehicleRegistration(\n  ...               license=u'MA 40387',\n  ...               address=u'10 Main St, Maynard, MA',\n  ...               model=u'BMW',\n  ...               make=u'325',\n  ...               year=u'2005',\n  ...               owner=VehicleOwner(firstName=u'Stephan',\n  ...                                  lastName=u'Richter'))\n  >>> request = testing.TestRequest()\n\n  >>> edit = RegistrationEditForm(reg, request)\n  >>> edit.update()\n\nNow let's try and edit the owner.  For example, suppose that Stephan\nRichter gave his BMW to Paul Carduner because he is such a nice guy.\n\n  >>> request = testing.TestRequest(form={\n  ...     'form.widgets.owner.firstName': u'Paul',\n  ...     'form.widgets.owner.lastName': u'Carduner',\n  ...     'form.widgets.license': u'MA 4038765',\n  ...     'form.widgets.address': u'Berkeley',\n  ...     'form.widgets.model': u'BMW',\n  ...     'form.widgets.make': u'325',\n  ...     'form.widgets.year': u'2005',\n  ...     'form.buttons.apply': u'Apply'\n  ...     })\n  >>> edit = RegistrationEditForm(reg, request)\n  >>> edit.update()\n\nWe'll see if everything worked on the form side.\n\n  >>> print(testing.render(edit, './/xmlns:i'))\n  <i>Data successfully updated.</i>\n\nNow the owner object should have updated fields.\n\n  >>> reg.owner.firstName\n  u'Paul'\n  >>> reg.owner.lastName\n  u'Carduner'\n  >>> reg.license\n  u'MA 4038765'\n  >>> reg.address\n  u'Berkeley'\n  >>> reg.model\n  u'BMW'\n  >>> reg.make\n  u'325'\n  >>> reg.year\n  u'2005'\n\nSo what happens, if errors happen inside a nested group? Let's use an empty\ninvalid object for the test missing input errors:\n\n  >>> reg = VehicleRegistration(owner=VehicleOwner())\n\n  >>> request = testing.TestRequest(form={\n  ...     'form.widgets.owner.firstName': u'',\n  ...     'form.widgets.owner.lastName': u'',\n  ...     'form.widgets.license': u'',\n  ...     'form.widgets.address': u'',\n  ...     'form.widgets.model': u'',\n  ...     'form.widgets.make': u'',\n  ...     'form.widgets.year': u'',\n  ...     'form.buttons.apply': u'Apply'\n  ...     })\n\n  >>> edit = RegistrationEditForm(reg, request)\n  >>> edit.update()\n  >>> data, errors = edit.extractData()\n  >>> print(testing.render(edit, './/xmlns:i'))\n  <i >There were some errors.</i>\n\n  >>> print(testing.render(edit, './/xmlns:fieldset/xmlns:ul'))\n  <ul>\n    <li>\n    License:\n      <div class=\"error\">Required input is missing.</div>\n    </li>\n    <li>\n    Address:\n      <div class=\"error\">Required input is missing.</div>\n    </li>\n    <li>\n    Model:\n      <div class=\"error\">Required input is missing.</div>\n    </li>\n    <li>\n    Make:\n      <div class=\"error\">Required input is missing.</div>\n    </li>\n    <li>\n    Year:\n      <div class=\"error\">Required input is missing.</div>\n    </li>\n  </ul>\n  <ul>\n    <li>\n    First Name:\n      <div class=\"error\">Required input is missing.</div>\n    </li>\n    <li>\n    Last Name:\n      <div class=\"error\">Required input is missing.</div>\n    </li>\n  </ul>\n\n\nGroup instance in nested group\n------------------------------\n\nLet's also test if the Group class can handle group objects as instances:\n\n  >>> reg = VehicleRegistration(\n  ...               license=u'MA 40387',\n  ...               address=u'10 Main St, Maynard, MA',\n  ...               model=u'BMW',\n  ...               make=u'325',\n  ...               year=u'2005',\n  ...               owner=VehicleOwner(firstName=u'Stephan',\n  ...                                  lastName=u'Richter'))\n  >>> request = testing.TestRequest()\n\n  >>> edit = RegistrationEditForm(reg, request)\n  >>> vrg = VehicleRegistrationGroup(edit.context, request, edit)\n  >>> ownerGroup = OwnerGroup(edit.context, request, edit)\n\nNow build the group instance object chain:\n\n  >>> vrg.groups = (ownerGroup,)\n  >>> edit.groups = (vrg,)\n\nAlso use refreshActions which is not needed but will make coverage this\nadditional line of code in the update method:\n\n  >>> edit.refreshActions = True\n\nUpdate and render:\n\n  >>> edit.update()\n  >>> print(edit.render())\n  <html xmlns=\"http://www.w3.org/1999/xhtml\">\n    <body>\n      <form action=\".\">\n        <fieldset>\n          <legend>Registration</legend>\n        <div class=\"row\">\n          <label for=\"form-widgets-license\">License</label>\n          <input id=\"form-widgets-license\"\n                 name=\"form.widgets.license\"\n                 class=\"text-widget required textline-field\"\n                 value=\"MA 40387\" type=\"text\" />\n        </div>\n        <div class=\"row\">\n          <label for=\"form-widgets-address\">Address</label>\n          <input id=\"form-widgets-address\"\n                 name=\"form.widgets.address\"\n                 class=\"text-widget required textline-field\"\n                 value=\"10 Main St, Maynard, MA\" type=\"text\" />\n        </div>\n        <div class=\"row\">\n          <label for=\"form-widgets-model\">Model</label>\n          <input id=\"form-widgets-model\" name=\"form.widgets.model\"\n                 class=\"text-widget required textline-field\"\n                 value=\"BMW\" type=\"text\" />\n        </div>\n        <div class=\"row\">\n          <label for=\"form-widgets-make\">Make</label>\n          <input id=\"form-widgets-make\" name=\"form.widgets.make\"\n                 class=\"text-widget required textline-field\"\n                 value=\"325\" type=\"text\" />\n        </div>\n        <div class=\"row\">\n          <label for=\"form-widgets-year\">Year</label>\n          <input id=\"form-widgets-year\" name=\"form.widgets.year\"\n                 class=\"text-widget required textline-field\"\n                 value=\"2005\" type=\"text\" />\n        </div>\n          <fieldset>\n          <legend>Owner</legend>\n        <div class=\"row\">\n          <label for=\"form-widgets-owner-firstName\">First Name</label>\n          <input id=\"form-widgets-owner-firstName\"\n                 name=\"form.widgets.owner.firstName\"\n                 class=\"text-widget required textline-field\"\n                 value=\"Stephan\" type=\"text\" />\n        </div>\n        <div class=\"row\">\n          <label for=\"form-widgets-owner-lastName\">Last Name</label>\n          <input id=\"form-widgets-owner-lastName\"\n                 name=\"form.widgets.owner.lastName\"\n                 class=\"text-widget required textline-field\"\n                 value=\"Richter\" type=\"text\" />\n        </div>\n        </fieldset>\n        </fieldset>\n        <div class=\"action\">\n          <input id=\"form-buttons-apply\" name=\"form.buttons.apply\"\n                 class=\"submit-widget button-field\" value=\"Apply\"\n                 type=\"submit\" />\n          </div>\n      </form>\n    </body>\n  </html>\n\n\nNow test the error handling if just one missing value is given in a group:\n\n  >>> request = testing.TestRequest(form={\n  ...     'form.widgets.owner.firstName': u'Paul',\n  ...     'form.widgets.owner.lastName': u'',\n  ...     'form.widgets.license': u'MA 4038765',\n  ...     'form.widgets.address': u'Berkeley',\n  ...     'form.widgets.model': u'BMW',\n  ...     'form.widgets.make': u'325',\n  ...     'form.widgets.year': u'2005',\n  ...     'form.buttons.apply': u'Apply'\n  ...     })\n\n  >>> edit = RegistrationEditForm(reg, request)\n  >>> vrg = VehicleRegistrationGroup(edit.context, request, edit)\n  >>> ownerGroup = OwnerGroup(edit.context, request, edit)\n  >>> vrg.groups = (ownerGroup,)\n  >>> edit.groups = (vrg,)\n\n  >>> edit.update()\n  >>> data, errors = edit.extractData()\n  >>> print(testing.render(edit, './/xmlns:i'))\n  <i >There were some errors.</i>\n\n  >>> print(testing.render(edit, './/xmlns:fieldset/xmlns:ul'))\n  <ul>\n    <li>\n    Last Name:\n      <div class=\"error\">Required input is missing.</div>\n    </li>\n  </ul>\n\nJust check whether we fully support the interface:\n\n  >>> from z3c.form import interfaces\n  >>> from zope.interface.verify import verifyClass\n  >>> verifyClass(interfaces.IGroup, group.Group)\n  True\n\n=========\nSub-Forms\n=========\n\nTraditionally, the Zope community talks about sub-forms in a generic manner\nwithout defining their purpose, restrictions and assumptions. When we\ninitially talked about sub-forms for this package, we quickly noticed that\nthere are several classes of sub-forms with different goals.\n\nOf course, we need to setup our defaults for this demonstration as well:\n\n  >>> from z3c.form import testing\n  >>> testing.setupFormDefaults()\n\n\nClass I: The form within the form\n---------------------------------\n\nThis class of sub-forms provides a complete form within a form, including its\nown actions. When an action of the sub-form is submitted, the parent form\nusually does not interact with that action at all. The same is true for the\nreverse; when an action of the parent form is submitted, the sub-form does not\nreact.\n\nA classic example for this type of sub-form is uploading an image. The subform\nallows uploading a file and once the file is uploaded the image is shown as\nwell as a \"Delete\"/\"Clear\" button. The sub-form will store the image in the\nsession and when the main form is submitted it looks in the session for the\nimage.\n\nThis scenario was well supported in ``zope.formlib`` and also does not require\nspecial support in ``z3c.form``. Let me show you, how this can be done.\n\nIn this example, we would like to describe a car and its owner:\n\n  >>> import zope.interface\n  >>> import zope.schema\n\n  >>> class IOwner(zope.interface.Interface):\n  ...     name = zope.schema.TextLine(title=u'Name')\n  ...     license = zope.schema.TextLine(title=u'License')\n\n  >>> class ICar(zope.interface.Interface):\n  ...     model = zope.schema.TextLine(title=u'Model')\n  ...     make = zope.schema.TextLine(title=u'Make')\n  ...     owner = zope.schema.Object(title=u'Owner', schema=IOwner)\n\nLet's now implement the two interfaces and create instances, so that we can\ncreate edit forms for it:\n\n  >>> @zope.interface.implementer(IOwner)\n  ... class Owner(object):\n  ...     def __init__(self, name, license):\n  ...         self.name = name\n  ...         self.license = license\n\n  >>> @zope.interface.implementer(ICar)\n  ... class Car(object):\n  ...     def __init__(self, model, make, owner):\n  ...         self.model = model\n  ...         self.make = make\n  ...         self.owner = owner\n\n  >>> me = Owner(u'Stephan Richter', u'MA-1231FW97')\n  >>> mycar = Car(u'Nissan', u'Sentra', me)\n\nWe define the owner sub-form as we would any other form. The only difference\nis the template, which should not render a form-tag:\n\n  >>> import os\n  >>> from zope.browserpage.viewpagetemplatefile import ViewPageTemplateFile\n  >>> from z3c.form import form, field, tests\n\n  >>> templatePath = os.path.dirname(tests.__file__)\n\n  >>> class OwnerForm(form.EditForm):\n  ...     template = ViewPageTemplateFile(\n  ...         'simple_owneredit.pt', templatePath)\n  ...     fields = field.Fields(IOwner)\n  ...     prefix = 'owner'\n\nNext we define the car form, which has the owner form as a sub-form. The car\nform also needs a special template, since it needs to render the sub-form at\nsome point. For the simplicity of this example, I have duplicated a lot of\ntemplate code here, but you can use your favorite template techniques, such as\nMETAL macros, viewlets, or pagelets to make better reuse of some code.\n\n  >>> class CarForm(form.EditForm):\n  ...     fields = field.Fields(ICar).select('model', 'make')\n  ...     template = ViewPageTemplateFile(\n  ...         'simple_caredit.pt', templatePath)\n  ...     prefix = 'car'\n  ...     def update(self):\n  ...         self.owner = OwnerForm(self.context.owner, self.request)\n  ...         self.owner.update()\n  ...         super(CarForm, self).update()\n\nLet's now instantiate the form and render it:\n\n  >>> from z3c.form.testing import TestRequest\n  >>> request = TestRequest()\n\n  >>> carForm = CarForm(mycar, request)\n  >>> carForm.update()\n  >>> print(carForm.render())\n  <html xmlns=\"http://www.w3.org/1999/xhtml\">\n    <body>\n      <form action=\".\">\n        <div class=\"row\">\n          <label for=\"car-widgets-model\">Model</label>\n          <input type=\"text\" id=\"car-widgets-model\" name=\"car.widgets.model\"\n                 class=\"text-widget required textline-field\" value=\"Nissan\" />\n        </div>\n        <div class=\"row\">\n          <label for=\"car-widgets-make\">Make</label>\n          <input type=\"text\" id=\"car-widgets-make\" name=\"car.widgets.make\"\n                 class=\"text-widget required textline-field\" value=\"Sentra\" />\n        </div>\n        <fieldset>\n          <legend>Owner</legend>\n          <div class=\"row\">\n            <label for=\"owner-widgets-name\">Name</label>\n            <input type=\"text\" id=\"owner-widgets-name\" name=\"owner.widgets.name\"\n                   class=\"text-widget required textline-field\"\n                   value=\"Stephan Richter\" />\n          </div>\n          <div class=\"row\">\n            <label for=\"owner-widgets-license\">License</label>\n            <input type=\"text\" id=\"owner-widgets-license\"\n                   name=\"owner.widgets.license\"\n                   class=\"text-widget required textline-field\"\n                   value=\"MA-1231FW97\" />\n          </div>\n          <div class=\"action\">\n            <input type=\"submit\" id=\"owner-buttons-apply\"\n                   name=\"owner.buttons.apply\"\n                   class=\"submit-widget button-field\"\n                   value=\"Apply\" />\n          </div>\n        </fieldset>\n        <div class=\"action\">\n          <input type=\"submit\" id=\"car-buttons-apply\"\n                 name=\"car.buttons.apply\"\n                 class=\"submit-widget button-field\"\n                 value=\"Apply\" />\n        </div>\n      </form>\n    </body>\n  </html>\n\nI can now submit the owner form, which should not submit any car changes I\nmight have made in the form:\n\n  >>> request = TestRequest(form={\n  ...     'car.widgets.model': u'BMW',\n  ...     'car.widgets.make': u'325',\n  ...     'owner.widgets.name': u'Stephan Richter',\n  ...     'owner.widgets.license': u'MA-97097A87',\n  ...     'owner.buttons.apply': u'Apply'\n  ...     })\n\n  >>> carForm = CarForm(mycar, request)\n  >>> carForm.update()\n\n  >>> mycar.model\n  u'Nissan'\n  >>> mycar.make\n  u'Sentra'\n\n  >>> me.name\n  u'Stephan Richter'\n  >>> me.license\n  u'MA-97097A87'\n\nAlso, the form should say that the data of the owner has changed:\n\n  >>> print(carForm.render())\n  <html xmlns=\"http://www.w3.org/1999/xhtml\">\n    <body>\n      <form action=\".\">\n        <div class=\"row\">\n          <label for=\"car-widgets-model\">Model</label>\n          <input type=\"text\" id=\"car-widgets-model\"\n                 name=\"car.widgets.model\"\n                 class=\"text-widget required textline-field\"\n                 value=\"BMW\" />\n        </div>\n        <div class=\"row\">\n          <label for=\"car-widgets-make\">Make</label>\n          <input type=\"text\" id=\"car-widgets-make\"\n                 name=\"car.widgets.make\"\n                 class=\"text-widget required textline-field\"\n                 value=\"325\" />\n        </div>\n        <fieldset>\n          <legend>Owner</legend>\n          <i>Data successfully updated.</i>\n          <div class=\"row\">\n            <label for=\"owner-widgets-name\">Name</label>\n            <input type=\"text\" id=\"owner-widgets-name\"\n                   name=\"owner.widgets.name\"\n                   class=\"text-widget required textline-field\"\n                   value=\"Stephan Richter\" />\n          </div>\n          <div class=\"row\">\n            <label for=\"owner-widgets-license\">License</label>\n            <input type=\"text\" id=\"owner-widgets-license\"\n                   name=\"owner.widgets.license\"\n                   class=\"text-widget required textline-field\"\n                   value=\"MA-97097A87\" />\n          </div>\n          <div class=\"action\">\n            <input type=\"submit\" id=\"owner-buttons-apply\"\n                   name=\"owner.buttons.apply\"\n                   class=\"submit-widget button-field\"\n                   value=\"Apply\" />\n          </div>\n        </fieldset>\n        <div class=\"action\">\n          <input type=\"submit\" id=\"car-buttons-apply\"\n                 name=\"car.buttons.apply\"\n                 class=\"submit-widget button-field\"\n                 value=\"Apply\" />\n        </div>\n      </form>\n    </body>\n  </html>\n\nThe same is true the other way around as well. Submitting the overall form\ndoes not submit the owner form:\n\n  >>> request = TestRequest(form={\n  ...     'car.widgets.model': u'BMW',\n  ...     'car.widgets.make': u'325',\n  ...     'car.buttons.apply': u'Apply',\n  ...     'owner.widgets.name': u'Claudia Richter',\n  ...     'owner.widgets.license': u'MA-123403S2',\n  ...     })\n\n  >>> carForm = CarForm(mycar, request)\n  >>> carForm.update()\n\n  >>> mycar.model\n  u'BMW'\n  >>> mycar.make\n  u'325'\n\n  >>> me.name\n  u'Stephan Richter'\n  >>> me.license\n  u'MA-97097A87'\n\n\nClass II: The logical unit\n--------------------------\n\nIn this class of sub-forms, a sub-form is often just a collection of widgets\nwithout any actions. Instead, the sub-form must be able to react to the\nactions of the parent form. A good example of those types of sub-forms is\nactually the example I chose above.\n\nSo let's redevelop our example above in a way that the owner sub-form is just\na logical unit that shares the action with its parent form. Initially, the\nexample does not look very different, except that we use ``EditSubForm`` as a\nbase class:\n\n  >>> from z3c.form import subform\n\n  >>> class OwnerForm(subform.EditSubForm):\n  ...     template = ViewPageTemplateFile(\n  ...         'simple_subedit.pt', templatePath)\n  ...     fields = field.Fields(IOwner)\n  ...     prefix = 'owner'\n\nThe main form also is pretty much the same, except that a subform takes three\nconstructor arguments, the last one being the parent form:\n\n  >>> class CarForm(form.EditForm):\n  ...     fields = field.Fields(ICar).select('model', 'make')\n  ...     template = ViewPageTemplateFile(\n  ...         'simple_caredit.pt', templatePath)\n  ...     prefix = 'car'\n  ...\n  ...     def update(self):\n  ...         super(CarForm, self).update()\n  ...         self.owner = OwnerForm(self.context.owner, self.request, self)\n  ...         self.owner.update()\n\nRendering the form works as before:\n\n  >>> request = TestRequest()\n  >>> carForm = CarForm(mycar, request)\n  >>> carForm.update()\n  >>> print(carForm.render())\n  <html xmlns=\"http://www.w3.org/1999/xhtml\">\n    <body>\n      <form action=\".\">\n        <div class=\"row\">\n          <label for=\"car-widgets-model\">Model</label>\n          <input type=\"text\" id=\"car-widgets-model\"\n                 name=\"car.widgets.model\"\n                 class=\"text-widget required textline-field\"\n                 value=\"BMW\" />\n        </div>\n        <div class=\"row\">\n          <label for=\"car-widgets-make\">Make</label>\n          <input type=\"text\" id=\"car-widgets-make\"\n                 name=\"car.widgets.make\"\n                 class=\"text-widget required textline-field\"\n                 value=\"325\" />\n        </div>\n        <fieldset>\n          <legend>Owner</legend>\n          <div class=\"row\">\n            <label for=\"owner-widgets-name\">Name</label>\n            <input type=\"text\" id=\"owner-widgets-name\"\n                   name=\"owner.widgets.name\"\n                   class=\"text-widget required textline-field\"\n                   value=\"Stephan Richter\" />\n          </div>\n          <div class=\"row\">\n            <label for=\"owner-widgets-license\">License</label>\n            <input type=\"text\" id=\"owner-widgets-license\"\n                   name=\"owner.widgets.license\"\n                   class=\"text-widget required textline-field\"\n                   value=\"MA-97097A87\" />\n          </div>\n        </fieldset>\n        <div class=\"action\">\n          <input type=\"submit\" id=\"car-buttons-apply\"\n                 name=\"car.buttons.apply\"\n                 class=\"submit-widget button-field\"\n                 value=\"Apply\" />\n        </div>\n      </form>\n    </body>\n  </html>\n\nThe interesting part of this setup is that the \"Apply\" button calls the action\nhandlers for both, the main and the sub-form:\n\n  >>> request = TestRequest(form={\n  ...     'car.widgets.model': u'Ford',\n  ...     'car.widgets.make': u'F150',\n  ...     'car.buttons.apply': u'Apply',\n  ...     'owner.widgets.name': u'Claudia Richter',\n  ...     'owner.widgets.license': u'MA-991723FDG',\n  ...     })\n\n  >>> carForm = CarForm(mycar, request)\n  >>> carForm.update()\n\n  >>> mycar.model\n  u'Ford'\n  >>> mycar.make\n  u'F150'\n  >>> me.name\n  u'Claudia Richter'\n  >>> me.license\n  u'MA-991723FDG'\n\nLet's now have a look at cases where an error happens. If an error occurs in\nthe parent form, the sub-form is still submitted:\n\n  >>> request = TestRequest(form={\n  ...     'car.widgets.model': u'Volvo\\n~',\n  ...     'car.widgets.make': u'450',\n  ...     'car.buttons.apply': u'Apply',\n  ...     'owner.widgets.name': u'Stephan Richter',\n  ...     'owner.widgets.license': u'MA-991723FDG',\n  ...     })\n\n  >>> carForm = CarForm(mycar, request)\n  >>> carForm.update()\n\n  >>> mycar.model\n  u'Ford'\n  >>> mycar.make\n  u'F150'\n  >>> me.name\n  u'Stephan Richter'\n  >>> me.license\n  u'MA-991723FDG'\n\nLet's look at the rendered form:\n\n  >>> print(carForm.render())\n  <html xmlns=\"http://www.w3.org/1999/xhtml\">\n    <body>\n      <i>There were some errors.</i>\n      <ul>\n        <li>\n          Model: <div class=\"error\">Constraint not satisfied</div>\n        </li>\n      </ul>\n      <form action=\".\">\n        <div class=\"row\">\n          <b><div class=\"error\">Constraint not satisfied</div>\n          </b><label for=\"car-widgets-model\">Model</label>\n          <input type=\"text\" id=\"car-widgets-model\"\n                 name=\"car.widgets.model\"\n                 class=\"text-widget required textline-field\"\n                 value=\"Volvo ~\" />\n        </div>\n        <div class=\"row\">\n          <label for=\"car-widgets-make\">Make</label>\n          <input type=\"text\" id=\"car-widgets-make\"\n                 name=\"car.widgets.make\"\n                 class=\"text-widget required textline-field\"\n                 value=\"450\" />\n        </div>\n        <fieldset>\n          <legend>Owner</legend>\n          <i>Data successfully updated.</i>\n          <div class=\"row\">\n            <label for=\"owner-widgets-name\">Name</label>\n            <input type=\"text\" id=\"owner-widgets-name\"\n                   name=\"owner.widgets.name\"\n                   class=\"text-widget required textline-field\"\n                   value=\"Stephan Richter\" />\n          </div>\n          <div class=\"row\">\n            <label for=\"owner-widgets-license\">License</label>\n            <input type=\"text\" id=\"owner-widgets-license\"\n                   name=\"owner.widgets.license\"\n                   class=\"text-widget required textline-field\"\n                   value=\"MA-991723FDG\" />\n          </div>\n        </fieldset>\n        <div class=\"action\">\n          <input type=\"submit\" id=\"car-buttons-apply\"\n                 name=\"car.buttons.apply\" class=\"submit-widget button-field\"\n                 value=\"Apply\" />\n        </div>\n      </form>\n    </body>\n  </html>\n\nNow, we know, we know. This might not be the behavior that *you* want. But\nremember how we started this document. We started with the recognition that\nthere are many classes and policies surrounding subforms. So while this\npackage provides some sensible default behavior, it is not intended to be\ncomprehensive.\n\nLet's now create an error in the sub-form, ensuring that an error message\noccurs:\n\n  >>> request = TestRequest(form={\n  ...     'car.widgets.model': u'Volvo',\n  ...     'car.widgets.make': u'450',\n  ...     'car.buttons.apply': u'Apply',\n  ...     'owner.widgets.name': u'Claudia\\n Richter',\n  ...     'owner.widgets.license': u'MA-991723F12',\n  ...     })\n\n  >>> carForm = CarForm(mycar, request)\n  >>> carForm.update()\n\n  >>> mycar.model\n  u'Volvo'\n  >>> mycar.make\n  u'450'\n  >>> me.name\n  u'Stephan Richter'\n  >>> me.license\n  u'MA-991723FDG'\n\n  >>> print(carForm.render()) # doctest: +NOPARSE_MARKUP\n  <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n  <html xmlns=\"http://www.w3.org/1999/xhtml\">\n      ...\n      <fieldset>\n        <legend>Owner</legend>\n        <i>There were some errors.</i>\n        <ul>\n           <li>\n             Name:\n             <div class=\"error\">Constraint not satisfied</div>\n           </li>\n        </ul>\n       ...\n     </fieldset>\n     ...\n  </html>\n\nIf the data did not change, it is also locally reported:\n\n  >>> request = TestRequest(form={\n  ...     'car.widgets.model': u'Ford',\n  ...     'car.widgets.make': u'F150',\n  ...     'car.buttons.apply': u'Apply',\n  ...     'owner.widgets.name': u'Stephan Richter',\n  ...     'owner.widgets.license': u'MA-991723FDG',\n  ...     })\n\n  >>> carForm = CarForm(mycar, request)\n  >>> carForm.update()\n  >>> print(carForm.render()) # doctest: +NOPARSE_MARKUP\n  <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n  <html xmlns=\"http://www.w3.org/1999/xhtml\">\n    ...\n      <fieldset>\n      <legend>Owner</legend>\n      <i>No changes were applied.</i>\n      ...\n      </fieldset>\n    ...\n  </html>\n\nFinal Note: With ``zope.formlib`` and ``zope.app.form`` people usually wrote\ncomplex object widgets to handle objects within forms. We never considered\nthis a good way of programming, since one loses control over the layout too\neasily.\n\n\nContext-free subforms\n---------------------\n\nOk, that was easy. But what about writing a form including a subform without a\ncontext? Let's show how we can write a form without any context using the\nsample above. Note, this sample form does not include actions which store the\nform input. You can store the values like in any other forms using the forms\nwidget method ``self.widgets.extract()`` which will return the form and\nsubform input values.\n\n  >>> from z3c.form.interfaces import IWidgets\n  >>> class OwnerAddForm(form.EditForm):\n  ...     template = ViewPageTemplateFile(\n  ...         'simple_owneredit.pt', templatePath)\n  ...     fields = field.Fields(IOwner)\n  ...     prefix = 'owner'\n  ...\n  ...     def updateWidgets(self):\n  ...         self.widgets = zope.component.getMultiAdapter(\n  ...             (self, self.request, self.getContent()), IWidgets)\n  ...         self.widgets.ignoreContext = True\n  ...         self.widgets.update()\n\nNext we define the car form, which has the owner form as a sub-form.\n\n  >>> class CarAddForm(form.EditForm):\n  ...     fields = field.Fields(ICar).select('model', 'make')\n  ...     template = ViewPageTemplateFile(\n  ...         'simple_caredit.pt', templatePath)\n  ...     prefix = 'car'\n  ...\n  ...     def updateWidgets(self):\n  ...         self.widgets = zope.component.getMultiAdapter(\n  ...             (self, self.request, self.getContent()), IWidgets)\n  ...         self.widgets.ignoreContext = True\n  ...         self.widgets.update()\n  ...\n  ...     def update(self):\n  ...         self.owner = OwnerAddForm(None, self.request)\n  ...         self.owner.update()\n  ...         super(CarAddForm, self).update()\n\nLet's now instantiate the form and render it. but first set up a simple\ncontainer which we can use for the add form context:\n\n  >>> class Container(object):\n  ...    \"\"\"Simple context simulating a container.\"\"\"\n  >>> container = Container()\n\nSet up a test request:\n\n  >>> from z3c.form.testing import TestRequest\n  >>> request = TestRequest()\n\nAnd render the form. As you can see, the widgets get rendered without any\n*real* context.\n\n  >>> carForm = CarAddForm(container, request)\n  >>> carForm.update()\n  >>> print(carForm.render())\n  <html xmlns=\"http://www.w3.org/1999/xhtml\">\n  <body>\n  <form action=\".\">\n    <div class=\"row\">\n      <label for=\"car-widgets-model\">Model</label>\n      <input type=\"text\" id=\"car-widgets-model\"\n             name=\"car.widgets.model\"\n             class=\"text-widget required textline-field\"\n             value=\"\" />\n    </div>\n    <div class=\"row\">\n      <label for=\"car-widgets-make\">Make</label>\n      <input type=\"text\" id=\"car-widgets-make\"\n             name=\"car.widgets.make\"\n             class=\"text-widget required textline-field\"\n             value=\"\" />\n    </div>\n    <fieldset>\n    <legend>Owner</legend>\n    <div class=\"row\">\n      <label for=\"owner-widgets-name\">Name</label>\n      <input type=\"text\" id=\"owner-widgets-name\"\n             name=\"owner.widgets.name\"\n             class=\"text-widget required textline-field\"\n             value=\"\" />\n    </div>\n    <div class=\"row\">\n      <label for=\"owner-widgets-license\">License</label>\n      <input type=\"text\" id=\"owner-widgets-license\"\n           name=\"owner.widgets.license\"\n           class=\"text-widget required textline-field\"\n           value=\"\" />\n    </div>\n    <div class=\"action\">\n      <input type=\"submit\" id=\"owner-buttons-apply\"\n           name=\"owner.buttons.apply\" class=\"submit-widget button-field\"\n           value=\"Apply\" />\n    </div>\n    </fieldset>\n    <div class=\"action\">\n      <input type=\"submit\" id=\"car-buttons-apply\"\n           name=\"car.buttons.apply\" class=\"submit-widget button-field\"\n           value=\"Apply\" />\n    </div>\n  </form>\n  </body>\n  </html>\n\nLet's show how we can extract the input values of the form and the subform.\nFirst give them some input:\n\n  >>> request = TestRequest(form={\n  ...     'car.widgets.model': u'Ford',\n  ...     'car.widgets.make': u'F150',\n  ...     'owner.widgets.name': u'Stephan Richter',\n  ...     'owner.widgets.license': u'MA-991723FDG',\n  ...     })\n  >>> carForm = CarAddForm(container, request)\n  >>> carForm.update()\n\nNow get the form values. This is normally done in a action handler:\n\n  >>> pprint(carForm.widgets.extract())\n  ({'make': u'F150', 'model': u'Ford'}, ())\n\n  >>> pprint(carForm.owner.widgets.extract())\n  ({'license': u'MA-991723FDG', 'name': u'Stephan Richter'}, ())\n\n==============\nField Managers\n==============\n\nOne of the features in ``zope.formlib`` that works really well is the syntax\nused to define the contents of the form. The formlib uses form fields, to\ndescribe how the form should be put together. Since we liked this way of\nworking, this package offers this feature as well in a very similar way.\n\nA field manager organizes all fields to be displayed within a form. Each field\nis associated with additional meta-data. The simplest way to create a field\nmanager is to specify the schema from which to extract all fields.\n\nThus, the first step is to create a schema:\n\n  >>> import zope.interface\n  >>> import zope.schema\n\n  >>> class IPerson(zope.interface.Interface):\n  ...      id = zope.schema.Int(\n  ...          title=u'Id',\n  ...          readonly=True)\n  ...\n  ...      name = zope.schema.TextLine(\n  ...          title=u'Name')\n  ...\n  ...      country = zope.schema.Choice(\n  ...          title=u'Country',\n  ...          values=(u'Germany', u'Switzerland', u'USA'),\n  ...          required=False)\n\nWe can now create the field manager:\n\n  >>> from z3c.form import field\n  >>> manager = field.Fields(IPerson)\n\nLike all managers in this package, it provides the enumerable mapping API:\n\n  >>> manager['id']\n  <Field 'id'>\n  >>> manager['unknown']\n  Traceback (most recent call last):\n  ...\n  KeyError: 'unknown'\n\n  >>> manager.get('id')\n  <Field 'id'>\n  >>> manager.get('unknown', 'default')\n  'default'\n\n  >>> 'id' in manager\n  True\n  >>> 'unknown' in manager\n  False\n\n  >>> manager.keys()\n  ['id', 'name', 'country']\n\n  >>> [key for key in manager]\n  ['id', 'name', 'country']\n\n  >>> manager.values()\n  [<Field 'id'>, <Field 'name'>, <Field 'country'>]\n\n  >>> manager.items()\n  [('id', <Field 'id'>),\n   ('name', <Field 'name'>),\n   ('country', <Field 'country'>)]\n\n  >>> len(manager)\n  3\n\nYou can also select the fields that you would like to have:\n\n  >>> manager = manager.select('name', 'country')\n  >>> manager.keys()\n  ['name', 'country']\n\nChanging the order is simply a matter of changing the selection order:\n\n  >>> manager = manager.select('country', 'name')\n  >>> manager.keys()\n  ['country', 'name']\n\nSelecting a field becomes a little bit more tricky when field names\noverlap. For example, let's say that a person can be adapted to a pet:\n\n  >>> class IPet(zope.interface.Interface):\n  ...      id = zope.schema.TextLine(\n  ...          title=u'Id')\n  ...\n  ...      name = zope.schema.TextLine(\n  ...          title=u'Name')\n\nThe pet field(s) can only be added to the fields manager with a prefix:\n\n  >>> manager += field.Fields(IPet, prefix='pet')\n  >>> manager.keys()\n  ['country', 'name', 'pet.id', 'pet.name']\n\nWhen selecting fields, this prefix has to be used:\n\n  >>> manager = manager.select('name', 'pet.name')\n  >>> manager.keys()\n  ['name', 'pet.name']\n\nHowever, sometimes it is tedious to specify the prefix together with the\nfield; for example here:\n\n  >>> manager = field.Fields(IPerson).select('name')\n  >>> manager += field.Fields(IPet, prefix='pet').select('pet.name', 'pet.id')\n  >>> manager.keys()\n  ['name', 'pet.name', 'pet.id']\n\nIt is easier to specify the prefix as an afterthought:\n\n  >>> manager = field.Fields(IPerson).select('name')\n  >>> manager += field.Fields(IPet, prefix='pet').select(\n  ...     'name', 'id', prefix='pet')\n  >>> manager.keys()\n  ['name', 'pet.name', 'pet.id']\n\nAlternatively, you can specify the interface:\n\n  >>> manager = field.Fields(IPerson).select('name')\n  >>> manager += field.Fields(IPet, prefix='pet').select(\n  ...     'name', 'id', interface=IPet)\n  >>> manager.keys()\n  ['name', 'pet.name', 'pet.id']\n\nSometimes it is easier to simply omit a set of fields instead of selecting all\nthe ones you want:\n\n  >>> manager = field.Fields(IPerson)\n  >>> manager = manager.omit('id')\n  >>> manager.keys()\n  ['name', 'country']\n\nAgain, you can solve name conflicts using the full prefixed name, ...\n\n  >>> manager = field.Fields(IPerson).omit('country')\n  >>> manager += field.Fields(IPet, prefix='pet')\n  >>> manager.omit('pet.id').keys()\n  ['id', 'name', 'pet.name']\n\nusing the prefix keyword argument, ...\n\n  >>> manager = field.Fields(IPerson).omit('country')\n  >>> manager += field.Fields(IPet, prefix='pet')\n  >>> manager.omit('id', prefix='pet').keys()\n  ['id', 'name', 'pet.name']\n\nor, using the interface:\n\n  >>> manager = field.Fields(IPerson).omit('country')\n  >>> manager += field.Fields(IPet, prefix='pet')\n  >>> manager.omit('id', interface=IPet).keys()\n  ['id', 'name', 'pet.name']\n\nYou can also add two field managers together:\n\n  >>> manager = field.Fields(IPerson).select('name', 'country')\n  >>> manager2 = field.Fields(IPerson).select('id')\n  >>> (manager + manager2).keys()\n  ['name', 'country', 'id']\n\nAdding anything else to a field manager is not well defined:\n\n  >>> manager + 1\n  Traceback (most recent call last):\n  ...\n  TypeError: unsupported operand type(s) for +: 'Fields' and 'int'\n\nYou also cannot make any additions that would cause a name conflict:\n\n  >>> manager + manager\n  Traceback (most recent call last):\n  ...\n  ValueError: ('Duplicate name', 'name')\n\nWhen creating a new form derived from another, you often want to keep existing\nfields and add new ones. In order to not change the super-form class, you need\nto copy the field manager:\n\n  >>> manager.keys()\n  ['name', 'country']\n  >>> manager.copy().keys()\n  ['name', 'country']\n\n\nMore on the Constructor\n-----------------------\n\nThe constructor does not only accept schemas to be passed in; one can also\njust pass in schema fields:\n\n  >>> field.Fields(IPerson['name']).keys()\n  ['name']\n\nHowever, the schema field has to have a name:\n\n  >>> email = zope.schema.TextLine(title=u'E-Mail')\n  >>> field.Fields(email)\n  Traceback (most recent call last):\n  ...\n  ValueError: Field has no name\n\nAdding a name helps:\n\n  >>> email.__name__ = 'email'\n  >>> field.Fields(email).keys()\n  ['email']\n\nOr, you can just pass in other field managers, which is the feature that the add\nmechanism uses:\n\n  >>> field.Fields(manager).keys()\n  ['name', 'country']\n\nLast, but not least, the constructor also accepts form fields, which are used\nby ``select()`` and ``omit()``:\n\n  >>> field.Fields(manager['name'], manager2['id']).keys()\n  ['name', 'id']\n\nIf the constructor does not recognize any of the types above, it raises a\n``TypeError`` exception:\n\n  >>> field.Fields(object())\n  Traceback (most recent call last):\n  ...\n  TypeError: ('Unrecognized argument type', <object object at ...>)\n\nAdditionally, you can specify several keyword arguments in the field manager\nconstructor that are used to set up the fields:\n\n* ``omitReadOnly``\n\n  When set to ``True`` all read-only fields are omitted.\n\n    >>> field.Fields(IPerson, omitReadOnly=True).keys()\n    ['name', 'country']\n\n* ``keepReadOnly``\n\n  Sometimes you want to keep a particular read-only field around, even though\n  in general you want to omit them. In this case you can specify the fields to\n  keep:\n\n    >>> field.Fields(\n    ...     IPerson, omitReadOnly=True, keepReadOnly=('id',)).keys()\n    ['id', 'name', 'country']\n\n* ``prefix``\n\n  Sets the prefix of the fields. This argument is passed on to each field.\n\n    >>> manager = field.Fields(IPerson, prefix='myform.')\n    >>> manager['myform.name']\n    <Field 'myform.name'>\n\n\n* ``interface``\n\n  Usually the interface is inferred from the field itself. The interface is\n  used to determine whether an adapter must be looked up for a given\n  context.\n\n  But sometimes fields are generated in isolation to an interface or the\n  interface of the field is not the one you want. In this case you can specify\n  the interface:\n\n    >>> class IMyPerson(IPerson):\n    ...     pass\n\n    >>> manager = field.Fields(email, interface=IMyPerson)\n    >>> manager['email'].interface\n    <InterfaceClass __builtin__.IMyPerson>\n\n* ``mode``\n\n  The mode in which the widget will be rendered. By default there are two\n  available, \"input\" and \"display\". When mode is not specified, \"input\" is\n  chosen.\n\n    >>> from z3c.form import interfaces\n    >>> manager = field.Fields(IPerson, mode=interfaces.DISPLAY_MODE)\n    >>> manager['country'].mode\n    'display'\n\n* ``ignoreContext``\n\n  While the ``ignoreContext`` flag is usually set on the form, it is sometimes\n  desirable to set the flag for a particular field.\n\n    >>> manager = field.Fields(IPerson)\n    >>> manager['country'].ignoreContext\n\n    >>> manager = field.Fields(IPerson, ignoreContext=True)\n    >>> manager['country'].ignoreContext\n    True\n\n    >>> manager = field.Fields(IPerson, ignoreContext=False)\n    >>> manager['country'].ignoreContext\n    False\n\n* ``showDefault``\n\n  The ``showDefault`` can be set on fields.\n\n    >>> manager = field.Fields(IPerson)\n    >>> manager['country'].showDefault\n\n    >>> manager = field.Fields(IPerson, showDefault=True)\n    >>> manager['country'].showDefault\n    True\n\n    >>> manager = field.Fields(IPerson, showDefault=False)\n    >>> manager['country'].showDefault\n    False\n\n\nFields Widget Manager\n---------------------\n\nWhen a form (or any other widget-using view) is updated, one of the tasks is\nto create the widgets. Traditionally, generating the widgets involved looking\nat the form fields (or similar) of a form and generating the widgets using the\ninformation of those specifications. This solution is good for the common\n(about 85%) use cases, since it makes writing new forms very simple and allows\na lot of control at a class-definition level.\n\nIt has, however, its limitations. It does not, for example, allow for\ncustomization without rewriting a form. This can range from omitting fields on\na particular form to generically adding a new widget to the form, such as an\n\"object name\" button on add forms. This package solves this issue by providing\na widget manager, which is responsible providing the widgets for a particular\nview.\n\nThe default widget manager for forms is able to look at a form's field\ndefinitions and create widgets for them. Thus, let's create a schema first:\n\n  >>> import zope.interface\n  >>> import zope.schema\n\n  >>> class LastNameTooShort(zope.schema.interfaces.ValidationError):\n  ...     \"\"\"The last name is too short.\"\"\"\n\n  >>> def lastNameConstraint(value):\n  ...     if value and value == value.lower():\n  ...         raise zope.interface.Invalid(u\"Name must have at least one capital letter\")\n  ...     return True\n\n  >>> class IPerson(zope.interface.Interface):\n  ...     id = zope.schema.TextLine(\n  ...         title=u'ID',\n  ...         description=u\"The person's ID.\",\n  ...         readonly=True,\n  ...         required=True)\n  ...\n  ...     lastName = zope.schema.TextLine(\n  ...         title=u'Last Name',\n  ...         description=u\"The person's last name.\",\n  ...         default=u'',\n  ...         required=True,\n  ...         constraint=lastNameConstraint)\n  ...\n  ...     firstName = zope.schema.TextLine(\n  ...         title=u'First Name',\n  ...         description=u\"The person's first name.\",\n  ...         default=u'-- unknown --',\n  ...         required=False)\n  ...\n  ...     @zope.interface.invariant\n  ...     def twiceAsLong(person):\n  ...         # note: we're protecting here values against being None\n  ...         # just in case ignoreRequiredOnExtract lets that through\n  ...         if len(person.lastName or '') >= 2 * len(person.firstName or ''):\n  ...             raise LastNameTooShort()\n\nNext we need a form that specifies the fields to be added:\n\n  >>> from z3c.form import field\n\n  >>> class PersonForm(object):\n  ...     prefix = 'form.'\n  ...     fields = field.Fields(IPerson)\n  >>> personForm = PersonForm()\n\nFor more details on how to define fields within a form, see ``form.txt``. We\ncan now create the fields widget manager. Its discriminators are the form for\nwhich the widgets are created, the request, and the context that is being\nmanipulated. In the simplest case the context is ``None`` and ignored, as it\nis true for an add form.\n\n  >>> from z3c.form.testing import TestRequest\n  >>> request = TestRequest()\n  >>> context = object()\n\n  >>> manager = field.FieldWidgets(personForm, request, context)\n  >>> manager.ignoreContext = True\n\n\nWidget Mapping\n~~~~~~~~~~~~~~\n\nThe main responsibility of the manager is to provide the ``IEnumerableMapping``\ninterface and an ``update()`` method. Initially the mapping, going from widget\nid to widget value, is empty:\n\n  >>> from zope.interface.common.mapping import IEnumerableMapping\n  >>> IEnumerableMapping.providedBy(manager)\n  True\n\n  >>> manager.keys()\n  []\n\nOnly by \"updating\" the manager, will the widgets become available; before we can\nuse the update method, however, we have to register the ``IFieldWidget`` adapter\nfor the ``ITextLine`` field:\n\n  >>> from z3c.form import interfaces, widget\n\n  >>> @zope.component.adapter(zope.schema.TextLine, TestRequest)\n  ... @zope.interface.implementer(interfaces.IFieldWidget)\n  ... def TextFieldWidget(field, request):\n  ...     return widget.FieldWidget(field, widget.Widget(request))\n\n  >>> zope.component.provideAdapter(TextFieldWidget)\n\n  >>> from z3c.form import converter\n  >>> zope.component.provideAdapter(converter.FieldDataConverter)\n  >>> zope.component.provideAdapter(converter.FieldWidgetDataConverter)\n\n  >>> manager.update()\n\nOther than usual mappings in Python, the widget manager's widgets are always\nin a particular order:\n\n  >>> manager.keys()\n  ['id', 'lastName', 'firstName']\n\nAs you can see, if we call update twice, we still get the same amount and\norder of keys:\n\n  >>> manager.update()\n  >>> manager.keys()\n  ['id', 'lastName', 'firstName']\n\nLet's make sure that all enumerable mapping functions work correctly:\n\n  >>> manager['lastName']\n  <Widget 'form.widgets.lastName'>\n\n  >>> manager['unknown']\n  Traceback (most recent call last):\n  ...\n  KeyError: 'unknown'\n\n  >>> manager.get('lastName')\n  <Widget 'form.widgets.lastName'>\n\n  >>> manager.get('unknown', 'default')\n  'default'\n\n  >>> 'lastName' in manager\n  True\n  >>> 'unknown' in manager\n  False\n\n  >>> [key for key in manager]\n  ['id', 'lastName', 'firstName']\n\n  >>> manager.values()\n  [<Widget 'form.widgets.id'>,\n   <Widget 'form.widgets.lastName'>,\n   <Widget 'form.widgets.firstName'>]\n\n  >>> manager.items()\n  [('id', <Widget 'form.widgets.id'>),\n   ('lastName', <Widget 'form.widgets.lastName'>),\n   ('firstName', <Widget 'form.widgets.firstName'>)]\n\n  >>> len(manager)\n  3\n\nIt is also possible to delete widgets from the manager:\n\n  >>> del manager['firstName']\n  >>> len(manager)\n  2\n  >>> manager.values()\n  [<Widget 'form.widgets.id'>, <Widget 'form.widgets.lastName'>]\n  >>> manager.keys()\n  ['id', 'lastName']\n  >>> manager.items()\n  [('id', <Widget 'form.widgets.id'>),\n  ('lastName', <Widget 'form.widgets.lastName'>)]\n\nNote that deleting a non-existent widget causes a ``KeyError`` to be raised:\n\n  >>> del manager['firstName']\n  Traceback (most recent call last):\n  ...\n  KeyError: 'firstName'\n\n\nProperties of widgets within a manager\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nWhen a widget is added to the widget manager, it is located:\n\n  >>> lname = manager['lastName']\n\n  >>> lname.__name__\n  'lastName'\n  >>> lname.__parent__\n  <z3c.form.field.FieldWidgets object at ...>\n\nAll widgets created by this widget manager are context aware:\n\n  >>> interfaces.IContextAware.providedBy(lname)\n  True\n  >>> lname.context is context\n  True\n\n\nDetermination of the widget mode\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nBy default, all widgets will also assume the mode of the manager:\n\n  >>> manager['lastName'].mode\n  'input'\n\n  >>> manager.mode = interfaces.DISPLAY_MODE\n  >>> manager.update()\n\n  >>> manager['lastName'].mode\n  'display'\n\nThe exception is when some fields specifically desire a different mode. In the\nfirst case, all \"readonly\" fields will be shown in display mode:\n\n  >>> manager.mode = interfaces.INPUT_MODE\n  >>> manager.update()\n\n  >>> manager['id'].mode\n  'display'\n\nAn exception is made when the flag, \"ignoreReadonly\" is set:\n\n  >>> manager.ignoreReadonly = True\n  >>> manager.update()\n\n  >>> manager['id'].mode\n  'input'\n\nIn the second case, the last name will inherit the mode from the widget\nmanager, while the first name will want to use a display widget:\n\n  >>> personForm.fields = field.Fields(IPerson).select('lastName')\n  >>> personForm.fields += field.Fields(\n  ...     IPerson, mode=interfaces.DISPLAY_MODE).select('firstName')\n\n  >>> manager.mode = interfaces.INPUT_MODE\n  >>> manager.update()\n\n  >>> manager['lastName'].mode\n  'input'\n  >>> manager['firstName'].mode\n  'display'\n\nIn a third case, the widget will be shown in display mode, if the attribute of\nthe context is not writable. Clearly this can never occur in add forms, since\nthere the context is ignored, but is an important use case in edit forms.\n\nThus, we need an implementation of the ``IPerson`` interface including some\nsecurity declarations:\n\n  >>> from zope.security import checker\n\n  >>> @zope.interface.implementer(IPerson)\n  ... class Person(object):\n  ...\n  ...     def __init__(self, firstName, lastName):\n  ...         self.id = firstName[0].lower() + lastName.lower()\n  ...         self.firstName = firstName\n  ...         self.lastName = lastName\n\n  >>> PersonChecker = checker.Checker(\n  ...     get_permissions = {'id': checker.CheckerPublic,\n  ...                        'firstName': checker.CheckerPublic,\n  ...                        'lastName': checker.CheckerPublic},\n  ...     set_permissions = {'firstName': 'test.Edit',\n  ...                        'lastName': checker.CheckerPublic}\n  ...     )\n\n  >>> srichter = checker.ProxyFactory(\n  ...     Person(u'Stephan', u'Richter'), PersonChecker)\n\nIn this case the last name is always editable, but for the first name the user\nwill need the edit (\"test.Edit\") permission.\n\nWe also need to register the data manager and setup a new security policy:\n\n  >>> from z3c.form import datamanager\n  >>> zope.component.provideAdapter(datamanager.AttributeField)\n\n  >>> from zope.security import management\n  >>> from z3c.form import testing\n  >>> management.endInteraction()\n  >>> newPolicy = testing.SimpleSecurityPolicy()\n  >>> oldpolicy = management.setSecurityPolicy(newPolicy)\n  >>> management.newInteraction()\n\nNow we can create the widget manager:\n\n  >>> personForm = PersonForm()\n  >>> request = TestRequest()\n  >>> manager = field.FieldWidgets(personForm, request, srichter)\n\nAfter updating the widget manager, the fields are available as widgets, the\nfirst name being in display and the last name is input mode:\n\n  >>> manager.update()\n  >>> manager['id'].mode\n  'display'\n  >>> manager['firstName'].mode\n  'display'\n  >>> manager['lastName'].mode\n  'input'\n\nHowever, explicitly overriding the mode in the field declaration overrides\nthis selection for you:\n\n  >>> personForm.fields['firstName'].mode = interfaces.INPUT_MODE\n\n  >>> manager.update()\n  >>> manager['id'].mode\n  'display'\n  >>> manager['firstName'].mode\n  'input'\n  >>> manager['lastName'].mode\n  'input'\n\n\n``showDefault``\n---------------\n\n``showDefault`` by default is True\n\n  >>> manager['firstName'].showDefault\n  True\n\n``showDefault`` gets set on the widget based on the field's setting.\n\n  >>> personForm.fields['firstName'].showDefault = False\n\n  >>> manager.update()\n  >>> manager['firstName'].showDefault\n  False\n\n  >>> personForm.fields['firstName'].showDefault = True\n\n  >>> manager.update()\n  >>> manager['firstName'].showDefault\n  True\n\nRequired fields\n---------------\n\nThere is a flag for required fields. This flag get set if at least one field\nis required. This let us render a required info legend in forms if required\nfields get used.\n\n  >>> manager.hasRequiredFields\n  True\n\n\nData extraction and validation\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nBesides managing widgets, the widget manager also controls the process of\nextracting and validating extracted data. Let's start with the validation\nfirst, which only validates the data as a whole, assuming each individual\nvalue being already validated.\n\nBefore we can use the method, we have to register a \"manager validator\":\n\n  >>> from z3c.form import validator\n  >>> zope.component.provideAdapter(validator.InvariantsValidator)\n\n  >>> personForm.fields = field.Fields(IPerson)\n  >>> manager.update()\n\n  >>> manager.validate(\n  ...     {'firstName': u'Stephan', 'lastName': u'Richter'})\n  ()\n\nThe result of this method is a tuple of errors that occurred during the\nvalidation. An empty tuple means the validation succeeded. Let's now make the\nvalidation fail:\n\n  >>> errors = manager.validate(\n  ...     {'firstName': u'Stephan', 'lastName': u'Richter-Richter'})\n\n  >>> [error.doc() for error in errors]\n  ['The last name is too short.']\n\nA special case occurs when the schema fields are not associated with an\ninterface:\n\n  >>> name = zope.schema.TextLine(__name__='name')\n\n  >>> class PersonNameForm(object):\n  ...     prefix = 'form.'\n  ...     fields = field.Fields(name)\n  >>> personNameForm = PersonNameForm()\n\n  >>> manager = field.FieldWidgets(personNameForm, request, context)\n\nIn this case, the widget manager's ``validate()`` method should simply ignore\nthe field and not try to look up any invariants:\n\n  >>> manager.validate({'name': u'Stephan'})\n  ()\n\nLet's now have a look at the widget manager's ``extract()``, which returns a\ndata dictionary and the collection of errors. Before we can validate, we have\nto register a validator for the widget:\n\n  >>> zope.component.provideAdapter(validator.SimpleFieldValidator)\n\nWhen all goes well, the data dictionary is complete and the error collection\nempty:\n\n  >>> request = TestRequest(form={\n  ...     'form.widgets.id': u'srichter',\n  ...     'form.widgets.firstName': u'Stephan',\n  ...     'form.widgets.lastName': u'Richter'})\n  >>> manager = field.FieldWidgets(personForm, request, context)\n  >>> manager.ignoreContext = True\n  >>> manager.update()\n\n  >>> data, errors = manager.extract()\n  >>> data['firstName']\n  u'Stephan'\n  >>> data['lastName']\n  u'Richter'\n  >>> errors\n  ()\n\nSince all errors are immediately converted to error view snippets, we have to\nprovide the adapter from a validation error to an error view snippet first:\n\n  >>> from z3c.form import error\n  >>> zope.component.provideAdapter(error.ErrorViewSnippet)\n  >>> zope.component.provideAdapter(error.InvalidErrorViewSnippet)\n\nLet's now cause a widget-level error by not submitting the required last\nname:\n\n  >>> request = TestRequest(form={\n  ...     'form.widgets.firstName': u'Stephan', 'form.widgets.id': u'srichter'})\n  >>> manager = field.FieldWidgets(personForm, request, context)\n  >>> manager.ignoreContext = True\n  >>> manager.update()\n  >>> manager.extract()\n  ({'firstName': u'Stephan'}, (<ErrorViewSnippet for RequiredMissing>,))\n\nWe can also turn off ``required`` checking for data extraction:\n\n  >>> request = TestRequest(form={\n  ...     'form.widgets.firstName': u'Stephan', 'form.widgets.id': u'srichter'})\n  >>> manager = field.FieldWidgets(personForm, request, context)\n  >>> manager.ignoreContext = True\n  >>> manager.ignoreRequiredOnExtract = True\n  >>> manager.update()\n\nHere we get the required field as ``None`` and no errors:\n\n  >>> pprint(manager.extract())\n  ({'firstName': u'Stephan', 'lastName': None}, ())\n\n  >>> manager.ignoreRequiredOnExtract = False\n\nOr, we could violate a constraint. This constraint raises Invalid, which is\na convenient way to raise errors where we mainly care about providing a custom\nerror message.\n\n  >>> request = TestRequest(form={\n  ...     'form.widgets.firstName': u'Stephan',\n  ...     'form.widgets.lastName': u'richter',\n  ...     'form.widgets.id': u'srichter'})\n  >>> manager = field.FieldWidgets(personForm, request, context)\n  >>> manager.ignoreContext = True\n  >>> manager.update()\n  >>> extracted = manager.extract()\n  >>> extracted\n  ({'firstName': u'Stephan'}, (<InvalidErrorViewSnippet for Invalid>,))\n\n  >>> extracted[1][0].createMessage()\n  u'Name must have at least one capital letter'\n\nFinally, let's ensure that invariant failures are also caught:\n\n  >>> request = TestRequest(form={\n  ...     'form.widgets.id': u'srichter',\n  ...     'form.widgets.firstName': u'Stephan',\n  ...     'form.widgets.lastName': u'Richter-Richter'})\n  >>> manager = field.FieldWidgets(personForm, request, context)\n  >>> manager.ignoreContext = True\n  >>> manager.update()\n  >>> data, errors = manager.extract()\n  >>> errors[0].error.doc()\n  'The last name is too short.'\n\nNote that the errors coming from invariants are all error view snippets as\nwell, just as it is the case for field-specific validation errors. And that's\nreally all there is!\n\nBy default, the ``extract()`` method not only returns the errors that it\ncatches, but also sets them on individual widgets and on the manager:\n\n  >>> manager.errors\n  (<ErrorViewSnippet for LastNameTooShort>,)\n\nThis behavior can be turned off. To demonstrate, let's make a new request that\ncauses a widget-level error:\n\n  >>> request = TestRequest(form={\n  ...     'form.widgets.firstName': u'Stephan', 'form.widgets.id': u'srichter'})\n  >>> manager = field.FieldWidgets(personForm, request, context)\n  >>> manager.ignoreContext = True\n  >>> manager.update()\n\nWe have to set the setErrors property to False before calling extract,\nwe still get the same result from the method call, ...\n\n  >>> manager.setErrors = False\n  >>> manager.extract()\n  ({'firstName': u'Stephan'}, (<ErrorViewSnippet for RequiredMissing>,))\n\nbut there are no side effects on the manager and the widgets:\n\n  >>> manager.errors\n  ()\n  >>> manager['lastName'].error is None\n  True\n\nCustomization of Ignoring the Context\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nNote that you can also manually control ignoring the context per field.\n\n  >>> class CustomPersonForm(object):\n  ...     prefix = 'form.'\n  ...     fields = field.Fields(IPerson).select('id')\n  ...     fields += field.Fields(IPerson, ignoreContext=True).select(\n  ...                   'firstName', 'lastName')\n  >>> customPersonForm = CustomPersonForm()\n\nLet's now create a manager and update it:\n\n  >>> customManager = field.FieldWidgets(customPersonForm, request, context)\n  >>> customManager.update()\n\n  >>> customManager['id'].ignoreContext\n  False\n  >>> customManager['firstName'].ignoreContext\n  True\n  >>> customManager['lastName'].ignoreContext\n  True\n\n\nFields -- Custom Widget Factories\n---------------------------------\n\nIt is possible to declare custom widgets for fields within the field's\ndeclaration.\n\nLet's have a look at the default form first. Initially, the standard\nregistered widgets are used:\n\n  >>> manager = field.FieldWidgets(personForm, request, srichter)\n  >>> manager.update()\n\n  >>> manager['firstName']\n  <Widget 'form.widgets.firstName'>\n\nNow we would like to have our own custom input widget:\n\n  >>> class CustomInputWidget(widget.Widget):\n  ...     pass\n\n  >>> def CustomInputWidgetFactory(field, request):\n  ...     return widget.FieldWidget(field, CustomInputWidget(request))\n\nIt can be simply assigned as follows:\n\n  >>> personForm.fields['firstName'].widgetFactory = CustomInputWidgetFactory\n  >>> personForm.fields['lastName'].widgetFactory = CustomInputWidgetFactory\n\nNow this widget should be used instead of the registered default one:\n\n  >>> manager = field.FieldWidgets(personForm, request, srichter)\n  >>> manager.update()\n  >>> manager['firstName']\n  <CustomInputWidget 'form.widgets.firstName'>\n\nIn the background the widget factory assignment really just registered the\ndefault factory in the ``WidgetFactories`` object, which manages the\ncustom widgets for all modes. Now all modes show this input widget:\n\n  >>> manager = field.FieldWidgets(personForm, request, srichter)\n  >>> manager.mode = interfaces.DISPLAY_MODE\n  >>> manager.update()\n  >>> manager['firstName']\n  <CustomInputWidget 'form.widgets.firstName'>\n\nHowever, we can also register a specific widget for the display mode:\n\n  >>> class CustomDisplayWidget(widget.Widget):\n  ...     pass\n\n  >>> def CustomDisplayWidgetFactory(field, request):\n  ...     return widget.FieldWidget(field, CustomDisplayWidget(request))\n\n  >>> personForm.fields['firstName']\\\n  ...     .widgetFactory[interfaces.DISPLAY_MODE] = CustomDisplayWidgetFactory\n  >>> personForm.fields['lastName']\\\n  ...     .widgetFactory[interfaces.DISPLAY_MODE] = CustomDisplayWidgetFactory\n\nNow the display mode should produce the custom display widget, ...\n\n  >>> manager = field.FieldWidgets(personForm, request, srichter)\n  >>> manager.mode = interfaces.DISPLAY_MODE\n  >>> manager.update()\n  >>> manager['firstName']\n  <CustomDisplayWidget 'form.widgets.firstName'>\n  >>> manager['lastName']\n  <CustomDisplayWidget 'form.widgets.lastName'>\n\n... while the input mode still shows the default custom input widget\non the ``lastName`` field but not on the ``firstName`` field since we\ndon't have the ``test.Edit`` permission:\n\n  >>> manager = field.FieldWidgets(personForm, request, srichter)\n  >>> manager.mode = interfaces.INPUT_MODE\n  >>> manager.update()\n  >>> manager['firstName']\n  <CustomDisplayWidget 'form.widgets.firstName'>\n  >>> manager['lastName']\n  <CustomInputWidget 'form.widgets.lastName'>\n\nThe widgets factories component,\n\n  >>> factories = personForm.fields['firstName'].widgetFactory\n  >>> factories\n  {'display': <function CustomDisplayWidgetFactory at ...>}\n\nis pretty much a standard dictionary that also manages a default value:\n\n  >>> factories.default\n  <function CustomInputWidgetFactory at ...>\n\nWhen getting a value for a key, if the key is not found, the default is\nreturned:\n\n  >>> sorted(factories.keys())\n  ['display']\n\n  >>> factories[interfaces.DISPLAY_MODE]\n  <function CustomDisplayWidgetFactory at ...>\n  >>> factories[interfaces.INPUT_MODE]\n  <function CustomInputWidgetFactory at ...>\n\n  >>> factories.get(interfaces.DISPLAY_MODE)\n  <function CustomDisplayWidgetFactory at ...>\n  >>> factories.get(interfaces.INPUT_MODE)\n  <function CustomInputWidgetFactory at ...>\n\nIf no default is specified,\n\n  >>> factories.default = None\n\nthen the dictionary behaves as usual:\n\n  >>> factories[interfaces.DISPLAY_MODE]\n  <function CustomDisplayWidgetFactory at ...>\n  >>> factories[interfaces.INPUT_MODE]\n  Traceback (most recent call last):\n  ...\n  KeyError: 'input'\n\n  >>> factories.get(interfaces.DISPLAY_MODE)\n  <function CustomDisplayWidgetFactory at ...>\n  >>> factories.get(interfaces.INPUT_MODE)\n\n=======\nButtons\n=======\n\nButtons are a method to declare actions for a form. Like fields describe\nwidgets within a form, buttons describe actions. The symmetry goes even\nfurther; like fields, buttons are schema fields within schema. When the form\nis instantiated and updated, the buttons are converted to actions.\n\n  >>> from z3c.form import button\n\n\nSchema Defined Buttons\n----------------------\n\nLet's now create a schema that describes the buttons of a form. Having button\nschemas allows one to more easily reuse button declarations and to group them\nlogically. ``Button`` objects are just a simple extension to ``Field``\nobjects, so they behave identical within a schema:\n\n  >>> import zope.interface\n  >>> class IButtons(zope.interface.Interface):\n  ...     apply = button.Button(title=u'Apply')\n  ...     cancel = button.Button(title=u'Cancel')\n\nIn reality, only the title and name is relevant. Let's now create a form that\nprovides those buttons.\n\n  >>> from z3c.form import interfaces\n  >>> @zope.interface.implementer(\n  ...     interfaces.IButtonForm, interfaces.IHandlerForm)\n  ... class Form(object):\n  ...     buttons = button.Buttons(IButtons)\n  ...     prefix = 'form'\n  ...\n  ...     @button.handler(IButtons['apply'])\n  ...     def apply(self, action):\n  ...         print('successfully applied')\n  ...\n  ...     @button.handler(IButtons['cancel'])\n  ...     def cancel(self, action):\n  ...         self.request.response.redirect('index.html')\n\nLet's now create an action manager for the button manager in the form. To do\nthat we first need a request and a form instance:\n\n  >>> from z3c.form.testing import TestRequest\n  >>> request = TestRequest()\n  >>> form = Form()\n\nWe also have to register a button action factory for the buttons:\n\n  >>> zope.component.provideAdapter(\n  ...     button.ButtonAction, provides=interfaces.IButtonAction)\n\nAction managers are instantiated using the form, request, and\ncontext/content. A special button-action-manager implementation is available\nin the ``button`` package:\n\n  >>> actions = button.ButtonActions(form, request, None)\n  >>> actions.update()\n\nOnce the action manager is updated, the buttons should be available as\nactions:\n\n  >>> actions.keys()\n  ['apply', 'cancel']\n\n  >>> actions['apply']\n  <ButtonAction 'form.buttons.apply' u'Apply'>\n\nIt is possible to customize how a button is transformed into an action\nby registering an adapter for the request and the button that provides\n``IButtonAction``.\n\n  >>> import zope.component\n  >>> from zope.publisher.interfaces.browser import IBrowserRequest\n  >>> class CustomButtonAction(button.ButtonAction):\n  ...     \"\"\"Custom Button Action Class.\"\"\"\n\n  >>> zope.component.provideAdapter(\n  ...     CustomButtonAction, provides=interfaces.IButtonAction)\n\nNow if we rerun update we will get this other ButtonAction\nimplementation. Note, there are two strategies what now could happen. We can\nremove the existing action and get the new adapter based action or we can\nreuse the existing action. Since the ButtonActions class offers an API for\nremove existing actions, we reuse the existing action because it very uncommon\nto replace existing action during an for update call with an adapter. If\nsomeone really will add an action adapter during process time via directly\nprovided interface, he is also responsible for remove existing actions.\n\nAs you can see we still will get the old button action if we only call update:\n\n  >>> actions.update()\n  >>> actions.keys()\n  ['apply', 'cancel']\n\n  >>> actions['apply']\n  <ButtonAction 'form.buttons.apply' u'Apply'>\n\nThis means we have to remove the previous action before we call update:\n\n  >>> del actions['apply']\n  >>> actions.update()\n\nMake sure we do not append a button twice to the key and value lists by calling\nupdate twice:\n\n  >>> actions.keys()\n  ['apply', 'cancel']\n\n  >>> actions['apply']\n  <CustomButtonAction 'form.buttons.apply' u'Apply'>\n\nAlternatively, customize an individual button by setting its\nactionFactory attribute.\n\n  >>> def customButtonActionFactory(request, field):\n  ...     print(\"This button factory creates a button only once.\")\n  ...     button = CustomButtonAction(request, field)\n  ...     button.css = \"happy\"\n  ...     return button\n\n  >>> form.buttons['apply'].actionFactory = customButtonActionFactory\n\nAgain, remove the old button action befor we call update:\n\n  >>> del actions['apply']\n  >>> actions.update()\n  This button factory creates a button only once.\n\n  >>> actions.update()\n  >>> actions['apply'].css\n  'happy'\n\nSince we only create a button once from an adapter or a factory, we can change\nthe button attributes without to lose changes:\n\n  >>> actions['apply'].css = 'very happy'\n  >>> actions['apply'].css\n  'very happy'\n\n  >>> actions.update()\n  >>> actions['apply'].css\n  'very happy'\n\nBut let's not digress too much and get rid of this customization\n\n  >>> form.buttons['apply'].actionFactory = None\n  >>> actions.update()\n\nButton actions are locations:\n\n  >>> apply = actions['apply']\n  >>> apply.__name__\n  'apply'\n  >>> apply.__parent__\n  <ButtonActions None>\n\nA button action is also a submit widget. The attributes translate as follows:\n\n  >>> interfaces.ISubmitWidget.providedBy(apply)\n  True\n\n  >>> apply.value == apply.title\n  True\n  >>> apply.id == apply.name.replace('.', '-')\n  True\n\nNext we want to display our button actions. To be able to do this, we have to\nregister a template for the submit widget:\n\n  >>> from z3c.form import testing, widget\n  >>> templatePath = testing.getPath('submit_input.pt')\n  >>> factory = widget.WidgetTemplateFactory(templatePath, 'text/html')\n\n  >>> from zope.pagetemplate.interfaces import IPageTemplate\n  >>> zope.component.provideAdapter(factory,\n  ...     (zope.interface.Interface, TestRequest, None, None,\n  ...      interfaces.ISubmitWidget),\n  ...     IPageTemplate, name='input')\n\nA widget template has many discriminators: context, request, view, field, and\nwidget. We can now render each action:\n\n  >>> print(actions['apply'].render())\n  <input type=\"submit\" id=\"form-buttons-apply\"\n         name=\"form.buttons.apply\" class=\"submit-widget button-field\"\n         value=\"Apply\" />\n\nSo displaying is nice, but how do button handlers get executed? The action\nmanager provides attributes and method to check whether actions were\nexecuted. Initially there are no executed actions:\n\n  >>> list(actions.executedActions)\n  []\n\nSo in this case executing the actions does not do anything:\n\n  >>> actions.execute()\n\nBut if the request contains the information that the button was pressed, the\nexecution works:\n\n  >>> request = TestRequest(form={'form.buttons.apply': 'Apply'})\n\n  >>> actions = button.ButtonActions(form, request, None)\n  >>> actions.update()\n  >>> actions.execute()\n\nAehm, something should have happened. But in order for the system to look at\nthe handlers declared in the form, a special action handler has to be\nregistered with the system:\n\n  >>> zope.component.provideAdapter(button.ButtonActionHandler)\n\nAnd voila, the execution works:\n\n  >>> actions.execute()\n  successfully applied\n\nFinally, if there is no handler for a button, then the button click is\nsilently ignored:\n\n  >>> form.handlers = button.Handlers()\n  >>> actions.execute()\n\nWhile this might seem awkward at first, this is an intended feature. Sometimes\nthere are several sub-forms that listen to a particular button and one form or\nanother might simply not care about the button at all and not provide a\nhandler.\n\n\nIn-Form Button Declarations\n---------------------------\n\nSome readers might find it cumbersome to declare a full schema just to create\nsome buttons. A faster method is to write simple arguments to the button\nmanager:\n\n  >>> @zope.interface.implementer(\n  ...     interfaces.IButtonForm, interfaces.IHandlerForm)\n  ... class Form(object):\n  ...     buttons = button.Buttons(\n  ...         button.Button('apply', title=u'Apply'))\n  ...     prefix = 'form.'\n  ...\n  ...     @button.handler(buttons['apply'])\n  ...     def apply(self, action):\n  ...         print('successfully applied')\n\nThe first argument of the ``Button`` class constructor is the name of the\nbutton. Optionally, this can also be one of the following keyword arguments:\n\n  >>> button.Button(name='apply').__name__\n  'apply'\n  >>> button.Button(__name__='apply').__name__\n  'apply'\n\nIf no name is specified, the button will not have a name immediately, ...\n\n  >>> button.Button(title=u'Apply').__name__\n  ''\n\nbecause if the button is created within an interface, the name is assigned\nlater:\n\n  >>> class IActions(zope.interface.Interface):\n  ...    apply = button.Button(title=u'Apply')\n\n  >>> IActions['apply'].__name__\n  'apply'\n\nHowever, once the button is added to a button manager, a name will be\nassigned:\n\n  >>> btns = button.Buttons(button.Button(title=u'Apply'))\n  >>> btns['apply'].__name__\n  'apply'\n\n  >>> btns = button.Buttons(button.Button(title=u'Apply and more'))\n  >>> btns['4170706c7920616e64206d6f7265'].__name__\n  '4170706c7920616e64206d6f7265'\n\nThis declaration behaves identical to the one before:\n\n  >>> form = Form()\n  >>> request = TestRequest()\n\n  >>> actions = button.ButtonActions(form, request, None)\n  >>> actions.update()\n  >>> actions.execute()\n\nWhen sending in the right information, the actions are executed:\n\n  >>> request = TestRequest(form={'form.buttons.apply': 'Apply'})\n  >>> actions = button.ButtonActions(form, request, None)\n  >>> actions.update()\n  >>> actions.execute()\n  successfully applied\n\nAn even simpler method -- resembling closest the API provided by formlib -- is\nto create the button and handler at the same time:\n\n  >>> @zope.interface.implementer(\n  ...     interfaces.IButtonForm, interfaces.IHandlerForm)\n  ... class Form(object):\n  ...     prefix = 'form.'\n  ...\n  ...     @button.buttonAndHandler(u'Apply')\n  ...     def apply(self, action):\n  ...         print('successfully applied')\n\nIn this case the ``buttonAndHandler`` decorator creates a button and a handler\nfor it. By default the name is computed from the title of the button, which is\nrequired. All (keyword) arguments are forwarded to the button\nconstructor. Let's now render the form:\n\n  >>> request = TestRequest(form={'form.buttons.apply': 'Apply'})\n  >>> actions = button.ButtonActions(form, request, None)\n  >>> actions.update()\n  >>> actions.execute()\n  successfully applied\n\nIf the title is a more complex string, then the name of the button becomes a\nhex-encoded string:\n\n  >>> class Form(object):\n  ...\n  ...     @button.buttonAndHandler(u'Apply and Next')\n  ...     def apply(self, action):\n  ...         print('successfully applied')\n\n  >>> Form.buttons.keys()\n  ['4170706c7920616e64204e657874']\n\nOf course, you can use the ``__name__`` argument to specify a name\nyourself. The decorator, however, also allows the keyword ``name``:\n\n  >>> class Form(object):\n  ...\n  ...     @button.buttonAndHandler(u'Apply and Next', name='applyNext')\n  ...     def apply(self, action):\n  ...         print('successfully applied')\n\n  >>> Form.buttons.keys()\n  ['applyNext']\n\nThis helper function also supports a keyword argument ``provides``, which\nallows the developer to specify a sequence of interfaces that the generated\nbutton should directly provide. Those provided interfaces can be used for a\nmultitude of things, including handler discrimination and UI layout:\n\n  >>> class IMyButton(zope.interface.Interface):\n  ...    pass\n\n  >>> class Form(object):\n  ...\n  ...     @button.buttonAndHandler(u'Apply', provides=(IMyButton,))\n  ...     def apply(self, action):\n  ...         print('successfully applied')\n\n  >>> IMyButton.providedBy(Form.buttons['apply'])\n  True\n\n\nButton Conditions\n-----------------\n\nSometimes it is desirable to only show a button when a certain condition is\nfulfilled. The ``Button`` field supports conditions via a simple argument. The\n``condition`` argument must be a callable taking the form as argument and\nreturning a truth-value. If the condition is not fulfilled, the button will not\nbe converted to an action:\n\n  >>> class Form(object):\n  ...     prefix = 'form'\n  ...     showApply = True\n  ...\n  ...     @button.buttonAndHandler(\n  ...         u'Apply', condition=lambda form: form.showApply)\n  ...     def apply(self, action):\n  ...         print('successfully applied')\n\nIn this case a form variable specifies the availability. Initially the button\nis available as action:\n\n  >>> myform = Form()\n  >>> actions = button.ButtonActions(myform, TestRequest(), None)\n  >>> actions.update()\n  >>> actions.keys()\n  ['apply']\n\nIf we set the show-apply attribute to false, the action will not be available.\n\n  >>> myform.showApply = False\n  >>> actions.update()\n  >>> actions.keys()\n  []\n  >>> actions.values()\n  []\n\nThis feature is very helpful in multi-forms and wizards.\n\n\nCustomizing the Title\n---------------------\n\nAs for widgets, it is often desirable to change attributes of the button\nactions without altering any original code. Again we will be using attribute\nvalue adapters to complete the task. Originally, our title is as follows:\n\n  >>> myform = Form()\n  >>> actions = button.ButtonActions(myform, TestRequest(), None)\n  >>> actions.update()\n  >>> actions['apply'].title\n  u'Apply'\n\nLet's now create a custom label for the action:\n\n  >>> ApplyLabel = button.StaticButtonActionAttribute(\n  ...     u'Apply now', button=myform.buttons['apply'])\n  >>> zope.component.provideAdapter(ApplyLabel, name='title')\n\nOnce the button action manager is updated, the new title is chosen:\n\n  >>> actions.update()\n  >>> actions['apply'].title\n  u'Apply now'\n\n\nThe Button Manager\n------------------\n\nThe button manager contains several additional API methods that make the\nmanagement of buttons easy.\n\nFirst, you are able to add button managers:\n\n  >>> bm1 = button.Buttons(IButtons)\n  >>> bm2 = button.Buttons(button.Button('help', title=u'Help'))\n\n  >>> bm1 + bm2\n  <z3c.form.button.Buttons object at ...>\n  >>> list(bm1 + bm2)\n  ['apply', 'cancel', 'help']\n\nThe result of the addition is another button manager. Also note that the order\nof the buttons is preserved throughout the addition. Adding anything else is\nnot well-defined:\n\n  >>> bm1 + 1\n  Traceback (most recent call last):\n  ...\n  TypeError: unsupported operand type(s) for +: 'Buttons' and 'int'\n\nSecond, you can select the buttons in a particular order:\n\n  >>> bm = bm1 + bm2\n  >>> list(bm)\n  ['apply', 'cancel', 'help']\n\n  >>> list(bm.select('help', 'apply', 'cancel'))\n  ['help', 'apply', 'cancel']\n\nThe ``select()`` method can also be used to eliminate another button:\n\n  >>> list(bm.select('help', 'apply'))\n  ['help', 'apply']\n\nOf course, in the example above we eliminated one and reorganized the buttons.\n\nThird, you can omit one or more buttons:\n\n  >>> list(bm.omit('cancel'))\n  ['apply', 'help']\n\nFinally, while the constructor is very flexible, you cannot just pass in\nanything:\n\n  >>> button.Buttons(1, 2)\n  Traceback (most recent call last):\n  ...\n  TypeError: ('Unrecognized argument type', 1)\n\nWhen creating a new form derived from another, you often want to keep existing\nbuttons and add new ones. In order not to change the super-form class, you need\nto copy the button manager:\n\n  >>> bm.keys()\n  ['apply', 'cancel', 'help']\n  >>> bm.copy().keys()\n  ['apply', 'cancel', 'help']\n\n\nThe Handlers Object\n-------------------\n\nAll handlers of a form are collected in the ``handlers`` attribute, which is a\n``Handlers`` instance:\n\n  >>> isinstance(form.handlers, button.Handlers)\n  True\n  >>> form.handlers\n  <Handlers [<Handler for <Button 'apply' u'Apply'>>]>\n\nInternally the object uses an adapter registry to manage the handlers for\nbuttons. If a handler is registered for a button, it simply behaves as an\ninstance-adapter.\n\nThe object itself is pretty simple. You can get a handler as follows:\n\n  >>> apply = form.buttons['apply']\n  >>> form.handlers.getHandler(apply)\n  <Handler for <Button 'apply' u'Apply'>>\n\nBut you can also register handlers for groups of buttons, either by interface\nor class:\n\n  >>> class SpecialButton(button.Button):\n  ...     pass\n\n  >>> def handleSpecialButton(form, action):\n  ...     return 'Special button action'\n\n  >>> form.handlers.addHandler(\n  ...     SpecialButton, button.Handler(SpecialButton, handleSpecialButton))\n\n  >>> form.handlers\n  <Handlers\n      [<Handler for <Button 'apply' u'Apply'>>,\n       <Handler for <class 'SpecialButton'>>]>\n\nNow all special buttons should use that handler:\n\n  >>> button1 = SpecialButton(name='button1', title=u'Button 1')\n  >>> button2 = SpecialButton(name='button2', title=u'Button 2')\n\n  >>> form.handlers.getHandler(button1)(form, None)\n  'Special button action'\n  >>> form.handlers.getHandler(button2)(form, None)\n  'Special button action'\n\nHowever, registering a more specific handler for button 1 will override the\ngeneral handler:\n\n  >>> def handleButton1(form, action):\n  ...     return 'Button 1 action'\n\n  >>> form.handlers.addHandler(\n  ...     button1, button.Handler(button1, handleButton1))\n\n  >>> form.handlers.getHandler(button1)(form, None)\n  'Button 1 action'\n  >>> form.handlers.getHandler(button2)(form, None)\n  'Special button action'\n\nYou can also add handlers objects:\n\n  >>> handlers2 = button.Handlers()\n\n  >>> button3 = SpecialButton(name='button3', title=u'Button 3')\n  >>> handlers2.addHandler(\n  ...     button3, button.Handler(button3, None))\n\n  >>> form.handlers + handlers2\n  <Handlers\n      [<Handler for <Button 'apply' u'Apply'>>,\n       <Handler for <class 'SpecialButton'>>,\n       <Handler for <SpecialButton 'button1' u'Button 1'>>,\n       <Handler for <SpecialButton 'button3' u'Button 3'>>]>\n\nHowever, adding other components is not supported:\n\n  >>> form.handlers + 1\n  Traceback (most recent call last):\n  ...\n  NotImplementedError\n\nThe handlers also provide a method to copy the handlers to a new instance:\n\n  >>> copy = form.handlers.copy()\n  >>> isinstance(copy, button.Handlers)\n  True\n  >>> copy is form.handlers\n  False\n\nThis is commonly needed when one wants to extend the handlers of a super-form.\n\n\nImage Buttons\n-------------\n\nA special type of button is the image button. Instead of creating a \"submit\"-\nor \"button\"-type input, an \"image\" button is created. An image button is a\nsimple extension of a button, requiring an `image` argument to the constructor:\n\n  >>> imgSubmit = button.ImageButton(\n  ...     name='submit',\n  ...     title=u'Submit',\n  ...     image=u'submit.png')\n  >>> imgSubmit\n  <ImageButton 'submit' u'submit.png'>\n\nSome browsers do not submit the value of the input, but only the coordinates\nof the image where the mouse click occurred. Thus we also need a special\nbutton action:\n\n  >>> from zope.publisher.browser import TestRequest\n  >>> request = TestRequest()\n\n  >>> imgSubmitAction = button.ImageButtonAction(request, imgSubmit)\n  >>> imgSubmitAction\n  <ImageButtonAction 'submit' u'Submit'>\n\nInitially, we did not click on the image:\n\n  >>> imgSubmitAction.isExecuted()\n  False\n\nNow the button is clicked:\n\n  >>> request = TestRequest(form={'submit.x': '3', 'submit.y': '4'})\n\n  >>> imgSubmitAction = button.ImageButtonAction(request, imgSubmit)\n  >>> imgSubmitAction.isExecuted()\n  True\n\nThe \"image\" type of the \"input\"-element also requires there to be a `src`\nattribute, which is the URL to the image to be used. The attribute is also\nsupported by the Python API. However, in order for the attribute to work, the\nimage must be available as a resource, so let's do that now:\n\n  # Traversing setup\n  >>> from zope.traversing import testing\n  >>> testing.setUp()\n\n  # Resource namespace\n  >>> import zope.component\n  >>> from zope.traversing.interfaces import ITraversable\n  >>> from zope.traversing.namespace import resource\n  >>> zope.component.provideAdapter(\n  ...     resource, (None,), ITraversable, name=\"resource\")\n  >>> zope.component.provideAdapter(\n  ...     resource, (None, None), ITraversable, name=\"resource\")\n\n  # New absolute URL adapter for resources, if available\n  >>> from zope.browserresource.resource import AbsoluteURL\n  >>> zope.component.provideAdapter(AbsoluteURL)\n\n  # Register the \"submit.png\" resource\n  >>> from zope.browserresource.resource import Resource\n  >>> testing.browserResource('submit.png', Resource)\n\nNow the attribute can be called:\n\n  >>> imgSubmitAction.src\n  u'http://127.0.0.1/@@/submit.png'\n\n==========\nDirectives\n==========\n\nWidget template directive\n-------------------------\n\nShow how we can use the widget template directive. Register the meta\nconfiguration for the directive.\n\n  >>> import sys\n  >>> from zope.configuration import xmlconfig\n  >>> import z3c.form\n  >>> context = xmlconfig.file('meta.zcml', z3c.form)\n\nWe need a custom widget template\n\n  >>> import os, tempfile\n  >>> temp_dir = tempfile.mkdtemp()\n  >>> widget_file = os.path.join(temp_dir, 'widget.pt')\n  >>> with open(widget_file, 'w') as file:\n  ...     _ = file.write('''\n  ... <html xmlns=\"http://www.w3.org/1999/xhtml\"\n  ...       xmlns:tal=\"http://xml.zope.org/namespaces/tal\"\n  ...       tal:omit-tag=\"\">\n  ...    <input type=\"text\" id=\"\" name=\"\" value=\"\" size=\"\"\n  ...           tal:attributes=\"id view/id;\n  ...                           name view/name;\n  ...                           size view/size;\n  ...                           value view/value;\" />\n  ... </html>\n  ... ''')\n\nand a interface\n\n  >>> import zope.interface\n  >>> from z3c.form import interfaces\n  >>> class IMyWidget(interfaces.IWidget):\n  ...     \"\"\"My widget interface.\"\"\"\n\nand a widget class:\n\n  >>> from z3c.form.testing import TestRequest\n  >>> from z3c.form.browser import text\n  >>> @zope.interface.implementer(IMyWidget)\n  ... class MyWidget(text.TextWidget):\n  ...     pass\n  >>> request = TestRequest()\n  >>> myWidget = MyWidget(request)\n\nMake them available under the fake package ``custom``:\n\n  >>> sys.modules['custom'] = type(\n  ...     'Module', (),\n  ...     {'IMyWidget': IMyWidget})()\n\nand register them as a widget template within the ``z3c:widgetTemplate``\ndirective:\n\n  >>> context = xmlconfig.string(\"\"\"\n  ... <configure\n  ...     xmlns:z3c=\"http://namespaces.zope.org/z3c\">\n  ...   <z3c:widgetTemplate\n  ...       template=\"%s\"\n  ...       widget=\"custom.IMyWidget\"\n  ...       />\n  ... </configure>\n  ... \"\"\" % widget_file, context=context)\n\nLet's get the template\n\n  >>> import zope.component\n  >>> from z3c.template.interfaces import IPageTemplate\n  >>> template = zope.component.queryMultiAdapter((None, request, None, None,\n  ...     myWidget), interface=IPageTemplate, name='input')\n\nand check it:\n\n  >>> from zope.browserpage.viewpagetemplatefile import ViewPageTemplateFile\n  >>> isinstance(template, ViewPageTemplateFile)\n  True\n\nLet's use the template within the widget.\n\n  >>> print(template(myWidget))\n  <input type=\"text\" value=\"\" />\n\nWe normally render the widget which returns the registered template.\n\n  >>> print(myWidget.render())\n  <input type=\"text\" value=\"\" />\n\nIf the template does not exist, then the widget directive should fail\nimmediately:\n\n  >>> unknownFile = os.path.join(temp_dir, 'unknown.pt')\n  >>> context = xmlconfig.string(\"\"\"\n  ... <configure\n  ...     xmlns:z3c=\"http://namespaces.zope.org/z3c\">\n  ...   <z3c:widgetTemplate\n  ...       template=\"%s\"\n  ...       widget=\"custom.IMyWidget\"\n  ...       />\n  ... </configure>\n  ... \"\"\" % unknownFile, context=context)\n  Traceback (most recent call last):\n  ...\n  ZopeXMLConfigurationError: File \"<string>\", line 4.2-7.8\n      ConfigurationError: ('No such file', '...unknown.pt')\n\n\nObject Widget template directive\n--------------------------------\n\nShow how we can use the objectwidget template directive.\n\nThe big difference between the 'simple' Widget template and the Object Widget\ndirective is that the Object Widget template takes the field's schema into\naccount. That makes it easy to register different widget templates for different\nsub-schemas. You can use this together with SubformAdapter to get a totally\ncustom subwidget.\n\nWe need a custom widget template\n\n  >>> widget_file = os.path.join(temp_dir, 'widget.pt')\n  >>> with open(widget_file, 'w') as file:\n  ...     _ = file.write('''\n  ... <html xmlns=\"http://www.w3.org/1999/xhtml\"\n  ...       xmlns:tal=\"http://xml.zope.org/namespaces/tal\"\n  ...       tal:omit-tag=\"\">\n  ...    <div class=\"object-widget\" tal:attributes=\"class view/klass\">\n  ...    yeah, this can get complex\n  ...    </div>\n  ... </html>\n  ... ''')\n\nand a interface\n\n  >>> class IMyObjectWidget(interfaces.IObjectWidget):\n  ...     \"\"\"My objectwidget interface.\"\"\"\n\nand a widget class:\n\n  >>> from z3c.form.browser import object\n  >>> @zope.interface.implementer(IMyObjectWidget)\n  ... class MyObjectWidget(object.ObjectWidget):\n  ...     pass\n  >>> request = TestRequest()\n  >>> myObjectWidget = MyObjectWidget(request)\n\n  >>> from z3c.form.testing import IMySubObject\n  >>> import zope.schema\n  >>> field = zope.schema.Object(\n  ...     __name__='subobject',\n  ...     title=u'my object widget',\n  ...     schema=IMySubObject)\n  >>> myObjectWidget.field = field\n\nMake them available under the fake package ``custom``:\n\n  >>> sys.modules['custom'] = type(\n  ...     'Module', (),\n  ...     {'IMyObjectWidget': IMyObjectWidget})()\n\nand register them as a widget template within the ``z3c:objectWidgetTemplate``\ndirective:\n\n  >>> context = xmlconfig.string(\"\"\"\n  ... <configure\n  ...     xmlns:z3c=\"http://namespaces.zope.org/z3c\">\n  ...   <z3c:objectWidgetTemplate\n  ...       template=\"%s\"\n  ...       widget=\"custom.IMyObjectWidget\"\n  ...       />\n  ... </configure>\n  ... \"\"\" % widget_file, context=context)\n\nLet's get the template\n\n  >>> template = zope.component.queryMultiAdapter((None, request, None, None,\n  ...     myObjectWidget, None), interface=IPageTemplate, name='input')\n\nand check it:\n\n  >>> isinstance(template, ViewPageTemplateFile)\n  True\n\nLet's use the template within the widget.\n\n  >>> print(template(myObjectWidget))\n  <div class=\"object-widget\">yeah, this can get complex</div>\n\nWe normally render the widget which returns the registered template.\n\n  >>> print(myObjectWidget.render())\n  <div class=\"object-widget\">yeah, this can get complex</div>\n\nIf the template does not exist, then the widget directive should fail\nimmediately:\n\n  >>> unknownFile = os.path.join(temp_dir, 'unknown.pt')\n  >>> context = xmlconfig.string(\"\"\"\n  ... <configure\n  ...     xmlns:z3c=\"http://namespaces.zope.org/z3c\">\n  ...   <z3c:objectWidgetTemplate\n  ...       template=\"%s\"\n  ...       widget=\"custom.IMyObjectWidget\"\n  ...       />\n  ... </configure>\n  ... \"\"\" % unknownFile, context=context)\n  Traceback (most recent call last):\n  ...\n  ZopeXMLConfigurationError: File \"<string>\", line 4.2-7.8\n      ConfigurationError: ('No such file', '...unknown.pt')\n\n\nRegister a specific template for a schema:\n\nWe need a custom widget template\n\n  >>> widgetspec_file = os.path.join(temp_dir, 'widgetspec.pt')\n  >>> with open(widgetspec_file, 'w') as file:\n  ...     _ = file.write('''\n  ... <html xmlns=\"http://www.w3.org/1999/xhtml\"\n  ...       xmlns:tal=\"http://xml.zope.org/namespaces/tal\"\n  ...       tal:omit-tag=\"\">\n  ...    <div class=\"object-widget\" tal:attributes=\"class view/klass\">\n  ...    this one is specific\n  ...    </div>\n  ... </html>\n  ... ''')\n\n  >>> context = xmlconfig.string(\"\"\"\n  ... <configure\n  ...     xmlns:z3c=\"http://namespaces.zope.org/z3c\">\n  ...   <z3c:objectWidgetTemplate\n  ...       template=\"%s\"\n  ...       widget=\"custom.IMyObjectWidget\"\n  ...       schema=\"z3c.form.testing.IMySubObject\"\n  ...       />\n  ... </configure>\n  ... \"\"\" % widgetspec_file, context=context)\n\nLet's get the template\n\n  >>> template = zope.component.queryMultiAdapter((None, request, None, None,\n  ...     myObjectWidget, None), interface=IPageTemplate, name='input')\n\nand check it:\n\n  >>> print(myObjectWidget.render())\n  <div class=\"object-widget\">this one is specific</div>\n\n\n\nCleanup\n-------\n\nNow we need to clean up the custom module.\n\n  >>> del sys.modules['custom']\n\nAlso let's not leave temporary files lying around\n\n  >>> import shutil\n  >>> shutil.rmtree(temp_dir)\n\n==========\nValidators\n==========\n\nValidators are components that validate submitted data. This is certainly not\na new concept, but in the previous form frameworks validation was hidden in\nmany places:\n\n* Field/Widget Validation\n\n  The schema field consists of a ``validate()`` method. Validation is\n  automatically invoked when converting a unicode string to a field value\n  using ``fromUnicode()``. This makes it very hard to customize the field\n  validation. No hooks were provided to exert additional restriction at the\n  presentation level.\n\n* Schema/Form Validation\n\n  This type of validation was not supported at all initially. ``zope.formlib``\n  fixed this problem by validating against schema invariants. While this was a\n  first good step, it still made it hard to customize validators, since it\n  required touching the base implementations of the forms.\n\n* Action Validation\n\n  ``zope.formlib`` supports the notion of action validatos. Actions have a\n  success and failure handler. If the validation succeeds, the success handler\n  is called, otherwise the failure handler is chosen. We believe that this\n  design was ill-conceived, especially the default, which required the data to\n  completely validate in order for the action to successful. There are many\n  actions that do not even care about the data in the form, such as \"Help\",\n  \"Cancel\" and \"Reset\" buttons. Thus validation should be part of the data\n  retrieval process and not the action.\n\nFor me, the primary goals of the validator framework are as follows:\n\n* Assert additional restrictions on the data at the presentation\n  level.\n\n  There are several use cases for this. Sometimes clients desire additional\n  restrictions on data for their particular version of the software. It is not\n  always desireable to adjust the model for this client, since the framework\n  knows how to handle the less restrictive case anyways. In another case,\n  additional restrictions might be applied to a particular form due to limited\n  restrictions.\n\n* Make validation pluggable.\n\n  Like most other components of this package, it should be possible to control\n  the validation adapters at a fine grained level.\n\n  * Widgets: context, request, view, field[1], widget\n\n  * Widget Managers: context, request, view, schema[2], manager\n\n  [1].. This is optional, since widgets must not necessarily have fields.\n  [2].. This is optional, since widget managers must not necessarily have\n  manage field widgets and thus know about schemas.\n\n* Provide good defaults that behave sensibly.\n\n  Good defaults are, like in anywhere in this pacakge, very important. We have\n  chosen to implement the ``zope.formlib`` behavior as the default, since it\n  worked very well -- with exception of action validation, of course.\n\nFor this package, we have decided to support validators at the widget and\nwidget manager level. By default the framework only supports field widgets,\nsince the validation of field-absent widgets is generally not\nwell-defined. Thus, we first need to create a schema.\n\n  >>> import zope.interface\n  >>> import zope.schema\n  >>> class IPerson(zope.interface.Interface):\n  ...     login = zope.schema.TextLine(\n  ...         title=u'Login',\n  ...         min_length=1,\n  ...         max_length=10,\n  ...         required=True)\n  ...\n  ...     email = zope.schema.TextLine(\n  ...         title=u'E-mail')\n  ...\n  ...     @zope.interface.invariant\n  ...     def isLoginPartOfEmail(person):\n  ...         if not person.email.startswith(person.login):\n  ...             raise zope.interface.Invalid(\"The login not part of email.\")\n  >>> @zope.interface.implementer(IPerson)\n  ... class Person(object):\n  ...     login = None\n  ...     email = None\n\n\nWidget Validators\n-----------------\n\nWidget validators only validate the data of one particular widget. The\nvalidated value is always assumed to be an internal value and not a widget\nvalue.\n\nBy default, the system uses the simple field validator, which simply uses the\n``validate()`` method of the field. For instantiation, all validators have the\nfollowing signature for its discriminators: context, request, view, field, and\nwidget\n\n  >>> from z3c.form import validator\n  >>> simple = validator.SimpleFieldValidator(\n  ...     None, None, None, IPerson['login'], None)\n\nA validator has a single method ``validate()``. When the validation is\nsuccessful, ``None`` is returned:\n\n  >>> simple.validate(u'srichter')\n\nA validation error is raised, when the validation fails:\n\n  >>> simple.validate(u'StephanCaveman3')\n  Traceback (most recent call last):\n  ...\n  TooLong: (u'StephanCaveman3', 10)\n\nLet's now create a validator that also requires at least 1 numerical character\nin the login name:\n\n  >>> import re\n  >>> class LoginValidator(validator.SimpleFieldValidator):\n  ...\n  ...     def validate(self, value):\n  ...         super(LoginValidator, self).validate(value)\n  ...         if re.search('[0-9]', value) is None:\n  ...             raise zope.interface.Invalid('No numerical character found.')\n\nLet's now try our new validator:\n\n  >>> login = LoginValidator(None, None, None, IPerson['login'], None)\n\n  >>> login.validate(u'srichter1')\n\n  >>> login.validate(u'srichter')\n  Traceback (most recent call last):\n  ...\n  Invalid: No numerical character found.\n\nWe can now register the validator with the component architecture, ...\n\n  >>> import zope.component\n  >>> zope.component.provideAdapter(LoginValidator)\n\nand look up the adapter using the usual way:\n\n  >>> from z3c.form import interfaces\n\n  >>> zope.component.queryMultiAdapter(\n  ...     (None, None, None, IPerson['login'], None),\n  ...     interfaces.IValidator)\n  <LoginValidator for IPerson['login']>\n\nUnfortunately, the adapter is now registered for all fields, so that the\nE-mail field also has this restriction (which is okay in this case, but not\ngenerally):\n\n  >>> zope.component.queryMultiAdapter(\n  ...     (None, None, None, IPerson['email'], None),\n  ...     interfaces.IValidator)\n  <LoginValidator for IPerson['email']>\n\nThe validator module provides a helper function to set the discriminators for\na validator, which can include instances:\n\n  >>> validator.WidgetValidatorDiscriminators(\n  ...     LoginValidator, field=IPerson['login'])\n\nLet's now clean up the component architecture and register the login validator\nagain:\n\n  >>> from zope.testing import cleanup\n  >>> cleanup.cleanUp()\n\n  >>> zope.component.provideAdapter(LoginValidator)\n\n  >>> zope.component.queryMultiAdapter(\n  ...     (None, None, None, IPerson['login'], None),\n  ...     interfaces.IValidator)\n  <LoginValidator for IPerson['login']>\n\n  >>> zope.component.queryMultiAdapter(\n  ...     (None, None, None, IPerson['email'], None),\n  ...     interfaces.IValidator)\n\nIgnoring unchanged values\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\nMost of the time we want to ignore unchanged fields/values at validation.\nA common usecase for this is if a value went away from a vocabulary and we want\nto keep the old value after editing.\nIn case you want to strict behaviour, register ``StrictSimpleFieldValidator``\nfor your layer.\n\n  >>> simple = validator.SimpleFieldValidator(\n  ...     None, None, None, IPerson['login'], None)\n\nNOT_CHANGED never gets validated.\n\n  >>> simple.validate(interfaces.NOT_CHANGED)\n\nCurrent value gets extracted by ``IDataManager``\nvia the widget, field and context\n\n  >>> from z3c.form.datamanager import AttributeField\n  >>> zope.component.provideAdapter(AttributeField)\n\n  >>> import z3c.form.testing\n  >>> request = z3c.form.testing.TestRequest()\n  >>> import z3c.form.widget\n  >>> widget = z3c.form.widget.Widget(request)\n  >>> context = Person()\n\n  >>> widget.context = context\n  >>> from z3c.form import interfaces\n  >>> zope.interface.alsoProvides(widget, interfaces.IContextAware)\n\n  >>> simple = validator.SimpleFieldValidator(\n  ...     context, request, None, IPerson['login'], widget)\n\nOK, let's see checking after setup.\nWorks like a StrictSimpleFieldValidator until we have to validate a different value:\n\n  >>> context.login = u'john'\n  >>> simple.validate(u'carter')\n  >>> simple.validate(u'hippocratiusxy')\n  Traceback (most recent call last):\n  ...\n  TooLong: (u'hippocratiusxy', 10)\n\nValidating the unchanged value works despite it would be an error.\n\n  >>> context.login = u'hippocratiusxy'\n  >>> simple.validate(u'hippocratiusxy')\n\nUnless we want to force validation:\n\n  >>> simple.validate(u'hippocratiusxy', force=True)\n  Traceback (most recent call last):\n  ...\n  TooLong: (u'hippocratiusxy', 10)\n\nSome exceptions:\n\n``missing_value`` gets validated\n\n  >>> simple.validate(IPerson['login'].missing_value)\n  Traceback (most recent call last):\n  ...\n  RequiredMissing: login\n\n\nWidget Validators and File-Uploads\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nFile-Uploads behave a bit different than the other form\nelements. Whether the user did not choose a file to upload\n``interfaces.NOT_CHANGED`` is set as value. But the validator knows\nhow to handle this.\n\nThe example has two bytes fields where File-Uploads are possible, one\nfield is required the other one not:\n\n  >>> class IPhoto(zope.interface.Interface):\n  ...     data = zope.schema.Bytes(\n  ...         title=u'Photo',\n  ...         required=True)\n  ...\n  ...     thumb = zope.schema.Bytes(\n  ...         title=u'Thumbnail',\n  ...         required=False)\n\nThere are several possible cases to differentiate between:\n\nNo widget\n+++++++++\n\nIf there is no widget or the widget does not provide\n``interfaces.IContextAware``, no value is looked up from the\ncontext. So the not required field validates successfully but the\nrequired one has an required missing error, as the default value of\nthe field is looked up on the field:\n\n  >>> simple_thumb = validator.StrictSimpleFieldValidator(\n  ...     None, None, None, IPhoto['thumb'], None)\n  >>> simple_thumb.validate(interfaces.NOT_CHANGED)\n\n  >>> simple_data = validator.StrictSimpleFieldValidator(\n  ...     None, None, None, IPhoto['data'], None)\n  >>> simple_data.validate(interfaces.NOT_CHANGED)\n  Traceback (most recent call last):\n  RequiredMissing: data\n\nWidget which ignores context\n++++++++++++++++++++++++++++\n\nIf the context is ignored in the widget - as in the add form - the\nbehavior is the same as if there was no widget:\n\n  >>> import z3c.form.widget\n  >>> widget = z3c.form.widget.Widget(None)\n  >>> zope.interface.alsoProvides(widget, interfaces.IContextAware)\n  >>> widget.ignoreContext = True\n  >>> simple_thumb = validator.StrictSimpleFieldValidator(\n  ...     None, None, None, IPhoto['thumb'], widget)\n  >>> simple_thumb.validate(interfaces.NOT_CHANGED)\n\n  >>> simple_data = validator.StrictSimpleFieldValidator(\n  ...     None, None, None, IPhoto['data'], widget)\n  >>> simple_data.validate(interfaces.NOT_CHANGED)\n  Traceback (most recent call last):\n  RequiredMissing: data\n\nLook up value from default adapter\n++++++++++++++++++++++++++++++++++\n\nWhen the value is ``interfaces.NOT_CHANGED`` the validator tries to\nlook up the default value using a ``interfaces.IValue``\nadapter. Whether the adapter is found, its value is used as default,\nso the validation of the required field is successful here:\n\n  >>> data_default = z3c.form.widget.StaticWidgetAttribute(\n  ...     b'data', context=None, request=None, view=None,\n  ...     field=IPhoto['data'], widget=widget)\n  >>> zope.component.provideAdapter(data_default, name='default')\n  >>> simple_data.validate(interfaces.NOT_CHANGED)\n\n\nLook up value from context\n++++++++++++++++++++++++++\n\nIf there is a context aware widget which does not ignore its context,\nthe value is looked up on the context using a data manager:\n\n  >>> @zope.interface.implementer(IPhoto)\n  ... class Photo(object):\n  ...     data = None\n  ...     thumb = None\n  >>> photo = Photo()\n  >>> widget.ignoreContext = False\n  >>> zope.component.provideAdapter(z3c.form.datamanager.AttributeField)\n\n  >>> simple_thumb = validator.StrictSimpleFieldValidator(\n  ...     photo, None, None, IPhoto['thumb'], widget)\n  >>> simple_thumb.validate(interfaces.NOT_CHANGED)\n\nIf the value is not set on the context it is a required missing as\nneither context nor input have a valid value:\n\n  >>> simple_data = validator.StrictSimpleFieldValidator(\n  ...     photo, None, None, IPhoto['data'], widget)\n  >>> simple_data.validate(interfaces.NOT_CHANGED)\n  Traceback (most recent call last):\n  RequiredMissing: data\n\nAfter setting the value validation is successful:\n\n  >>> photo.data = b'data'\n  >>> simple_data.validate(interfaces.NOT_CHANGED)\n\n\nClean-up\n++++++++\n\n  >>> gsm = zope.component.getGlobalSiteManager()\n  >>> gsm.unregisterAdapter(z3c.form.datamanager.AttributeField)\n  True\n  >>> gsm.unregisterAdapter(data_default, name='default')\n  True\n\n\nIgnoring required\n~~~~~~~~~~~~~~~~~\n\nSometimes we want to ignore ``required`` checking.\nThat's because we want to have *all* fields extracted from the form\nregardless whether required fields are filled.\nAnd have no required-errors displayed.\n\n  >>> class IPersonRequired(zope.interface.Interface):\n  ...     login = zope.schema.TextLine(\n  ...         title=u'Login',\n  ...         required=True)\n  ...\n  ...     email = zope.schema.TextLine(\n  ...         title=u'E-mail')\n\n  >>> simple = validator.SimpleFieldValidator(\n  ...     None, None, None, IPersonRequired['login'], None)\n\n  >>> simple.validate(None)\n  Traceback (most recent call last):\n  ...\n  RequiredMissing: login\n\nOoops we need a widget too.\n\n  >>> widget = z3c.form.widget.Widget(None)\n  >>> widget.field = IPersonRequired['login']\n\n  >>> simple = validator.SimpleFieldValidator(\n  ...     None, None, None, IPersonRequired['login'], widget)\n\n  >>> simple.validate(None)\n  Traceback (most recent call last):\n  ...\n  RequiredMissing: login\n\nMeeeh, need to signal that we need to ignore ``required``:\n\n  >>> widget.ignoreRequiredOnValidation = True\n\n  >>> simple.validate(None)\n\n\nWidget Manager Validators\n-------------------------\n\nThe widget manager validator, while similar in spirit, works somewhat\ndifferent. The discriminators of the widget manager validator are: context,\nrequest, view, schema, and manager.\n\nA simple default implementation is provided that checks the invariants of the\nschemas:\n\n  >>> invariants = validator.InvariantsValidator(\n  ...     None, None, None, IPerson, None)\n\nWidget manager validators have the option to validate a data dictionary,\n\n  >>> invariants.validate(\n  ...     {'login': u'srichter', 'email': u'srichter@foo.com'})\n  ()\n\nor an object implementing the schema:\n\n  >>> @zope.interface.implementer(IPerson)\n  ... class Person(object):\n  ...     login = u'srichter'\n  ...     email = u'srichter@foo.com'\n  >>> stephan = Person()\n\n  >>> invariants.validateObject(stephan)\n  ()\n\nSince multiple errors can occur during the validation process, all errors are\ncollected in a tuple, which is returned. If the tuple is empty, the validation\nwas successful. Let's now generate a failure:\n\n  >>> errors = invariants.validate(\n  ...     {'login': u'srichter', 'email': u'strichter@foo.com'})\n\n  >>> for e in errors:\n  ...     print(e.__class__.__name__ + ':', e)\n  Invalid: The login not part of email.\n\nLet's now have a look at writing a custom validator. In this case, we want to\nensure that the E-mail address is at most twice as long as the login:\n\n  >>> class CustomValidator(validator.InvariantsValidator):\n  ...     def validateObject(self, obj):\n  ...         errors = super(CustomValidator, self).validateObject(obj)\n  ...         if len(obj.email) > 2 * len(obj.login):\n  ...             errors += (zope.interface.Invalid('Email too long.'),)\n  ...         return errors\n\nSince the ``validate()`` method of ``InvatiantsValidator`` simply uses\n``validateObject()`` it is enough to only override ``validateObject()``. Now\nwe can use the validator:\n\n  >>> custom = CustomValidator(\n  ...     None, None, None, IPerson, None)\n\n  >>> custom.validate(\n  ...     {'login': u'srichter', 'email': u'srichter@foo.com'})\n  ()\n  >>> errors = custom.validate(\n  ...     {'login': u'srichter', 'email': u'srichter@foobar.com'})\n  >>> for e in errors:\n  ...     print(e.__class__.__name__ + ':', e)\n  Invalid: Email too long.\n\nTo register the custom validator only for this schema, we have to use the\ndiscriminator generator again.\n\n  >>> from z3c.form import util\n  >>> validator.WidgetsValidatorDiscriminators(\n  ...     CustomValidator, schema=util.getSpecification(IPerson, force=True))\n\nNote: Of course we could have used the ``zope.component.adapts()`` function\n      from within the class, but I think it is too tedious, since you have to\n      specify all discriminators and not only the specific ones you are\n      interested in.\n\nAfter registering the validator,\n\n  >>> zope.component.provideAdapter(CustomValidator)\n\nit becomes the validator for this schema:\n\n  >>> zope.component.queryMultiAdapter(\n  ...     (None, None, None, IPerson, None), interfaces.IManagerValidator)\n  <CustomValidator for IPerson>\n\n  >>> class ICar(zope.interface.Interface):\n  ...     pass\n  >>> zope.component.queryMultiAdapter(\n  ...     (None, None, None, ICar, None), interfaces.IManagerValidator)\n\n\nThe Data Wrapper\n----------------\n\nThe ``Data`` class provides a wrapper to present a dictionary as a class\ninstance. This is used to check for invariants, which always expect an\nobject. While the common use cases of the data wrapper are well tested in the\ncode above, there are some corner cases that need to be addressed.\n\nSo let's start by creating a data object:\n\n  >>> context = object()\n  >>> data = validator.Data(IPerson, {'login': 'srichter', 'other': 1}, context)\n\nWhen we try to access a name that is not in the schema, we get an attribute\nerror:\n\n  >>> data.address\n  Traceback (most recent call last):\n  ...\n  AttributeError: address\n\n  >>> data.other\n  Traceback (most recent call last):\n  ...\n  AttributeError: other\n\nIf the field found is a method, then a runtime error is raised:\n\n  >>> class IExtendedPerson(IPerson):\n  ...     def compute():\n  ...         \"\"\"Compute something.\"\"\"\n\n  >>> data = validator.Data(IExtendedPerson, {'compute': 1}, context)\n  >>> data.compute\n  Traceback (most recent call last):\n  ...\n  RuntimeError: ('Data value is not a schema field', 'compute')\n\nFinally, the context is available as attribute directly:\n\n  >>> data.__context__ is context\n  True\n\nIt is used by the validators (especially invariant validators) to provide a\ncontext of validation, for example to look up a vocabulary or access the\nparent of an object. Note that the context will be different between add and\nedit forms.\n\nValidation of interface variants when not all fields are displayed in form\n--------------------------------------------------------------------------\n\nWe need to register the data manager to access the data on the context object:\n\n  >>> from z3c.form import datamanager\n  >>> zope.component.provideAdapter(datamanager.AttributeField)\n\nSometimes you might leave out fields in the form which need to compute the\ninvariant. An exception should be raised. The data wrapper is used to test\nthe invariants and looks up values on the context object that are left out in\nthe form.\n\n  >>> invariants = validator.InvariantsValidator(\n  ...     stephan, None, None, IPerson, None)\n  >>> errors = invariants.validate({'email': 'foo@bar.com'})\n  >>> errors[0].__class__.__name__\n  'Invalid'\n  >>> errors[0].args[0]\n  'The login not part of email.'\n\n=======\nWidgets\n=======\n\nWidgets are small UI components that accept and process the textual user\ninput. The only responsibility of a widget is to represent a value to the\nuser, allow it to be modified and then return a new value. Good examples of\nwidgets include the Qt widgets and HTML widgets. The widget is not responsible\nfor converting its value to the desired internal value or validate the\nincoming data. These responsibilities are passed data converters and\nvalidators, respectively.\n\nThere are several problems that can be identified in the original Zope 3 widget\nimplementation located at ``zope.app.form``.\n\n(1) Field Dependence -- Widgets are always views of fields. While this might\n    be a correct choice for a high-level API, it is fundamentally wrong. It\n    disallows us to use widgets without defining fields. This also couples\n    certain pieces of information too tightly to the field, especially, value\n    retrieval from and storage to the context, validation and raw data\n    conversion.\n\n(2) Form Dependence -- While widgets do not have to be located within a form,\n    they are usually tightly coupled to it. It is very difficult to use\n    widgets outside the context of a form.\n\n(3) Traversability -- Widgets cannot be traversed, which means that they\n    cannot interact easily using Javascript. This is not a fundamental\n    problem, but simply a lack of the current design to recognize that small\n    UI components must also be traversable and thus have a URI.\n\n(4) Customizability -- A consequence of issue (1) is that widgets are not\n    customizable enough. Implementing real-world projects has shown that\n    widgets often want a very fine-grained ability to customize values. A\n    prime example is the label. Because the label of a widget is retrieved\n    from the field title, it is impossible to provide an alternative label for\n    a widget. While the label could be changed from the form, this would\n    require rewriting the entire form to change a label. Instead, we often\n    endde up writing cusom schemas.\n\n(5) Flexibility -- Oftentimes it is desired to have one widget, but multiple\n    styles of representation. For example, in one scenario the widget uses a\n    plain HTML widget and in another a fancy JavaScript widget is used. The\n    current implementation makes it very hard to provide alternative styles\n    for a widget.\n\n\nCreating and Using Simple Widgets\n---------------------------------\n\nWhen using the widget API by itself, the simplest way to use it is to just\ninstantiate it using the request:\n\n  >>> from z3c.form.testing import TestRequest\n  >>> from z3c.form import widget\n  >>> request = TestRequest()\n  >>> age = widget.Widget(request)\n\nIn this case we instantiated a generic widget. A full set of simple\nbrowser-based widgets can be found in the ``browser/`` package. Since no\nhelper components are around to fill the attributes of the widget, we have to\ndo it by hand:\n\n  >>> age.name = 'age'\n  >>> age.label = u'Age'\n  >>> age.value = '39'\n\nThe most important attributes are the \"name\" and the \"value\". The name is used\nto identify the widget within the form. The value is either the value to be\nmanipulated or the default value. The value must be provided in the form the\nwidget needs it. It is the responsibility of a data converter to convert\nbetween the widget value and the desired internal value.\n\nBefore we can render the widget, we have to register a template for the\nwidget. The first step is to define the template:\n\n  >>> import tempfile\n  >>> textWidgetTemplate = tempfile.mktemp('text.pt')\n  >>> with open(textWidgetTemplate, 'w') as file:\n  ...     _ = file.write('''\n  ... <html xmlns=\"http://www.w3.org/1999/xhtml\"\n  ...       xmlns:tal=\"http://xml.zope.org/namespaces/tal\"\n  ...       tal:omit-tag=\"\">\n  ...    <input type=\"text\" name=\"\" value=\"\"\n  ...           tal:attributes=\"name view/name; value view/value;\" />\n  ... </html>\n  ... ''')\n\nNext, we have to create a template factory for the widget:\n\n  >>> from z3c.form.widget import WidgetTemplateFactory\n  >>> factory = WidgetTemplateFactory(\n  ...     textWidgetTemplate, widget=widget.Widget)\n\nThe first argument, which is also required, is the path to the template\nfile. An optional ``content_type`` keyword argument allows the developer to\nspecify the output content type, usually \"text/html\". Then there are five\nkeyword arguments that specify the discriminators of the template:\n\n* ``context`` -- This is the context in which the widget is displayed. In a\n  simple widget like the one we have now, the context is ``None``.\n\n* ``request`` -- This discriminator allows you to specify the type of request\n  for which the widget will be available. In our case this would be a browser\n  request. Note that browser requests can be further broken into layer, so you\n  could also specify a layer interface here.\n\n* ``view`` -- This is the view from which the widget is used. The simple\n  widget at hand, does not have a view associated with it though.\n\n* ``field`` -- This is the field for which the widget provides a\n  representation. Again, this simple widget does not use a field, so it is\n  ``None``.\n\n* ``widget`` -- This is the widget itself. With this discriminator you can\n  specify for which type of widget you are providing a template.\n\nWe can now register the template factory. The name of the factory is the mode\nof the widget. By default, there are two widget modes: \"input\" and\n\"display\". However, since the mode is just a string, one can develop other\nkinds of modes as needed for a project. The default mode is \"input\":\n\n  >>> from z3c.form import interfaces\n  >>> age.mode is interfaces.INPUT_MODE\n  True\n\n  >>> import zope.component\n  >>> zope.component.provideAdapter(factory, name=interfaces.INPUT_MODE)\n\nOnce everything is set up, the widget is updated and then rendered:\n\n  >>> age.update()\n  >>> print(age.render())\n  <input type=\"text\" name=\"age\" value=\"39\" />\n\nIf a value is found in the request, it takes precedence, since the user\nentered the value:\n\n  >>> age.request = TestRequest(form={'age': '25'})\n  >>> age.update()\n  >>> print(age.render())\n  <input type=\"text\" name=\"age\" value=\"25\" />\n\nHowever, there is an option to turn off all request data:\n\n  >>> age.value = '39'\n  >>> age.ignoreRequest = True\n  >>> age.update()\n  >>> print(age.render())\n  <input type=\"text\" name=\"age\" value=\"39\" />\n\nAdditionally the widget provides a dictionary representation of its data through a json_data() method:\n  >>> from pprint import pprint\n  >>> pprint(age.json_data())\n  {'error': '',\n   'id': '',\n   'label': 'Age',\n   'mode': 'input',\n   'name': 'age',\n   'required': False,\n   'type': 'text',\n   'value': '39'}\n\n\nCreating and Using Field Widgets\n--------------------------------\n\nAn extended form of the widget allows fields to control several of the\nwidget's properties. Let's create a field first:\n\n  >>> ageField = zope.schema.Int(\n  ...     __name__ = 'age',\n  ...     title = u'Age',\n  ...     min = 0,\n  ...     max = 130)\n\nWe can now use our simple widget and create a field widget from it:\n\n  >>> ageWidget = widget.FieldWidget(ageField, age)\n\nSuch a widget provides ``IFieldWidget``:\n\n  >>> interfaces.IFieldWidget.providedBy(ageWidget)\n  True\n\nOf course, this is more commonly done using an adapter. Commonly those\nadapters look like this:\n\n  >>> @zope.component.adapter(zope.schema.Int, TestRequest)\n  ... @zope.interface.implementer(interfaces.IFieldWidget)\n  ... def IntWidget(field, request):\n  ...     return widget.FieldWidget(field, widget.Widget(request))\n\n  >>> zope.component.provideAdapter(IntWidget)\n  >>> ageWidget = zope.component.getMultiAdapter((ageField, request),\n  ...     interfaces.IFieldWidget)\n\nNow we just have to update and render the widget:\n\n  >>> ageWidget.update()\n  >>> print(ageWidget.render())\n  <input type=\"text\" name=\"age\" />\n\nThere is no initial value for the widget, since there is no value in the\nrequest and the field does not provide a default. Let's now give our field a\ndefault value and see what happens:\n\n  >>> ageField.default = 30\n  >>> ageWidget.update()\n  Traceback (most recent call last):\n  ...\n  TypeError: ('Could not adapt', <Widget 'age'>,\n              <InterfaceClass z3c.form.interfaces.IDataConverter>)\n\nIn order for the widget to be able to take the field's default value and use\nit to provide an initial value the widget, we need to provide a data converter\nthat defines how to convert from the field value to the widget value.\n\n  >>> from z3c.form import converter\n  >>> zope.component.provideAdapter(converter.FieldWidgetDataConverter)\n  >>> zope.component.provideAdapter(converter.FieldDataConverter)\n\n  >>> ageWidget.update()\n  >>> print(ageWidget.render())\n  <input type=\"text\" name=\"age\" value=\"30\" />\n\nAgain, the request value is honored above everything else:\n\n  >>> ageWidget.request = TestRequest(form={'age': '25'})\n  >>> ageWidget.update()\n  >>> print(ageWidget.render())\n  <input type=\"text\" name=\"age\" value=\"25\" />\n\n\nCreating and Using Context Widgets\n----------------------------------\n\nWhen widgets represent an attribute value of an object, then this object must\nbe set as the context of the widget:\n\n  >>> class Person(object):\n  ...     age = 45\n  >>> person = Person()\n\n  >>> ageWidget.context = person\n  >>> zope.interface.alsoProvides(ageWidget, interfaces.IContextAware)\n\nThe result is that the context value takes over precendence over the default\nvalue:\n\n  >>> ageWidget.request = TestRequest()\n  >>> ageWidget.update()\n  Traceback (most recent call last):\n  ...\n  ComponentLookupError: ((...), <InterfaceClass ...IDataManager>, u'')\n\nThis call fails because the widget does not know how to extract the value from\nthe context. Registering a data manager for the widget does the trick:\n\n  >>> from z3c.form import datamanager\n  >>> zope.component.provideAdapter(datamanager.AttributeField)\n\n  >>> ageWidget.update()\n  >>> print(ageWidget.render())\n  <input type=\"text\" name=\"age\" value=\"45\" />\n\nIf the context value is unknown (None), the default value kicks in.\n\n  >>> person.age = None\n\n  >>> ageWidget.update()\n  >>> print(ageWidget.render())\n  <input type=\"text\" name=\"age\" value=\"30\" />\n\nUnless the widget is explicitely asked to not to show defaults.\nThis is handy for EditForms.\n\n  >>> ageWidget.showDefault = False\n\n  >>> ageWidget.update()\n  >>> print(ageWidget.render())\n  <input type=\"text\" name=\"age\" value=\"\" />\n\n  >>> ageWidget.showDefault = True\n  >>> person.age = 45\n\nThe context can be explicitely ignored, making the widget display the default\nvalue again:\n\n  >>> ageWidget.ignoreContext = True\n  >>> ageWidget.update()\n  >>> print(ageWidget.render())\n  <input type=\"text\" name=\"age\" value=\"30\" />\n\nAgain, the request value is honored above everything else:\n\n  >>> ageWidget.request = TestRequest(form={'age': '25'})\n  >>> ageWidget.ignoreContext = False\n  >>> ageWidget.update()\n  >>> print(ageWidget.render())\n  <input type=\"text\" name=\"age\" value=\"25\" />\n\nBut what happens if the object we are working on is security proxied? In\nparticular, what happens, if the access to the attribute is denied. To see\nwhat happens, we have to create a proxied person:\n\n  >>> from zope.security import checker\n  >>> PersonChecker = checker.Checker({'age': 'Access'}, {'age': 'Edit'})\n\n  >>> ageWidget.request = TestRequest()\n  >>> ageWidget.context = checker.ProxyFactory(Person(), PersonChecker)\n\nAfter changing the security policy, ...\n\n  >>> from zope.security import management\n  >>> from z3c.form import testing\n  >>> management.endInteraction()\n  >>> newPolicy = testing.SimpleSecurityPolicy()\n  >>> oldPolicy = management.setSecurityPolicy(newPolicy)\n  >>> management.newInteraction()\n\nit is not possible anymore to update the widget:\n\n  >>> ageWidget.update()\n  Traceback (most recent call last):\n  ...\n  Unauthorized: (<Person object at ...>, 'age', 'Access')\n\nIf no security declaration has been made at all, we get a\n``ForbiddenAttribute`` error:\n\n  >>> ageWidget.context = checker.ProxyFactory(Person(), checker.Checker({}))\n  >>> ageWidget.update()\n  Traceback (most recent call last):\n  ...\n  ForbiddenAttribute: ('age', <Person object at ...>)\n\nLet's clean up the setup:\n\n  >>> management.endInteraction()\n  >>> newPolicy = management.setSecurityPolicy(oldPolicy)\n  >>> management.newInteraction()\n\n  >>> ageWidget.context = Person()\n\n\nDynamically Changing Attribute Values\n-------------------------------------\n\nOnce widgets are used within a framework, it is very tedious to write Python\ncode to adjust certain attributes, even though hooks exist. The easiest way to\nchange those attribute values is actually to provide an adapter that provides\nthe custom value.\n\nWe can create a custom label for the age widget:\n\n  >>> AgeLabel = widget.StaticWidgetAttribute(\n  ...     u'Current Age',\n  ...     context=None, request=None, view=None, field=ageField, widget=None)\n\nClearly, this code does not require us to touch the orginal form and widget\ncode, given that we have enough control over the selection. In the example\nabove, all the selection discriminators are listed for demonstration\npurposes. Of course, the label in this case can be created as follows:\n\n  >>> AgeLabel = widget.StaticWidgetAttribute(u'Current Age', field=ageField)\n\nMuch better, isn't it? Initially the label is the title of the field:\n\n  >>> ageWidget.label\n  u'Age'\n\nLet's now simply register the label as a named adapter; the name is the name\nof the attribute to change:\n\n  >>> zope.component.provideAdapter(AgeLabel, name='label')\n\nAsking the widget for the label now will return the newly registered label:\n\n  >>> ageWidget.update()\n  >>> ageWidget.label\n  u'Current Age'\n\nOf course, simply setting the label or changing the label extraction via a\nsub-class are other options you might want to consider. Furthermore, you\ncould also create a computed attribute value or implement your own component.\n\nOverriding other attributes, such as ``required``, is done in the same\nway. If any widget provides new attributes, they are also overridable this\nway. For example, the selection widget defines a label for the option that no\nvalue was selected. We often want to override this, because the German\ntranslation sucks or the wording is often too generic. Widget implementation\nshould add names of overridable attributes to their \"_adapterValueAttributes\"\ninternal attribute.\n\nLet's try to override the ``required`` attribute. By default the widget is required,\nbecause the field is required as well:\n\n  >>> ageWidget.required\n  True\n\nLet's provide a static widget attribute adapter with name \"required\":\n\n  >>> AgeNotRequired = widget.StaticWidgetAttribute(False, field=ageField)\n  >>> zope.component.provideAdapter(AgeNotRequired, name=\"required\")\n\nNow, let's check if it works:\n\n  >>> ageWidget.update()\n  >>> ageWidget.required\n  False\n\nOverriding the default value is somewhat special due to the complexity of\nobtaining the value. So let's register one now:\n\n  >>> AgeDefault = widget.StaticWidgetAttribute(50, field=ageField)\n  >>> zope.component.provideAdapter(AgeDefault, name=\"default\")\n\nLet's now instantiate, update and render the widget to see the default value:\n\n  >>> ageWidget = zope.component.getMultiAdapter((ageField, request),\n  ...     interfaces.IFieldWidget)\n  >>> ageWidget.update()\n  >>> print(ageWidget.render())\n  <input type=\"text\" name=\"age\" value=\"50\" />\n\nThis value is also respected by the json_data method:\n  >>> from pprint import pprint\n  >>> pprint(ageWidget.json_data())\n  {'error': '',\n   'id': 'age',\n   'label': 'Current Age',\n   'mode': 'input',\n   'name': 'age',\n   'required': False,\n   'type': 'text',\n   'value': '50'}\n\n\nSequence Widget\n---------------\n\nA common use case in user interfaces is to ask the user to select one or more\nitems from a set of options/choices. The ``widget`` module provides a basic\nwidget implementation to support this use case.\n\nThe options available for selections are known as terms. Initially, there are\nno terms:\n\n  >>> request = TestRequest()\n  >>> seqWidget = widget.SequenceWidget(request)\n  >>> seqWidget.name = 'seq'\n\n  >>> seqWidget.terms is None\n  True\n\nThere are two ways terms can be added, either manually or via an\nadapter. Those term objects must provide ``ITerms``. There is no simple\ndefault implementation, so we have to provide one ourselves:\n\n  >>> from zope.schema import vocabulary\n  >>> @zope.interface.implementer(interfaces.ITerms)\n  ... class Terms(vocabulary.SimpleVocabulary):\n  ...     def getValue(self, token):\n  ...         return self.getTermByToken(token).value\n\n  >>> terms = Terms(\n  ...   [Terms.createTerm(1, 'v1', u'Value 1'),\n  ...    Terms.createTerm(2, 'v2', u'Value 2'),\n  ...    Terms.createTerm(3, 'v3', u'Value 3')])\n  >>> seqWidget.terms = terms\n\nOnce the ``terms`` attribute is set, updating the widgets does not change the\nterms:\n\n  >>> seqWidget.update()\n  >>> [term.value for term in seqWidget.terms]\n  [1, 2, 3]\n\nThe value of a sequence widget is a tuple/list of term tokens. When extracting\nvalues from the request, the values must be valid tokens, otherwise the\ndefault value is returned:\n\n  >>> seqWidget.request = TestRequest(form={'seq': ['v1']})\n  >>> seqWidget.extract()\n  ('v1',)\n\n  >>> seqWidget.request = TestRequest(form={'seq': ['v4']})\n  >>> seqWidget.extract()\n  <NO_VALUE>\n\n  >>> seqWidget.request = TestRequest(form={'seq-empty-marker': '1'})\n  >>> seqWidget.extract()\n  ()\n\nNote that we also support single values being returned outside a sequence. The\nextracted value is then wrapped by a tuple. This feature is useful when\nintegrating with third-party client frameworks that do not know about the Zope\nnaming conventions.\n\n  >>> seqWidget.request = TestRequest(form={'seq': 'v1'})\n  >>> seqWidget.extract()\n  ('v1',)\n\nIf the no-value token has been selected, it is returned without further\nverification:\n\n  >>> seqWidget.request = TestRequest(form={'seq': [seqWidget.noValueToken]})\n  >>> seqWidget.extract()\n  ('--NOVALUE--',)\n\nSince the value of the widget is a tuple of tokens, when displaying the\nvalues, they have to be converted to the title of the term:\n\n  >>> seqWidget.value = ('v1', 'v2')\n  >>> seqWidget.displayValue\n  [u'Value 1', u'Value 2']\n\nUnknown values/terms get silently ignored.\n\n  >>> seqWidget.value = ('v3', 'v4')\n  >>> seqWidget.displayValue\n  [u'Value 3']\n\nWhen input forms are directly switched to display forms within the same\nrequest, it can happen that the value contains the \"--NOVALUE--\" token\nentry. This entry should be silently ignored:\n\n  >>> seqWidget.value = (seqWidget.noValueToken,)\n  >>> seqWidget.displayValue\n  []\n\nTo demonstrate how the terms is automatically chosen by a widget, we should\ninstantiate a field widget. Let's do this with a choice field:\n\n  >>> seqField = zope.schema.Choice(\n  ...     title=u'Sequence Field',\n  ...     vocabulary=terms)\n\nLet's now create the field widget:\n\n  >>> seqWidget = widget.FieldWidget(seqField, widget.SequenceWidget(request))\n  >>> seqWidget.terms\n\nThe terms should be available as soon as the widget is updated:\n\n  >>> seqWidget.update()\n  Traceback (most recent call last):\n  ...\n  ComponentLookupError: ((...), <InterfaceClass ...ITerms>, u'')\n\nThis failed, because we did not register an adapter for the terms yet. After\nthe adapter is registered, everything should work as expected:\n\n  >>> from z3c.form import term\n  >>> zope.component.provideAdapter(term.ChoiceTermsVocabulary)\n  >>> zope.component.provideAdapter(term.ChoiceTerms)\n\n  >>> seqWidget.update()\n  >>> seqWidget.terms\n  <z3c.form.term.ChoiceTermsVocabulary object at ...>\n\nThe representation of this widget as json looks a bit different:\n  >>> from pprint import pprint\n  >>> pprint(seqWidget.json_data())\n  {'error': '',\n   'id': '',\n   'label': 'Sequence Field',\n   'mode': 'input',\n   'name': '',\n   'required': True,\n   'type': 'sequence',\n   'value': ()}\n\n\nSo that's it. Everything else is the same from then on.\n\n\nMulti Widget\n------------\n\nA common use case in user interfaces is to ask the user to define one or more\nitems. The ``widget`` module provides a basic widget implementation to support\nthis use case.\n\nThe `MultiWidget` allows to store none, one or more values for a sequence or dictionary\nfield.  Don't get confused by the term sequence. The sequence used in\n`SequenceWidget` means that the widget can choose from a sequence of values\nwhich is really a collection. The `MultiWidget` can collect values to build\nand store a sequence of values like those used in `ITuple` or `IList` field.\n\n  >>> request = TestRequest()\n  >>> multiWidget = widget.MultiWidget(request)\n  >>> multiWidget.name = 'multi.name'\n  >>> multiWidget.id = 'multi-id'\n\n  >>> multiWidget.value\n  []\n\nLet's define a field for our multi widget:\n\n  >>> multiField = zope.schema.List(\n  ...     value_type=zope.schema.Int(default=42))\n  >>> multiWidget.field = multiField\n\nIf the multi is used with a schema.List the value of a multi widget is always list.\nWhen extracting values from the\nrequest, the values must be a list of valid values based on the value_type\nfield used from the used sequence field. The widget also uses a counter which\nis required for processing the input from a request. The counter is a marker\nfor build the right amount of enumerated widgets.\n\nIf we provide no request we will get no value:\n\n  >>> multiWidget.extract()\n  <NO_VALUE>\n\nIf we provide an empty counter we will get an empty list.\nThis is accordance with Widget.extract(), where a missing request value\nis <NO_VALUE> and an empty ('') request value is ''.\n\n  >>> multiWidget.request = TestRequest(form={'multi.name.count':'0'})\n  >>> multiWidget.extract()\n  []\n\nIf we provide real values within the request, we will get it back:\n\n  >>> multiWidget.request = TestRequest(form={'multi.name.count':'2',\n  ...                                         'multi.name.0':u'42',\n  ...                                         'multi.name.1':u'43'})\n  >>> multiWidget.extract()\n  [u'42', u'43']\n\nIf we provide a bad value we will get the bad value within the extract method.\nOur widget update process will validate this bad value later:\n\n  >>> multiWidget.request = TestRequest(form={'multi.name.count':'1',\n  ...                                         'multi.name.0':u'bad'})\n  >>> multiWidget.extract()\n  [u'bad']\n\nStoring a widget value forces to update the (sub) widgets. This forces also to\nvalidate the (sub) widget values. To show this we need to register a\nvalidator:\n\n  >>> from z3c.form.validator import SimpleFieldValidator\n  >>> zope.component.provideAdapter(SimpleFieldValidator)\n\nSince the value of the widget is a list of (widget) value items, when\ndisplaying the values, they can be used as they are:\n\n  >>> multiWidget.request = TestRequest(form={'multi.name.count':'2',\n  ...                                         'multi.name.0':u'42',\n  ...                                         'multi.name.1':u'43'})\n  >>> multiWidget.value = multiWidget.extract()\n  >>> multiWidget.value\n  [u'42', u'43']\n\nEach widget normally gets first processed by it's update method call after\ninitialization. This update call forces to call extract, which first will get\nthe right amount of (sub) widgets by the given counter value. Based on that\ncounter value the right amount of widgets will get created. Each widget will\nreturn it's own value and this collected values get returned by the extract\nmethod. The multi widget update method will then store this values if any given\nas multi widget value argument. If extract doesn't return a value the multi\nwidget update method will use it's default value. If we store a given value\nfrom the extract as multi widget value, this will force to setup the multi\nwidget widgets based on the given values and apply the right value for them.\nAfter that the multi widget is ready for rendering. The good thing about that\npattern is that it is possible to set a value before or after the update method\nis called. At any time if we change the multi widget value the (sub) widgets\nget updated within the new relevant value.\n\n  >>> multiRequest = TestRequest(form={'multi.name.count':'2',\n  ...                                  'multi.name.0':u'42',\n  ...                                  'multi.name.1':u'43'})\n\n  >>> multiWidget = widget.FieldWidget(multiField, widget.MultiWidget(\n  ...     multiRequest))\n  >>> multiWidget.name = 'multi.name'\n  >>> multiWidget.value\n  []\n\n  >>> multiWidget.update()\n\n  >>> multiWidget.widgets[0].value\n  u'42'\n\n  >>> multiWidget.widgets[1].value\n  u'43'\n\n  >>> multiWidget.value\n  [u'42', u'43']\n\nMultiWidget also declares the ``allowAdding`` and ``allowRemoving``\nattributes that can be used in browser presentation to control add/remove\nbutton availability. To ease working with common cases, the\n``updateAllowAddRemove`` method provided that will set those attributes\nin respect to field's min_length and max_length, if the field provides\nzope.schema.interfaces.IMinMaxLen interface.\n\nLet's define a field with min and max length constraints and create\na widget for it.\n\n  >>> multiField = zope.schema.List(\n  ...     value_type=zope.schema.Int(),\n  ...     min_length=2,\n  ...     max_length=5)\n\n  >>> request = TestRequest()\n  >>> multiWidget = widget.FieldWidget(multiField, widget.MultiWidget(request))\n\nLets ensure that the minimum number of widgets are created.\n\n  >>> multiWidget.update()\n  >>> len(multiWidget.widgets)\n  2\n\nNow, let's check if the function will do the right thing depending on\nthe value:\n\nNo value:\n\n  >>> multiWidget.updateAllowAddRemove()\n  >>> multiWidget.allowAdding, multiWidget.allowRemoving\n  (True, False)\n\nMinimum length:\n\n  >>> multiWidget.value = [u'3', u'5']\n  >>> multiWidget.updateAllowAddRemove()\n  >>> multiWidget.allowAdding, multiWidget.allowRemoving\n  (True, False)\n\nSome allowed length:\n\n  >>> multiWidget.value = [u'3', u'5', u'8', u'6']\n  >>> multiWidget.updateAllowAddRemove()\n  >>> multiWidget.allowAdding, multiWidget.allowRemoving\n  (True, True)\n\nMaximum length:\n\n  >>> multiWidget.value = [u'3', u'5', u'8', u'6', u'42']\n  >>> multiWidget.updateAllowAddRemove()\n  >>> multiWidget.allowAdding, multiWidget.allowRemoving\n  (False, True)\n\nOver maximum length:\n\n  >>> multiWidget.value = [u'3', u'5', u'8', u'6', u'42', u'45']\n  >>> multiWidget.updateAllowAddRemove()\n  >>> multiWidget.allowAdding, multiWidget.allowRemoving\n  (False, True)\n\nI know a guy who once switched widget mode in the middle. All simple widgets\nare easy to hack, but multiWidget needs to update all subwidgets:\n\n  >>> [w.mode for w in multiWidget.widgets]\n  ['input', 'input', 'input', 'input', 'input', 'input']\n\nSwitch the multiWidget mode:\n\n  >>> multiWidget.mode = interfaces.DISPLAY_MODE\n\nYes, all subwidgets switch mode:\n\n  >>> [w.mode for w in multiWidget.widgets]\n  ['display', 'display', 'display', 'display', 'display', 'display']\n\nThe json data representing the multi widget:\n  >>> from pprint import pprint\n  >>> pprint(multiWidget.json_data())\n  {'error': '',\n   'id': '',\n   'label': '',\n   'mode': 'display',\n   'name': '',\n   'required': True,\n   'type': 'multi',\n   'value': ['3', '5', '8', '6', '42', '45'],\n   'widgets': [{'error': '',\n                'id': '-0',\n                'label': '',\n                'mode': 'display',\n                'name': '.0',\n                'required': True,\n                'type': 'text',\n                'value': '3'},\n               {'error': '',\n                'id': '-1',\n                'label': '',\n                'mode': 'display',\n                'name': '.1',\n                'required': True,\n                'type': 'text',\n                'value': '5'},\n               {'error': '',\n                'id': '-2',\n                'label': '',\n                'mode': 'display',\n                'name': '.2',\n                'required': True,\n                'type': 'text',\n                'value': '8'},\n               {'error': '',\n                'id': '-3',\n                'label': '',\n                'mode': 'display',\n                'name': '.3',\n                'required': True,\n                'type': 'text',\n                'value': '6'},\n               {'error': '',\n                'id': '-4',\n                'label': '',\n                'mode': 'display',\n                'name': '.4',\n                'required': True,\n                'type': 'text',\n                'value': '42'},\n               {'error': '',\n                'id': '-5',\n                'label': '',\n                'mode': 'display',\n                'name': '.5',\n                'required': True,\n                'type': 'text',\n                'value': '45'}]}\n\n\n\nMulti Dict Widget\n-----------------\n\nWe can also use a multiWidget in Dict mode by just using a field which a Dict:\n\n  >>> multiField = zope.schema.Dict(\n  ...     key_type=zope.schema.Int(),\n  ...     value_type=zope.schema.Int(default=42))\n  >>> multiWidget.field = multiField\n  >>> multiWidget.name = 'multi.name'\n\nNow if we set the value to a list we get an error:\n\n  >>> multiWidget.value = [u'3', u'5', u'8', u'6', u'42', u'45']\n  Traceback (most recent call last):\n  ...\n  ValueError: need more than 1 value to unpack\n\nbut a dictionary is good.\n\n  >>> multiWidget.value = [(u'1', u'3'), (u'2', u'5'), (u'3', u'8'), (u'4', u'6'), (u'5', u'42'), (u'6', u'45')]\n\nand our requests now have to include keys as well as values\n\n  >>> multiWidget.request = TestRequest(form={'multi.name.count':'2',\n  ...                                         'multi.name.key.0':u'1',\n  ...                                         'multi.name.0':u'42',\n  ...                                         'multi.name.key.1':u'2',\n  ...                                         'multi.name.1':u'43'})\n  >>> multiWidget.extract()\n  [(u'1', u'42'), (u'2', u'43')]\n\nLet's define a field with min and max length constraints and create\na widget for it.\n\n  >>> multiField = zope.schema.Dict(\n  ...     key_type=zope.schema.Int(),\n  ...     value_type=zope.schema.Int(default=42),\n  ...     min_length=2,\n  ...     max_length=5)\n\n\n  >>> request = TestRequest()\n  >>> multiWidget = widget.FieldWidget(multiField, widget.MultiWidget(request))\n\nLets ensure that the minimum number of widgets are created.\n\n  >>> multiWidget.update()\n  >>> len(multiWidget.widgets)\n  2\n\nWe can add new items\n\n  >>> multiWidget.appendAddingWidget()\n  >>> multiWidget.appendAddingWidget()\n\n  >>> multiWidget.update()\n  >>> len(multiWidget.widgets)\n  4\n\nThe json data representing the Multi Dict Widget is the same as the Multi widget:\n\nWidget Events\n-------------\n\nWidget-system interaction can be very rich and wants to be extended in\nunexpected ways. Thus there exists a generic widget event that can be used by\nother code.\n\n  >>> event = widget.WidgetEvent(ageWidget)\n  >>> event\n  <WidgetEvent <Widget 'age'>>\n\nThese events provide the ``IWidgetEvent`` interface:\n\n  >>> interfaces.IWidgetEvent.providedBy(event)\n  True\n\nThere exists a special event that can be send out after a widget has been\nupdated, ...\n\n  >>> afterUpdate = widget.AfterWidgetUpdateEvent(ageWidget)\n  >>> afterUpdate\n  <AfterWidgetUpdateEvent <Widget 'age'>>\n\nwhich provides another special interface:\n\n  >>> interfaces.IAfterWidgetUpdateEvent.providedBy(afterUpdate)\n  True\n\nThis event should be used by widget-managing components and is not created and\nsent out internally by the widget's ``update()`` method. The event was\ndesigned to provide an additional hook between updating the widget and\nrendering it.\n\n\nCleanup\n-------\n\nLet's not leave temporary files lying around\n\n  >>> import os\n  >>> os.remove(textWidgetTemplate)\n\n=================\nContent Providers\n=================\n\nWe want to mix fields and content providers.\n\nThis allow to enrich the form by interlacing html snippets produced by content\nproviders.\n\nFor instance, we might want to render the table of results in a search form.\n\nWe might also need to render HTML close to a widget as a handle used when\nimproving UI with Ajax.\n\nAdding HTML outside the widgets avoids the systematic need of\nsubclassing or changing the full widget rendering.\n\nTest setup\n----------\nBefore we can use a widget manager, the ``IFieldWidget`` adapter\nhas to be registered for the ``ITextLine`` field::\n\n  >>> import zope.component\n  >>> import zope.interface\n  >>> from z3c.form import interfaces, widget\n  >>> from z3c.form.browser import text\n  >>> from z3c.form.testing import TestRequest\n\n  >>> @zope.component.adapter(zope.schema.TextLine, TestRequest)\n  ... @zope.interface.implementer(interfaces.IFieldWidget)\n  ... def TextFieldWidget(field, request):\n  ...     return widget.FieldWidget(field, text.TextWidget(request))\n\n  >>> zope.component.provideAdapter(TextFieldWidget)\n\n  >>> from z3c.form import converter\n  >>> zope.component.provideAdapter(converter.FieldDataConverter)\n  >>> zope.component.provideAdapter(converter.FieldWidgetDataConverter)\n\nWe define a simple test schema with fields::\n\n  >>> import zope.interface\n  >>> import zope.schema\n\n  >>> class IPerson(zope.interface.Interface):\n  ...\n  ...     id = zope.schema.TextLine(\n  ...         title=u'ID',\n  ...         description=u\"The person's ID.\",\n  ...         required=True)\n  ...\n  ...     fullname = zope.schema.TextLine(\n  ...         title=u'FullName',\n  ...         description=u\"The person's name.\",\n  ...         required=True)\n  ...\n\nA class that implements the schema::\n\n  >>> class Person(object):\n  ...    id = 'james'\n  ...    fullname = 'James Bond'\n\nThe usual request instance::\n\n  >>> request = TestRequest()\n\nWe want to insert a content provider in between fields.\nWe define a test content provider that renders extra help text::\n\n  >>> from zope.publisher.browser import BrowserView\n  >>> from zope.contentprovider.interfaces import IContentProvider\n  >>> class ExtendedHelp(BrowserView):\n  ...   def __init__(self, context, request, view):\n  ...       super(ExtendedHelp, self).__init__(context, request)\n  ...       self.__parent__ = view\n  ...\n  ...   def update(self):\n  ...       self.person = self.context.id\n  ...\n  ...   def render(self):\n  ...       return '<div class=\"ex-help\">Help about person %s</div>' % self.person\n\nForm definition\n---------------\n\nThe meat of the tests begins here.\n\nWe define a form as usual by inheriting from ``form.Form``::\n\n  >>> from z3c.form import field, form\n  >>> from zope.interface import implementer\n\nTo enable content providers, the form class must :\n\n  1. implement ``IFieldsAndContentProvidersForm``\n  2. have a ``contentProviders`` attribute that is\n     an instance of the ``ContentProviders`` class.\n\n::\n\n  >>> from z3c.form.interfaces import IFieldsAndContentProvidersForm\n  >>> from z3c.form.contentprovider import ContentProviders\n\nContent provider assignment\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nContent providers classes (factories) can be assigned directly to the\n``ContentProviders`` container::\n\n  >>> @implementer(IFieldsAndContentProvidersForm)\n  ... class PersonForm(form.Form):\n  ...     fields = field.Fields(IPerson)\n  ...     ignoreContext = True\n  ...     contentProviders = ContentProviders()\n  ...     contentProviders['longHelp'] = ExtendedHelp\n  ...     contentProviders['longHelp'].position = 1\n\nLet's instantiate content and form instances::\n\n  >>> person = Person()\n  >>> personForm = PersonForm(person, request)\n\nOnce the widget manager has been updated, it holds the content provider::\n\n  >>> from z3c.form.contentprovider import FieldWidgetsAndProviders\n  >>> manager = FieldWidgetsAndProviders(personForm, request, person)\n  >>> manager.ignoreContext = True\n  >>> manager.update()\n  >>> widgets = manager._data\n  >>> ids = sorted(widgets.keys())\n  >>> ids\n  ['fullname', 'id', 'longHelp']\n  >>> widgets['longHelp']\n  <ExtendedHelp object at ...>\n  >>> widgets['id']\n  <TextWidget 'form.widgets.id'>\n  >>> widgets['fullname']\n  <TextWidget 'form.widgets.fullname'>\n  >>> manager.get('longHelp').render()\n  '<div class=\"ex-help\">Help about person james</div>'\n\nContent provider lookup\n~~~~~~~~~~~~~~~~~~~~~~~\n\nForms can also refer by name to content providers.\n\nLet's register a content provider by name as usual::\n\n  >>> from zope.component import provideAdapter\n  >>> from zope.contentprovider.interfaces import IContentProvider\n  >>> from z3c.form.interfaces import IFormLayer\n  >>> provideAdapter(ExtendedHelp,\n  ...                (zope.interface.Interface,\n  ...                 IFormLayer,\n  ...                 zope.interface.Interface),\n  ...                provides=IContentProvider, name='longHelp')\n\nLet the form refer to it::\n\n  >>> @implementer(IFieldsAndContentProvidersForm)\n  ... class LookupPersonForm(form.Form):\n  ...     prefix = 'form.'\n  ...     fields = field.Fields(IPerson)\n  ...     ignoreContext = True\n  ...     contentProviders = ContentProviders(['longHelp'])\n  ...     contentProviders['longHelp'].position = 2\n\n  >>> lookupForm = LookupPersonForm(person, request)\n\nAfter update, the widget manager refers to the content provider::\n\n  >>> from z3c.form.contentprovider import FieldWidgetsAndProviders\n  >>> manager = FieldWidgetsAndProviders(lookupForm, request, person)\n  >>> manager.ignoreContext = True\n  >>> manager.update()\n  >>> widgets = manager._data\n  >>> ids = sorted(widgets.keys())\n  >>> ids\n  ['fullname', 'id', 'longHelp']\n  >>> widgets['longHelp']\n  <ExtendedHelp object at ...>\n  >>> widgets['id']\n  <TextWidget 'form.widgets.id'>\n  >>> widgets['fullname']\n  <TextWidget 'form.widgets.fullname'>\n  >>> manager.get('longHelp').render()\n  '<div class=\"ex-help\">Help about person james</div>'\n\nProviders position\n~~~~~~~~~~~~~~~~~~\n\nUntil here, we have defined position for content providers without explaining\nhow it is used.\n\nA position needs to be defined for each provider. Let's forget to define a\nposition::\n\n  >>> @implementer(IFieldsAndContentProvidersForm)\n  ... class UndefinedPositionForm(form.Form):\n  ...     prefix = 'form.'\n  ...     fields = field.Fields(IPerson)\n  ...     ignoreContext = True\n  ...     contentProviders = ContentProviders(['longHelp'])\n\n  >>> form = UndefinedPositionForm(person, request)\n  >>> manager = FieldWidgetsAndProviders(form, request, person)\n  >>> manager.ignoreContext = True\n\nWhen updating the widget manager, we get an exception::\n\n  >>> manager.update()\n  Traceback (most recent call last):\n  ...\n  ValueError: Position of the following content provider should be an integer: 'longHelp'.\n\nLet's check positioning of content providers::\n\n  >>> LookupPersonForm.contentProviders['longHelp'].position = 0\n  >>> manager = FieldWidgetsAndProviders(lookupForm, request, person)\n  >>> manager.ignoreContext = True\n  >>> manager.update()\n  >>> manager.values()\n  [<ExtendedHelp object at ...>, <TextWidget 'form.widgets.id'>, <TextWidget 'form.widgets.fullname'>]\n\n  >>> LookupPersonForm.contentProviders['longHelp'].position = 1\n  >>> manager = FieldWidgetsAndProviders(lookupForm, request, person)\n  >>> manager.ignoreContext = True\n  >>> manager.update()\n  >>> manager.values()\n  [<TextWidget 'form.widgets.id'>, <ExtendedHelp object at ...>, <TextWidget 'form.widgets.fullname'>]\n\n  >>> LookupPersonForm.contentProviders['longHelp'].position = 2\n  >>> manager = FieldWidgetsAndProviders(lookupForm, request, person)\n  >>> manager.ignoreContext = True\n  >>> manager.update()\n  >>> manager.values()\n  [<TextWidget 'form.widgets.id'>, <TextWidget 'form.widgets.fullname'>, <ExtendedHelp object at ...>]\n\nUsing value larger than sequence length implies end of sequence::\n\n  >>> LookupPersonForm.contentProviders['longHelp'].position = 3\n  >>> manager = FieldWidgetsAndProviders(lookupForm, request, person)\n  >>> manager.ignoreContext = True\n  >>> manager.update()\n  >>> manager.values()\n  [<TextWidget 'form.widgets.id'>, <TextWidget 'form.widgets.fullname'>, <ExtendedHelp object at ...>]\n\nA negative value is interpreted same as ``insert`` method of Python lists::\n\n  >>> LookupPersonForm.contentProviders['longHelp'].position = -1\n  >>> manager = FieldWidgetsAndProviders(lookupForm, request, person)\n  >>> manager.ignoreContext = True\n  >>> manager.update()\n  >>> manager.values()\n  [<TextWidget 'form.widgets.id'>, <ExtendedHelp object at ...>, <TextWidget 'form.widgets.fullname'>]\n\nRendering the form\n------------------\n\nOnce the form has been updated, it can be rendered.\n\nSince we have not assigned a template yet, we have to do it now.\nWe have a small template as part of this example::\n\n  >>> import os\n  >>> from zope.browserpage.viewpagetemplatefile import ViewPageTemplateFile\n  >>> from zope.browserpage.viewpagetemplatefile import BoundPageTemplate\n  >>> from z3c.form import tests\n  >>> def personTemplate(form):\n  ...     form.template = BoundPageTemplate(\n  ...         ViewPageTemplateFile(\n  ...             'simple_edit_with_providers.pt',\n  ...             os.path.dirname(tests.__file__)), form)\n  >>> personTemplate(personForm)\n\nTo enable form updating, all widget adapters must be registered::\n\n  >>> from z3c.form.testing import setupFormDefaults\n  >>> setupFormDefaults()\n\n``FieldWidgetsAndProviders`` is registered as widget manager for\n``IFieldsAndContentProvidersForm``::\n\n  >>> personForm.update()\n  >>> personForm.widgets\n  <z3c.form.contentprovider.FieldWidgetsAndProviders object at ...>\n\nLet's render the form::\n\n  >>> print(personForm.render())\n  <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n  <html xmlns=\"http://www.w3.org/1999/xhtml\">\n    <body>\n      <form action=\".\">\n        <div class=\"row\">\n          <label for=\"form-widgets-id\">ID</label>\n          <input id=\"form-widgets-id\" name=\"form.widgets.id\"\n                 class=\"text-widget required textline-field\"\n                 value=\"\" type=\"text\" />\n        </div>\n        <div class=\"row\">\n          <div class=\"ex-help\">Help about person james</div>\n        </div>\n        <div class=\"row\">\n          <label for=\"form-widgets-fullname\">FullName</label>\n          <input id=\"form-widgets-fullname\"\n                 name=\"form.widgets.fullname\"\n                 class=\"text-widget required textline-field\"\n                 value=\"\" type=\"text\" />\n        </div>\n      </form>\n    </body>\n  </html>\n\n===============\nAction Managers\n===============\n\nAction managers are components that manage all actions that can be taken\nwithin a view, usually a form. They are also responsible for executing actions\nwhen asked to do so.\n\nCreating an action manager\n--------------------------\n\nAn action manager is a form-related adapter that has the following\ndiscriminator: form, request, and content. While there is a base\nimplementation for an action manager, the ``action`` module does not provide a\nfull implementation.\n\nSo we first have to build a simple implementation based on the ``Actions``\nmanager base class which allows us to add actions. Note that the following\nimplementation is for demonstration purposes. If you want to see a real action\nmanager implementation, then have a look at ``ButtonActions``. Let's now\nimplement our simple action manager:\n\n  >>> from z3c.form import action\n  >>> class SimpleActions(action.Actions):\n  ...     \"\"\"Simple sample.\"\"\"\n  ...\n  ...     def append(self, name, action):\n  ...         \"\"\"See z3c.form.interfaces.IActions.\"\"\"\n  ...         if not name in self:\n  ...             self._data_keys.append(name)\n  ...         self._data_values.append(action)\n  ...         self._data[name] = action\n\nBefore we can initialise the action manager, we have to create instances for\nour three discriminators, just enough to get it working:\n\n  >>> import zope.interface\n  >>> from z3c.form import interfaces\n  >>> @zope.interface.implementer(interfaces.IForm)\n  ... class Form(object):\n  ...     pass\n  >>> form = Form()\n\n  >>> @zope.interface.implementer(zope.interface.Interface)\n  ... class Content(object):\n  ...     pass\n  >>> content = Content()\n\n  >>> from z3c.form.testing import TestRequest\n  >>> request = TestRequest()\n\nWe are now ready to create the action manager, which is a simple\ntriple-adapter:\n\n  >>> manager = SimpleActions(form, request, content)\n  >>> manager\n  <SimpleActions None>\n\nAs we can see in the manager representation above, the name of the manager is\n``None``, since we have not specified one:\n\n  >>> manager.__name__ = 'example'\n  >>> manager\n  <SimpleActions 'example'>\n\n\nManaging and Accessing Actions\n------------------------------\n\nInitially there are no actions in the manager:\n\n  >>> manager.keys()\n  []\n\nOur simple implementation of has an additional ``append()`` method, which we\nwill use to add actions:\n\n  >>> apply = action.Action(request, u'Apply')\n  >>> manager.append(apply.name, apply)\n\nThe action is added immediately:\n\n  >>> manager.keys()\n  ['apply']\n\nHowever, you should not rely on it being added, and always update the manager\nonce all actions were defined:\n\n  >>> manager.update()\n\nNote: If the title of the action is a more complex unicode string and no name\nis specified for the action, then a hexadecimal name is created from the\ntitle:\n\n  >>> action.Action(request, u'Apply Now!').name\n  '4170706c79204e6f7721'\n\nSince the action manager is an enumerable mapping, ...\n\n  >>> from zope.interface.common.mapping import IEnumerableMapping\n  >>> IEnumerableMapping.providedBy(manager)\n  True\n\nthere are several API methods available:\n\n  >>> manager['apply']\n  <Action 'apply' u'Apply'>\n  >>> manager['foo']\n  Traceback (most recent call last):\n  ...\n  KeyError: 'foo'\n\n  >>> manager.get('apply')\n  <Action 'apply' u'Apply'>\n  >>> manager.get('foo', 'default')\n  'default'\n\n  >>> 'apply' in manager\n  True\n  >>> 'foo' in manager\n  False\n\n  >>> manager.values()\n  [<Action 'apply' u'Apply'>]\n\n  >>> manager.items()\n  [('apply', <Action 'apply' u'Apply'>)]\n\n  >>> len(manager)\n  1\n\n\nExecuting actions\n-----------------\n\nWhen an action is executed, an execution adapter is looked up. If there is no\nadapter, nothing happens. So let's create a request that submits the apply\nbutton:\n\n  >>> request = TestRequest(form={'apply': 'Apply'})\n  >>> manager = SimpleActions(form, request, content)\n\nWe also want to have two buttons in this case, so that we can ensure that only\none is executed:\n\n  >>> apply = action.Action(request, u'Apply')\n  >>> manager.append(apply.name, apply)\n\n  >>> cancel = action.Action(request, u'Cancel')\n  >>> manager.append(cancel.name, cancel)\n  >>> manager.update()\n\nNow that the manager is updated, we can ask it for the \"executed\" actions:\n\n  >>> manager.executedActions\n  [<Action 'apply' u'Apply'>]\n\nExecuting the actions does nothing, because there are no handlers yet:\n\n  >>> manager.execute()\n\n\nLet's now register an action handler that listens to the \"Apply\" action. An\naction handler has four discriminators: form, request, content, and\naction. All those objects are available to the handler under those names. When\nusing the base action handler from the ``action`` module, ``__call__()`` is\nthe only method that needs to be implemented:\n\n  >>> from z3c.form import util\n\n  >>> class SimpleActionHandler(action.ActionHandlerBase):\n  ...     zope.component.adapts(\n  ...         None, TestRequest, None, util.getSpecification(apply))\n  ...     def __call__(self):\n  ...         print('successfully applied')\n\n  >>> zope.component.provideAdapter(SimpleActionHandler)\n\nAs you can see, we registered the action specifically for the apply\naction. Now, executing the actions calls this handler:\n\n  >>> manager.execute()\n  successfully applied\n\nOf course it only works for the \"Apply\" action and not \"\"Cancel\":\n\n  >>> request = TestRequest(form={'cancel': 'Cancel'})\n  >>> manager.request = apply.request = cancel.request = request\n  >>> manager.execute()\n\nFurther, when a handler is successfully executed, an event is sent out, so\nlet's register an event handler:\n\n  >>> eventlog = []\n  >>> @zope.component.adapter(interfaces.IActionEvent)\n  ... def handleEvent(event):\n  ...     eventlog.append(event)\n\n  >>> zope.component.provideHandler(handleEvent)\n\nLet's now execute the \"Apply\" action again:\n\n  >>> request = TestRequest(form={'apply': 'Apply'})\n  >>> manager.request = apply.request = cancel.request = request\n  >>> manager.execute()\n  successfully applied\n\n  >>> eventlog[-1]\n  <ActionSuccessful for <Action 'apply' u'Apply'>>\n\nAction handlers, however, can also raise action errors. These action errors\nare caught and an event is created notifying the system of the problem. The\nerror is not further propagated. Other errors are not handled by the system to\navoid hiding real failures of the code.\n\nLet's see how action errors can be used by implementing a handler for the\ncancel action:\n\n  >>> class ErrorActionHandler(action.ActionHandlerBase):\n  ...     zope.component.adapts(\n  ...         None, TestRequest, None, util.getSpecification(cancel))\n  ...     def __call__(self):\n  ...         raise interfaces.ActionExecutionError(\n  ...             zope.interface.Invalid('Something went wrong'))\n\n  >>> zope.component.provideAdapter(ErrorActionHandler)\n\nAs you can see, the action execution error wraps some other execption, in this\ncase a simple invalid error.\n\nExecuting the \"Cancel\" action now produces the action error event:\n\n  >>> request = TestRequest(form={'cancel': 'Cancel'})\n  >>> manager.request = apply.request = cancel.request = request\n  >>> manager.execute()\n\n  >>> eventlog[-1]\n  <ActionErrorOccurred for <Action 'cancel' u'Cancel'>>\n\n  >>> eventlog[-1].error\n  <ActionExecutionError wrapping ...Invalid...>\n\n\n========================\nAttribute Value Adapters\n========================\n\nIn advanced, highly customized projects it is often the case that a property\nwants to be overridden for a particular customer in a particular case. A prime\nexample is the label of a widget. Until this implementation of a form\nframework was written, widgets only could get their label from the field they\nwere representing. Thus, wanting to change the label of a widget meant\nimplementing a custom schema and re-registering the form in question for the\ncustom schema. It is needless to say that this was very annoying.\n\nFor this form framework, we are providing multiple levels of customization. \nThe user has the choice to change the value of an attribute through attribute \nassignment or adapter lookup. The chronological order of an attribute value \nassignment is as follows:\n\n1. During initialization or right thereafter, the attribute value can be set\n   by direct attribute assignment, i.e. ``obj.attr = value``\n\n2. While updating the object, an adapter is looked up for the attribute. If an\n   adapter is found, the attribute value will be overridden. Of course, if the\n   object does not have an ``update()`` method, one can choose another\n   location to do the adapter lookup.\n\n3. After updating, the developer again has the choice to override the attribute\n   allowing granularity above and beyond the adapter.\n\nThe purpose of this module is to implement the availability of an attribute\nvalue using an adapter.\n\n  >>> from z3c.form import value\n\nThe module provides helper functions and classes, to create those adapters\nwith as little code as possible.\n\n\nStatic Value Adapter\n--------------------\n\nTo demonstrate the static value adapter, let's go back to our widget label\nexample. Let's create a couple of simple widgets and forms first:\n\n  >>> class TextWidget(object):\n  ...    label = u'Text'\n  >>> tw = TextWidget()\n\n  >>> class CheckboxWidget(object):\n  ...    label = u'Checkbox'\n  >>> cbw = CheckboxWidget()\n\n  >>> class Form1(object):\n  ...    pass\n  >>> form1 = Form1()\n\n  >>> class Form2(object):\n  ...    pass\n  >>> form2 = Form2()\n\nWe can now create a generic widget property adapter:\n\n  >>> WidgetAttribute = value.StaticValueCreator(\n  ...     discriminators = ('widget', 'view')\n  ...     )\n\nCreating the widget attribute object, using the helper function above, allows\nus to define the discriminators (or the granulatrity) that can be used to\ncontrol a widget attribute by an adapter. In our case this is the widget\nitself and the form/view in which the widget is displayed. In other words, it\nwill be possible to register a widget attribute value specifically for a\nparticular widget, a particular form, or a combination thereof.\n\nLet's now create a label attribute adapter for the text widget, since our\ncustomer does not like the default label:\n\n  >>> TextLabel = WidgetAttribute(u'My Text', widget=TextWidget)\n\nThe first argument of any static attribute value is the value itself, in our\ncase the string \"My Text\". The following keyword arguments are the\ndiscriminators specified in the property factory. Since we only specify the\nwidget, the label will be available to all widgets. But first we have to\nregister the adapter:\n\n  >>> import zope.component\n  >>> zope.component.provideAdapter(TextLabel, name='label')\n\nThe name of the adapter is the attribute name of the widget. Let's now see how\nwe can get the label:\n\n  >>> from z3c.form import interfaces\n  >>> staticValue = zope.component.getMultiAdapter(\n  ...     (tw, form1), interfaces.IValue, name='label')\n  >>> staticValue\n  <StaticValue u'My Text'>\n\nThe resulting value object has one public method ``get()``, which returns the\nactual value:\n\n  >>> staticValue.get()\n  u'My Text'\n\nAs we said before, the value should be available to all forms, ...\n\n  >>> zope.component.getMultiAdapter(\n  ...     (tw, form2), interfaces.IValue, name='label')\n  <StaticValue u'My Text'>\n\n... but only to the ``TextWidget``:\n\n  >>> zope.component.getMultiAdapter(\n  ...     (cbw, form2), interfaces.IValue, name='label')\n  Traceback (most recent call last):\n  ...\n  ComponentLookupError: ((<CheckboxWidget...>, <Form2...>),\n                          <InterfaceClass ...IValue>, 'label')\n\nBy the way, the attribute adapter factory notices, if you specify a\ndiscriminator that was not specified:\n\n  >>> WidgetAttribute(u'My Text', form=Form2)\n  Traceback (most recent call last):\n  ...\n  ValueError: One or more keyword arguments did not match the discriminators.\n\n  >>> WidgetAttribute.discriminators\n  ('widget', 'view')\n\n\nComputed Value Adapter\n----------------------\n\nA second implementation of the value adapter in the evaluated value, where one\ncan specify a function that computes the value to be returned. The only\nargument to the function is the value adapter instance itself, which then\ncontains all the discriminators as specified when creating the generic widget\nattribute factory. Let's take the same use case as before, but generating the\nvalue as follows:\n\n  >>> def getLabelValue(adapter):\n  ...     return adapter.widget.label + ' (1)'\n\nNow we create the value adapter for it:\n\n  >>> WidgetAttribute = value.ComputedValueCreator(\n  ...     discriminators = ('widget', 'view')\n  ...     )\n\n  >>> TextLabel = WidgetAttribute(getLabelValue, widget=TextWidget)\n\nAfter registering the adapter, ...\n\n  >>> zope.component.provideAdapter(TextLabel, name='label')\n\nwe now get the answers:\n\n  >>> from z3c.form import interfaces\n  >>> zope.component.getMultiAdapter(\n  ...     (tw, form1), interfaces.IValue, name='label')\n  <ComputedValue u'Text (1)'>\n\n\n__Note__: The two implementations of the attribute value adapters are not\n          meant to be canonical features that must always be used. The API is\n          kept simple to allow you to quickly implement your own value\n          adapter.\n\n\nAutomatic Interface Assignment\n------------------------------\n\nOftentimes it is desirable to register an attribute value adapter for an\ninstance. A good example is a field, so let's create a small schema:\n\n  >>> import zope.interface\n  >>> import zope.schema\n  >>> class IPerson(zope.interface.Interface):\n  ...     firstName = zope.schema.TextLine(title=u'First Name')\n  ...     lastName = zope.schema.TextLine(title=u'Last Name')\n\nThe customer now requires that the title -- which is the basis of the widget\nlabel for field widgets -- of the last name should be \"Surname\". Until now the\noption was to write a new schema changing the title. With this attribute value\nmodule, as introduced thus far, we would need to provide a special interface\nfor the last name field, since registering a label adapter for all text fields\nwould also change the first name.\n\nBefore demonstrating the solution to this problem, let's first create a field\nattribute value:\n\n  >>> FieldAttribute = value.StaticValueCreator(\n  ...     discriminators = ('field',)\n  ...     )\n\nWe can now create the last name title, changing only the title of the\n``lastName`` field. Instead of passing in an interface of class as the field\ndiscriminator, we pass in the field instance:\n\n  >>> LastNameTitle = FieldAttribute(u'Surname', field=IPerson['lastName'])\n\nThe attribute value factory will automatically detect instances, create an\ninterface on the fly, directly provide it on the field and makes it the\ndiscriminator interface for the adapter registratioon.\n\nSo after registering the adapter, ...\n\n  >>> zope.component.provideAdapter(LastNameTitle, name='title')\n\nthe adapter is only available to the last name field and not the first name:\n\n  >>> zope.component.queryMultiAdapter(\n  ...     (IPerson['lastName'],), interfaces.IValue, name='title')\n  <StaticValue u'Surname'>\n\n  >>> zope.component.queryMultiAdapter(\n  ...     (IPerson['firstName'],), interfaces.IValue, name='title')\n\n=============\nData Managers\n=============\n\nFor the longest time the way widgets retrieved and stored their values on the\nactual content/model was done by binding the field to a context and then\nsetting and getting the attribute from it. This has several distinct design\nshortcomings:\n\n1. The field has too much responsibility by knowing about its implementations.\n\n2. There is no way of redefining the method used to store and access data\n   other than rewriting fields.\n\n3. Finding the right content/model to modify is an implicit policy: Find an\n   adapter for the field's schema and then set the value there.\n\nWhile implementing some real-world projects, we noticed that this approach is\ntoo limiting and we often could not use the form framework when we wanted or\nhad to jump through many hoops to make it work for us. For example, if we want\nto display a form to collect data that does not correspond to a set of content\ncomponents, we were forced to not only write a schema for the form, but also\nimplement that schema as a class. but all we wanted was a dictionary. For\nedit-form like tasks we often also had an initial dictionary, which we just\nwanted modified.\n\nData managers abstract the getting and setting of the data. A data manager is\nresponsible for setting one piece of data in a particular context.\n\n  >>> from z3c.form import datamanager\n\n\nAttribute Field Manager\n-----------------------\n\nThe most common case, of course, is the management of class attributes through\nfields. In this case, the data manager needs to know about the context and the\nfield it is managing the data for.\n\n  >>> import zope.interface\n  >>> import zope.schema\n  >>> class IPerson(zope.interface.Interface):\n  ...     name = zope.schema.TextLine(\n  ...         title=u'Name',\n  ...         default=u'<no name>')\n  ...     phone = zope.schema.TextLine(\n  ...         title=u'Phone')\n\n  >>> @zope.interface.implementer(IPerson)\n  ... class Person(object):\n  ...     name = u''\n  ...     def __init__(self, name):\n  ...         self.name = name\n\n  >>> stephan = Person(u'Stephan Richter')\n\nWe can now instantiate the data manager for Stephan's name:\n\n  >>> nameDm = datamanager.AttributeField(stephan, IPerson['name'])\n\nThe data manager consists of a few simple methods to accomplish its\npurpose. Getting the value is done using the ``get()`` or ``query()`` method:\n\n  >>> nameDm.get()\n  u'Stephan Richter'\n\n  >>> nameDm.query()\n  u'Stephan Richter'\n\nThe value can be set using ``set()``:\n\n  >>> nameDm.set(u'Stephan \"Caveman\" Richter')\n\n  >>> nameDm.get()\n  u'Stephan \"Caveman\" Richter'\n  >>> stephan.name\n  u'Stephan \"Caveman\" Richter'\n\nIf an attribute is not available, ``get()`` fails and ``query()`` returns a\ndefault value:\n\n  >>> phoneDm = datamanager.AttributeField(stephan, IPerson['phone'])\n\n  >>> phoneDm.get()\n  Traceback (most recent call last):\n  ...\n  AttributeError: 'Person' object has no attribute 'phone'\n\n  >>> phoneDm.query()\n  <NO_VALUE>\n  >>> phoneDm.query('nothing')\n  'nothing'\n\nA final feature that is supported by the data manager is the check whether a\nvalue can be accessed and written. When the context is not security proxied,\nboth, accessing and writing, is allowed:\n\n  >>> nameDm.canAccess()\n  True\n  >>> nameDm.canWrite()\n  True\n\nTo demonstrate the behavior for a security-proxied component, we first have to\nprovide security declarations for our person:\n\n  >>> from zope.security.management import endInteraction\n  >>> from zope.security.management import newInteraction\n  >>> from zope.security.management import setSecurityPolicy\n  >>> import z3c.form.testing\n  >>> endInteraction()\n  >>> newPolicy = z3c.form.testing.SimpleSecurityPolicy()\n  >>> newPolicy.allowedPermissions = ('View', 'Edit')\n  >>> oldpolicy = setSecurityPolicy(newPolicy)\n  >>> newInteraction()\n\n  >>> from zope.security.checker import Checker\n  >>> from zope.security.checker import defineChecker\n  >>> personChecker = Checker({'name':'View', 'name':'Edit'})\n  >>> defineChecker(Person, personChecker)\n\nWe now need to wrap stephan into a proxy:\n\n  >>> protectedStephan = zope.security.checker.ProxyFactory(stephan)\n\nSince we are not logged in as anyone, we cannot acces or write the value:\n\n  >>> nameDm = datamanager.AttributeField(protectedStephan, IPerson['name'])\n\n  >>> nameDm.canAccess()\n  False\n  >>> nameDm.canWrite()\n  False\n\nClearly, this also means that ``get()`` and ``set()`` are also shut off:\n\n  >>> nameDm.get()\n  Traceback (most recent call last):\n  ...\n  Unauthorized: (<Person object at ...>, 'name', 'Edit')\n\n  >>> nameDm.set(u'Stephan')\n  Traceback (most recent call last):\n  ...\n  ForbiddenAttribute: ('name', <Person object at ...>)\n\nNow we have to setup the security system and \"log in\" as a user:\n\n  >>> newPolicy.allowedPermissions = ('View', 'Edit')\n  >>> newPolicy.loggedIn = True\n\nThe created principal, with which we are logged in now, can only access the\nattribute:\n\n  >>> nameDm.canAccess()\n  True\n  >>> nameDm.canWrite()\n  False\n\nThus only the ``get()`` method is allowed:\n\n  >>> nameDm.get()\n  u'Stephan \"Caveman\" Richter'\n\n  >>> nameDm.set(u'Stephan')\n  Traceback (most recent call last):\n  ...\n  ForbiddenAttribute: ('name', <Person object at ...>)\n\nIf field's schema is not directly provided by the context, the datamanager\nwill attempt to find an adapter. Let's give the person an address for example:\n\n  >>> class IAddress(zope.interface.Interface):\n  ...     city = zope.schema.TextLine(title=u'City')\n\n  >>> @zope.interface.implementer(IAddress)\n  ... class Address(object):\n  ...     zope.component.adapts(IPerson)\n  ...     def __init__(self, person):\n  ...         self.person = person\n  ...     @property\n  ...     def city(self):\n  ...         return getattr(self.person, '_city', None)\n  ...     @city.setter\n  ...     def city(self, value):\n  ...         self.person._city = value\n\n  >>> zope.component.provideAdapter(Address)\n\nNow we can create a data manager for the city attribute:\n\n  >>> cityDm = datamanager.AttributeField(stephan, IAddress['city'])\n\nWe can access and write to the city attribute:\n\n  >>> cityDm.canAccess()\n  True\n  >>> cityDm.canWrite()\n  True\n\nInitially there is no value, but of course we can create one:\n\n  >>> cityDm.get()\n\n  >>> cityDm.set(u'Maynard')\n  >>> cityDm.get()\n  u'Maynard'\n\nThe value can be accessed through the adapter itself as well:\n\n  >>> IAddress(stephan).city\n  u'Maynard'\n\nWhile we think that implicitly looking up an adapter is not the cleanest\nsolution, it allows us to mimic the behavior of ``zope.formlib``. We think\nthat we will eventually provide alternative ways to accomplish the same in a\nmore explicit way.\n\nIf we try to set a value that is read-only, a type error is raised:\n\n  >>> readOnlyName = zope.schema.TextLine(\n  ...     __name__='name',\n  ...     readonly=True)\n\n  >>> nameDm = datamanager.AttributeField(stephan, readOnlyName)\n  >>> nameDm.set(u'Stephan')\n  Traceback (most recent call last):\n  ...\n  TypeError: Can't set values on read-only fields\n             (name=name, class=__builtin__.Person)\n\nFinally, we instantiate the data manager with a ``zope.schema``\nfield. And we can access the different methods like before.\n\n  >>> nameDm = datamanager.AttributeField(\n  ...    stephan, zope.schema.TextLine(__name__ = 'name'))\n  >>> nameDm.canAccess()\n  True\n  >>> nameDm.canWrite()\n  True\n\n  >>> nameDm.get()\n  u'Stephan \"Caveman\" Richter'\n  >>> nameDm.query()\n  u'Stephan \"Caveman\" Richter'\n\n  >>> nameDm.set(u'Stephan Richter')\n  >>> nameDm.get()\n  u'Stephan Richter'\n\nDictionary Field Manager\n------------------------\n\nAnother implementation of the data manager interface is provided by the\ndictionary field manager, which does not expect an instance with attributes as\nits context, but a dictionary. It still uses a field to determine the key to\nmodify.\n\n  >>> personDict = {}\n  >>> nameDm = datamanager.DictionaryField(personDict, IPerson['name'])\n\nThe datamanager can really only deal with dictionaries and mapping types:\n\n  >>> import zope.interface.common.mapping\n  >>> import persistent.mapping\n  >>> import persistent.dict\n  >>> @zope.interface.implementer(zope.interface.common.mapping.IMapping)\n  ... class MyMapping(object):\n  ...     pass\n  >>> datamanager.DictionaryField(MyMapping(), IPerson['name'])\n  <z3c.form.datamanager.DictionaryField object at ...>\n  >>> datamanager.DictionaryField(persistent.mapping.PersistentMapping(),\n  ...     IPerson['name'])\n  <z3c.form.datamanager.DictionaryField object at ...>\n  >>> datamanager.DictionaryField(persistent.dict.PersistentDict(),\n  ...     IPerson['name'])\n  <z3c.form.datamanager.DictionaryField object at ...>\n\n  >>> datamanager.DictionaryField([], IPerson['name'])\n  Traceback (most recent call last):\n  ...\n  ValueError: Data are not a dictionary: <type 'list'>\n\nLet's now access the name:\n\n  >>> nameDm.get()\n  Traceback (most recent call last):\n  ...\n  AttributeError\n\n  >>> nameDm.query()\n  <NO_VALUE>\n\nInitially we get the default value (as specified in the field), since the\nperson dictionariy has no entry. If no default value has been specified in the\nfield, the missing value is returned.\n\nNow we set a value and it should be available:\n\n  >>> nameDm.set(u'Roger Ineichen')\n\n  >>> nameDm.get()\n  u'Roger Ineichen'\n  >>> personDict\n  {'name': u'Roger Ineichen'}\n\nSince this dictionary is not security proxied, any field can be accessed and\nwritten to:\n\n  >>> nameDm.canAccess()\n  True\n  >>> nameDm.canWrite()\n  True\n\nAs with the attribute data manager, readonly fields cannot be set:\n\n  >>> nameDm = datamanager.DictionaryField(personDict, readOnlyName)\n  >>> nameDm.set(u'Stephan')\n  Traceback (most recent call last):\n  ...\n  TypeError: Can't set values on read-only fields name=name\n\n\nCleanup\n-------\n\nWe clean up the changes we made in these examples:\n\n  >>> endInteraction()\n  >>> ignore = setSecurityPolicy(oldpolicy)\n\n==============\nData Converter\n==============\n\nThe data converter is the component that converts an internal data value as\ndescribed by a field to an external value as required by a widget and vice\nversa. The goal of the converter is to avoid field and widget proliferation\nsolely to handle different types of values. The purpose of fields is to\ndescribe internal data types and structures and that of widgets to provide one\nparticular mean of input.\n\nThe only two discriminators for the converter are the field and the widget.\n\nLet's look at the ``Int`` field to ``TextWidget`` converter as an example:\n\n  >>> import zope.schema\n  >>> age = zope.schema.Int(\n  ...     __name__='age',\n  ...     title=u'Age',\n  ...     min=0)\n\n  >>> from z3c.form.testing import TestRequest\n  >>> from z3c.form import widget\n  >>> text = widget.Widget(TestRequest())\n\n  >>> from z3c.form import converter\n  >>> conv = converter.FieldDataConverter(age, text)\n\nThe field data converter is a generic data converter that can be used for all\nfields that implement ``IFromUnicode``. If, for example, a ``Date`` field\n-- which does not provide ``IFromUnicode`` -- is passed in, then a type error\nis raised:\n\n  >>> converter.FieldDataConverter(zope.schema.Date(), text)\n  Traceback (most recent call last):\n  ...\n  TypeError: Field of type ``Date`` must provide ``IFromUnicode``.\n\nA named field will tell it's name:\n\n  >>> converter.FieldDataConverter(zope.schema.Date(__name__=\"foobar\"), text)\n  Traceback (most recent call last):\n  ...\n  TypeError: Field ``foobar`` of type ``Date`` must provide ``IFromUnicode``.\n\nHowever, the ``FieldDataConverter`` is registered for ``IField``, since many\nfields (like ``Decimal``) for which we want to create custom converters\nprovide ``IFromUnicode`` more specifically than their characterizing interface\n(like ``IDecimal``).\n\nThe converter can now convert any integer to a the value the test widget deals\nwith, which is an ASCII string:\n\n  >>> conv.toWidgetValue(34)\n  u'34'\n\nWhen the missing value is passed in, an empty string should be returned:\n\n  >>> conv.toWidgetValue(age.missing_value)\n  u''\n\nOf course, values can also be converted from a widget value to field value:\n\n  >>> conv.toFieldValue('34')\n  34\n\nAn empty string means simply that the value is missing and the missing value\nof the field is returned:\n\n  >>> age.missing_value = -1\n  >>> conv.toFieldValue('')\n  -1\n\nOf course, trying to convert a non-integer string representation fails in a\nconversion error:\n\n  >>> conv.toFieldValue('3.4')\n  Traceback (most recent call last):\n  ...\n  ValueError: invalid literal for int(): 3.4\n\nAlso, the conversion to the field value also validates the data; in this case\nnegative values are not allowed:\n\n  >>> conv.toFieldValue('-34')\n  Traceback (most recent call last):\n  ...\n  TooSmall: (-34, 0)\n\nThat's pretty much the entire API. When dealing with converters within the\ncomponent architecture, everything is a little bit simpler. So let's register\nthe converter:\n\n  >>> import zope.component\n  >>> zope.component.provideAdapter(converter.FieldDataConverter)\n\nOnce we ensure that our widget is a text widget, we can lookup the adapter:\n\n  >>> import zope.interface\n  >>> from z3c.form import interfaces\n  >>> zope.interface.alsoProvides(text, interfaces.ITextWidget)\n\n  >>> zope.component.getMultiAdapter((age, text), interfaces.IDataConverter)\n  <FieldDataConverter converts from Int to Widget>\n\nFor field-widgets there is a helper adapter that makes the lookup even\nsimpler:\n\n  >>> zope.component.provideAdapter(converter.FieldWidgetDataConverter)\n\nAfter converting our simple widget to a field widget,\n\n  >>> fieldtext = widget.FieldWidget(age, text)\n\nwe can now lookup the data converter adapter just by the field widget itself:\n\n  >>> interfaces.IDataConverter(fieldtext)\n  <FieldDataConverter converts from Int to Widget>\n\n\nNumber Data Converters\n----------------------\n\nAs hinted on above, the package provides a specific data converter for each of\nthe three main numerical types: ``int``, ``float``, ``Decimal``. Specifically,\nthose data converters support full localization of the number formatting.\n\n  >>> age = zope.schema.Int()\n  >>> intdc = converter.IntegerDataConverter(age, text)\n  >>> intdc\n  <IntegerDataConverter converts from Int to Widget>\n\nSince the age is so small, the formatting is trivial:\n\n  >>> intdc.toWidgetValue(34)\n  u'34'\n\nBut if we increase the number, the grouping seprator will be used:\n\n  >>> intdc.toWidgetValue(3400)\n  u'3,400'\n\nAn empty string is returned, if the missing value is passed in:\n\n  >>> intdc.toWidgetValue(None)\n  u''\n\nOf course, parsing these outputs again, works as well:\n\n  >>> intdc.toFieldValue(u'34')\n  34\n\nBut if we increase the number, the grouping seprator will be used:\n\n  >>> intdc.toFieldValue(u'3,400')\n  3400\n\nLuckily our parser is somewhat forgiving, and even allows for missing group\ncharacters:\n\n  >>> intdc.toFieldValue(u'3400')\n  3400\n\nIf an empty string is passed in, the missing value of the field is returned:\n\n  >>> intdc.toFieldValue(u'')\n\nFinally, if the input does not match at all, then a validation error is\nreturned:\n\n  >>> intdc.toFieldValue(u'fff')\n  Traceback (most recent call last):\n  ...\n  FormatterValidationError:\n      (u'The entered value is not a valid integer literal.', u'fff')\n\nThe formatter validation error derives from the regular validation error, but\nallows you to specify the message that is output when asked for the\ndocumentation:\n\n  >>> err = converter.FormatterValidationError(u'Something went wrong.', None)\n  >>> err.doc()\n  u'Something went wrong.'\n\nLet's now look at the float data converter.\n\n  >>> rating = zope.schema.Float()\n  >>> floatdc = converter.FloatDataConverter(rating, text)\n  >>> floatdc\n  <FloatDataConverter converts from Float to Widget>\n\nAgain, you can format and parse values:\n\n  >>> floatdc.toWidgetValue(7.43)\n  u'7.43'\n  >>> floatdc.toWidgetValue(10239.43)\n  u'10,239.43'\n\n  >>> floatdc.toFieldValue(u'7.43') == 7.43\n  True\n  >>> type(floatdc.toFieldValue(u'7.43'))\n  <type 'float'>\n  >>> floatdc.toFieldValue(u'10,239.43')\n  10239.43\n\nThe error message, however, is customized to the floating point:\n\n  >>> floatdc.toFieldValue(u'fff')\n  Traceback (most recent call last):\n  ...\n  FormatterValidationError:\n      (u'The entered value is not a valid decimal literal.', u'fff')\n\nThe decimal converter works like the other two before.\n\n  >>> money = zope.schema.Decimal()\n  >>> decimaldc = converter.DecimalDataConverter(money, text)\n  >>> decimaldc\n  <DecimalDataConverter converts from Decimal to Widget>\n\nFormatting and parsing should work just fine:\n\n  >>> import decimal\n\n  >>> decimaldc.toWidgetValue(decimal.Decimal('7.43'))\n  u'7.43'\n  >>> decimaldc.toWidgetValue(decimal.Decimal('10239.43'))\n  u'10,239.43'\n\n  >>> decimaldc.toFieldValue(u'7.43')\n  Decimal(\"7.43\")\n  >>> decimaldc.toFieldValue(u'10,239.43')\n  Decimal(\"10239.43\")\n\nAgain, the error message, is customized to the floating point:\n\n  >>> floatdc.toFieldValue(u'fff')\n  Traceback (most recent call last):\n  ...\n  FormatterValidationError:\n      (u'The entered value is not a valid decimal literal.', u'fff')\n\n\nBool Data Converter\n---------------------\n\n  >>> yesno = zope.schema.Bool()\n  >>> yesnowidget = widget.Widget(TestRequest())\n  >>> conv = converter.FieldDataConverter(yesno, yesnowidget)\n  >>> conv.toWidgetValue(True)\n  'True'\n\n  >>> conv.toWidgetValue(False)\n  'False'\n\n\nText Data Converters\n----------------------\n\nUsers often add empty spaces by mistake, for example when copy-pasting content\ninto the form.\n\n  >>> name = zope.schema.TextLine()\n  >>> namewidget = widget.Widget(TestRequest())\n  >>> conv = converter.FieldDataConverter(name, namewidget)\n  >>> conv.toFieldValue(u'Einstein ')\n  'Einstein'\n\n\nDate Data Converter\n-------------------\n\nSince the ``Date`` field does not provide ``IFromUnicode``, we have to provide\na custom data converter. This default one is not very sophisticated and is\ninteded for use with the text widget:\n\n  >>> date = zope.schema.Date()\n\n  >>> ddc = converter.DateDataConverter(date, text)\n  >>> ddc\n  <DateDataConverter converts from Date to Widget>\n\nDates are simply converted to ISO format:\n\n  >>> import datetime\n  >>> bday = datetime.date(1980, 1, 25)\n\n  >>> ddc.toWidgetValue(bday)\n  u'80/01/25'\n\nIf the date is the missing value, an empty string is returned:\n\n  >>> ddc.toWidgetValue(None)\n  u''\n\nThe converter only knows how to convert this particular format back to a\ndatetime value:\n\n  >>> ddc.toFieldValue(u'80/01/25')\n  datetime.date(1980, 1, 25)\n\nBy default the converter converts missing input to missin_input value:\n\n  >>> ddc.toFieldValue(u'') is None\n  True\n\nIf the passed in string cannot be parsed, a formatter validation error is\nraised:\n\n  >>> ddc.toFieldValue(u'8.6.07')\n  Traceback (most recent call last):\n  ...\n  FormatterValidationError: (\"The datetime string did not match the pattern\n                              u'yy/MM/dd'.\", u'8.6.07')\n\nTime Data Converter\n-------------------\n\nSince the ``Time`` field does not provide ``IFromUnicode``, we have to provide\na custom data converter. This default one is not very sophisticated and is\ninteded for use with the text widget:\n\n  >>> time = zope.schema.Time()\n\n  >>> tdc = converter.TimeDataConverter(time, text)\n  >>> tdc\n  <TimeDataConverter converts from Time to Widget>\n\nDates are simply converted to ISO format:\n\n  >>> noon = datetime.time(12, 0, 0)\n\n  >>> tdc.toWidgetValue(noon)\n  u'12:00'\n\nThe converter only knows how to convert this particular format back to a\ndatetime value:\n\n  >>> tdc.toFieldValue(u'12:00')\n  datetime.time(12, 0)\n\nBy default the converter converts missing input to missin_input value:\n\n  >>> tdc.toFieldValue(u'') is None\n  True\n\n\nDatetime Data Converter\n-----------------------\n\nSince the ``Datetime`` field does not provide ``IFromUnicode``, we have to\nprovide a custom data converter. This default one is not very sophisticated\nand is inteded for use with the text widget:\n\n  >>> dtField = zope.schema.Datetime()\n\n  >>> dtdc = converter.DatetimeDataConverter(dtField, text)\n  >>> dtdc\n  <DatetimeDataConverter converts from Datetime to Widget>\n\nDates are simply converted to ISO format:\n\n  >>> bdayNoon = datetime.datetime(1980, 1, 25, 12, 0, 0)\n\n  >>> dtdc.toWidgetValue(bdayNoon)\n  u'80/01/25 12:00'\n\nThe converter only knows how to convert this particular format back to a\ndatetime value:\n\n  >>> dtdc.toFieldValue(u'80/01/25 12:00')\n  datetime.datetime(1980, 1, 25, 12, 0)\n\nBy default the converter converts missing input to missin_input value:\n\n  >>> dtdc.toFieldValue(u'') is None\n  True\n\n\nTimedelta Data Converter\n------------------------\n\nSince the ``Timedelta`` field does not provide ``IFromUnicode``, we have to\nprovide a custom data converter. This default one is not very sophisticated\nand is inteded for use with the text widget:\n\n  >>> timedelta = zope.schema.Timedelta()\n\n  >>> tddc = converter.TimedeltaDataConverter(timedelta, text)\n  >>> tddc\n  <TimedeltaDataConverter converts from Timedelta to Widget>\n\nDates are simply converted to ISO format:\n\n  >>> allOnes = datetime.timedelta(1, 3600+60+1)\n\n  >>> tddc.toWidgetValue(allOnes)\n  u'1 day, 1:01:01'\n\nThe converter only knows how to convert this particular format back to a\ndatetime value:\n\n  >>> tddc.toFieldValue(u'1 day, 1:01:01')\n  datetime.timedelta(1, 3661)\n\nIf no day is available, the following short form is used:\n\n  >>> noDay = datetime.timedelta(0, 3600+60+1)\n  >>> tddc.toWidgetValue(noDay)\n  u'1:01:01'\n\nAnd now back to the field value:\n\n  >>> tddc.toFieldValue(u'1:01:01')\n  datetime.timedelta(0, 3661)\n\nBy default the converter converts missing input to missin_input value:\n\n  >>> tddc.toFieldValue(u'') is None\n  True\n\n\nFile Upload Data Converter\n--------------------------\n\nSince the ``Bytes`` field can contain a ``FileUpload`` object, we have to make\nsure we can convert ``FileUpload`` objects to bytes too.\n\n  >>> import z3c.form.browser.file\n  >>> fileWidget = z3c.form.browser.file.FileWidget(TestRequest())\n  >>> bytes = zope.schema.Bytes()\n\n  >>> fudc = converter.FileUploadDataConverter(bytes, fileWidget)\n  >>> fudc\n  <FileUploadDataConverter converts from Bytes to FileWidget>\n\nThe file upload widget usually provides a file object. But sometimes is also\nprovides a string:\n\n  >>> simple = 'foobar'\n  >>> fudc.toFieldValue(simple)\n  'foobar'\n\nThe converter can also convert ``FileUpload`` objects. So we need to setup a\nfields storage stub ...\n\n  >>> class FieldStorageStub:\n  ...     def __init__(self, file):\n  ...         self.file = file\n  ...         self.headers = {}\n  ...         self.filename = 'foo.bar'\n\nand a ``FileUpload`` component:\n\n  >>> try:\n  ...     from cStringIO import StringIO as BytesIO\n  ... except ImportError:\n  ...     from io import BytesIO\n  >>> from zope.publisher.browser import FileUpload\n  >>> myfile = BytesIO(b'File upload contents.')\n  >>> aFieldStorage = FieldStorageStub(myfile)\n  >>> myUpload = FileUpload(aFieldStorage)\n\nLet's try to convert the input now:\n\n  >>> fudc.toFieldValue(myUpload)\n  'File upload contents.'\n\nBy default the converter converts missing input to the ``NOT_CHANGED`` value:\n\n  >>> fudc.toFieldValue('')\n  <NOT_CHANGED>\n\nThis allows machinery later to ignore the field without sending all the data\naround.\n\nIf we get an empty filename in a ``FileUpload`` obejct, we also get the\n``missing_value``. But this really means that there was an error somewhere in\nthe upload, since you are normaly not able to upload a file without a filename:\n\n  >>> class EmptyFilenameFieldStorageStub:\n  ...     def __init__(self, file):\n  ...         self.file = file\n  ...         self.headers = {}\n  ...         self.filename = ''\n  >>> myfile = BytesIO(b'')\n  >>> aFieldStorage = EmptyFilenameFieldStorageStub(myfile)\n  >>> myUpload = FileUpload(aFieldStorage)\n  >>> bytes = zope.schema.Bytes()\n  >>> fudc = converter.FileUploadDataConverter(bytes, fileWidget)\n  >>> fudc.toFieldValue(myUpload) is None\n  True\n\nThere is also a ``ValueError`` if we don't get a seekable file from the\n``FieldStorage`` during the upload:\n\n  >>> myfile = ''\n  >>> aFieldStorage = FieldStorageStub(myfile)\n  >>> myUpload = FileUpload(aFieldStorage)\n  >>> bytes = zope.schema.Bytes()\n  >>> fudc = converter.FileUploadDataConverter(bytes, fileWidget)\n  >>> fudc.toFieldValue(myUpload) is None\n  Traceback (most recent call last):\n  ...\n  ValueError: (u'Bytes data are not a file object', ...AttributeError...)\n\nWhen converting to the widget value, not conversion should be done, since\nbytes are not convertable in that sense.\n\n  >>> fudc.toWidgetValue(b'\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\rIHDR\\x00\\x00\\x04')\n\nWhen the file upload widget is not used and a text-based widget is desired,\nthen the regular field data converter will be chosen. Using a text widget,\nhowever, must be setup manually in the form with code like this::\n\n  fields['bytesField'].widgetFactory = TextWidget\n\n\nSequence Data Converter\n-----------------------\n\nFor widgets and fields that work with choices of a sequence, a special data\nconverter is required that works with terms. A prime example is a choice\nfield. Before we can use the converter, we have to register some adapters:\n\n  >>> from z3c.form import term\n  >>> import zc.sourcefactory.browser.source\n  >>> import zc.sourcefactory.browser.token\n  >>> zope.component.provideAdapter(term.ChoiceTermsVocabulary)\n  >>> zope.component.provideAdapter(term.ChoiceTermsSource)\n  >>> zope.component.provideAdapter(term.ChoiceTerms)\n  >>> zope.component.provideAdapter(\n  ...     zc.sourcefactory.browser.source.FactoredTerms)\n  >>> zope.component.provideAdapter(\n  ...     zc.sourcefactory.browser.token.fromInteger)\n\nThe choice fields can be used together with vocabularies and sources.\n\nUsing vocabulary\n~~~~~~~~~~~~~~~~\n\nLet's now create a choice field (using a vocabulary) and a widget:\n\n  >>> from zope.schema.vocabulary import SimpleVocabulary\n\n  >>> gender = zope.schema.Choice(\n  ...     vocabulary = SimpleVocabulary([\n  ...              SimpleVocabulary.createTerm(0, 'm', u'male'),\n  ...              SimpleVocabulary.createTerm(1, 'f', u'female'),\n  ...              ]) )\n\n  >>> from z3c.form import widget\n  >>> seqWidget = widget.SequenceWidget(TestRequest())\n  >>> seqWidget.field = gender\n\nWe now use the field and widget to instantiate the converter:\n\n  >>> sdv = converter.SequenceDataConverter(gender, seqWidget)\n\nWe can now convert a real value to a widget value, which will be the term's\ntoken:\n\n  >>> sdv.toWidgetValue(0)\n  ['m']\n\nThe result is always a sequence, since sequence widgets only deal collections\nof values. Of course, we can convert the widget value back to an internal\nvalue:\n\n  >>> sdv.toFieldValue(['m'])\n  0\n\nSometimes a field is not required. In those cases, the internal value is the\nmissing value of the field. The converter interprets that as no value being\nselected:\n\n  >>> gender.missing_value = 'missing'\n\n  >>> sdv.toWidgetValue(gender.missing_value)\n  []\n\nIf the internal value is not a valid item in the terms, it is treated as\nmissing:\n\n  >>> sdv.toWidgetValue(object())\n  []\n\nIf \"no value\" has been specified in the widget, the missing value\nof the field is returned:\n\n  >>> sdv.toFieldValue([u'--NOVALUE--'])\n  'missing'\n\nAn empty list will also cause the missing value to be returned:\n\n  >>> sdv.toFieldValue([])\n  'missing'\n\nUsing source\n~~~~~~~~~~~~\n\nLet's now create a choice field (using a source) and a widget:\n\n  >>> from zc.sourcefactory.basic import BasicSourceFactory\n  >>> class GenderSourceFactory(BasicSourceFactory):\n  ...     _mapping = {0: u'male', 1: u'female'}\n  ...     def getValues(self):\n  ...         return self._mapping.keys()\n  ...     def getTitle(self, value):\n  ...         return self._mapping[value]\n  >>> gender_source = zope.schema.Choice(\n  ...     source = GenderSourceFactory())\n\n  >>> seqWidget = widget.SequenceWidget(TestRequest())\n  >>> seqWidget.field = gender_source\n\nWe now use the field and widget to instantiate the converter:\n\n  >>> sdv = converter.SequenceDataConverter(gender, seqWidget)\n\nWe can now convert a real value to a widget value, which will be the term's\ntoken:\n\n  >>> sdv.toWidgetValue(0)\n  ['0']\n\nThe result is always a sequence, since sequence widgets only deal collections\nof values. Of course, we can convert the widget value back to an internal\nvalue:\n\n  >>> sdv.toFieldValue(['0'])\n  0\n\nSometimes a field is not required. In those cases, the internalvalue is the\nmissing value of the field. The converter interprets that as no value being\nselected:\n\n  >>> gender.missing_value = 'missing'\n\n  >>> sdv.toWidgetValue(gender.missing_value)\n  []\n\nIf \"no value\" has been specified in the widget, the missing value\nof the field is returned:\n\n  >>> sdv.toFieldValue([u'--NOVALUE--'])\n  'missing'\n\nAn empty list will also cause the missing value to be returned:\n\n  >>> sdv.toFieldValue([])\n  'missing'\n\n\nCollection Sequence Data Converter\n----------------------------------\n\nFor widgets and fields that work with a sequence of choices, another data\nconverter is required that works with terms. A prime example is a list\nfield. Before we can use the converter, we have to register the terms adapters:\n\n  >>> from z3c.form import term\n  >>> zope.component.provideAdapter(term.CollectionTerms)\n  >>> zope.component.provideAdapter(term.CollectionTermsVocabulary)\n  >>> zope.component.provideAdapter(term.CollectionTermsSource)\n\nCollections can also use either vocabularies or sources.\n\nUsing vocabulary\n~~~~~~~~~~~~~~~~\n\nLet's now create a list field (using the previously defined field using\na vocabulary) and a widget:\n\n  >>> genders = zope.schema.List(value_type=gender)\n  >>> seqWidget = widget.SequenceWidget(TestRequest())\n  >>> seqWidget.field = genders\n\nWe now use the field and widget to instantiate the converter:\n\n  >>> csdv = converter.CollectionSequenceDataConverter(genders, seqWidget)\n\nWe can now convert a real value to a widget value, which will be the term's\ntoken:\n\n  >>> csdv.toWidgetValue([0])\n  ['m']\n\nThe result is always a sequence, since sequence widgets only deal collections\nof values. Of course, we can convert the widget value back to an internal\nvalue:\n\n  >>> csdv.toFieldValue(['m'])\n  [0]\n\nOf course, a collection field can also have multiple values:\n\n  >>> csdv.toWidgetValue([0, 1])\n  ['m', 'f']\n\n  >>> csdv.toFieldValue(['m', 'f'])\n  [0, 1]\n\nIf any of the values are not a valid choice, they are simply ignored:\n\n  >>> csdv.toWidgetValue([0, 3])\n  ['m']\n\n\nSometimes a field is not required. In those cases, the internal value is the\nmissing value of the field. The converter interprets that as no values being\ngiven:\n\n  >>> genders.missing_value is None\n  True\n  >>> csdv.toWidgetValue(genders.missing_value)\n  []\n\nFor some field, like the ``Set``, the collection type is a tuple. Sigh. In\nthese cases we use the last entry in the tuple as the type to use:\n\n  >>> genders = zope.schema.Set(value_type=gender)\n  >>> seqWidget = widget.SequenceWidget(TestRequest())\n  >>> seqWidget.field = genders\n\n  >>> csdv = converter.CollectionSequenceDataConverter(genders, seqWidget)\n\n  >>> csdv.toWidgetValue(set([0]))\n  ['m']\n\n  >>> csdv.toFieldValue(['m'])\n  set([0])\n\nGetting Terms\n+++++++++++++\n\nAs an optimization of this converter, the converter actually does not look up\nthe terms itself but uses the widget's ``terms`` attribute. If the terms are\nnot yet retrieved, the converter will ask the widget to do so when in need.\n\nSo let's see how this works when getting the widget value:\n\n  >>> seqWidget = widget.SequenceWidget(TestRequest())\n  >>> seqWidget.field = genders\n\n  >>> seqWidget.terms\n\n  >>> csdv = converter.CollectionSequenceDataConverter(genders, seqWidget)\n  >>> csdv.toWidgetValue([0])\n  ['m']\n\n  >>> seqWidget.terms\n  <z3c.form.term.CollectionTermsVocabulary object ...>\n\nThe same is true when getting the field value:\n\n  >>> seqWidget = widget.SequenceWidget(TestRequest())\n  >>> seqWidget.field = genders\n\n  >>> seqWidget.terms\n\n  >>> csdv = converter.CollectionSequenceDataConverter(genders, seqWidget)\n  >>> csdv.toFieldValue(['m'])\n  set([0])\n\n  >>> seqWidget.terms\n  <z3c.form.term.CollectionTermsVocabulary object ...>\n\n\nCorner case: Just in case the field has a sequence as ``_type``:\n\n  >>> class myField(zope.schema.List):\n  ...     _type = (list, tuple)\n\n  >>> genders = myField(value_type=gender)\n  >>> seqWidget = widget.SequenceWidget(TestRequest())\n  >>> seqWidget.field = genders\n\nWe now use the field and widget to instantiate the converter:\n\n  >>> csdv = converter.CollectionSequenceDataConverter(genders, seqWidget)\n\nThe converter uses the latter type (tuple) to convert:\n\n  >>> csdv.toFieldValue(['m'])\n  (0,)\n\nUsing source\n~~~~~~~~~~~~\n\nLet's now create a list field (using the previously defined field using\na source) and a widget:\n\n  >>> genders_source = zope.schema.List(value_type=gender_source)\n  >>> seqWidget = widget.SequenceWidget(TestRequest())\n  >>> seqWidget.field = genders_source\n\nWe now use the field and widget to instantiate the converter:\n\n  >>> csdv = converter.CollectionSequenceDataConverter(\n  ...     genders_source, seqWidget)\n\nWe can now convert a real value to a widget value, which will be the term's\ntoken:\n\n  >>> csdv.toWidgetValue([0])\n  ['0']\n\nThe result is always a sequence, since sequence widgets only deal collections\nof values. Of course, we can convert the widget value back to an internal\nvalue:\n\n  >>> csdv.toFieldValue(['0'])\n  [0]\n\nFor some field, like the ``Set``, the collection type is a tuple. Sigh. In\nthese cases we use the last entry in the tuple as the type to use:\n\n  >>> genders_source = zope.schema.Set(value_type=gender_source)\n  >>> seqWidget = widget.SequenceWidget(TestRequest())\n  >>> seqWidget.field = genders_source\n\n  >>> csdv = converter.CollectionSequenceDataConverter(\n  ...     genders_source, seqWidget)\n\n  >>> csdv.toWidgetValue(set([0]))\n  ['0']\n\n  >>> csdv.toFieldValue(['0'])\n  set([0])\n\nGetting Terms\n+++++++++++++\n\nAs an optimization of this converter, the converter actually does not look up\nthe terms itself but uses the widget's ``terms`` attribute. If the terms are\nnot yet retrieved, the converter will ask the widget to do so when in need.\n\nSo let's see how this works when getting the widget value:\n\n  >>> seqWidget = widget.SequenceWidget(TestRequest())\n  >>> seqWidget.field = genders_source\n\n  >>> seqWidget.terms\n\n  >>> csdv = converter.CollectionSequenceDataConverter(\n  ...     genders_source, seqWidget)\n  >>> csdv.toWidgetValue([0])\n  ['0']\n\n  >>> seqWidget.terms\n  <z3c.form.term.CollectionTermsSource object ...>\n\nThe same is true when getting the field value:\n\n  >>> seqWidget = widget.SequenceWidget(TestRequest())\n  >>> seqWidget.field = genders_source\n\n  >>> seqWidget.terms\n\n  >>> csdv = converter.CollectionSequenceDataConverter(\n  ...     genders_source, seqWidget)\n  >>> csdv.toFieldValue(['0'])\n  set([0])\n\n  >>> seqWidget.terms\n  <z3c.form.term.CollectionTermsSource object ...>\n\n\nBoolean to Single Checkbox Data Converter\n-----------------------------------------\n\nThe conversion from any field to the single checkbox widget value is a special\ncase, because it has to be defined what selecting the value means. In the case\nof the boolean field, \"selected\" means ``True`` and if unselected, ``False``\nis returned:\n\n  >>> boolField = zope.schema.Bool()\n\n  >>> bscbx = converter.BoolSingleCheckboxDataConverter(boolField, seqWidget)\n  >>> bscbx\n  <BoolSingleCheckboxDataConverter converts from Bool to SequenceWidget>\n\nLet's now convert boolean field to widget values:\n\n  >>> bscbx.toWidgetValue(True)\n  ['selected']\n  >>> bscbx.toWidgetValue(False)\n  []\n\nConverting back is equally simple:\n\n  >>> bscbx.toFieldValue(['selected'])\n  True\n  >>> bscbx.toFieldValue([])\n  False\n\nNote that this widget has no concept of missing value, since it can only\nrepresent two states by desgin.\n\n\nText Lines Data Converter\n-------------------------\n\nFor sequence widgets and fields that work with a sequence of `TextLine` value\nfields, a simple data converter is required. Let's create a list of text lines\nfield and a widget:\n\n  >>> languages = zope.schema.List(\n  ...     value_type=zope.schema.TextLine(),\n  ...     default=[],\n  ...     missing_value=None,\n  ...     )\n\n  >>> from z3c.form.browser import textlines\n  >>> tlWidget = textlines.TextLinesWidget(TestRequest())\n  >>> tlWidget.field = languages\n\nWe now use the field and widget to instantiate the converter:\n\n  >>> tlc = converter.TextLinesConverter(languages, tlWidget)\n\nWe can now convert a real value to a widget value:\n\n  >>> tlc.toWidgetValue([u'de', u'fr', u'en'])\n  u'de\\nfr\\nen'\n\nEmpty entries are significant:\n\n  >>> tlc.toWidgetValue([u'de', u'fr', u'en', u''])\n  u'de\\nfr\\nen\\n'\n\n\nThe result is always a string, since text lines widgets only deal with textarea\nas input field. Of course, we can convert the widget value back to an internal\nvalue:\n\n  >>> tlc.toFieldValue('de\\nfr\\nen')\n  [u'de', u'fr', u'en']\n\nEach line should be one item:\n\n  >>> tlc.toFieldValue('this morning\\ntomorrow evening\\nyesterday')\n  [u'this morning', u'tomorrow evening', u'yesterday']\n\nEmpty lines are significant:\n\n  >>> tlc.toFieldValue('de\\n\\nfr\\nen')\n  [u'de', u'', u'fr', u'en']\n\nEmpty lines are also significant at the end:\n\n  >>> tlc.toFieldValue('de\\nfr\\nen\\n')\n  [u'de', u'fr', u'en', u'']\n\n\nAn empty string will also cause the missing value to be returned:\n\n  >>> tlc.toFieldValue('') is None\n  True\n\nIt also should work for schema fields that define their type as tuple,\nfor instance zope.schema.Int declares its type as (int, long).\n\n  >>> ids = zope.schema.List(\n  ...     value_type=zope.schema.Int(),\n  ...     )\n\nLet's illustrate the problem:\n\n  >>> zope.schema.Int._type == zope.schema._compat.integer_types\n  True\n\n  Note: Should be int and long in Python 2.\n\nThe converter will use the first one.\n\n  >>> tlWidget.field = ids\n  >>> tlc = converter.TextLinesConverter(ids, tlWidget)\n\nOf course, it still can convert to the widget value:\n\n  >>> tlc.toWidgetValue([1,2,3])\n  u'1\\n2\\n3'\n\nAnd back:\n\n  >>> tlc.toFieldValue(u'1\\n2\\n3')\n  [1, 2, 3]\n\nAn empty string will also cause the missing value to be returned:\n\n  >>> tlc.toFieldValue('') is None\n  True\n\nConverting Missing value to Widget value returns '':\n\n  >>> tlc.toWidgetValue(tlc.field.missing_value)\n  u''\n\nJust in case the field has sequence as its ``_type``:\n\n  >>> class myField(zope.schema.List):\n  ...     _type = (list, tuple)\n\n  >>> ids = myField(\n  ...     value_type=zope.schema.Int(),\n  ...     )\n\nThe converter will use the latter one.\n\n  >>> tlWidget.field = ids\n  >>> tlc = converter.TextLinesConverter(ids, tlWidget)\n\nOf course, it still can convert to the widget value:\n\n  >>> tlc.toWidgetValue([1,2,3])\n  u'1\\n2\\n3'\n\nAnd back:\n\n  >>> tlc.toFieldValue(u'1\\n2\\n3')\n  (1, 2, 3)\n\nWhat if we have a wrong number:\n\n  >>> tlc.toFieldValue(u'1\\n2\\n3\\nfoo')\n  Traceback (most recent call last):\n  ...\n  FormatterValidationError: (\"invalid literal for int() with base 10: 'foo'\", u'foo')\n\n\n\n\nMulti Data Converter\n--------------------\n\nFor multi widgets and fields that work with a sequence of other basic types, a\nseparate data converter is required. Let's create a list of integers field and\na widget:\n\n  >>> numbers = zope.schema.List(\n  ...     value_type=zope.schema.Int(),\n  ...     default=[],\n  ...     missing_value=None,\n  ...     )\n\n  >>> from z3c.form.browser import multi\n  >>> multiWidget = multi.MultiWidget(TestRequest())\n  >>> multiWidget.field = numbers\n\nBefore we can convert, we have to regsiter a widget for the integer field:\n\n  >>> from z3c.form.browser import text\n  >>> zope.component.provideAdapter(\n  ...     text.TextFieldWidget,\n  ...     (zope.schema.Int, TestRequest))\n\nWe now use the field and widget to instantiate the converter:\n\n  >>> conv = converter.MultiConverter(numbers, multiWidget)\n\nWe can now convert a list of integers to the multi-widget internal\nrepresentation:\n\n  >>> conv.toWidgetValue([1, 2, 3])\n  [u'1', u'2', u'3']\n\nIf the value is the missing value, an empty list is returned:\n\n  >>> conv.toWidgetValue(None)\n  []\n\nNow, let's look at the reverse:\n\n  >>> conv.toFieldValue([u'1', u'2', u'3'])\n  [1, 2, 3]\n\nIf the list is empty, the missing value is returned:\n\n  >>> conv.toFieldValue([]) is None\n  True\n\nDict Multi Data Converter\n-------------------------\n\nFor multi widgets and fields that work with a dictionary of other basic types, a\nseparate data converter is required. Let's create a dict of integers field and\na widget:\n\n  >>> numbers = zope.schema.Dict(\n  ...     value_type=zope.schema.Int(),\n  ...     key_type=zope.schema.Int(),\n  ...     default={},\n  ...     missing_value=None,\n  ...     )\n\n  >>> from z3c.form.browser import multi\n  >>> multiWidget = multi.MultiWidget(TestRequest())\n  >>> multiWidget.field = numbers\n\nBefore we can convert, we have to regsiter a widget for the integer field:\n\n  >>> from z3c.form.browser import text\n  >>> zope.component.provideAdapter(\n  ...     text.TextFieldWidget,\n  ...     (zope.schema.Int, TestRequest))\n\nWe now use the field and widget to instantiate the converter:\n\n  >>> conv = converter.DictMultiConverter(numbers, multiWidget)\n\nWe can now convert a dict of integers to the multi-widget internal\nrepresentation:\n\n  >>> sorted(conv.toWidgetValue({1:1, 2:4, 3:9}))\n  [(u'1', u'1'), (u'2', u'4'), (u'3', u'9')]\n\nIf the value is the missing value, an empty dict is returned:\n\n  >>> conv.toWidgetValue(None)\n  []\n\nNow, let's look at the reverse:\n\n  >>> conv.toFieldValue([(u'1',u'1'), (u'2',u'4'), (u'3',u'9')])\n  {1: 1, 2: 4, 3: 9}\n\nIf the list is empty, the missing value is returned:\n\n  >>> conv.toFieldValue([]) is None\n  True\n\n=====\nTerms\n=====\n\nTerms are used to provide choices for sequence widgets or any other construct\nneeding them. Since Zope 3 already has sources and vocabularies, the base\nterms class simply builds on them.\n\nVocabularies\n------------\n\nThus, let's create a vocabulary first:\n\n  >>> from zope.schema import vocabulary\n  >>> ratings = vocabulary.SimpleVocabulary([\n  ...     vocabulary.SimpleVocabulary.createTerm(0, '0', u'bad'),\n  ...     vocabulary.SimpleVocabulary.createTerm(1, '1', u'okay'),\n  ...     vocabulary.SimpleVocabulary.createTerm(2, '2', u'good')\n  ...     ])\n\nTerms\n~~~~~\n\nNow we can create the terms object:\n\n  >>> from z3c.form import term\n  >>> terms = term.Terms()\n  >>> terms.terms = ratings\n\nGetting a term from a given value is simple:\n\n  >>> terms.getTerm(0).title\n  u'bad'\n  >>> terms.getTerm(3)\n  Traceback (most recent call last):\n  ...\n  LookupError: 3\n\nWhen converting values from their Web representation back to the internal\nrepresentation, we have to be able to look up a term by its token:\n\n  >>> terms.getTermByToken('0').title\n  u'bad'\n  >>> terms.getTerm('3')\n  Traceback (most recent call last):\n  ...\n  LookupError: 3\n\nHowever, often we just want the value so asking for the value that is\nrepresented by a token saves usually one line of code:\n\n  >>> terms.getValue('0')\n  0\n  >>> terms.getValue('3')\n  Traceback (most recent call last):\n  ...\n  LookupError: 3\n\nYou can also iterate through all terms:\n\n  >>> [entry.title for entry in terms]\n  [u'bad', u'okay', u'good']\n\nOr ask how many terms you have in the first place:\n\n  >>> len(terms)\n  3\n\nFinally the API allows you to check whether a particular value is available in\nthe terms:\n\n  >>> 0 in terms\n  True\n  >>> 3 in terms\n  False\n\nNow, there are several terms implementations that were designed for particular\nfields. Within the framework, terms are used as adapters with the follwoing\ndiscriminators: context, request, form, field, vocabulary/source and widget.\n\n\nChoice field\n~~~~~~~~~~~~\n\nThe first terms implementation is for ``Choice`` fields. Choice fields\nunfortunately can have a vocabulary and a source which behave differently.\nLet's have a look a the vocabulary first:\n\n  >>> import zope.component\n  >>> zope.component.provideAdapter(term.ChoiceTermsVocabulary)\n  >>> import z3c.form.testing\n  >>> request = z3c.form.testing.TestRequest()\n  >>> import z3c.form.widget\n  >>> widget = z3c.form.widget.Widget(request)\n\n  >>> import zope.schema\n\n  >>> ratingField = zope.schema.Choice(\n  ...     title=u'Rating',\n  ...     vocabulary=ratings)\n\n  >>> terms = term.ChoiceTerms(\n  ...     None, request, None, ratingField, widget)\n  >>> [entry.title for entry in terms]\n  [u'bad', u'okay', u'good']\n\nSometimes choice fields only specify a vocabulary name and the actual\nvocabulary is looked up at run time.\n\n  >>> ratingField2 = zope.schema.Choice(\n  ...     title=u'Rating',\n  ...     vocabulary='Ratings')\n\nInitially we get an error because the \"Ratings\" vocabulary is not defined:\n\n  >>> terms = term.ChoiceTerms(\n  ...     None, request, None, ratingField2, widget)\n  Traceback (most recent call last):\n  ...\n  VocabularyRegistryError: unknown vocabulary: 'Ratings'\n\nLet's now register the vocabulary under this name:\n\n  >>> def RatingsVocabulary(obj):\n  ...     return ratings\n\n  >>> from zope.schema import vocabulary\n  >>> vr = vocabulary.getVocabularyRegistry()\n  >>> vr.register('Ratings', RatingsVocabulary)\n\nWe should now be able to get all terms as before:\n\n  >>> terms = term.ChoiceTerms(\n  ...     None, request, None, ratingField, widget)\n  >>> [entry.title for entry in terms]\n  [u'bad', u'okay', u'good']\n\n\nMissing terms\n+++++++++++++\n\nSometimes it happens that a term goes away from the vocabulary, but our\nstored objects still reference that term.\n\n  >>> zope.component.provideAdapter(term.MissingChoiceTermsVocabulary)\n\n  >>> terms = term.ChoiceTerms(\n  ...     None, request, None, ratingField, widget)\n  >>> term = terms.getTermByToken('42')\n  Traceback (most recent call last):\n  ...\n  LookupError: 42\n\nThe same goes with looking up a term by value:\n\n  >>> term = terms.getTerm('42')\n  Traceback (most recent call last):\n  ...\n  LookupError: 42\n\nOoops, well this works only if the context has the right value for us.\nThis is because we don't want to accept any crap that's coming from HTML.\n\n  >>> class IPerson(zope.interface.Interface):\n  ...     gender = zope.schema.Choice(title=u'Gender', vocabulary='Genders')\n  >>> @zope.interface.implementer(IPerson)\n  ... class Person(object):\n  ...     gender = None\n  >>> gendersVocabulary = vocabulary.SimpleVocabulary([\n  ...     vocabulary.SimpleVocabulary.createTerm(1, 'male', u'Male'),\n  ...     vocabulary.SimpleVocabulary.createTerm(2, 'female', u'Female'),\n  ...     ])\n  >>> def GendersVocabulary(obj):\n  ...     return ratings\n  >>> vr.register('Genders', GendersVocabulary)\n\n  >>> ctx = Person()\n  >>> ctx.gender = 42\n\n  >>> genderWidget = z3c.form.widget.Widget(request)\n  >>> genderWidget.context = ctx\n  >>> from z3c.form import interfaces\n  >>> zope.interface.alsoProvides(genderWidget, interfaces.IContextAware)\n  >>> from z3c.form.datamanager import AttributeField\n  >>> zope.component.provideAdapter(AttributeField)\n\n  >>> terms = term.ChoiceTerms(\n  ...     ctx, request, None, IPerson['gender'], genderWidget)\n\nHere we go:\n\n  >>> missingTerm = terms.getTermByToken('42')\n\nWe get the term, we passed the token, the value is coming from the context.\n\n  >>> missingTerm.token\n  '42'\n  >>> missingTerm.value\n  42\n\nWe cannot figure the title, so we construct one.\nOverride ``makeMissingTerm`` if you want your own.\n\n  >>> missingTerm.title\n  u'Missing: ${value}'\n\nStill we raise LookupError if the token does not fit the context's value:\n\n  >>> missingTerm = terms.getTermByToken('99')\n  Traceback (most recent call last):\n  ...\n  LookupError: 99\n\nThe same goes with looking up a term by value.\nWe get the term if the context's value fits:\n\n  >>> missingTerm = terms.getTerm(42)\n  >>> missingTerm.token\n  '42'\n\nAnd an exception if it does not:\n\n  >>> missingTerm = terms.getTerm(99)\n  Traceback (most recent call last):\n  ...\n  LookupError: 99\n\n\nBool fields\n~~~~~~~~~~~\n\nA similar terms implementation exists for a ``Bool`` field:\n\n  >>> truthField = zope.schema.Bool()\n\n  >>> terms = term.BoolTerms(None, None, None, truthField, None)\n  >>> [entry.title for entry in terms]\n  [u'yes', u'no']\n\nIn case you don't like the choice of 'yes' and 'no' for the labels, we\ncan subclass the ``BoolTerms`` class to control the display labels.\n\n  >>> class MyBoolTerms(term.BoolTerms):\n  ...   trueLabel = u'True'\n  ...   falseLabel = u'False'\n\n  >>> terms = MyBoolTerms(None, None, None, truthField, None)\n  >>> [entry.title for entry in terms]\n  [u'True', u'False']\n\n\nCollections\n~~~~~~~~~~~\n\nFinally, there are a terms adapters for all collections. But we have to\nregister some adapters before using it:\n\n  >>> from z3c.form import term\n  >>> zope.component.provideAdapter(term.CollectionTerms)\n  >>> zope.component.provideAdapter(term.CollectionTermsVocabulary)\n  >>> zope.component.provideAdapter(term.CollectionTermsSource)\n\n  >>> ratingsField = zope.schema.List(\n  ...     title=u'Ratings',\n  ...     value_type=ratingField)\n\n  >>> terms = term.CollectionTerms(\n  ...     None, request, None, ratingsField, widget)\n  >>> [entry.title for entry in terms]\n  [u'bad', u'okay', u'good']\n\n\nSources\n-------\n\nBasic sources\n~~~~~~~~~~~~~\n\nBasic sources need no context to compute their value. Let's create a\nsource first:\n\n  >>> from zc.sourcefactory.basic import BasicSourceFactory\n  >>> class RatingSourceFactory(BasicSourceFactory):\n  ...     _mapping = {10: u'ugly', 20: u'nice', 30: u'great'}\n  ...     def getValues(self):\n  ...         return self._mapping.keys()\n  ...     def getTitle(self, value):\n  ...         return self._mapping[value]\n\nAs we did not include the configure.zcml of zc.sourcefactory we have\nto register some required adapters manually. We also need the\nChoiceTermsSource adapter:\n\n  >>> import zope.component\n  >>> import zc.sourcefactory.browser.source\n  >>> import zc.sourcefactory.browser.token\n  >>> zope.component.provideAdapter(\n  ...     zc.sourcefactory.browser.source.FactoredTerms)\n  >>> zope.component.provideAdapter(\n  ...     zc.sourcefactory.browser.token.fromInteger)\n  >>> zope.component.provideAdapter(term.ChoiceTermsSource)\n\nChoice fields\n+++++++++++++\n\nSources can be used with ``Choice`` fields like vocabularies.  First\nwe create a field based on the source:\n\n  >>> sourceRatingField = zope.schema.Choice(\n  ...     title=u'Sourced Rating',\n  ...     source=RatingSourceFactory())\n\nWe connect the field to a widget to see the ITerms adapter for sources\nat work:\n\n  >>> terms = term.ChoiceTerms(\n  ...     None, request, None, sourceRatingField, widget)\n\nIterating over the terms adapter returnes the term objects:\n\n  >>> [entry for entry in terms]\n  [<zc.sourcefactory.browser.source.FactoredTerm object at 0x...>,\n   <zc.sourcefactory.browser.source.FactoredTerm object at 0x...>,\n   <zc.sourcefactory.browser.source.FactoredTerm object at 0x...>]\n  >>> len(terms)\n  3\n  >>> [entry.token for entry in terms]\n  ['10', '20', '30']\n  >>> [entry.title for entry in terms]\n  [u'ugly', u'nice', u'great']\n\nUsing a token it is possible to look up the term and the value:\n\n  >>> terms.getTermByToken('20').title\n  u'nice'\n  >>> terms.getValue('30')\n  30\n\nWith can test if a value is in the source:\n\n  >>> 30 in terms\n  True\n  >>> 25 in terms\n  False\n\nMissing terms\n#############\n\nSometimes it happens that a value goes away from the source, but our\nstored objects still has this value.\n\n  >>> zope.component.provideAdapter(term.MissingChoiceTermsSource)\n\n  >>> terms = term.ChoiceTerms(\n  ...     None, request, None, sourceRatingField, widget)\n  >>> terms.getTermByToken('42')\n  Traceback (most recent call last):\n  ...\n  LookupError: 42\n\nThe same goes with looking up a term by value:\n\n  >>> terms.getTerm(42)\n  Traceback (most recent call last):\n  ...\n  LookupError: 42\n\nOoops, well this works only if the context has the right value for us.\nThis is because we don't want to accept any crap that's coming from HTML.\n\n  >>> class IRating(zope.interface.Interface):\n  ...     rating = zope.schema.Choice(title=u'Sourced Rating',\n  ...                                 source=RatingSourceFactory())\n  >>> @zope.interface.implementer(IRating)\n  ... class Rating(object):\n  ...     rating = None\n\n  >>> ctx = Rating()\n  >>> ctx.rating = 42\n\n  >>> ratingWidget = z3c.form.widget.Widget(request)\n  >>> ratingWidget.context = ctx\n  >>> from z3c.form import interfaces\n  >>> zope.interface.alsoProvides(ratingWidget, interfaces.IContextAware)\n  >>> from z3c.form.datamanager import AttributeField\n  >>> zope.component.provideAdapter(AttributeField)\n\n  >>> terms = term.ChoiceTerms(\n  ...     ctx, request, None, IRating['rating'], ratingWidget)\n\nHere we go:\n\n  >>> missingTerm = terms.getTermByToken('42')\n\nWe get the term, we passed the token, the value is coming from the context.\n\n  >>> missingTerm.token\n  '42'\n  >>> missingTerm.value\n  42\n\nWe cannot figure the title, so we construct one.\nOverride ``makeMissingTerm`` if you want your own.\n\n  >>> missingTerm.title\n  u'Missing: ${value}'\n\nStill we raise LookupError if the token does not fit the context's value:\n\n  >>> missingTerm = terms.getTermByToken('99')\n  Traceback (most recent call last):\n  ...\n  LookupError: 99\n\nThe same goes with looking up a term by value.\nWe get the term if the context's value fits:\n\n  >>> missingTerm = terms.getTerm(42)\n  >>> missingTerm.token\n  '42'\n\nAnd an exception if it does not:\n\n  >>> missingTerm = terms.getTerm(99)\n  Traceback (most recent call last):\n  ...\n  LookupError: 99\n\n\nCollections\n+++++++++++\n\nFinally, there are terms adapters for all collections:\n\n  >>> sourceRatingsField = zope.schema.List(\n  ...     title=u'Sourced Ratings',\n  ...     value_type=sourceRatingField)\n\n  >>> terms = term.CollectionTerms(\n  ...     None, request, None, sourceRatingsField, widget)\n  >>> [entry.title for entry in terms]\n  [u'ugly', u'nice', u'great']\n\n\nContextual sources\n~~~~~~~~~~~~~~~~~~\n\nContextual sources depend on the context they are called on. Let's\ncreate a context and a contextual source:\n\n  >>> from zc.sourcefactory.contextual import BasicContextualSourceFactory\n  >>> class RatingContext(object):\n  ...     base_value = 10\n  >>> class ContextualRatingSourceFactory(BasicContextualSourceFactory):\n  ...     _mapping = {10: u'ugly', 20: u'nice', 30: u'great'}\n  ...     def getValues(self, context):\n  ...         return [context.base_value + x for x in self._mapping.keys()]\n  ...     def getTitle(self, context, value):\n  ...         return self._mapping[value - context.base_value]\n\nAs we did not include the configure.zcml of zc.sourcefactory we have\nto register some required adapters manually. We also need the\nChoiceTermsSource adapter:\n\n  >>> import zope.component\n  >>> import zc.sourcefactory.browser.source\n  >>> import zc.sourcefactory.browser.token\n  >>> zope.component.provideAdapter(\n  ...     zc.sourcefactory.browser.source.FactoredContextualTerms)\n  >>> zope.component.provideAdapter(\n  ...     zc.sourcefactory.browser.token.fromInteger)\n  >>> zope.component.provideAdapter(term.ChoiceTermsSource)\n\nChoice fields\n+++++++++++++\n\nContextual sources can be used with ``Choice`` fields like\nvocabularies.  First we create a field based on the source:\n\n  >>> contextualSourceRatingField = zope.schema.Choice(\n  ...     title=u'Context Sourced Rating',\n  ...     source=ContextualRatingSourceFactory())\n\nWe create an context object and connect the field to a widget to see\nthe ITerms adapter for sources at work:\n\n  >>> rating_context = RatingContext()\n  >>> rating_context.base_value = 100\n  >>> terms = term.ChoiceTerms(\n  ...     rating_context, request, None, contextualSourceRatingField, widget)\n\nIterating over the terms adapter returnes the term objects:\n\n  >>> [entry for entry in terms]\n  [<zc.sourcefactory.browser.source.FactoredTerm object at 0x...>,\n   <zc.sourcefactory.browser.source.FactoredTerm object at 0x...>,\n   <zc.sourcefactory.browser.source.FactoredTerm object at 0x...>]\n  >>> len(terms)\n  3\n  >>> [entry.token for entry in terms]\n  ['110', '120', '130']\n  >>> [entry.title for entry in terms]\n  [u'ugly', u'nice', u'great']\n\nUsing a token, it is possible to look up the term and the value:\n\n  >>> terms.getTermByToken('120').title\n  u'nice'\n  >>> terms.getValue('130')\n  130\n\nWith can test if a value is in the source:\n\n  >>> 130 in terms\n  True\n  >>> 125 in terms\n  False\n\nCollections\n+++++++++++\n\nFinally, there are terms adapters for all collections:\n\n  >>> contextualSourceRatingsField = zope.schema.List(\n  ...     title=u'Contextual Sourced Ratings',\n  ...     value_type=contextualSourceRatingField)\n\n  >>> terms = term.CollectionTerms(\n  ...     rating_context, request, None, contextualSourceRatingsField, widget)\n  >>> [entry.title for entry in terms]\n  [u'ugly', u'nice', u'great']\n\n\nMissing terms in collections\n############################\n\nSometimes it happens that a value goes away from the source, but our\nstored collection still has this value.\n\n  >>> zope.component.provideAdapter(term.MissingCollectionTermsSource)\n\n  >>> terms = term.CollectionTerms(\n  ...     RatingContext(), request, None, contextualSourceRatingsField, widget)\n  >>> terms\n  <z3c.form.term.MissingCollectionTermsSource object at 0x...>\n  >>> terms.getTermByToken('42')\n  Traceback (most recent call last):\n  ...\n  LookupError: 42\n\nThe same goes with looking up a term by value:\n\n  >>> terms.getTerm(42)\n  Traceback (most recent call last):\n  ...\n  LookupError: 42\n\nThe same goes with looking up a value by the token:\n\n  >>> terms.getValue('42')\n  Traceback (most recent call last):\n  ...\n  LookupError: 42\n\n\nOoops, well this works only if the context has the right value for us.\nThis is because we don't want to accept any crap that's coming from HTML.\n\n  >>> class IRatings(zope.interface.Interface):\n  ...     ratings = zope.schema.List(\n  ...         title=u'Contextual Sourced Ratings',\n  ...         value_type=contextualSourceRatingField)\n  >>> @zope.interface.implementer(IRatings)\n  ... class Ratings(object):\n  ...     ratings = None\n  ...     base_value = 10\n\n  >>> ctx = Ratings()\n  >>> ctx.ratings = [42, 10]\n\n  >>> ratingsWidget = z3c.form.widget.Widget(request)\n  >>> ratingsWidget.context = ctx\n  >>> from z3c.form import interfaces\n  >>> zope.interface.alsoProvides(ratingsWidget, interfaces.IContextAware)\n  >>> from z3c.form.datamanager import AttributeField\n  >>> zope.component.provideAdapter(AttributeField)\n\n  >>> terms = term.CollectionTerms(\n  ...     ctx, request, None, IRatings['ratings'], ratingsWidget)\n\nHere we go:\n\n  >>> term = terms.getTerm(42)\n  >>> missingTerm = terms.getTermByToken('42')\n\nWe get the term, we passed the token, the value is coming from the context.\n\n  >>> missingTerm.token\n  '42'\n  >>> missingTerm.value\n  42\n\nWe cannot figure the title, so we construct one.\nOverride ``makeMissingTerm`` if you want your own.\n\n  >>> missingTerm.title\n  u'Missing: ${value}'\n\nWe can get the value for a missing term:\n\n  >>> terms.getValue('42')\n  42\n\nStill we raise LookupError if the token does not fit the context's value:\n\n  >>> missingTerm = terms.getTermByToken('99')\n  Traceback (most recent call last):\n  ...\n  LookupError: 99\n\nThe same goes with looking up a term by value.\nWe get the term if the context's value fits:\n\n  >>> missingTerm = terms.getTerm(42)\n  >>> missingTerm.token\n  '42'\n\nAnd an exception if it does not:\n\n  >>> missingTerm = terms.getTerm(99)\n  Traceback (most recent call last):\n  ...\n  LookupError: 99\n\n=============================\nUtility Functions and Classes\n=============================\n\nThis file documents the utility functions and classes that are otherwise not\ntested.\n\n  >>> from z3c.form import util\n\n\n``createId(name)`` Function\n---------------------------\n\nThis function converts an arbitrary unicode string into a valid Python\nidentifier. If the name is a valid identifier, then it is just returned, but\nall upper case letters are lowered:\n\n  >>> util.createId(u'Change')\n  'change'\n\n  >>> util.createId(u'Change_2')\n  'change_2'\n\nIf a name is not a valid identifier, a hex code of the string is created:\n\n  >>> util.createId(u'Change 3')\n  '4368616e67652033'\n\nThe function can also handle non-ASCII characters:\n\n  >>> id = util.createId(u'&#196;ndern')\n\nSince the output depends on how Python is compiled (UCS-2 or 4), we only check\nthat we have a valid id:\n\n  >>> util._identifier.match(id) is not None\n  True\n\n\n``createCSSId(name)`` Function\n------------------------------\n\nThis function takes any unicode name and coverts it into an id that\ncan be easily referenced by CSS selectors.  Characters that are in the\nascii alphabet, are numbers, or are '-' or '_' will be left the same.\nAll other characters will be converted to ordinal numbers:\n\n  >>> util.createCSSId(u'NormalId')\n  'NormalId'\n  >>> id = util.createCSSId(u'&#1593;&#1614;&#1585;&#1614;')\n  >>> util._identifier.match(id) is not None\n  True\n  >>> util.createCSSId(u'This has spaces')\n  'This20has20spaces'\n\n  >>> util.createCSSId(str([(1, 'x'), ('foobar', 42)]))\n  '5b2812c2027x27292c202827foobar272c2042295d'\n\n\n``getWidgetById(form, id)`` Function\n------------------------------------\n\nGiven a form and a widget id, this function extracts the widget for you. First\nwe need to create a properly developed form:\n\n  >>> import zope.interface\n  >>> import zope.schema\n\n  >>> class IPerson(zope.interface.Interface):\n  ...     name = zope.schema.TextLine(title=u'Name')\n\n  >>> from z3c.form import form, field\n  >>> class AddPerson(form.AddForm):\n  ...     fields = field.Fields(IPerson)\n\n  >>> from z3c.form import testing\n  >>> testing.setupFormDefaults()\n\n  >>> addPerson = AddPerson(None, testing.TestRequest())\n  >>> addPerson.update()\n\nWe can now ask for the widget:\n\n  >>> util.getWidgetById(addPerson, 'form-widgets-name')\n  <TextWidget 'form.widgets.name'>\n\nThe widget id can be split into a prefix and a widget name. The id must always\nstart with the correct prefix, otherwise a value error is raised:\n\n  >>> util.getWidgetById(addPerson, 'myform-widgets-name')\n  Traceback (most recent call last):\n  ...\n  ValueError: Name 'myform.widgets.name' must start with prefix 'form.widgets.'\n\nIf the widget is not found but the prefix is correct, ``None`` is returned:\n\n  >>> util.getWidgetById(addPerson, 'form-widgets-myname') is None\n  True\n\n\n``extractFileName(form, id, cleanup=True, allowEmptyPostfix=False)`` Function\n-----------------------------------------------------------------------------\n\nTest the filename extraction method:\n\n  >>> class IDocument(zope.interface.Interface):\n  ...     data = zope.schema.Bytes(title=u'Data')\n\nDefine a widgets stub and a upload widget stub class and setup them as a\nfaked form:\n\n  >>> class FileUploadWidgetStub(object):\n  ...     def __init__(self):\n  ...         self.filename = None\n\n  >>> class WidgetsStub(object):\n  ...     def __init__(self):\n  ...         self.data = FileUploadWidgetStub()\n  ...         self.prefix = 'widgets.'\n  ...     def get(self, name, default):\n  ...         return self.data\n\n  >>> class FileUploadFormStub(form.AddForm):\n  ...     def __init__(self):\n  ...         self.widgets = WidgetsStub()\n  ...\n  ...     def setFakeFileName(self, filename):\n  ...         self.widgets.data.filename = filename\n\nNow we can setup the stub form. Note this form is just a fake it's not a real\nimplementation. We just provide a form like class which simulates the\nFileUpload object in the a widget. See z3c.form.browser.file.txt for a real\nfile upload test uscase:\n\n  >>> uploadForm = FileUploadFormStub()\n  >>> uploadForm.setFakeFileName('foo.txt')\n\nAnd extract the filename\n\n  >>> util.extractFileName(uploadForm, 'form.widgets.data', cleanup=True)\n  'foo.txt'\n\nTest a unicode filename:\n\n  >>> uploadForm.setFakeFileName(u'foo.txt')\n  >>> util.extractFileName(uploadForm, 'form.widgets.data', cleanup=True)\n  u'foo.txt'\n\nTest a windows IE uploaded filename:\n\n  >>> uploadForm.setFakeFileName(u'D:\\\\some\\\\folder\\\\foo.txt')\n  >>> util.extractFileName(uploadForm, 'form.widgets.data', cleanup=True)\n  u'foo.txt'\n\nTest another filename:\n\n  >>> uploadForm.setFakeFileName(u'D:/some/folder/foo.txt')\n  >>> util.extractFileName(uploadForm, 'form.widgets.data', cleanup=True)\n  u'foo.txt'\n\nTest another filename:\n\n  >>> uploadForm.setFakeFileName(u'/tmp/folder/foo.txt')\n  >>> util.extractFileName(uploadForm, 'form.widgets.data', cleanup=True)\n  u'foo.txt'\n\nTest special characters in filename, e.g. dots:\n\n  >>> uploadForm.setFakeFileName(u'/tmp/foo.bar.txt')\n  >>> util.extractFileName(uploadForm, 'form.widgets.data', cleanup=True)\n  u'foo.bar.txt'\n\nTest some other special characters in filename:\n\n  >>> uploadForm.setFakeFileName(u'/tmp/foo-bar.v.0.1.txt')\n  >>> util.extractFileName(uploadForm, 'form.widgets.data', cleanup=True)\n  u'foo-bar.v.0.1.txt'\n\nTest special characters in file path of filename:\n\n  >>> uploadForm.setFakeFileName(u'/tmp-v.1.0/foo-bar.v.0.1.txt')\n  >>> util.extractFileName(uploadForm, 'form.widgets.data', cleanup=True)\n  u'foo-bar.v.0.1.txt'\n\nTest optional keyword arguments. But remember it's hard for Zope to guess the\ncontent type for filenames without extensions:\n\n  >>> uploadForm.setFakeFileName(u'minimal')\n  >>> util.extractFileName(uploadForm, 'form.widgets.data', cleanup=True,\n  ...     allowEmptyPostfix=True)\n  u'minimal'\n\n  >>> uploadForm.setFakeFileName(u'/tmp/minimal')\n  >>> util.extractFileName(uploadForm, 'form.widgets.data', cleanup=True,\n  ...     allowEmptyPostfix=True)\n  u'minimal'\n\n  >>> uploadForm.setFakeFileName(u'D:\\\\some\\\\folder\\\\minimal')\n  >>> util.extractFileName(uploadForm, 'form.widgets.data', cleanup=True,\n  ...     allowEmptyPostfix=True)\n  u'minimal'\n\nThere will be a ValueError if we get a empty filename by default:\n\n  >>> uploadForm.setFakeFileName(u'/tmp/minimal')\n  >>> util.extractFileName(uploadForm, 'form.widgets.data', cleanup=True)\n  Traceback (most recent call last):\n  ...\n  ValueError: Missing filename extension.\n\nWe also can skip removing a path from a upload. Note only IE will upload a\npath in a upload ``<input type=\"file\" ...>`` field:\n\n  >>> uploadForm.setFakeFileName(u'/tmp/foo.txt')\n  >>> util.extractFileName(uploadForm, 'form.widgets.data', cleanup=False)\n  u'/tmp/foo.txt'\n\n  >>> uploadForm.setFakeFileName(u'/tmp-v.1.0/foo-bar.v.0.1.txt')\n  >>> util.extractFileName(uploadForm, 'form.widgets.data', cleanup=False)\n  u'/tmp-v.1.0/foo-bar.v.0.1.txt'\n\n  >>> uploadForm.setFakeFileName(u'D:\\\\some\\\\folder\\\\foo.txt')\n  >>> util.extractFileName(uploadForm, 'form.widgets.data', cleanup=False)\n  u'D:\\\\some\\\\folder\\\\foo.txt'\n\nAnd missing filename extensions are also not allowed by deafault if we skip\nthe filename:\n\n  >>> uploadForm.setFakeFileName(u'/tmp/minimal')\n  >>> util.extractFileName(uploadForm, 'form.widgets.data', cleanup=False)\n  Traceback (most recent call last):\n  ...\n  ValueError: Missing filename extension.\n\n\n``extractContentType(form, id)`` Function\n-----------------------------------------\n\nThere is also a method which is able to extract the content type for a given\nfile upload. We can use the stub form from the previous test.\n\nNot sure if this an error but on my windows system this test returns\nimage/pjpeg (progressive jpeg) for foo.jpg and image/x-png for foo.png. So\nlet's allow this too since this depends on guess_content_type and is not\nreally a part of z3c.form.\n\n  >>> uploadForm = FileUploadFormStub()\n  >>> uploadForm.setFakeFileName('foo.txt')\n  >>> util.extractContentType(uploadForm, 'form.widgets.data')\n  'text/plain'\n\n  >>> uploadForm.setFakeFileName('foo.gif')\n  >>> util.extractContentType(uploadForm, 'form.widgets.data')\n  'image/gif'\n\n  >>> uploadForm.setFakeFileName('foo.jpg')\n  >>> util.extractContentType(uploadForm, 'form.widgets.data')\n  'image/...jpeg'\n\n  >>> uploadForm.setFakeFileName('foo.png')\n  >>> util.extractContentType(uploadForm, 'form.widgets.data')\n  'image/...png'\n\n  >>> uploadForm.setFakeFileName('foo.tif')\n  >>> util.extractContentType(uploadForm, 'form.widgets.data')\n  'image/tiff'\n\n  >>> uploadForm.setFakeFileName('foo.doc')\n  >>> util.extractContentType(uploadForm, 'form.widgets.data')\n  'application/msword'\n\n  >>> uploadForm.setFakeFileName('foo.zip')\n  >>> (util.extractContentType(uploadForm, 'form.widgets.data')\n  ...     in ('application/zip', 'application/x-zip-compressed'))\n  True\n\n  >>> uploadForm.setFakeFileName('foo.unknown')\n  >>> util.extractContentType(uploadForm, 'form.widgets.data')\n  'text/x-unknown-content-type'\n\n\n`UniqueOrderedKeys` object\n--------------------------\n\nThis object manages the keys of a dictionary. It ensures that no values are\nadded multiple times and retains the original order of the keys.\n\n  >>> keys = util.UniqueOrderedKeys([1, 2])\n\nLet's now add another key:\n\n  >>> keys.append(3)\n  >>> keys.data\n  [1, 2, 3]\n\nTrying to add `3` again causes a `ValueError` exception:\n\n  >>> keys.append(3)\n  Traceback (most recent call last):\n  ...\n  ValueError: 3\n\n\n`Manager` object\n----------------\n\nThe manager object is a base class of a mapping object that keeps track of the\nkey order as they are added.\n\n  >>> manager = util.Manager()\n\nInitially the manager is empty:\n\n  >>> len(manager)\n  0\n\nSince this base class mainly defines a read-interface, we have to add the\nvalues manually:\n\n  >>> manager._data_values.append(2)\n  >>> manager._data_keys.append('b')\n  >>> manager._data['b'] = 2\n\n  >>> manager._data_values.append(1)\n  >>> manager._data_keys.append('a')\n  >>> manager._data['a'] = 1\n\nLet's iterate through the manager:\n\n  >>> tuple(iter(manager))\n  ('b', 'a')\n  >>> manager.keys()\n  ['b', 'a']\n  >>> manager.values()\n  [2, 1]\n  >>> manager.items()\n  [('b', 2), ('a', 1)]\n\nLet's ow look at item access:\n\n  >>> 'b' in manager\n  True\n  >>> manager.get('b')\n  2\n  >>> manager.get('c', 'None')\n  'None'\n\nIt also supports deletion:\n\n  >>> del manager['b']\n  >>> manager.items()\n  [('a', 1)]\n\nWhen the `_data_keys` is reset it will always produce a `UniqueOrderedKeys`:\n\n  >>> manager._data_keys = []\n  >>> manager._data_keys\n  <z3c.form.util.UniqueOrderedKeys ...>\n\n  >>> manager._data_keys = util.UniqueOrderedKeys()\n  >>> manager._data_keys\n  <z3c.form.util.UniqueOrderedKeys ...>\n\n\n`SelectionManager` object\n-------------------------\n\nThe selection manager is an extension to the manager and provides a few more\nAPI functions. Unfortunately, this base class is totally useless without a\nsensible constructor:\n\n  >>> import zope.interface\n\n  >>> class MySelectionManager(util.SelectionManager):\n  ...     managerInterface = zope.interface.Interface\n  ...\n  ...     def __init__(self, *args):\n  ...         super(MySelectionManager, self).__init__()\n  ...         args = list(args)\n  ...         for arg in args:\n  ...             if isinstance(arg, MySelectionManager):\n  ...                 args += arg.values()\n  ...                 continue\n  ...             self._data_values.append(arg)\n  ...             self._data_keys.append(str(arg))\n  ...             self._data[str(arg)] = arg\n\nLet's now create two managers:\n\n  >>> manager1 = MySelectionManager(1, 2)\n  >>> manager2 = MySelectionManager(3, 4)\n\nYou can add two managers:\n\n  >>> manager = manager1 + manager2\n  >>> manager.values()\n  [1, 2, 3, 4]\n\nNext, you can select only certain names:\n\n  >>> manager.select('1', '2', '3').values()\n  [1, 2, 3]\n\nOr simply omit a value.\n\n  >>> manager.omit('2').values()\n  [1, 3, 4]\n\nYou can also easily copy a manager:\n\n  >>> manager.copy() is not manager\n  True\n\nThat's all.\n\n`getSpecification()` function\n-----------------------------\n\nThis function is capable of returning an `ISpecification` for any object,\nincluding instances.\n\nFor an interface, it simply returns the interface:\n\n  >>> import zope.interface\n  >>> class IFoo(zope.interface.Interface):\n  ...     pass\n\n  >>> util.getSpecification(IFoo) == IFoo\n  True\n\nDitto for a class:\n\n  >>> class Bar(object):\n  ...     pass\n\n  >>> util.getSpecification(Bar) == Bar\n  True\n\nFor an instance, it will create a marker interface on the fly if necessary:\n\n  >>> bar = Bar()\n  >>> util.getSpecification(bar) # doctest: +ELLIPSIS\n  <InterfaceClass z3c.form.util.IGeneratedForObject_...>\n\nThe ellipsis represents a hash of the object.\n\nIf the function is called twice on the same object, it will not create a new\nmarker each time:\n\n  >>> baz = Bar()\n  >>> barMarker = util.getSpecification(bar)\n  >>> bazMarker1 = util.getSpecification(baz)\n  >>> bazMarker2 = util.getSpecification(baz)\n\n  >>> barMarker is bazMarker1\n  False\n\n  >>> bazMarker1 == bazMarker2\n  True\n  >>> bazMarker1 is bazMarker2\n  True\n\n`changedField()` function\n-------------------------\n\nDecide whether a field was changed/modified.\n\n  >>> class IPerson(zope.interface.Interface):\n  ...     login = zope.schema.TextLine(\n  ...         title=u'Login')\n  ...     address = zope.schema.Object(\n  ...         schema=zope.interface.Interface)\n\n  >>> @zope.interface.implementer(IPerson)\n  ... class Person(object):\n  ...     login = 'johndoe'\n  >>> person = Person()\n\nfield.context is None and no context passed:\n\n  >>> util.changedField(IPerson['login'], 'foo')\n  True\n\nIObject field:\n\n  >>> util.changedField(IPerson['address'], object(), context = person)\n  True\n\nfield.context or context passed:\n\n  >>> import z3c.form.datamanager\n  >>> zope.component.provideAdapter(z3c.form.datamanager.AttributeField)\n\n  >>> util.changedField(IPerson['login'], 'foo', context = person)\n  True\n  >>> util.changedField(IPerson['login'], 'johndoe', context = person)\n  False\n\n  >>> fld = IPerson['login'].bind(person)\n  >>> util.changedField(fld, 'foo')\n  True\n  >>> util.changedField(fld, 'johndoe')\n  False\n\nNo access:\n\n  >>> save = z3c.form.datamanager.AttributeField.canAccess\n  >>> z3c.form.datamanager.AttributeField.canAccess = lambda self: False\n\n  >>> util.changedField(IPerson['login'], 'foo', context = person)\n  True\n  >>> util.changedField(IPerson['login'], 'johndoe', context = person)\n  True\n\n  >>> z3c.form.datamanager.AttributeField.canAccess = save\n\n\n`changedWidget()` function\n---------------------------\n\nDecide whether a widget value was changed/modified.\n\n  >>> import z3c.form.testing\n  >>> request = z3c.form.testing.TestRequest()\n  >>> import z3c.form.widget\n  >>> widget = z3c.form.widget.Widget(request)\n\nIf the widget is not IContextAware, there's nothing to check:\n\n  >>> from z3c.form import interfaces\n  >>> interfaces.IContextAware.providedBy(widget)\n  False\n\n  >>> util.changedWidget(widget, 'foo')\n  True\n\nMake it IContextAware:\n\n  >>> widget.context = person\n  >>> zope.interface.alsoProvides(widget, interfaces.IContextAware)\n\n  >>> widget.field = IPerson['login']\n\n  >> util.changedWidget(widget, 'foo')\n  True\n\n  >>> util.changedWidget(widget, 'johndoe')\n  False\n\nField and context is also overridable:\n\n  >>> widget.field = None\n  >>> util.changedWidget(widget, 'johndoe', field=IPerson['login'])\n  False\n\n  >>> p2 = Person()\n  >>> p2.login = 'foo'\n\n  >>> util.changedWidget(widget, 'foo', field=IPerson['login'], context=p2)\n  False\n\n`sortedNone()` function\n------------------------\n\n  >>> util.sortedNone([None, 'a', 'b'])\n  [None, 'a', 'b']\n\n  >>> util.sortedNone([None, 1, 2])\n  [None, 1, 2]\n\n  >>> util.sortedNone([None, True, False])\n  [None, False, True]\n\n  >>> util.sortedNone([['true'], [], ['false']])\n  [[], ['false'], ['true']]\n\n  >>> util.sortedNone([('false',), ('true',), ()])\n  [(), ('false',), ('true',)]\n\n\n=======\nCHANGES\n=======\n\n3.5 (2017-09-19)\n----------------\n\n- Add support for Python 3.6.\n\n- Drop support for Python 3.3.\n\n- Avoid duplicated IDs when using a non-required field with\n  ``z3c.formwidget.query.widget.QuerySourceRadioWidget``.\n  [pgrunewald]\n\n\n3.4.0 (2016-11-15)\n------------------\n\n- Drop support for Python 2.6.\n\n- Support Python 3.5 officially.\n\n- Fix TypeError: object of type 'generator' has no ``len()``.\n  Happens with z3c.formwidget.query.  [maurits]\n\n- Turned ``items`` into a property again on all widgets.\n  For the select widget it was a method since 2.9.0.\n  For the radio and checkbox widgets it was a method since 3.2.10.\n  For orderedselect and multi it was always a property.\n  Fixes https://github.com/zopefoundation/z3c.form/issues/44\n  [maurits]\n\n- Fix handling of missing terms in collections. (See version 2.9 describing\n  this feature.)\n\n- Fix `orderedselect_input.js` resource to be usable on browser layers which do\n  not extend ``zope.publisher.interfaces.browser.IDefaultBrowserLayer``.\n\n3.3.0 (2016-03-09)\n------------------\n\n- *MAJOR* overhaul of ObjectWidget:\n\n  * low level unittests passed, but high level was not tops\n    basic rule is that widgets want RAW values and all conversion\n    must be done in ``ObjectConverter``\n\n  * ``ObjectSubForm`` and ``SubformAdapter`` is removed,\n    it was causing more problems than good\n\n  * added high level integration tests\n\n- Removed ``z3c.coverage`` from ``test`` extra.  [gforcada, maurits]\n\n\n3.2.10 (2016-03-09)\n-------------------\n\n- RadioWidget items are better determined when they are needed [agroszer]\n\n- CheckBoxWidget items are better determined when they are needed [agroszer]\n\n- Bugfix: The ``ChoiceTerms`` adapter blindly assumed that the passed in field\n  is unbound, which is not necessarily the case in interesting ObjectWidget\n  scenarios. Not it checks for a non-None field context first. [srichter]\n\n3.2.9 (2016-02-01)\n------------------\n\n- Correctly handled ``noValueToken`` in RadioWidget.  This avoids a\n  ``LookupError: --NOVALUE--``.  [gaudenz,ale-rt]\n\n- Added ``json`` method for forms and ``json_data`` method for\n  widgets.  [mmilkin]\n\n- Change javascript for updating ordered select widget hidden structure so it\n  works again on IE11 and doesn't send back an empty list that deletes all\n  selections on save. Fixes https://github.com/zopefoundation/z3c.form/issues/23\n  [fredvd]\n\n- Started on Dutch translations.\n  [maurits]\n\n\n3.2.8 (2015-11-09)\n------------------\n\n- Standardized namespace __init__.  [agroszer]\n\n\n3.2.7 (2015-09-20)\n------------------\n\n- Remove \"cannot move farther up/down\" messages\n  in ordered select widget.\n  [esteele]\n\n- Updated Traditional Chinese translation.\n  [l34marr]\n\n\n3.2.6 (2015-09-10)\n------------------\n\n- Fixed warnings in headers of locales files.\n  Checked with `msgfmt -c`.\n  [maurits]\n\n- Added Finnish translation.\n  [petri]\n\n- Added Traditional Chinese translation.\n  [l34marr]\n\n\n3.2.5 (2015-09-09)\n------------------\n\n- Fixed error on Python 3: NameError: global name 'basestring' is not\n  defined.  This fixes a bug introduced in version 3.2.1.\n  [maurits]\n\n\n3.2.4 (2015-07-18)\n------------------\n\n- Fix ordered select input widget not working.\n  [vangheem]\n\n- ReSt fix.\n  [timo]\n\n\n3.2.3 (2015-03-21)\n------------------\n\n- 3.2.2 was a brown bag release. Fix MANIFEST.in to include the js file that has been added in 3.2.2.\n  [timo]\n\n\n3.2.2 (2015-03-21)\n------------------\n\n- move js to separate file to prevent escaped entities in Plone 5.\n  [pbauer]\n\n\n3.2.1 (2014-06-09)\n------------------\n\n- Add DataExtractedEvent, which is thrown after data and errors are extracted\n  from widgets. Fixes https://github.com/zopefoundation/z3c.form/pull/18\n\n- Remove spaces at start and end of text field values.\n\n- Explicitly hide span in ``orderedselect_input.pt``.  This only\n  contains hidden inputs, but Internet Explorer 10 was showing them\n  anyway.  Fixes https://github.com/zopefoundation/z3c.form/issues/19\n\n\n3.2.0 (2014-03-18)\n------------------\n\n- Feature: Added text and password widget HTML5 attributes required by\n  plone.login.\n\n\n3.1.1 (2014-03-02)\n------------------\n\n- Feature: Added a consistent id on single checkbox and multi checkbox\n  widgets.\n\n\n3.1.0 (2013-12-02)\n------------------\n\n- Feature: Added a consistent id on ordered selection widget.\n\n- Feature: Added a hidden template for the textlines widget.\n\n- Feature: added an API to render each radio button separately.\n\n\n3.0.5 (2013-10-09)\n------------------\n\n- Bug: Remove errors for cases where the key field of a dict field uses a\n  sequence widget (most notably choices). The sequence widget always returns\n  lists as widget values, which are not hashable. We convert those lists to\n  tuples now within the dict support.\n\n\n3.0.4 (2013-10-06)\n------------------\n\n- Feature: Moved registration of translation directories to a separate ZCML\n  file.\n\n- Bug: Fixed a typo in German translations.\n\n\n3.0.3 (2013-09-06)\n------------------\n\n- Feature: Version 2.9 introduced a solution for missing terms in\n  vocabularies. Adapted sources to this solution, too.\n\n\n3.0.2 (2013-08-14)\n------------------\n\n- Bug: Fix unicode decode error in weird cases in\n  ``checkbox.CheckboxWidget.update()`` and ``radio.RadioWidget.update()`` (eg:\n  when ``term.value`` is an Plone Archetype ATFile)\n\n3.0.1 (2013-06-25)\n------------------\n\n- Bug: The alpha slipped out as 3.0.0, removed ``ZODB-4.0.0dev.tar.gz``\n  to reduce damage\n\n- Bug: Fixed a bug in ``widget.py`` ``def wrapCSSClass``\n\n\n3.0.0 (2013-06-24)\n------------------\n\n- Feature: Added support for ``IDict`` field in ``MultiWidget``.\n\n- Bug: Only add the 'required' CSS class to widgets when they are in input mode.\n\n- Bug: Catch bug where if a select value was set as from hidden input or\n  through a rest url as a single value, it won't error out when trying to\n  remove from ignored list. Probably not the 100% right fix but it catches\n  core dumps and is sane anyways.\n\n\n3.0.0a3 (2013-04-08)\n--------------------\n\n- Feature: Updated pt_BR translation.\n\n- Bug: Fixed a bug where file input value was interpeted as UTF-8.\n\n\n3.0.0a2 (2013-02-26)\n--------------------\n\n- Bug: The 3.0.0a1 release was missing some files (e.g. ``locales``) due to an\n  incomplete ``MANIFEST.in``.\n\n\n3.0.0a1 (2013-02-24)\n--------------------\n\n- Feature: Removed several parts to be installed by default, since some\n  packages are not ported yet.\n\n- Feature: Added support for Python 3.3.\n\n- Feature: Replaced deprecated ``zope.interface.implements`` usage with\n  equivalent ``zope.interface.implementer`` decorator.\n\n- Feature: Dropped support for Python 2.4 and 2.5.\n\n- Bug: Make sure the call to the method that returns the default value\n  is made with a field which has its context bound.\n\n\n2.9.1 (2012-11-27)\n------------------\n\n- Feautre: The ``updateWidgets`` method has received an argument\n  ``prefix`` which allows setting the prefix of the field widgets\n  adapter.\n\n  This allows updating the common widgets prefix before the individual\n  widgets are updated, useful for situations where neither a form, nor\n  a widgets prefix is desired.\n\n- Bug: Capitalize the messages 'no value' and 'select a value'. This change\n  has been applied also to the existing translations (where applicable).\n\n- Bug: ``TextLinesConverter``: Do not ignore newlines at the end of the\n  inputted string, thus do not eat blank items\n\n- Bug: ``TextLinesConverter``: ``toFieldValue()``, convert conversion\n  exceptions to ``FormatterValidationError``, for cases like got a string\n  instead of int.\n\n2.9.0 (2012-09-17)\n------------------\n\n- Feature: Missing terms in vocabularies: this was a pain until now.\n  Now it's possible to have the same (missing) value unchanged on the object\n  with an EditForm after save as it was before editing.\n  That brings some changes with it:\n\n  * *MAJOR*: unchanged values/fields do not get validated anymore\n    (unless they are empty or are FileUploads)\n\n  * A temporary ``SimpleTerm`` gets created for the missing value\n    Title is by default \"Missing: ${value}\". See MissingTermsMixin.\n\n- Feature: Split ``configure.zcml``\n\n- Bug: ``SequenceWidget`` DISPLAY_MODE: silently ignore missing tokens,\n  because INPUT_MODE and HIDDEN_MODE does that too.\n\n2.8.2 (2012-08-17)\n------------------\n\n- Feature: Added ``IForm.ignoreRequiredOnValidation``,\n  ``IWidgets.ignoreRequiredOnValidation``,\n  ``IWidget.ignoreRequiredOnValidation``.\n  Those enable ``extract`` and ``extractData`` to return without errors in\n  case a required field is not filled.\n  That also means the usual \"Missing value\" error will not get displayed.\n  But the ``required-info`` (usually the ``*``) yes.\n  This is handy to store partial state.\n\n\n2.8.1 (2012-08-06)\n------------------\n\n- Fixed broken release, my python 2.7 windows setup didn't release the new\n  widget.zcml, widget_layout.pt and widget_layout_hidden.pt files. After\n  enhance the pattern in MANIFEST.in everything seems fine. That's probably\n  because I patched my python version with the \\*build exclude pattern patch.\n  And yes, the new files where added to the svn repos! After deep into this\n  again, it seems that only previous added \\*.txt, \\*.pt files get added to\n  the release. A fresh checkout sdist release only contains the \\*.py and \\*.mo\n  files. Anyway the enhanced MANIFEST.in file solved the problem.\n\n\n2.8.0 (2012-08-06)\n------------------\n\n- Feature: Implemented widget layout concept similar to z3c.pagelet. The new\n  layout concept allows to register layout templates additional to the widget\n  templates. Such a layout template only get used if a widget get called.\n  This enhacement is optional and compatible with all previous z3c.form\n  versions and doesn't affect existing code and custom implementations\n  except if you implemented a own __call__ method for widgets which\n  wasn't implemented in previous versions. The new __call__ method will lookup\n  and return a layout template which supports additional HTML code used as\n  a wrapper for the HTML code returned from the widget render method.\n  This concept allows to define additional HTML construct provided for all\n  widget and render specific CSS classes arround the widget per context, view,\n  request, etc discriminators. Such a HTML constuct was normaly supported in\n  form macros which can't get customized on a per widget, view or context base.\n\n  Summary; the new layout concept allows us to define a wrapper CSS elements\n  for the widget element (label, widget, error) on a per widgte base and skip\n  the generic form macros offered from z3c.formui.\n\n  Note; you only could get into trouble if you define a widget in tal without\n  to prefix them with ``nocall:`` e.g. tal:define=\"widget view/widgets/foo\"\n  Just add a nocall like tal:define=\"widget nocall:view/widgets/foo\" if your\n  rendering engine calls the __call__method by default. Also note that the\n  following will also call the __call__ method tal:define=\"widget myWidget\".\n\n- Fixed content type extraction test which returned different values. This\n  probably depends on a newer version of guess_content_type. Just allow\n  image/x-png and image/pjpeg as valid values.\n\n\n2.7.0 (2012-07-11)\n------------------\n\n- Remove `zope34` extra, use an older version of z3c.form if you need to\n  support pre-ZTK versions.\n\n- Require at least zope.app.container 3.7 for adding support.\n\n- Avoid dependency on ZODB3.\n\n- Added IField.showDefault and IWidget.showDefault\n  That controls whether the widget should look for field default values\n  to display. This can be really helpful in EditForms, where you don't\n  want to have default values instead of actual (missing) values.\n  By default it is True to provide backwards compatibility.\n\n2.6.1 (2012-01-30)\n------------------\n\n- Fixed a potential problem where a non-ascii vocabulary/source term value\n  could cause the checkbox and readio widget to crash.\n\n- Fixed a problem with the ``datetime.timedelta`` converter, which failed to\n  convert back to the field value, when the day part was missing.\n\n\n2.6.0 (2012-01-30)\n------------------\n\n- Remove \":list\" from radio inputs, since radio buttons can be only one value\n  by definition. See LP580840.\n\n- Changed radio button and checkbox widget labels from token to value (wrapped\n  by a unicode conversion) to make it consistent with the parent\n  ``SequenceWidget`` class. This way, edit and display views of the widgets\n  show the same label. See LP623210.\n\n- Remove dependency on zope.site.hooks, which was moved to zope.component in\n  3.8.0 (present in ZTK 1.0 and above).\n\n- Make zope.container dependency more optional (it is only used in tests)\n\n- Properly escape JS code in script tag for the ordered-select widget. See\n  LP829484.\n\n- Cleaned whitespace in page templates.\n\n- Fix ``IGroupForm`` interface and actually use it in the ``GroupForm``\n  class. See LP580839.\n\n- Added Spanish translation.\n\n- Added Hungarian translation.\n\n2.5.1 (2011-11-26)\n------------------\n\n- Better compatibility with Chameleon 2.x.\n\n- Added \\*.mo files missing in version 2.5.0.\n\n- Pinned minimum version of test dependency `z3c.template`.\n\n2.5.0 (2011-10-29)\n------------------\n\n- Fixed coverage report generator script buildout setup.\n\n- Note: z3c.pt and chameleon are not fully compatible right now with TAL.\n  Traversing the repeat wrapper is not done the same way. ZPT uses the\n  following pattern:\n  <tal:block condition=\"not:repeat/value/end\">, </tal:block>\n\n  Chameleon only supports python style traversing:\n  <tal:block condition=\"not:python:repeat['value'].end\">, </tal:block>\n\n- Upgrade to chameleon 2.0 template engine and use the newest z3c.pt and\n  z3c.ptcompat packages adjusted to work with chameleon 2.0.\n\n  See the notes from the z3c.ptcompat package:\n\n  Update z3c.ptcompat implementation to use component-based template engine\n  configuration, plugging directly into the Zope Toolkit framework.\n\n  The z3c.ptcompat package no longer provides template classes, or ZCML\n  directives; you should import directly from the ZTK codebase.\n\n  Also, note that the ``PREFER_Z3C_PT`` environment option has been\n  rendered obsolete; instead, this is now managed via component\n  configuration.\n\n  Attention: You need to include the configure.zcml file from z3c.ptcompat\n  for enable the z3c.pt template engine. The configure.zcml will plugin the\n  template engine. Also remove any custom built hooks which will import\n  z3c.ptcompat in your tests or other places.\n\n  You can directly use the BoundPageTemplate and ViewPageTempalteFile from\n  zope.browserpage.viewpagetemplatefile if needed. This templates will implicit\n  use the z3c.pt template engine if the z3c.ptcompat configure.zcml is\n  loaded.\n\n\n2.4.4 (2011-07-11)\n------------------\n\n- Remove unneeded dependency on deprecated ``zope.app.security``.\n\n- Fixed ButtonActions.update() to correctly remove actions when called again,\n  after the button condition become false.\n\n\n2.4.3 (2011-05-20)\n------------------\n\n- Declare TextLinesFieldWidget as an IFieldWidget implementer.\n\n- Clarify MultiWidget.extract(), when there are zero items,\n  this is now [] instead of <NO_VALUE>\n\n- Some typos fixed\n\n- Fixed test failure due to change in floating point representation in Python\n  2.7.\n\n- Ensure at least min_length widgets are rendered for a MultiWidget in input\n  mode.\n\n- Added Japanese translation.\n\n- Added base of Czech translation.\n\n- Added Portuguese Brazilian translation.\n\n2.4.2 (2011-01-22)\n------------------\n\n- Adjust test for the contentprovider feature to not depend on the\n  ContentProviderBase class that was introduced in zope.contentprovider 3.5.0.\n  This restores compatibility with Zope 2.10.\n\n- Security issue, removed IBrowserRequest from IFormLayer. This prevents to\n  mixin IBrowserRequest into non IBrowserRequest e.g. IJSONRPCRequest.\n  This should be compatible since a browser request using z3c.form already\n  provides IBrowserRequest and the IFormLayer is only a marker interface used\n  as skin layer.\n\n- Add English translation (generated from translation template using\n  msgen z3c.form.pot > en/LC_MESSAGES/z3c.form.po).\n\n- Added Norwegian translation, thanks to Helge Tesdal and Martijn Pieters.\n\n- Updated German translation.\n\n\n2.4.1 (2010-07-18)\n------------------\n\n- Since version 2.3.4 ``applyChanges`` required that the value exists\n  when the field had a ``DictionaryField`` data manager otherwise it\n  broke with an ``AttributeError``. Restored previous behavior that\n  values need not to be exist before ``applyChanges`` was called by\n  using ``datamanager.query()`` instead of ``datamanager.get()`` to\n  get the previous value.\n\n- Added missing dependency on ``zope.contentprovider``.\n\n- No longer using deprecated ``zope.testing.doctest`` by using\n  python's built-in ``doctest`` module.\n\n2.4.0 (2010-07-01)\n------------------\n\n- Feature: mix fields and content providers in forms. This allow to enrich\n  the form by interlacing html snippets produced by content providers.\n  Adding html outside the widgets avoids the systematic need of\n  subclassing or changing the full widget rendering.\n\n- Bug: Radio widget was not treating value as a list in hidden mode.\n\n\n2.3.4 (2010-05-17)\n------------------\n\n- Bugfix: applyChanges should not try to compare old and new values if the old\n  value can not be accessed.\n\n- Fix DictionaryField to conform to the IDataManager spec: get() should raise\n  an exception if no value can be found.\n\n\n2.3.3 (2010-04-20)\n------------------\n\n- The last discriminator of the 'message' IValue adapter used in the\n  ErrorViewSnippet is called 'content', but it was looked up as the error view\n  itself. It is now looked up on the form's context.\n\n- Don't let util.getSpecification() generate an interface more than once.\n  This causes strange effects when used in value adapters: if two adapters\n  use e.g. ISchema['some_field'] as a \"discriminator\" for 'field', with one\n  adapter being more specific on a discriminator that comes later in the\n  discriminator list (e.g. 'form' for an ErrorViewMessage), then depending on\n  the order in which these two were set up, the adapter specialisation may\n  differ, giving unexpected results that make it look like the adapter\n  registry is picking the wrong adapter.\n\n- Fix trivial test failures on Python 2.4 stemming from differences in\n  pprint's sorting of dicts.\n\n- Don't invoke render() when publishing the form as a view if the HTTP status\n  code has been set to one in the 3xx range (e.g. a redirect or not-modified\n  response) - the response body will be ignored by the browser anyway.\n\n- Handle Invalid exceptions from constraints and field validators.\n\n- Don't create unnecessary self.items in update() method of\n  SelectWidget in DISPLAY_MODE. Now items is a property.\n\n- Add hidden widget templates for radio buttons and checkboxes.\n\n2.3.2 (2010-01-21)\n------------------\n\n- Reverted changes made in the previous release as the ``getContent``\n  method can return anything it wants to as long as a data manager can\n  map the fields to it. So ``context`` should be used for group\n  instantiation. In cases where ``context`` is not wanted, the group\n  can be instantiated in the ``update`` method of its parent group or\n  form. See also\n  https://mail.zope.org/pipermail/zope-dev/2010-January/039334.html\n\n  (So version 2.3.2 is the same as version 2.3.0.)\n\n\n2.3.1 (2010-01-18)\n------------------\n\n- ``GroupForm`` and ``Group`` now use ``getContent`` method when\n  instantiating group classes instead of directly accessing\n  ``self.context``.\n\n\n2.3.0 (2009-12-28)\n------------------\n\nRefactoring\n~~~~~~~~~~~\n\n- Removed deprecated zpkg slug and ZCML slugs.\n\n- Adapted tests to `zope.schema` 3.6.0.\n\n- Avoid to use `zope.testing.doctestunit` as it is now deprecated.\n\nUpdate\n~~~~~~\n\n- Updated German translations.\n\n\n2.2.0 (2009-10-27)\n------------------\n\n- Feature: Add ``z3c.form.error.ComputedErrorViewMessage`` factory for easy\n  creation of dynamically computed error messages.\n\n- Bug: <div class=\"error\"> was generated twice for MultiWidget and\n  ObjectWidget in input mode.\n\n- Bug: Replace dots with hyphens when generating form id from its name.\n\n- Refactored OutputChecker to its own module to allow using\n  ``z3c.form.testing`` without needing to depend on ``lxml``.\n\n- Refactored: Folded duplicate code in\n  ``z3c.form.datamanager.AttributeField`` into a single property.\n\n\n2.1.0 (2009-07-22)\n------------------\n\n- Feature: The `DictionaryFieldManager` now allows all mappings\n  (``zope.interface.common.mapping.IMapping``), even\n  ``persistent.mapping.PersistentMapping`` and\n  ``persistent.dict.PersistentDict``. By default, however, the field\n  manager is only registered for dict, because it would otherwise get\n  picked up in undesired scenarios.\n\n- Bug: Updated code to pass all tests on the latest package versions.\n\n- Bug: Completed the Zope 3.4 backwards-compatibility. Also created a buidlout\n  configuration file to test the Zope 3.4 compatibility. Note: You *must* use\n  the 'latest' or 'zope34' extra now to get all required\n  packages. Alternatively, you can specify the packages listed in either of\n  those extras explicitely in your product's required packages.\n\n\n2.0.0 (2009-06-14)\n------------------\n\nFeatures\n~~~~~~~~\n\n- KGS 3.4 compatibility. This is a real hard thing, because `z3c.form` tests\n  use `lxml` >= 2.1.1 to check test output, but KGS 3.4 has `lxml`\n  1.3.6. Therefore we agree on that if tests pass with all package versions\n  nailed by KGS 3.4 but `lxml` overridden to 2.1.1 then the `z3c.form` package\n  works with a plain KGS 3.4.\n\n- Removed hard `z3c.ptcompat` and thus `z3c.pt` dependency.  If you have\n  `z3c.ptcompat` on the Python path it will be used.\n\n- Added nested group support. Groups are rendered as fieldsets.  Nested\n  fieldsets are very useful when designing forms.\n\n  WARNING: If your group did have an `applyChanges()` (or any added(?)) method\n  the new one added by this change might not match the signature.\n\n- Added `labelRequired` and `requiredInfo` form attributes. This is useful for\n  conditional rendering a required info legend in form templates.  The\n  `requiredInfo` label depends by default on a given `labelRequired` message\n  id and will only return the label if at least one widget field is required.\n\n- Add support for refreshing actions after their execution. This is useful\n  when button action conditions are changing as a result of action\n  execution. All you need is to set the `refreshActions` flag of the form to\n  `True` in your action handler.\n\n- Added support for using sources. Where it was previosly possible to use a\n  vocabulary it is now also possible to use a source. This works both for\n  basic and contextual sources.\n\n  **IMPORTANT:** The `ChoiceTerms` and `CollectionTerms` in `z3c.form.term`\n  are now simple functions that query for real `ITerms` adapters for field's\n  `source` or `value_type` respectively. So if your code inherits the old\n  `ChoiceTerms` and `CollectionTerms` classes, you'll need to review and adapt\n  it. See the `z3c.form.term` module and its documentation.\n\n- The new `z3c.form.interfaces.NOT_CHANGED` special value is available to\n  signal that the current value should be left as is.  It's currently handled\n  in the `z3c.form.form.applyChanges()` function.\n\n- When no file is specified in the file upload widget, instead of overwriting\n  the value with a missing one, the old data is retained.  This is done by\n  returning the new `NOT_CHANGED` special value from the\n  `FileUploadDataConvereter`.\n\n- Preliminary support for widgets for the `schema.IObject` field has been\n  added. However, there is a big caveat, please read the ``object-caveat.txt``\n  document inside the package.\n\n  A new `objectWidgetTemplate` ZCML directive is provided to register widget\n  templates for specific object field schemas.\n\n- Implemented the `MultiWidget` widget. This widget allows you to use simple\n  fields like `ITextLine`, `IInt`, `IPassword`, etc. in a `IList` or `ITuple`\n  sequence.\n\n- Implemented `TextLinesWidget` widget. This widget offers a text area element\n  and splits lines in sequence items. This is usfull for power user\n  interfaces.  The widget can be used for sequence fields (e.g. `IList`) that\n  specify a simple value type field (e.g. `ITextLine` or `IInt`).\n\n- Added a new flag `ignoreContext` to the form field, so that one can\n  individually select which fields should and which ones should not ignore the\n  context.\n\n- Allow raw request values of sequence widgets to be non-sequence values,\n  which makes integration with Javascript libraries easier.\n\n- Added support in the file upload widget's testing flavor to specify\n  'base64'-encoded strings in the hidden text area, so that binary data can be\n  uploaded as well.\n\n- Allow overriding the `required` widget attribute using `IValue` adapter just\n  like it's done for `label` and `name` attributes.\n\n- Add the `prompt` attribute of the `SequenceWidget` to the list of adaptable\n  attributes.\n\n- Added benchmarking suite demonstrating performance gain when using\n  ``z3c.pt``.\n\n- Added support for ``z3c.pt``. Usage is switched on via the \"PREFER_Z3C_PT\"\n  environment variable or via ``z3c.ptcompat.config.[enable/diable]()``.\n\n- The `TypeError` message used when a field does not provide `IFormUnicode`\n  now also contains the type of the field.\n\n- Add support for internationalization of `z3c.form` messages.  Added Russian,\n  French, German and Chinese translations.\n\n- Sphinx documentation for the package can now be created using the new `docs`\n  script.\n\n- The widget for fields implementing `IChoice` is now looked up by querying\n  for an adapter for ``(field, field.vocabulary, request)`` so it can be\n  differentiated according to the type of the source used for the field.\n\n- Move `formErrorsMessage` attribute from `AddForm` and `EditForm` to the\n  `z3c.form.form.Form` base class as it's very common validation status\n  message and can be easily reused (especially when translations are\n  provided).\n\nRefactoring\n~~~~~~~~~~~\n\n- Removed compatibility support with Zope 3.3.\n\n- Templates now declare XML namespaces.\n\n- HTML output is now compared using a modified version of the XML-aware output\n  checker provided by `lxml`.\n\n- Remove unused imports, adjust buildout dependencies in `setup.py`.\n\n- Use the `z3c.ptcompat` template engine compatibility layer.\n\nFixed Bugs\n~~~~~~~~~~\n\n- **IMPORTANT** - The signature of `z3c.form.util.extractFileName` function\n  changed because of spelling mistake fix in argument name. The\n  `allowEmtpyPostFix` is now called `allowEmptyPostfix` (note `Empty` instead\n  of `Emtpy` and `Postfix` instead of `PostFix`).\n\n- **IMPORTANT** - The `z3c.form.interfaces.NOVALUE` special value has been\n  renamed to `z3c.form.interfaces.NO_VALUE` to follow the common naming\n  style. The backward-compatibility `NOVALUE` name is still in place, but the\n  `repr` output of the object has been also changed, thus it may break your\n  doctests.\n\n- When dealing with `Bytes` fields, we should do a null conversion when going\n  to its widget value.\n\n- `FieldWidgets` update method were appending keys and values within each\n  update call. Now the `util.Manager` uses a `UniqueOrderedKeys`\n  implementation which will ensure that we can't add duplicated manager\n  keys. The implementation also ensures that we can't override the\n  `UniqueOrderedKeys` instance with a new list by using a decorator. If this\n  `UniqueOrderedKeys` implementation doesn't fit for all use cases, we should\n  probably use a customized `UserList` implementation. Now we can call\n  ``widgets.update()`` more then one time without any side effect.\n\n- `ButtonActions` update where appending keys and values within each update\n  call. Now we can call ``actions.update()`` more then one time without any\n  side effect.\n\n- The `CollectionSequenceDataConverter` no longer throws a ``TypeError:\n  'NoneType' object is not iterable`` when passed the value of a non-required\n  field (which in the case of a `List` field is `None`).\n\n- The `SequenceDataConverter` and `CollectionSequenceDataConverter` converter\n  classes now ignore values that are not present in the terms when converting\n  to a widget value.\n\n- Use ``nocall:`` modifier in `orderedselect_input.pt` to avoid calling list\n  entry if it is callable.\n\n- `SingleCheckBoxFieldWidget` doesn't repeat the label twice (once in ``<div\n  class=\"label\">``, and once in the ``<label>`` next to the checkbox).\n\n- Don't cause warnings in Python 2.6.\n\n- `validator.SimpleFieldValidator` is now able to handle\n  `interfaces.NOT_CHANGED`. This value is set for file uploads when the user\n  does not choose a file for upload.\n\n\n1.9.0 (2008-08-26)\n------------------\n\n- Feature: Use the ``query()`` method in the widget manager to try extract a\n  value. This ensures that the lookup is never failing, which is particularly\n  helpful for dictionary-based data managers, where dictionaries might not\n  have all keys.\n\n- Feature: Changed the ``get()`` method of the data manager to throw an error\n  when the data for the field cannot be found. Added ``query()`` method to\n  data manager that returns a default value, if no value can be found.\n\n- Feature: Deletion of widgets from field widget managers is now possible.\n\n- Feature: Groups now produce detailed `ObjectModifiedEvent` descriptions like\n  regular edit forms do. (Thanks to Carsten Senger for providing a patch.)\n\n- Feature: The widget manager's ``extract()`` method now supports an optional\n  ``setErrors`` (default value: True) flag that allows one to not set errors\n  on the widgets and widget manager during data extraction. Use case: You want\n  to inspect the entered data and handle errors manually.\n\n- Bug: The ``ignoreButtons`` flag of the ``z3c.form.form.extends()`` method\n  was not honored. (Thanks to Carsten Senger for providing a patch.)\n\n- Bug: Group classes now implement ``IGroup``. This also helps with the\n  detection of group instantiation. (Thanks to Carsten Senger for providing a\n  patch.)\n\n- Bug: The list of changes in a group were updated incorrectly, since it was\n  assumed that groups would modify mutually exclusive interfaces. Instead of\n  using an overwriting dictionary ``update()`` method, a purely additive merge\n  is used now. (Thanks to Carsten Senger for providing a patch.)\n\n- Bug: Added a widget for ``IDecimal`` field in testing setup.\n\n- Feature: The ``z3c.form.util`` module has a new function, ``createCSSId()``\n  method that generates readable ids for use with css selectors from any\n  unicode string.\n\n- Bug: The ``applyChanges()`` method in group forms did not return a changes\n  dictionary, but simply a boolean. This is now fixed and the group form\n  changes are now merged with the main form changes.\n\n- Bug: Display widgets did not set the style attribute if it was\n  available, even though the input widgets did set the style attribute.\n\n\n1.8.2 (2008-04-24)\n------------------\n\n- Bug: Display Widgets added spaces (due to code indentation) to the displayed\n  values, which in some cases, like when displaying Python source code, caused\n  the appearance to be incorrect.\n\n- Bug: Prevent to call ``__len__`` on ``ITerms`` and use ``is None`` for check\n  for existence. Because ``__len__`` is not a part of the ITerms API and ``not\n  widget.terms`` will end in calling ``__len__`` on existing terms.\n\n\n1.8.1 (2008-04-08)\n------------------\n\n- Bug: Fixed a bug that prohibited groups from having different contents than\n  the parent form.  Previously, the groups contents were not being properly\n  updated. Added new documentation on how to use groups to generate\n  object-based sub-forms. Thanks to Paul Carduner for providing the fix and\n  documentation.\n\n\n1.8.0 (2008-01-23)\n------------------\n\n- Feature: Implemented ``IDisplayForm`` interface.\n\n- Feature: Added integration tests for form interfaces. Added default class\n  attribute called ``widgets`` in form class with default value ``None``. This\n  helps to pass the integration tests. Now, the ``widgets`` attribute can also\n  be used as a indicator for updated forms.\n\n- Feature: Implemented additional ``createAndAdd`` hook in ``AddForm``. This\n  allows you to implement create and add in a single method. It also supports\n  graceful abortion of a create and add process if we do not return the new\n  object. This means it can also be used as a hook for custom error messages\n  for errors happen during create and add.\n\n- Feature: Add a hidden widget template for the ``ISelectWidget``.\n\n- Feature: Arrows in the ordered select widget replaced by named entities.\n\n- Feature: Added ``CollectionSequenceDataConverter`` to ``setupFormDefaults``.\n\n- Feature: Templates for the CheckBox widget are now registered in\n  ``checkbox.zcml``.\n\n- Feature: If a value cannot be converted from its unicode representation to a\n  field value using the field's ``IFromUnicode`` interface, the resulting type\n  error now shows the field name, if available.\n\n- Bug: ``createId`` could not handle arbitrary unicode input. Thanks to\n  Andreas Reuleaux for reporting the bug and a patch for it. (Added\n  descriptive doctests for the function in the process.)\n\n- Bug: Interface invariants where not working when not all fields needed for\n  computing the invariant are in the submitted form.\n\n- Bug: Ordered select didn't submit selected values.\n\n- Bug: Ordered select lists displayed tokens instead of value,\n\n- Bug: ``SequenceWidget`` displayed tokens instead of value.\n\n\n1.7.0 (2007-10-09)\n------------------\n\n- Feature: Implemented ``ImageButton``, ``ImageAction``, ``ImageWidget``, and\n  ``ImageFieldWidget`` to support imge submit buttons.\n\n- Feature: The ``AttributeField`` data manager now supports adapting\n  the content to the fields interface when the content doesn't implement\n  this interface.\n\n- Feature: Implemented single checkbox widget that can be used for boolean\n  fields. They are not available by default but can be set using the\n  ``widgetFactory`` attribute.\n\n- Bug: More lingual issues have been fixed in the documentation. Thanks to\n  Martijn Faassen for doing this.\n\n- Bug: When an error occurred during processing of the request the\n  widget ended up being security proxied and the system started\n  throwing `TraversalError`-'s trying to access the `label` attribute of\n  the widget. Declared that the widgets require the `zope.Public`\n  permission in order to access these attributes.\n\n- Bug: When rendering a widget the ``style`` attribute was not honored. Thanks\n  to Andreas Reuleaux for reporting.\n\n- Bug: When an error occurred in the sub-form, the status message was not set\n  correctly. Fixed the code and the incorrect test. Thanks to Markus\n  Kemmerling for reporting.\n\n- Bug: Several interfaces had the ``self`` argument in the method\n  signature. Thanks to Markus Kemmerling for reporting.\n\n\n1.6.0 (2007-08-24)\n------------------\n\n- Feature: An event handler for ``ActionErrorOccurred`` events is registered\n  to merge the action error into the form's error collectors, such as\n  ``form.widgets.errors`` and ``form.widgets['name'].error`` (if\n  applicable). It also sets the status of the form. (Thanks to Herman\n  Himmelbauer, who requested the feature, for providing use cases.)\n\n- Feature: Action can now raise ``ActionExecutionError`` exceptions that will\n  be handled by the framework. These errors wrap the original error. If an\n  error is specific to a widget, then the widget name is passed to a special\n  ``WidgetActionExecutionError`` error. (Thanks to Herman Himmelbauer, who\n  requested the feature, for providing use cases.)\n\n- Feature: After an action handler has been executed, an action executed event\n  is sent to the system. If the execution was successful, the event is\n  ``ActionSuccessfull`` event is sent. If an action execution error was\n  raised, the ``ActionErrorOccurred`` event is raised. (Thanks to Herman\n  Himmelbauer, who requested the feature, for providing use cases.)\n\n- Feature: The ``applyChanges()`` function now returns a dictionary of changes\n  (grouped by interface) instead of a boolean. This allows us to generate a\n  more detailed object-modified event. If no changes are applied, an empty\n  dictionary is returned. The new behavior is compatible with the old one, so\n  no changes to your code are required. (Thanks to Darryl Cousins for the\n  request and implementation.)\n\n- Feature: A new ``InvalidErrorViewSnippet`` class provides an error view\n  snippet for ``zope.interface.Invalid`` exceptions, which are frequently used\n  for invariants.\n\n- Feature: When a widget is required, HTML-based widgets now declare a\n  \"required\" class.\n\n- Feature: The validation data wrapper now knows about the context of the\n  validation, which provides a hook for invariants to access the environment.\n\n- Feature: The BoolTerms term tokens are now cosntants and stay the same, even\n  if the label has changed. The choice for the token is \"true\" and \"false\". By\n  default it used to be \"yes\" and \"no\", so you probably have to change some\n  unit tests. Functional tests are still okay, because you select by term\n  title.\n\n- Feature: BoolTerms now expose the labels for the true and false values\n  to the class. This makes it a matter of doing trivial sub-classing to\n  change the labels for boolean terms.\n\n- Feature: Exposed several attributes of the widget manager to the form for\n  convenience. The attributes are: mode, ignoreContext, ignoreRequest,\n  ignoreReadonly.\n\n- Feature: Provide more user-friendly error messages for number formatting.\n\n- Refactoring: The widget specific class name was in camel-case. A converntion\n  that later developed uses always dash-based naming of HTML/CSS related\n  variables. So for example, the class name \"textWidget\" is now\n  \"text-widget\". This change will most likely require some changes to your CSS\n  declarations!\n\n- Documentation: The text of ``field.txt`` has been reviewed linguistically.\n\n- Documentation: While reviewing the ``form.txt`` with some people, several\n  unclear and incomplete statements were discovered and fixed.\n\n- Bug (IE): In Internet Explorer, when a label for a radio input field is only\n  placed around the text describing the choice, then only the text is\n  surrounded by a dashed box. IE users reported this to be confusing, thus we\n  now place the label around the text and the input element so that both are\n  surrounded by the dashed border. In Firefox and KHTML (Safari) only the\n  radio button is surrounded all the time.\n\n- Bug: When extracting and validating data in the widget manager, invariant\n  errors were not converted to error view snippets.\n\n- Bug: When error view snippets were not widget-specific -- in other words,\n  the ``widget`` attribute was ``None`` -- rendering the template would fail.\n\n\n1.5.0 (2007-07-18)\n------------------\n\n- Feature: Added a span around values for widgets in display mode. This allows\n  for easier identification widget values in display mode.\n\n- Feature: Added the concept of widget events and implemented a particular\n  \"after widget update\" event that is called right after a widget is updated.\n\n- Feature: Restructured the approach to customize button actions, by requiring\n  the adapter to provide a new interface ``IButtonAction``. Also, an adapter\n  is now provided by default, still allowing cusotmization using the usual\n  methods though.\n\n- Feature: Added button widget. While it is not very useful without\n  Javascript, it still belongs into this package for completion.\n\n- Feature: All ``IFieldWidget`` instances that are also HTML element widgets\n  now declare an additional CSS class of the form \"<fieldtype.lower()>-field\".\n\n- Feature: Added ``addClass()`` method to HTML element widgets, so that adding\n  a new CSS class is simpler.\n\n- Feature: Renamed \"css\" attribute of the widget to \"klass\", because the class\n  of an HTML element is a classification, not a CSS marker.\n\n- Feature: Reviewed all widget attributes. Added all available HTML attributes\n  to the widgets.\n\n- Documentation: Removed mentioning of widget's \"hint\" attribute, since it\n  does not exist.\n\n- Optimization: The terms for a sequence widget were looked up multiple times\n  among different components. The widget is now the canonical source for the\n  terms and other components, such as the converter uses them. This avoids\n  looking up the terms multiple times, which can be an expensive process for\n  some applications.\n\n- Bug/Feature: Correctly create labels for radio button choices.\n\n- Bug: Buttons did not honor the name given by the schema, if created within\n  one, because we were too anxious to give buttons a name. Now name assignment\n  is delayed until the button is added to the button manager.\n\n- Bug: Button actions were never updated in the actions manager.\n\n- Bug: Added tests for textarea widget.\n\n\n1.4.0 (2007-06-29)\n------------------\n\n- Feature: The select widget grew a new ``prompt`` flag, which allows you to\n  explicitely request a selection prompt as the first option in the selection\n  (even for required fields). When set, the prompt message is shown. Such a\n  prompt as option is common in Web-UIs.\n\n- Feature: Allow \"no value message\" of select widgets to be dynamically\n  changed using an attribute value adapter.\n\n- Feature: Internationalized data conversion for date, time, date/time,\n  integer, float and decimal. Now the locale data is used to format and parse\n  those data types to provide the bridge to text-based widgets. While those\n  features require the latest zope.i18n package, backward compatibility is\n  provided.\n\n- Feature: All forms now have an optional label that can be used by the UI.\n\n- Feature: Implemented groups within forms. Groups allow you to combine a set\n  of fields/widgets into a logical unit. They were designed with ease of use\n  in mind.\n\n- Feature: Button Actions -- in other words, the widget for the button field\n  -- can now be specified either as the \"actionFactory\" on the button field or\n  as an adapter.\n\n- Bug: Recorded all public select-widget attributes in the interface.\n\n\n1.3.0 (2007-06-22)\n------------------\n\n- Feature: In an edit form applying the data and generating all necessary\n  messages was all done within the \"Apply\" button handler. Now the actual task\n  of storing is factored out into a new method called \"applyChanges(data)\",\n  which returns whether the data has been changed. This is useful for forms\n  not dealing with objects.\n\n- Feature: Added support for ``hidden`` fields. You can now use the ``hidden``\n  mode for widgets which should get rendered as ``<input type=\"hidden\"\n  />``.\n\n  Note: Make sure you use the new formui templates which will avoid rendering\n        labels for hidden widgets or adjust your custom form macros.\n\n- Feature: Added ``missing_value`` support to data/time converters\n\n- Feature: Added named vocabulary lookup in ``ChoiceTerms`` and\n  ``CollectionTerms``.\n\n- Feature: Implemented support for ``FileUpload`` in ``FileWidget``.\n\n  * Added helper for handling ``FileUpload`` widgets:\n\n    + ``extractContentType(form, id)``\n\n      Extracts the content type if ``IBytes``/``IFileWidget`` was used.\n\n    + ``extractFileName(form, id, cleanup=True, allowEmtpyPostFix=False)``\n\n      Extracts a filename if ``IBytes``/``IFileWidget`` was used.\n\n      Uploads from win/IE need some cleanup because the filename includes also\n      the path. The option ``cleanup=True`` will do this for you. The option\n      ``allowEmtpyPostFix`` allows you to pass a filename without\n      extensions. By default this option is set to ``False`` and will raise a\n      ``ValueError`` if a filename doesn't contain an extension.\n\n  * Created afile upload data converter registered for\n    ``IBytes``/``IFileWidget`` ensuring that the converter will only be used\n    for fiel widgets. The file widget is now the default for the bytes\n    field. If you need to use a text area widget for ``IBytes``, you have to\n    register a custom widget in the form using::\n\n      fields['foobar'].widgetFactory = TextWidget\n\n- Feature: Originally, when an attribute access failed in Unauthorized or\n  ForbiddenAttribute exceptions, they were ignored as if the attribute would\n  have no value. Now those errors are propagated and the system will fail\n  providing the developer with more feedback. The datamanager also grew a new\n  ``query()`` method that returns always a default and the ``get()`` method\n  propagates any exceptions.\n\n- Feature: When writing to a field is forbidden due to insufficient\n  priviledges, the resulting widget mode will be set to \"display\". This\n  behavior can be overridden by explicitely specifying the mode on a field.\n\n- Feature: Added an add form implementation against ``IAdding``. While this is\n  not an encouraged method of adding components, many people still use this\n  API to extend the ZMI.\n\n- Feature: The ``IFields`` class' ``select()`` and ``omit()`` method now\n  support two ketword arguments \"prefix\" and \"interface\" that allow the\n  selection and omission of prefixed fields and still specify the short\n  name. Thanks to Nikolay Kim for the idea.\n\n- Feature: HTML element ids containing dots are not very good, because then\n  the \"element#id\" CSS selector does not work and at least in Firefox the\n  attribute selector (\"element[attr=value]\") does not work for the id\n  either. Converted the codebase to use dashes in ids instead.\n\n- Bug/Feature: The ``IWidgets`` component is now an adapter of the form\n  content and not the form context. This guarantees that vocabulary factories\n  receive a context that is actually useful.\n\n- Bug: The readonly flag within a field was never honored. When a field is\n  readonly, it is displayed in \"display\" mode now. This can be overridden by\n  the widget manager's \"ignoreReadonly\" flag, which is necessary for add\n  forms.\n\n- Bug: The mode selection made during the field layout creation was not\n  honored and the widget manager always overrode the options providing its\n  value. Now the mode specified in the field is more important than the one\n  from the widget manager.\n\n- Bug: It sometimes happens that the sequence widget has the no-value token as\n  one element. This caused ``displayValue()`` to fail, since it tried to find\n  a term for it. For now we simply ignore the no-value token.\n\n- Bug: Fixed the converter when the incoming value is an empty string. An\n  empty string really means that we have no value and it is thus missing,\n  returning the missing value.\n\n- Bug: Fix a slightly incorrect implementation. It did not cause any harm in\n  real-world forms, but made unit testing much harder, since an API\n  expectation was not met correctly.\n\n- Bug: When required selections where not selected in radio and checkbox\n  widgets, then the conversion did not behave correctly. This also revealed\n  some issues with the converter code that have been fixed now.\n\n- Bug: When fields only had a vocabulary name, the choice terms adaptation\n  would fail, since the field was not bound. This has now been corrected.\n\n- Documentation: Integrated English language and content review improvements\n  by Roy Mathew in ``form.txt``.\n\n\n1.2.0 (2007-05-30)\n------------------\n\n- Feature: Added ability to change the button action title using an ``IValue``\n  adapter.\n\n\n1.1.0 (2007-05-30)\n------------------\n\n- Feature: Added compatibility for Zope 3.3 and thus Zope 2.10.\n\n\n1.0.0 (2007-05-24)\n------------------\n\n- Initial Release",
    "docs_url": "https://pythonhosted.org/z3c.form/",
    "download_url": "",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "https://github.com/zopefoundation/z3c.form",
    "keywords": "zope3 form widget",
    "license": "ZPL 2.1",
    "maintainer": "",
    "maintainer_email": "",
    "name": "z3c.form",
    "platform": "",
    "project_url": "https://pypi.org/project/z3c.form/",
    "release_url": "https://pypi.org/project/z3c.form/3.5/",
    "requires_dist": [],
    "requires_python": "",
    "summary": "An advanced form and widget framework for Zope 3",
    "version": "3.5"
  },
  "releases": {
    "1.0.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "ff7dac65f58f0fe91b34284edb77c9c6",
          "sha256": "8ef3e80461322c5de76c01c89e968ea00eacbedce6f084c1bd4d08442dc27788"
        },
        "downloads": 3545,
        "filename": "z3c.form-1.0.0-py2.4.egg",
        "has_sig": false,
        "md5_digest": "ff7dac65f58f0fe91b34284edb77c9c6",
        "packagetype": "bdist_egg",
        "python_version": "2.4",
        "size": 241561,
        "upload_time": "2007-05-24T15:21:06",
        "url": "https://files.pythonhosted.org/packages/28/85/a20f9049474f17fffea88f20296fa97ea898741483bb61b3b75fa5576122/z3c.form-1.0.0-py2.4.egg"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "29f3935f74d7f5748137171cf9c6ffcf",
          "sha256": "56a4debf07eacb8da6a02d88c367db67936814fb895f59f8a9230190f0521cb2"
        },
        "downloads": 3315,
        "filename": "z3c.form-1.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "29f3935f74d7f5748137171cf9c6ffcf",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 190316,
        "upload_time": "2007-05-24T15:20:44",
        "url": "https://files.pythonhosted.org/packages/c2/50/9144f72a11ebc5b95083858cb27e34d400eb04d95cc9c08588dc342f0ad4/z3c.form-1.0.0.tar.gz"
      }
    ],
    "1.0c1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "1b66ae545d76a1ae42110fc3581fe616",
          "sha256": "c471a6761bc082aa5f5c5bb7326bb5846e0353bd73bbea842f4e252573d40efc"
        },
        "downloads": 3563,
        "filename": "z3c.form-1.0c1-py2.4.egg",
        "has_sig": false,
        "md5_digest": "1b66ae545d76a1ae42110fc3581fe616",
        "packagetype": "bdist_egg",
        "python_version": "2.4",
        "size": 203685,
        "upload_time": "2007-05-22T15:00:34",
        "url": "https://files.pythonhosted.org/packages/36/75/9057bc0d5b5375bc702e1ae2a87b0fd8094668e026bc3af04fc62aab02aa/z3c.form-1.0c1-py2.4.egg"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "86edbc5ff7305571610f4753f4491203",
          "sha256": "e95b539c54b30a690e9308b7d441648782428aef9aaa461afb5ec8366792c16a"
        },
        "downloads": 3287,
        "filename": "z3c.form-1.0c1.tar.gz",
        "has_sig": false,
        "md5_digest": "86edbc5ff7305571610f4753f4491203",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 114918,
        "upload_time": "2007-05-22T15:00:15",
        "url": "https://files.pythonhosted.org/packages/7d/eb/b229cb7534cdf8199cc80b9d2960bb900fb675fcebc7fa1577239b463029/z3c.form-1.0c1.tar.gz"
      }
    ],
    "1.0c2": [
      {
        "comment_text": "",
        "digests": {
          "md5": "cdf19b1f6bef62cec51ef7b16944b9fe",
          "sha256": "795e193e7a29657606cdac0627ee74a17c9da840eda8f570199ed975e158a3b8"
        },
        "downloads": 3525,
        "filename": "z3c.form-1.0c2-py2.4.egg",
        "has_sig": false,
        "md5_digest": "cdf19b1f6bef62cec51ef7b16944b9fe",
        "packagetype": "bdist_egg",
        "python_version": "2.4",
        "size": 203679,
        "upload_time": "2007-05-22T16:39:23",
        "url": "https://files.pythonhosted.org/packages/a0/be/c59c5afb388f9e913bd8fb7f6becf1a2356580e3da67abc28b659f8782bf/z3c.form-1.0c2-py2.4.egg"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "ac4f8c34b0e6aa7a8ee5206a697d9ca2",
          "sha256": "57345957bb36a36822a6ed1cce267c6c6d681665ed4718afedac7915195d80fe"
        },
        "downloads": 3323,
        "filename": "z3c.form-1.0c2.tar.gz",
        "has_sig": false,
        "md5_digest": "ac4f8c34b0e6aa7a8ee5206a697d9ca2",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 114918,
        "upload_time": "2007-05-22T16:39:09",
        "url": "https://files.pythonhosted.org/packages/ab/a7/59f2226dbf4583f8a1bb78d855b6db157927f74f5ce085c52047bfe05a29/z3c.form-1.0c2.tar.gz"
      }
    ],
    "1.1.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "99b0591f228cde2fd525d95865659b29",
          "sha256": "ce870e805931c94f5604cc49420fe4c3c3eff8a5e1f98e6d0accae373c2b5e30"
        },
        "downloads": 4013,
        "filename": "z3c.form-1.1.0-py2.4.egg",
        "has_sig": false,
        "md5_digest": "99b0591f228cde2fd525d95865659b29",
        "packagetype": "bdist_egg",
        "python_version": "2.4",
        "size": 244286,
        "upload_time": "2007-05-31T02:33:38",
        "url": "https://files.pythonhosted.org/packages/9e/81/accc62c03ac905f066a8a6895329af671b559af484d195afb7b881d1722f/z3c.form-1.1.0-py2.4.egg"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "7f3f4e6e68dc8cb7ad9f5d4f8817f3d2",
          "sha256": "cf882116472786a95de583ac0143429505ab5f6f5402b91e3f3791cb7dd98f93"
        },
        "downloads": 3361,
        "filename": "z3c.form-1.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "7f3f4e6e68dc8cb7ad9f5d4f8817f3d2",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 190906,
        "upload_time": "2007-05-31T02:31:10",
        "url": "https://files.pythonhosted.org/packages/6c/aa/a9145d090eebdd115df5bc3e396c3a60b28a3813578b243a36f7340e7ee0/z3c.form-1.1.0.tar.gz"
      }
    ],
    "1.2.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "2758bbc7c214ddc2e982bcb7b4aad33f",
          "sha256": "b31eb029b86683181d55f08337d2751e6a87ba131c2d28e52bbe9271af543c48"
        },
        "downloads": 3549,
        "filename": "z3c.form-1.2.0-py2.4.egg",
        "has_sig": false,
        "md5_digest": "2758bbc7c214ddc2e982bcb7b4aad33f",
        "packagetype": "bdist_egg",
        "python_version": "2.4",
        "size": 245191,
        "upload_time": "2007-05-31T04:40:55",
        "url": "https://files.pythonhosted.org/packages/fd/19/bd89fd624b241413d31c46c65ac1536d9040b5ff7a55cd6edf1047367d07/z3c.form-1.2.0-py2.4.egg"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "95f3f497a39717e7c41db8eb472f896c",
          "sha256": "4d694b31251956b62650060b5357ad352546205ed66982eb22cb16008c4bce15"
        },
        "downloads": 3312,
        "filename": "z3c.form-1.2.0.tar.gz",
        "has_sig": false,
        "md5_digest": "95f3f497a39717e7c41db8eb472f896c",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 191773,
        "upload_time": "2007-05-31T04:40:33",
        "url": "https://files.pythonhosted.org/packages/dd/d0/ddc783d6a93c8990c11a87fc23c3d0e3e67fa006326cdb97d28739246539/z3c.form-1.2.0.tar.gz"
      }
    ],
    "1.3.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "aa8bdb2dd242f8da3017d4634140af78",
          "sha256": "3eb89a4cae681f9e478db6f364a280b58ac427af3d971ba85b04b4622fdbf4f3"
        },
        "downloads": 3595,
        "filename": "z3c.form-1.3.0-py2.4.egg",
        "has_sig": false,
        "md5_digest": "aa8bdb2dd242f8da3017d4634140af78",
        "packagetype": "bdist_egg",
        "python_version": "2.4",
        "size": 265262,
        "upload_time": "2007-06-22T17:25:03",
        "url": "https://files.pythonhosted.org/packages/f1/6f/e032ef867ac25223feb17768155a287a44b9dbcfec2567fd4133c2c82389/z3c.form-1.3.0-py2.4.egg"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "df014960b16940c361b3c54297a4e8f9",
          "sha256": "2c18759bc0dc46849ebbb22b7ed071deb15cbb32e7d7590cee86f29a01d88e39"
        },
        "downloads": 3335,
        "filename": "z3c.form-1.3.0.tar.gz",
        "has_sig": false,
        "md5_digest": "df014960b16940c361b3c54297a4e8f9",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 215099,
        "upload_time": "2007-06-22T17:02:04",
        "url": "https://files.pythonhosted.org/packages/05/cd/94cd4cbb08e4e777d64499779567fe9f413e7a56f2218b0289c577fad40d/z3c.form-1.3.0.tar.gz"
      }
    ],
    "1.4.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "85ad27e58a69f5f4bbd0fac3b46e2b48",
          "sha256": "82bab99157ce1c8bcad426d12452ce208069505b863007635496a1e813265326"
        },
        "downloads": 3571,
        "filename": "z3c.form-1.4.0-py2.4.egg",
        "has_sig": false,
        "md5_digest": "85ad27e58a69f5f4bbd0fac3b46e2b48",
        "packagetype": "bdist_egg",
        "python_version": "2.4",
        "size": 286478,
        "upload_time": "2007-06-29T05:47:17",
        "url": "https://files.pythonhosted.org/packages/7c/77/05ee3a37dd14396491a9cd4e9790f049b4d8647d1793660ccb9ea02a0bea/z3c.form-1.4.0-py2.4.egg"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "b58f05d3f0eba89b74e5e1373ca2abaa",
          "sha256": "ae5d4a5dc6ab4ab69a1960eed9d577ac5bcddc9ad42f7274cfb99d42d0f4b856"
        },
        "downloads": 3315,
        "filename": "z3c.form-1.4.0.tar.gz",
        "has_sig": false,
        "md5_digest": "b58f05d3f0eba89b74e5e1373ca2abaa",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 232220,
        "upload_time": "2007-06-29T05:46:49",
        "url": "https://files.pythonhosted.org/packages/99/6f/4b2eae29c98b9654857d32ed27437437f25656eff144ae11e4972e45c9bf/z3c.form-1.4.0.tar.gz"
      }
    ],
    "1.4.0b1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "690fd3b414d8e550b5b2f7d0ec755c27",
          "sha256": "8a444aa56152ff32fc3b24c4d2e7b781b70b420cefad44420f0a25e8e8462b96"
        },
        "downloads": 3554,
        "filename": "z3c.form-1.4.0b1-py2.4.egg",
        "has_sig": false,
        "md5_digest": "690fd3b414d8e550b5b2f7d0ec755c27",
        "packagetype": "bdist_egg",
        "python_version": "2.4",
        "size": 275902,
        "upload_time": "2007-06-27T08:12:11",
        "url": "https://files.pythonhosted.org/packages/99/ff/7940a42e31c0f6322bdd7373e84f65003763354b174c07829af379b94772/z3c.form-1.4.0b1-py2.4.egg"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "c94fcfb46560310cd6845344cb8ce224",
          "sha256": "0d88ecc93fcf33317c8127b45257e7e543ef2fad921765cd6ff263e570483c24"
        },
        "downloads": 3321,
        "filename": "z3c.form-1.4.0b1.tar.gz",
        "has_sig": false,
        "md5_digest": "c94fcfb46560310cd6845344cb8ce224",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 225197,
        "upload_time": "2007-06-27T08:11:28",
        "url": "https://files.pythonhosted.org/packages/bf/9d/6c7272ca2fc41683ff561968162fb19eb7720031d6ffe50b162211b597e8/z3c.form-1.4.0b1.tar.gz"
      }
    ],
    "1.5.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "b42e150355d17265e4398ec96f52457b",
          "sha256": "2fb693c187a97df7d9eba2fb5537da1b5b6064027b17f315083a003b1dc00d25"
        },
        "downloads": 3588,
        "filename": "z3c.form-1.5.0-py2.4.egg",
        "has_sig": false,
        "md5_digest": "b42e150355d17265e4398ec96f52457b",
        "packagetype": "bdist_egg",
        "python_version": "2.4",
        "size": 305861,
        "upload_time": "2007-07-18T21:40:22",
        "url": "https://files.pythonhosted.org/packages/72/a9/ddf0568a35c5919a6d37b6bb918c1ff0ef1e0cc3cc6ba396801b28f54d0e/z3c.form-1.5.0-py2.4.egg"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "d0055d004cb5d92613b2976dde0e7e4e",
          "sha256": "48e318214357582a7da58fa733cae807e770bb8d20ae64a0dd50121ab5e67cdd"
        },
        "downloads": 3341,
        "filename": "z3c.form-1.5.0.tar.gz",
        "has_sig": false,
        "md5_digest": "d0055d004cb5d92613b2976dde0e7e4e",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 241960,
        "upload_time": "2007-07-18T21:40:07",
        "url": "https://files.pythonhosted.org/packages/8c/6b/3b19b9501157cd0464bf3c3e68cf0c19a3cf6f295bead6588eca0c1b06b7/z3c.form-1.5.0.tar.gz"
      }
    ],
    "1.5.0b1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "53189783cc91293a32dc836c4de3ec86",
          "sha256": "5a9586919f6cdf04d1ffda1bf7d42d3db6d2ce8e56155490284d3d58b8fe0ebf"
        },
        "downloads": 3599,
        "filename": "z3c.form-1.5.0b1-py2.4.egg",
        "has_sig": false,
        "md5_digest": "53189783cc91293a32dc836c4de3ec86",
        "packagetype": "bdist_egg",
        "python_version": "2.4",
        "size": 298268,
        "upload_time": "2007-07-04T17:28:27",
        "url": "https://files.pythonhosted.org/packages/c9/ea/11e93b1704373b1fbcb20b60fe08777ccb6ac972390b03426c0b34502753/z3c.form-1.5.0b1-py2.4.egg"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "b1daeebb0a069d9c518f3d7c6465fd42",
          "sha256": "92305ddf9460905870a0ef6e8bb3dff51bcb23194e06dd7058d5460852c27272"
        },
        "downloads": 3299,
        "filename": "z3c.form-1.5.0b1.tar.gz",
        "has_sig": false,
        "md5_digest": "b1daeebb0a069d9c518f3d7c6465fd42",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 238445,
        "upload_time": "2007-07-04T17:27:49",
        "url": "https://files.pythonhosted.org/packages/5a/6c/a698b6aca2a274102109a066dde1d3e3d13e95979b035a4740a6d785dd98/z3c.form-1.5.0b1.tar.gz"
      }
    ],
    "1.6.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "8c04585212f44d6017fd463deb6ef8f4",
          "sha256": "d0fe6adc99e287a05ba2b00b06c83cf7c5b5c56052b911e732a4e28f46a3e67f"
        },
        "downloads": 3580,
        "filename": "z3c.form-1.6.0-py2.4.egg",
        "has_sig": false,
        "md5_digest": "8c04585212f44d6017fd463deb6ef8f4",
        "packagetype": "bdist_egg",
        "python_version": "2.4",
        "size": 309789,
        "upload_time": "2007-08-24T03:36:21",
        "url": "https://files.pythonhosted.org/packages/e4/e2/3299bbab5138e52a86f6831efcac39de7eb3cc0f2c25e95ffab9bd53dc9b/z3c.form-1.6.0-py2.4.egg"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "a2945cb4ccbddb9afa86dfa4ada81eaa",
          "sha256": "04a3153433da9aea9ce10f8c6627c538406776f57300a74ec5fef12a06ff4951"
        },
        "downloads": 3355,
        "filename": "z3c.form-1.6.0.tar.gz",
        "has_sig": false,
        "md5_digest": "a2945cb4ccbddb9afa86dfa4ada81eaa",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 253689,
        "upload_time": "2007-08-24T03:36:13",
        "url": "https://files.pythonhosted.org/packages/07/0e/595d7a8faceda380f202d8a7cab9e3b1e29cb6a4677379b5d4bb00697976/z3c.form-1.6.0.tar.gz"
      }
    ],
    "1.7.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "c703997c20bac5776c57b6db37746a6d",
          "sha256": "51c10cf66176894b90dd127d8298f66942672e0f09214486aaa35ce432b29dd6"
        },
        "downloads": 3919,
        "filename": "z3c.form-1.7.0.tar.gz",
        "has_sig": false,
        "md5_digest": "c703997c20bac5776c57b6db37746a6d",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 261011,
        "upload_time": "2007-10-10T02:03:08",
        "url": "https://files.pythonhosted.org/packages/5d/00/bcf2dfb088dc22df001ab18239b2621205f513b8ac921c887f12b950ee1f/z3c.form-1.7.0.tar.gz"
      }
    ],
    "1.8.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "ba1dbf232bdd31fc2c8ce0219c4ac289",
          "sha256": "69a58dc62d8082a3c45b7d3ec70f2c2c698f6bc75990c0d73bce1bb09522527d"
        },
        "downloads": 4469,
        "filename": "z3c.form-1.8.0.tar.gz",
        "has_sig": false,
        "md5_digest": "ba1dbf232bdd31fc2c8ce0219c4ac289",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 265696,
        "upload_time": "2008-01-23T21:47:52",
        "url": "https://files.pythonhosted.org/packages/18/0a/881a2503c1381b52bf768cf9b33b06f5845388ce38634c9f2d528df9de2e/z3c.form-1.8.0.tar.gz"
      }
    ],
    "1.8.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "1561b2d69e6aae54eaa8e9cb0686cf73",
          "sha256": "ac864fe183f215dc94eeb91345bfa2ff51b58e6f6fd6f622a608839a3eb8a77a"
        },
        "downloads": 3564,
        "filename": "z3c.form-1.8.1.tar.gz",
        "has_sig": false,
        "md5_digest": "1561b2d69e6aae54eaa8e9cb0686cf73",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 268575,
        "upload_time": "2008-04-08T20:54:14",
        "url": "https://files.pythonhosted.org/packages/a0/c2/18f33561f237f2d97a31b1d3d7ab6b2c89eb83135dd493e6590bd4604f96/z3c.form-1.8.1.tar.gz"
      }
    ],
    "1.8.2": [
      {
        "comment_text": "",
        "digests": {
          "md5": "8ff672ee36251040a006249136668f9d",
          "sha256": "f925f1140adf4b885ea2cdd2c9626f00a900f22c7db3c4939901e476a42a33f4"
        },
        "downloads": 5250,
        "filename": "z3c.form-1.8.2.tar.gz",
        "has_sig": false,
        "md5_digest": "8ff672ee36251040a006249136668f9d",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 268990,
        "upload_time": "2008-04-25T01:20:46",
        "url": "https://files.pythonhosted.org/packages/0f/2d/1e2032b0ea0996cd476d8d2a632e270f461cebca7c86d979187ec7f9b940/z3c.form-1.8.2.tar.gz"
      }
    ],
    "1.9.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "23ae49ad729d490bb9bb346e50241c57",
          "sha256": "670844af299c9190a6c66ffc40b54f85b609534191e519472f1e160fac4106d6"
        },
        "downloads": 25036,
        "filename": "z3c.form-1.9.0.tar.gz",
        "has_sig": false,
        "md5_digest": "23ae49ad729d490bb9bb346e50241c57",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 277281,
        "upload_time": "2008-08-27T04:30:21",
        "url": "https://files.pythonhosted.org/packages/60/f4/6614bb0aeb763ff665eb2e397405dd4d87dfaf0d3bbe087a014e0ab9e3de/z3c.form-1.9.0.tar.gz"
      }
    ],
    "2.0.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "77920ac521aca059d2497cf45a0a5db0",
          "sha256": "e90d2ac0038c0659d411559a6f603f5e7e081aa095c6dfdc0dc8bb833e73859c"
        },
        "downloads": 4170,
        "filename": "z3c.form-2.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "77920ac521aca059d2497cf45a0a5db0",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 387385,
        "upload_time": "2009-06-14T04:49:20",
        "url": "https://files.pythonhosted.org/packages/39/45/7fc28377dfe125c641d56769d3a61a8a973b237490973344d1a115a55488/z3c.form-2.0.0.tar.gz"
      }
    ],
    "2.1.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "a94612c21669f302e1d4fb2b270489d4",
          "sha256": "b979a32282361c08016c27cd41d26ebd91e1a38d86293fd7a0dfd4cccfaea6a1"
        },
        "downloads": 6273,
        "filename": "z3c.form-2.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "a94612c21669f302e1d4fb2b270489d4",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 397618,
        "upload_time": "2009-07-23T05:20:21",
        "url": "https://files.pythonhosted.org/packages/7b/cd/80fc6c46d5bb58e7eaf68496b6d6951b0d3e92193d17b9480c11f4c45cbf/z3c.form-2.1.0.tar.gz"
      }
    ],
    "2.2.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "5c0611913b76d8671cf59554ade20a19",
          "sha256": "2966da138c9d83cd4e024365792fa7dd25faaa7979a037c1ce327547ff0b0f89"
        },
        "downloads": 6767,
        "filename": "z3c.form-2.2.0.tar.gz",
        "has_sig": false,
        "md5_digest": "5c0611913b76d8671cf59554ade20a19",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 381305,
        "upload_time": "2009-10-27T21:12:50",
        "url": "https://files.pythonhosted.org/packages/6e/40/c52ab101ae1ef634c0752af4e5837c955dcfe2c966bfc4ed31ace732dc36/z3c.form-2.2.0.tar.gz"
      }
    ],
    "2.3.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "9ac156b89c218059321f1ae892406c41",
          "sha256": "f7e2d768c7f92f21dbb3524414b714f334aa3c1a1b858cc603be08fefdfec271"
        },
        "downloads": 3603,
        "filename": "z3c.form-2.3.0.tar.gz",
        "has_sig": false,
        "md5_digest": "9ac156b89c218059321f1ae892406c41",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 381421,
        "upload_time": "2009-12-28T12:54:17",
        "url": "https://files.pythonhosted.org/packages/9e/4b/b08bd76e0ff13c09d4372cd24e753e93e5cd61e70458e22e502e2f66772b/z3c.form-2.3.0.tar.gz"
      }
    ],
    "2.3.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "53e22a60779645aa5ad7f20d96267e3a",
          "sha256": "7e459d30e6a75c4de117f67fb346fe380893ce4b9c59e37dfffa445bbcf9af0b"
        },
        "downloads": 3481,
        "filename": "z3c.form-2.3.1.tar.gz",
        "has_sig": false,
        "md5_digest": "53e22a60779645aa5ad7f20d96267e3a",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 381571,
        "upload_time": "2010-01-18T21:31:34",
        "url": "https://files.pythonhosted.org/packages/a9/ea/14a3def47fdd175d8c34ecd98f506b43e5d6f413023689c3fb6f684624c4/z3c.form-2.3.1.tar.gz"
      }
    ],
    "2.3.2": [
      {
        "comment_text": "",
        "digests": {
          "md5": "85e2297ca6bdbc7a794ee4e868dce8c8",
          "sha256": "41767b3e57c75d8b27d43e4decff52c9f700ab7debc454b11ac1f79420374802"
        },
        "downloads": 8041,
        "filename": "z3c.form-2.3.2.tar.gz",
        "has_sig": false,
        "md5_digest": "85e2297ca6bdbc7a794ee4e868dce8c8",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 382212,
        "upload_time": "2010-01-21T21:21:33",
        "url": "https://files.pythonhosted.org/packages/4d/89/14aa46ce8265480a7beac6067857101894478033c3350ee73e093cfc0943/z3c.form-2.3.2.tar.gz"
      }
    ],
    "2.3.3": [
      {
        "comment_text": "",
        "digests": {
          "md5": "e56a6312f46ca9976c8cae682933b76f",
          "sha256": "691c7599d46568fdd0190a18d977838b680d83c6e157bb5a60ca4ac016ee0b9a"
        },
        "downloads": 15983,
        "filename": "z3c.form-2.3.3.tar.gz",
        "has_sig": false,
        "md5_digest": "e56a6312f46ca9976c8cae682933b76f",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 392495,
        "upload_time": "2010-04-20T09:26:56",
        "url": "https://files.pythonhosted.org/packages/cf/11/8c7d007546ed9e9bac105f39fac3d8ddae4aa6c656755f8f8e71c32488eb/z3c.form-2.3.3.tar.gz"
      }
    ],
    "2.3.4": [
      {
        "comment_text": "",
        "digests": {
          "md5": "f8338857c4ea95ab451ca2b3bed0c5d5",
          "sha256": "9a21e833fb82108ff72975ace880cc477c44cc88628f37aa8218d960a37429bb"
        },
        "downloads": 4591,
        "filename": "z3c.form-2.3.4.tar.gz",
        "has_sig": false,
        "md5_digest": "f8338857c4ea95ab451ca2b3bed0c5d5",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 388322,
        "upload_time": "2010-05-17T13:05:38",
        "url": "https://files.pythonhosted.org/packages/8e/cf/b18ecbfeda21cf1f374835091134a17cd1f5a478227a845a691d4aba3266/z3c.form-2.3.4.tar.gz"
      }
    ],
    "2.4.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "ee8dab7c2e0c3732a3d452b6c96b96d1",
          "sha256": "f7630a0132b747be00753429608a62bc2aebd113c8a953573307b1c7b62292b8"
        },
        "downloads": 3645,
        "filename": "z3c.form-2.4.0.tar.gz",
        "has_sig": false,
        "md5_digest": "ee8dab7c2e0c3732a3d452b6c96b96d1",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 396687,
        "upload_time": "2010-07-01T14:55:37",
        "url": "https://files.pythonhosted.org/packages/7e/d6/639973f61c51523b4be0fcf7eab9eaa8e10d0aa3055512c38be66a586201/z3c.form-2.4.0.tar.gz"
      }
    ],
    "2.4.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "f57fa311633df146d5f45b80ce1e8e2c",
          "sha256": "fa7ccad03796917a0f27414416b76a97a08aa4e908235c27ff00da675ff23623"
        },
        "downloads": 12282,
        "filename": "z3c.form-2.4.1.tar.gz",
        "has_sig": false,
        "md5_digest": "f57fa311633df146d5f45b80ce1e8e2c",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 396057,
        "upload_time": "2010-07-18T21:07:36",
        "url": "https://files.pythonhosted.org/packages/4b/98/38d551243da346de770932b6d350ccdb16867cc0a3451c31ad4c19de7d04/z3c.form-2.4.1.tar.gz"
      }
    ],
    "2.4.2": [
      {
        "comment_text": "",
        "digests": {
          "md5": "ef643d3b57003aef3086888863521c24",
          "sha256": "856e2717b42885af8b98996aa40ed42a0f68afea3d936a33f375a912e32325cd"
        },
        "downloads": 10360,
        "filename": "z3c.form-2.4.2.zip",
        "has_sig": true,
        "md5_digest": "ef643d3b57003aef3086888863521c24",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 498546,
        "upload_time": "2011-01-23T01:16:36",
        "url": "https://files.pythonhosted.org/packages/23/1d/db6bb6cc74fd83c17d8f58bfd9695fda02539a07587d0181884e2f518f37/z3c.form-2.4.2.zip"
      }
    ],
    "2.4.3": [
      {
        "comment_text": "",
        "digests": {
          "md5": "7bffbe3a921509b106d66b37670a59db",
          "sha256": "406806a093821361e9c5f79e46ab35c1d43f9276de40d797b45097501b1d880f"
        },
        "downloads": 16080,
        "filename": "z3c.form-2.4.3.zip",
        "has_sig": false,
        "md5_digest": "7bffbe3a921509b106d66b37670a59db",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 555488,
        "upload_time": "2011-05-20T16:45:52",
        "url": "https://files.pythonhosted.org/packages/3c/89/39ef05d154b6b399492c0e85ed2e54937d2fc56921b669ebb33b57f6ad8f/z3c.form-2.4.3.zip"
      }
    ],
    "2.4.4": [
      {
        "comment_text": "",
        "digests": {
          "md5": "30e8b04297bbdf10db4517205e8759cf",
          "sha256": "22682b22c16bd4b0d6201ae499b775193c0b2dbbe09407ad6edce7598d63e100"
        },
        "downloads": 10231,
        "filename": "z3c.form-2.4.4.tar.gz",
        "has_sig": false,
        "md5_digest": "30e8b04297bbdf10db4517205e8759cf",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 414519,
        "upload_time": "2011-07-11T18:52:00",
        "url": "https://files.pythonhosted.org/packages/14/fd/91d0c935a1be3aea1add4cc9269d80eabac55c6691aef4f38f4a4bf2718a/z3c.form-2.4.4.tar.gz"
      }
    ],
    "2.5.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "8daec640ffe0246fc501c8aade0ebf05",
          "sha256": "514ff0c71e4932d4dc689521dd8a9595869e8b9cf209bf60b5b34b20f99db580"
        },
        "downloads": 3407,
        "filename": "z3c.form-2.5.0.zip",
        "has_sig": false,
        "md5_digest": "8daec640ffe0246fc501c8aade0ebf05",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 543741,
        "upload_time": "2011-10-29T23:11:22",
        "url": "https://files.pythonhosted.org/packages/89/02/1760ab95924d4fd1a59d94470c2cb644b863849029c3d309072a85f7d49f/z3c.form-2.5.0.zip"
      }
    ],
    "2.5.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "f029f83dd226f695f55049ed1ecee95e",
          "sha256": "d54ebf36b8a323ae2801ef8ec6aa9ed515c8aabf0cd389036fef3d182c1f4738"
        },
        "downloads": 27162,
        "filename": "z3c.form-2.5.1.tar.gz",
        "has_sig": false,
        "md5_digest": "f029f83dd226f695f55049ed1ecee95e",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 453490,
        "upload_time": "2011-11-26T12:52:13",
        "url": "https://files.pythonhosted.org/packages/27/df/f73f782c896dc31177d4ee70f6eb3235463c10f78da88290daa4abb9ca7b/z3c.form-2.5.1.tar.gz"
      }
    ],
    "2.6.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "95f219c3cbe42cb9dec1d689b1e626a1",
          "sha256": "c3c920f7bf54389b6afd89a0348b148fa007e090aae5f8f4d2fa64b7f05546e9"
        },
        "downloads": 2943,
        "filename": "z3c.form-2.6.0.tar.gz",
        "has_sig": false,
        "md5_digest": "95f219c3cbe42cb9dec1d689b1e626a1",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 466467,
        "upload_time": "2012-01-30T10:17:26",
        "url": "https://files.pythonhosted.org/packages/e4/65/6e7e2d6d3a83c4e5683b6bc05f802792be86ae0d080991c9daf646222d6b/z3c.form-2.6.0.tar.gz"
      }
    ],
    "2.6.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "9cfa09350dde431afee0cf840d3927d2",
          "sha256": "0f69540af8061ba5f5e6bb3d84054360aaf4025f57f4eb855ad6ee1baa2a5560"
        },
        "downloads": 5619,
        "filename": "z3c.form-2.6.1.tar.gz",
        "has_sig": false,
        "md5_digest": "9cfa09350dde431afee0cf840d3927d2",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 441863,
        "upload_time": "2012-01-31T05:09:41",
        "url": "https://files.pythonhosted.org/packages/9d/9f/0f57335323f1785236cdc4496b8c7cd071b14929a74cb04f0982d1209f04/z3c.form-2.6.1.tar.gz"
      }
    ],
    "2.7.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "0bba2ee5d4f6f825bd14d96f5b3c46a0",
          "sha256": "41563a699b0a5f975d0de155b0919db03462330df0e978b7d7e8cecbc4d682c8"
        },
        "downloads": 2969,
        "filename": "z3c.form-2.7.0.zip",
        "has_sig": false,
        "md5_digest": "0bba2ee5d4f6f825bd14d96f5b3c46a0",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 541701,
        "upload_time": "2012-07-11T16:26:34",
        "url": "https://files.pythonhosted.org/packages/a8/34/be004acbc1d688408c44e7b1cc92a7d2ee8eeb191b1a92924de98b8a3ec9/z3c.form-2.7.0.zip"
      }
    ],
    "2.8.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "0e066b6a0ae4e7c9e92e09a65854bf36",
          "sha256": "a923eacb216743b0225e9e366d5fb86b0d123201d9a4730159124ff414c758fe"
        },
        "downloads": 2658,
        "filename": "z3c.form-2.8.0.zip",
        "has_sig": false,
        "md5_digest": "0e066b6a0ae4e7c9e92e09a65854bf36",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 537702,
        "upload_time": "2012-08-06T03:48:27",
        "url": "https://files.pythonhosted.org/packages/e7/f8/b9a24b3436e3f99df119989d2f8dbc6fd5a6ad26d74ea8b75f384577e6f2/z3c.form-2.8.0.zip"
      }
    ],
    "2.8.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "f6b0b845679850427d35c47130b16e78",
          "sha256": "0776b9f71e9e3c769572912628cccac04e7a74bb8f58b568aa4279bc28c6e1a1"
        },
        "downloads": 2694,
        "filename": "z3c.form-2.8.1.zip",
        "has_sig": false,
        "md5_digest": "f6b0b845679850427d35c47130b16e78",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 538870,
        "upload_time": "2012-08-06T07:12:51",
        "url": "https://files.pythonhosted.org/packages/eb/69/023f77ebbea59beaba1cd53249fdf7e539f86c9cb410b8c19db68a92020e/z3c.form-2.8.1.zip"
      }
    ],
    "2.8.2": [
      {
        "comment_text": "",
        "digests": {
          "md5": "b645cff9040850ff23fe41a79b876ac3",
          "sha256": "6d1d2205afea375da68174cf2257718bf536294f005a1ed512c59ea19829c481"
        },
        "downloads": 3846,
        "filename": "z3c.form-2.8.2.zip",
        "has_sig": false,
        "md5_digest": "b645cff9040850ff23fe41a79b876ac3",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 550212,
        "upload_time": "2012-08-17T13:21:10",
        "url": "https://files.pythonhosted.org/packages/fa/3f/1fa83b21657cb25eba818ba7779819a6167be0d296e8b48577f25c37c3e6/z3c.form-2.8.2.zip"
      }
    ],
    "2.9.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "331d1c10f34e052583d4815525b23be7",
          "sha256": "553088c2e3194fe70418a75c3815b4c86961f62c694fd9af9a326b2adc83a152"
        },
        "downloads": 3387,
        "filename": "z3c.form-2.9.0.zip",
        "has_sig": false,
        "md5_digest": "331d1c10f34e052583d4815525b23be7",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 565187,
        "upload_time": "2012-09-17T13:19:56",
        "url": "https://files.pythonhosted.org/packages/ac/b3/7ef1e7871c8ba96ff27f49107e31061f268ac1487b279531762192171b20/z3c.form-2.9.0.zip"
      }
    ],
    "2.9.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "1e8d0fb817fcdf47319519530e0e035b",
          "sha256": "3c85c5b8d1a82a27877db6f1ca584ab34fe1bcc3d8229f23dfefd328170fbc37"
        },
        "downloads": 3384,
        "filename": "z3c.form-2.9.1.zip",
        "has_sig": false,
        "md5_digest": "1e8d0fb817fcdf47319519530e0e035b",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 577417,
        "upload_time": "2012-11-27T10:03:56",
        "url": "https://files.pythonhosted.org/packages/3d/f9/271b611c2dbd1f686bb8e17d899dad9d7d0c4bebc356d932aa09451482f4/z3c.form-2.9.1.zip"
      }
    ],
    "3.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "f9fa3cf56c83722425b3b1be4467ce46",
          "sha256": "9900e6f64952057446f224483ad8eeb01c5270dcc4a0b88261ced802aa312c44"
        },
        "downloads": 5392,
        "filename": "z3c.form-3.0.zip",
        "has_sig": false,
        "md5_digest": "f9fa3cf56c83722425b3b1be4467ce46",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 1040706,
        "upload_time": "2013-05-24T02:26:36",
        "url": "https://files.pythonhosted.org/packages/f3/e0/bd62310b34ec68d36ce19335cde88da917b105cada56d7d96be0058d6d49/z3c.form-3.0.zip"
      }
    ],
    "3.0.0a1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "e071ffe6d44f75c97cc04100e2d9d964",
          "sha256": "580094f5efbb3b6b5aec0a5fff0225d1e9589b51d5e034c032102dba49b3366d"
        },
        "downloads": 2248,
        "filename": "z3c.form-3.0.0a1.zip",
        "has_sig": false,
        "md5_digest": "e071ffe6d44f75c97cc04100e2d9d964",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 502750,
        "upload_time": "2013-02-24T22:07:06",
        "url": "https://files.pythonhosted.org/packages/97/63/07ee24f59cb379ffa06ebf1be55d79a274367c7831ed297f6dc214776787/z3c.form-3.0.0a1.zip"
      }
    ],
    "3.0.0a2": [
      {
        "comment_text": "",
        "digests": {
          "md5": "c4468ed0273901fb887cca9cfd1bb2cb",
          "sha256": "936bd3f1643a78657918b280dd4b8364096d09b0d8f49044a6e184e4721999ba"
        },
        "downloads": 3563,
        "filename": "z3c.form-3.0.0a2.zip",
        "has_sig": false,
        "md5_digest": "c4468ed0273901fb887cca9cfd1bb2cb",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 640712,
        "upload_time": "2013-02-26T07:24:17",
        "url": "https://files.pythonhosted.org/packages/91/8b/b91c206a2f97f25468eeab31b75892edd9f10f1349757aab58ddc9d0537b/z3c.form-3.0.0a2.zip"
      }
    ],
    "3.0.0a3": [
      {
        "comment_text": "",
        "digests": {
          "md5": "557032834c90b71cf55b1068ee41472b",
          "sha256": "1575d8c1abe802b3b4ebb5efa3490017989c50491c40d2e2655e14e7598bf41c"
        },
        "downloads": 5486,
        "filename": "z3c.form-3.0.0a3.zip",
        "has_sig": false,
        "md5_digest": "557032834c90b71cf55b1068ee41472b",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 1038242,
        "upload_time": "2013-04-06T16:28:47",
        "url": "https://files.pythonhosted.org/packages/51/bb/65555e78f8cdaf84f49d1cd60a3db92c1b42d401d93f138dc28f0f7be6da/z3c.form-3.0.0a3.zip"
      }
    ],
    "3.0.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "7c9338dbe89b8c27ebba7441b14786ac",
          "sha256": "72da959ed4019a5e1f6456a926b9d223ae658dd4419e077f9c1918521283c187"
        },
        "downloads": 2101,
        "filename": "z3c.form-3.0.1.zip",
        "has_sig": false,
        "md5_digest": "7c9338dbe89b8c27ebba7441b14786ac",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 585365,
        "upload_time": "2013-06-25T14:36:17",
        "url": "https://files.pythonhosted.org/packages/21/de/4f13f4e8a74ee3fc7f4ec51f49693e4d376bbef78d527aecd901f0815d0a/z3c.form-3.0.1.zip"
      }
    ],
    "3.0.2": [
      {
        "comment_text": "",
        "digests": {
          "md5": "8eab166766c6ae2e44e40f54136b3f79",
          "sha256": "1794b46e2b95709337ab0cd86a65f30cdd65614a140d740c99abcf7f0f308f9c"
        },
        "downloads": 9415,
        "filename": "z3c.form-3.0.2.zip",
        "has_sig": false,
        "md5_digest": "8eab166766c6ae2e44e40f54136b3f79",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 646395,
        "upload_time": "2013-08-13T22:11:56",
        "url": "https://files.pythonhosted.org/packages/7d/98/7f503206174416805c6df005f3cba03c167c60cd135630087f6318652cea/z3c.form-3.0.2.zip"
      }
    ],
    "3.0.3": [
      {
        "comment_text": "",
        "digests": {
          "md5": "15e9e50ee55b0c9c084268676a6ae1b5",
          "sha256": "53e67b6cacbe55eae086863990dad8d55f8f08837e1ce28e8f6e2abadffb46ea"
        },
        "downloads": 2133,
        "filename": "z3c.form-3.0.3.zip",
        "has_sig": false,
        "md5_digest": "15e9e50ee55b0c9c084268676a6ae1b5",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 587406,
        "upload_time": "2013-09-06T18:53:17",
        "url": "https://files.pythonhosted.org/packages/56/80/a77a218389c1bfbe54a56279d17f0ef9eeefd461d8f5c4ef40100dc536e1/z3c.form-3.0.3.zip"
      }
    ],
    "3.0.4": [
      {
        "comment_text": "",
        "digests": {
          "md5": "b88db97078a5e4ebfa6b7ee845ef6910",
          "sha256": "82b590259ad2e6ec1f1f0a82ee5835cdaca6a72c386310bd7b4b621b495c3dd1"
        },
        "downloads": 1853,
        "filename": "z3c.form-3.0.4.zip",
        "has_sig": false,
        "md5_digest": "b88db97078a5e4ebfa6b7ee845ef6910",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 587808,
        "upload_time": "2013-10-06T18:05:22",
        "url": "https://files.pythonhosted.org/packages/b4/c3/d4830eb877a8d05c94397d3845c07415e1e6c480a1d8285d68fc3a512714/z3c.form-3.0.4.zip"
      }
    ],
    "3.0.5": [
      {
        "comment_text": "",
        "digests": {
          "md5": "fe9192c7d730e304342bcb42a35d8d16",
          "sha256": "c855ed2bbc4f13cad07a0f2f2ff5b70328603898f6128d884d0ce847035f48e9"
        },
        "downloads": 9829,
        "filename": "z3c.form-3.0.5.zip",
        "has_sig": false,
        "md5_digest": "fe9192c7d730e304342bcb42a35d8d16",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 587884,
        "upload_time": "2013-10-10T01:04:34",
        "url": "https://files.pythonhosted.org/packages/ce/51/0e2d827e340c6160edd645f5ce4735e82b6d709abf84df62d074cdae2684/z3c.form-3.0.5.zip"
      }
    ],
    "3.1.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "368128a1d69bf912c49f183e2d49e3b2",
          "sha256": "de476d9cfb938cf40c996e1f8b9c3f7772677579f6fe9fe0ee368e6aecb610fe"
        },
        "downloads": 6376,
        "filename": "z3c.form-3.1.0.zip",
        "has_sig": false,
        "md5_digest": "368128a1d69bf912c49f183e2d49e3b2",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 590609,
        "upload_time": "2013-12-02T15:14:04",
        "url": "https://files.pythonhosted.org/packages/7b/46/4984226644d6f0edd11c16d1cb5567f76013566872ae2468a86f164058c7/z3c.form-3.1.0.zip"
      }
    ],
    "3.1.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "0b54d848d6a1be9eab867255e10f5504",
          "sha256": "97353891874877d20cfe4d1da052d09f56eff4735172e7f9931b8c571a3c8f0c"
        },
        "downloads": 7645,
        "filename": "z3c.form-3.1.1.zip",
        "has_sig": false,
        "md5_digest": "0b54d848d6a1be9eab867255e10f5504",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 650501,
        "upload_time": "2014-03-02T06:04:33",
        "url": "https://files.pythonhosted.org/packages/08/a7/ca794b7c2114588cca41ad634d30fb3c15d16582bbc4b19c8d63d8e8a8c9/z3c.form-3.1.1.zip"
      }
    ],
    "3.2.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "68a1f5076a482fb19876363ec6d327d6",
          "sha256": "a4d976b746e148ef0155fa9080baf67adbfaaf160fbd3a8bf6e606b4587cf8e1"
        },
        "downloads": 2033,
        "filename": "z3c.form-3.2.0.zip",
        "has_sig": false,
        "md5_digest": "68a1f5076a482fb19876363ec6d327d6",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 591338,
        "upload_time": "2014-03-19T00:18:41",
        "url": "https://files.pythonhosted.org/packages/a7/8c/85488b7f479c46b070f1c095485f4471e3cc44c06265cf07ebac42112035/z3c.form-3.2.0.zip"
      }
    ],
    "3.2.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "95a8cee9e60e7a113c8ab58544046227",
          "sha256": "ab294ea6c93f8d05b613d4ec6fe4883e86ac3b7e095c585663926aa431606ea0"
        },
        "downloads": 12764,
        "filename": "z3c.form-3.2.1.zip",
        "has_sig": false,
        "md5_digest": "95a8cee9e60e7a113c8ab58544046227",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 653425,
        "upload_time": "2014-04-22T17:08:28",
        "url": "https://files.pythonhosted.org/packages/a7/83/77bf5c58fdf6b0f8b43c5334e5637dc64d53a5ae43ed2f034a099054f271/z3c.form-3.2.1.zip"
      }
    ],
    "3.2.10": [
      {
        "comment_text": "",
        "digests": {
          "md5": "fd4d172dc7c73de53790e8cc0258aca3",
          "sha256": "31b3fdabf939909d5e0670be018fe51eb7b8a9929607c9e9c1a8508f9e3ea182"
        },
        "downloads": 174,
        "filename": "z3c.form-3.2.10.tar.gz",
        "has_sig": false,
        "md5_digest": "fd4d172dc7c73de53790e8cc0258aca3",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 483564,
        "upload_time": "2016-03-09T13:34:36",
        "url": "https://files.pythonhosted.org/packages/6e/fc/0ae7dc440e7522c8e4afeae85d690c2886f04212e185f7856110ed8387eb/z3c.form-3.2.10.tar.gz"
      }
    ],
    "3.2.11": [
      {
        "comment_text": "",
        "digests": {
          "md5": "d043c12bbc66d2aa526ad45fd3a59b38",
          "sha256": "aa97a5941a3090b0974aa5228097ce252ce5f6d56753745d66235f3a8c37ad8d"
        },
        "downloads": 263,
        "filename": "z3c.form-3.2.11.tar.gz",
        "has_sig": false,
        "md5_digest": "d043c12bbc66d2aa526ad45fd3a59b38",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 530854,
        "upload_time": "2016-11-15T22:04:41",
        "url": "https://files.pythonhosted.org/packages/26/02/56e16c4c7d8ca170e5c54623c54a9d15a7fd77f2641e6947884df9031196/z3c.form-3.2.11.tar.gz"
      }
    ],
    "3.2.2": [
      {
        "comment_text": "",
        "digests": {
          "md5": "0480eaeea64010080a29146639c7f239",
          "sha256": "77a3950cb4b83ff87726e2c2e64c4b2086d0af01383de74c51f4ad26d9bc1933"
        },
        "downloads": 1118,
        "filename": "z3c.form-3.2.2.zip",
        "has_sig": false,
        "md5_digest": "0480eaeea64010080a29146639c7f239",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 652966,
        "upload_time": "2015-03-21T19:33:11",
        "url": "https://files.pythonhosted.org/packages/e8/4e/69e23e5d8b123e848f57b207fdc5767cef61414ecea5f3066e2e608b64af/z3c.form-3.2.2.zip"
      }
    ],
    "3.2.3": [
      {
        "comment_text": "",
        "digests": {
          "md5": "99b3d25fa4319c930d702738e9a3cbf0",
          "sha256": "209a49f2c50e47399668b87a2bd8aec291e5770bf0c31998a9390213783729ef"
        },
        "downloads": 7232,
        "filename": "z3c.form-3.2.3.zip",
        "has_sig": false,
        "md5_digest": "99b3d25fa4319c930d702738e9a3cbf0",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 654489,
        "upload_time": "2015-03-21T20:41:26",
        "url": "https://files.pythonhosted.org/packages/b8/4b/10b7fe477465f1f88ff751ebd42e706ff9b9b41e4ea57e5b62c53373d308/z3c.form-3.2.3.zip"
      }
    ],
    "3.2.4": [
      {
        "comment_text": "",
        "digests": {
          "md5": "4aea7c74a2e996e7831d79511f12d900",
          "sha256": "037d42b3fb2eecbdefa6b00daee1a13c711aa27befe1dd5a912312bd6c788ec3"
        },
        "downloads": 8103,
        "filename": "z3c.form-3.2.4.tar.gz",
        "has_sig": false,
        "md5_digest": "4aea7c74a2e996e7831d79511f12d900",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 512273,
        "upload_time": "2015-07-18T13:59:50",
        "url": "https://files.pythonhosted.org/packages/65/5b/5bdb079cb28bbcd70f397d81aaae911e6dedc12e9cb1a50e26e8dda32eca/z3c.form-3.2.4.tar.gz"
      }
    ],
    "3.2.5": [
      {
        "comment_text": "",
        "digests": {
          "md5": "ea51402141f62026e157a6b61b5ea78e",
          "sha256": "5951ed28b21a7cb3d19406341c4f756f1bb16ed0305d0c280c5623d8300796a2"
        },
        "downloads": 646,
        "filename": "z3c.form-3.2.5.tar.gz",
        "has_sig": false,
        "md5_digest": "ea51402141f62026e157a6b61b5ea78e",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 512627,
        "upload_time": "2015-09-08T23:14:36",
        "url": "https://files.pythonhosted.org/packages/8d/5e/3d2f350aac5b02ae7aad017615666e1d5f52ce143ec967b11630ba171cf3/z3c.form-3.2.5.tar.gz"
      }
    ],
    "3.2.6": [
      {
        "comment_text": "",
        "digests": {
          "md5": "4d74a937bb80cc92aacfa042dc76bb36",
          "sha256": "e873a9a647d6c7f71bd0ce941497d4c6b52a7b77b29fa9da5ca857aac0281b30"
        },
        "downloads": 1293,
        "filename": "z3c.form-3.2.6.tar.gz",
        "has_sig": false,
        "md5_digest": "4d74a937bb80cc92aacfa042dc76bb36",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 523728,
        "upload_time": "2015-09-10T14:46:59",
        "url": "https://files.pythonhosted.org/packages/9a/5a/8b44215607c930b66fd3c0bd9425fa7e0036c2e64e260e9cfb1f17e57e2e/z3c.form-3.2.6.tar.gz"
      }
    ],
    "3.2.7": [
      {
        "comment_text": "",
        "digests": {
          "md5": "3339800cbaf1bffa445d3ba8d588da3d",
          "sha256": "e9e67b0d6682f8aabad1835f5b5060e300bb52b069d038f94f37d858179d1c2b"
        },
        "downloads": 4778,
        "filename": "z3c.form-3.2.7.tar.gz",
        "has_sig": false,
        "md5_digest": "3339800cbaf1bffa445d3ba8d588da3d",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 523750,
        "upload_time": "2015-09-20T19:34:26",
        "url": "https://files.pythonhosted.org/packages/60/1c/7d7ecbb82f99ea3631ee9316d9e506210ab548df6ac0fcadf2543582ae80/z3c.form-3.2.7.tar.gz"
      }
    ],
    "3.2.8": [
      {
        "comment_text": "",
        "digests": {
          "md5": "163de4609acbc19017c53139d2c829b5",
          "sha256": "0a1955efc5b6a6212ba3696f8878eeac86f5611f68b16565f410ed48bb653234"
        },
        "downloads": 1077,
        "filename": "z3c.form-3.2.8.tar.gz",
        "has_sig": false,
        "md5_digest": "163de4609acbc19017c53139d2c829b5",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 473917,
        "upload_time": "2015-11-09T14:54:59",
        "url": "https://files.pythonhosted.org/packages/8a/73/25421b8492e50e714812db26a87881d9cacaa12595c1bdf6a02dc318ae67/z3c.form-3.2.8.tar.gz"
      }
    ],
    "3.2.9": [
      {
        "comment_text": "",
        "digests": {
          "md5": "c44d024efb98e9276a4e9c0602651ca5",
          "sha256": "28a73c47c271cf53cc7096c970ec662848363d17b164a0be06a0ad57cc796638"
        },
        "downloads": 2112,
        "filename": "z3c.form-3.2.9.tar.gz",
        "has_sig": false,
        "md5_digest": "c44d024efb98e9276a4e9c0602651ca5",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 530164,
        "upload_time": "2016-02-01T11:02:05",
        "url": "https://files.pythonhosted.org/packages/53/cd/822de17a3ef2d49da5467e3a6377b8b29e336535f551f9a2f81274fd29ff/z3c.form-3.2.9.tar.gz"
      }
    ],
    "3.3.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "a4f8c5d376785eedfdd8525c3c635533",
          "sha256": "f6b53443327cc60c436a8898e25ccbe09820cab987a3c9795faa96a1d1b797df"
        },
        "downloads": 523,
        "filename": "z3c.form-3.3.0.tar.gz",
        "has_sig": false,
        "md5_digest": "a4f8c5d376785eedfdd8525c3c635533",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 495517,
        "upload_time": "2016-03-09T13:53:44",
        "url": "https://files.pythonhosted.org/packages/0c/c9/eaaf9e3d433a72c1fd8017916d495505992c2ba99c69d854483e653b6311/z3c.form-3.3.0.tar.gz"
      }
    ],
    "3.4.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "2208913cb57765418aa9134f00c6ebfe",
          "sha256": "64da547f050798a891754ce31b453f34dd68e6472c246c58a2c4b715df46965b"
        },
        "downloads": 307,
        "filename": "z3c.form-3.4.0.tar.gz",
        "has_sig": false,
        "md5_digest": "2208913cb57765418aa9134f00c6ebfe",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 542558,
        "upload_time": "2016-11-15T22:05:59",
        "url": "https://files.pythonhosted.org/packages/1b/13/2bfa183aea8d009a5d76ba1cf23c6a15d938528fa7b9316948efeb96daf6/z3c.form-3.4.0.tar.gz"
      }
    ],
    "3.5": [
      {
        "comment_text": "",
        "digests": {
          "md5": "3e4506d9b9267b7a5a67f158b3e07698",
          "sha256": "0cb5d46e5c5ec432251976dfa09f7d58bf19f4e3c95c11492f6fbd6294a553e3"
        },
        "downloads": 0,
        "filename": "z3c.form-3.5.tar.gz",
        "has_sig": false,
        "md5_digest": "3e4506d9b9267b7a5a67f158b3e07698",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 498547,
        "upload_time": "2017-09-19T11:38:53",
        "url": "https://files.pythonhosted.org/packages/a3/84/b73562cae3cdd0ce60dd5024e2bb02dcdbece6c62977841c29c377f9a287/z3c.form-3.5.tar.gz"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "3e4506d9b9267b7a5a67f158b3e07698",
        "sha256": "0cb5d46e5c5ec432251976dfa09f7d58bf19f4e3c95c11492f6fbd6294a553e3"
      },
      "downloads": 0,
      "filename": "z3c.form-3.5.tar.gz",
      "has_sig": false,
      "md5_digest": "3e4506d9b9267b7a5a67f158b3e07698",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 498547,
      "upload_time": "2017-09-19T11:38:53",
      "url": "https://files.pythonhosted.org/packages/a3/84/b73562cae3cdd0ce60dd5024e2bb02dcdbece6c62977841c29c377f9a287/z3c.form-3.5.tar.gz"
    }
  ]
}