{
  "info": {
    "author": "Adrian Room",
    "author_email": "<ingolemo@gmail.com>",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 3 - Alpha",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: MIT License",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.5"
    ],
    "description": "# Lenses\n\nLenses is a python library that helps you to manipulate large\ndata-structures without mutating them. It is inspired by the lenses in\nHaskell, although it's much less principled and the api is more suitable\nfor python.\n\n\n## Installation\n\nYou can install the latest github version using pip like so:\n\n\tpip install git+git://github.com/ingolemo/python-lenses.git\n\nYou can uninstall similarly:\n\n\tpip uninstall lenses\n\n\n## How to Use\n\nThe lenses library makes liberal use of docstrings, which you can access\nas normal with the `pydoc` shell command, the `help` function in the\nrepl, or by reading the source yourself.\n\nMost users will only need the docs from `lenses.Lens`. If you want to\nadd hooks to allow parts of the library to work with custom objects then\nyou should check out the `lenses.setters` module. Most of the fancy lens\ncode is in the `lenses.baselens` module for those who are curious how\neverything works.\n\nAn example is given in the `examples` folder.\n\n\n### The Basics\n\nFor most users, the lenses library exports only one thing worth knowing\nabout; a `lens` function:\n\n\t>>> from lenses import lens\n\nIf you have a large data structure that you want to manipulate, you can\npass it to this function and you will receive a bound `Lens` object,\nwhich is a lens that has been bound to that specific object. The lens\ncan then be walked to focus it down on a particular part of the\ndata-structure. You walk the lens by getting attributes and items from\nit (anything that would call `__getattr__` or `__getitem__`):\n\n\t>>> data = [1, 2, 3]\n\t>>> my_lens = lens(data)[1]\n\nOnce you arrive at the data you want, you can get hold of it with the\n`get` method:\n\n\t>>> my_lens.get()\n\t2\n\nJust getting data using the lens isn't very impressive. Better is the\n`set` method, which allows you to set that particular piece of data\nwithin the larger data structure. It returns a copy of the original data\nstructure with that one single piece of data changed. Note that the lens\nnever mutates the original data structure:\n\n\t>>> my_lens.set(5)\n\t[1, 5, 3]\n\t>>> data\n\t[1, 2, 3]\n\nLenses allow you to manipulate arbitrarily nested objects:\n\n\t>>> data = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\t>>> lens(data)[1][0].set(20)\n\t[[1, 2, 3], [20, 5, 6], [7, 8, 9]]\n\t>>> lens(data)[2].set(20)\n\t[[1, 2, 3], [4, 5, 6], 20]\n\nAnd they support more than just lists. Any mutable python object that\ncan by copied with `copy.copy` will work. Immutable objects need special\nsupport, but support for any python object can be added so long as you\nknow how to construct a new version of that object with the appropriate\ndata changed. tuples and namedtuples are supported out of the box.\n\n\t>>> class MyClass:\n\t...     def __init__(self, attribute):\n\t...         self.attr = attribute\n\t...     def __repr__(self):\n\t...         return 'MyClass(' + repr(self.attr) + ')'\n\t...\n\t>>> data = (0, MyClass({'hello': 'world'}))\n\t>>> lens(data)[1].attr['hello'].set('everyone')\n\t(0, MyClass({'hello': 'everyone'}))\n\nIf you wish to apply a function using a lens you can use the `modify`\nmethod:\n\n\t>>> lens([1, 2, 3])[0].modify(lambda a: a + 10)\n\t[11, 2, 3]\n\nYou can call methods on the data using `call`. Note that this\nmethod should return new data to include in the data-structure:\n\n\t>>> lens([1, {2}, 3])[1].call('union', {4, 5})\n\t[1, {2, 4, 5}, 3]\n\nLenses will also pass most operators through to the data they're focused\non. This makes using lenses in your code much more readable:\n\n\t>>> lens([1, 2, 3])[0] + 10\n\t[11, 2, 3]\n\nLenses work best when you have to manipulate highly nested data\nstructures that hold a great deal of state, such as when programming\ngames:\n\n\t>>> from collections import namedtuple\n\t>>> \n\t>>> GameState = namedtuple('GameState', 'worlds current_world current_level')\n\t>>> World = namedtuple('World', 'levels theme')\n\t>>> Level = namedtuple('Level', 'map enemies')\n\t>>> Enemy = namedtuple('Enemy', 'x y')\n\t>>> \n\t>>> old_state = GameState({\n\t...     1: World({}, 'grassland'),\n\t...     2: World({\n\t...         1: Level({}, {\n\t...             'goomba1': Enemy(100, 45),\n\t...             'goomba2': Enemy(130, 45),\n\t...             'goomba3': Enemy(160, 45),\n\t...         }),\n\t...     }, 'desert'),\n\t... }, 1, 1)\n\t>>> \n\t>>> new_state = lens(old_state).worlds[2].levels[1].enemies['goomba3'].x + 1\n\nWith the structure above, that last line of code produces a new\n`GameState` object where the third enemy on the first level of the\nsecond world has been moved across by one pixel without any of the\nobjects in the original state being mutated. Without lenses this would\ntake a rather large amount of plumbing to achieve.\n\nNote that the lens does not make a deep copy of the entire state.\nObjects in the state that do not need to change are reused and no new\ncopies are made. This makes lenses more memory efficient than using\n`copy.deepcopy` for sufficiently large states:\n\n\t>>> old_state.worlds[1] is new_state.worlds[1]\n\tTrue\n\t>>> old_state.worlds[2] is new_state.worlds[2]\n\tFalse\n\n\n### Unbound Lenses\n\nIf you pass no arguments to the `lens` function then you will get an\nunbound `Lens` object. An unbound lens can be manipulated in all the\nways that a bound lens can except that you can't call any of the methods\nthat manipulate the state (such as `get` and `set`).\n\n\t>>> unbound_lens = lens()\n\t>>> key_one = unbound_lens['one']\n\nYou can then attach a state to the lens using the `bind` method and call\nstate manipulating methods as normal:\n\n\t>>> key_one.bind({'one': 1, 'two': 2}).get()\n\t1\n\nAlternatively, you can call the state manipulating method as normal and\npass in a keyword-only `state` argument for the method to act on:\n\n\t>>> key_one.get(state={'one': 1, 'two': 2})\n\t1\n\nYou can use unbound Lens objects as descriptors. That is, if you set a\nlens as a class attribute and you access that attribute from an\ninstance, you will get a lens that has been bound to that instance. This\nallows you to conveniently store and access lenses that are likely to be\nused with particular classes as attributes of those classes. Attribute\naccess is much more readable than requiring the user of a class to\nconstruct a lens themselves.\n\n\t>>> class ClassWithLens:\n\t...     def __init__(self, items):\n\t...         self._private_items = items\n\t...     def __repr__(self):\n\t...         return 'ClassWithLens({!r})'.format(self._private_items)\n\t...     first = lens()._private_items[0]\n\t...\n\t>>> my_instance = ClassWithLens([1, 2, 3])\n\t>>> my_instance.first.set(4)\n\tClassWithLens([4, 2, 3])\n\nIf you ever end up focusing an object with a lens as one of its\nattributes then you can use that lens by accessing the attribute with\nan extra `_l` at the end:\n\n\t>>> data = [ClassWithLens([1, 2, 3]), ClassWithLens([4, 5, 6])]\n\t>>> lens(data)[1].first_l.set(7)\n\t[ClassWithLens([1, 2, 3]), ClassWithLens([7, 5, 6])]\n\n\n### Composing Lenses\n\nIf you have two lenses, you can join them together using the `add_lens`\nmethod. Joining lenses means that one of the lenses is placed \"inside\"\nof the other so that the focus of one lens is fed into the other one as\nits state:\n\n\t>>> first = lens()[0]\n\t>>> second = lens()[1]\n\t>>> first_then_second = first.add_lens(second)\n\t>>> first_then_second.bind([[2, 3], [4, 5]]).get()\n\t3\n\t>>> second_then_first = second.add_lens(first)\n\t>>> second_then_first.bind([[2, 3], [4, 5]]).get()\n\t4\n\nWhen you call `a.add_lens(b)`, `b` must be an unbound lens and the\nresulting lens will be bound to the same object as `a`, if any.\n\n\n### Lenses that do computation\n\nSo far we've seen lenses that extract data out of data-structures, but\nlenses are more powerful than that. Lenses can actually perform\narbitrary computation on the data passing through them as long as that\ncomputation can be reversed.\n\nA simple example is that of the `item_` method which returns a lens that\nfocuses on a single key of a dictionary but returns both the key and the\nvalue:\n\n\t>>> l = lens({'one': 1})\n\t>>> l.item_('one').get()\n\t('one', 1)\n\t>>> l.item_('one').set(('three', 3))\n\t{'three': 3}\n\nThere are a number of such more complicated lenses defined on `Lens`. To\nhelp avoid collision with accessing attributes on the state, their names\nall end with a single underscore. See `help(lenses.Lens)` in the repl\nfor more. If you need to access an attribute on the state that has been\nshadowed by Lens' methods then you can use `Lens.getattr_(attribute)`.\n\nAt their heart, lenses are really just souped-up getters and setters. If\nyou have a getter and a setter for some data then you can turn those\ninto a lens using the `getter_setter_` method. Here is a lens that\nfocuses some text and interprets it as json data:\n\n\t>>> import json\n\t>>> def setter(state, value):\n\t...     return json.dumps(value)\n\t...\n\t>>> json_lens = lens().getter_setter_(json.loads, setter)\n\t>>> my_data = json_lens.bind('{\"numbers\":[1, 2, 3]}')\n\t>>> my_data.get()\n\t{'numbers': [1, 2, 3]}\n\t>>> my_data['numbers'][1].set(4)\n\t'{\"numbers\": [1, 4, 3]}'\n\nThis is just an example; the json lens defined above is already\navailable with the `json_` method. See the docstrings for both these\nmethods for details on how to use them.\n\n\n### Traversals\n\nAll the lenses so far have focused a single object inside a state, but\nit is possible for a lens to have more than one focus. A lens with\nmultiple foci is usually referred to as a traversal. A simple traversal\ncan be made with the `_both` method. `Lens.both_` focuses the two\nobjects at indices `0` and `1` within the state. It is intended to be\nused with tuples of length 2, but will work on any indexable object.\n\nOne issue with multi-focus lenses is that the `get` method only ever\nreturns a single focus. It will return the _first_ item focused by the\ntraversal. If you want to get all the items focused by a lens then you\ncan use the `get_all` method which will return those objects in a list:\n\n\t>>> lens([0, 1, 2, 3]).both_().get_all()\n\t[0, 1]\n\nSetting works with a traversal, though all foci will be set to the same\nobject.\n\n\t>>> lens([0, 1, 2, 3]).both_().set(4)\n\t[4, 4, 2, 3]\n\nModifying is the most useful operation you can perform. The modification\nwill be applied to all the foci independently. All the foci must be of\nthe same type (or at least be of a type that supports the modification\nthat you want to make).\n\n\t>>> lens([0, 1, 2, 3]).both_().modify(lambda a: a + 10)\n\t[10, 11, 2, 3]\n\t>>> lens([0, 1.0, 2, 3]).both_().modify(str)\n\t['0', '1.0', 2, 3]\n\nYou can of course use the same shortcut for operators that single-focus\nlenses allow:\n\n\t>>> lens([0, 1, 2, 3]).both_() + 10\n\t[10, 11, 2, 3]\n\nTraversals can be composed with normal lenses. The result is a traversal\nwith the lens applied to each of its original foci:\n\n\t>>> both_first = lens([[0, 1], [2, 3]]).both_()[0]\n\t>>> both_first.get_all()\n\t[0, 2]\n\t>>> both_first + 10\n\t[[10, 1], [12, 3]]\n\nTraversals can also be composed with other traversals just fine. They\nwill simply increase the number of foci targeted. Note that `get_all`\nreturns a flat list of foci; none of the structure of the state is\npreserved.\n\n\t>>> both_twice = lens([[0, 1], [2, 3]]).both_().both_()\n\t>>> both_twice.get_all()\n\t[0, 1, 2, 3]\n\t>>> both_twice + 10\n\t[[10, 11], [12, 13]]\n\nA slightly more useful traversal method is `each_`. `each_` will focus\nall of the items in a data-structure analogous to iterating over it\nusing python's `iter` and `next`. It supports most of the built-in\niterables out of the box, but if you want to use it on your own objects\nthen you will need to add a hook yourself.\n\n\t>>> lens([1, 2, 3]).each_() + 10\n\t[11, 12, 13]\n\nThe `values_` method returns a traversal that focuses all of the values\nin a dictionary. If we return to our `GameState` example from earlier,\nwe can use `values_` to move _every_ enemy in the same level 1 pixel\nover to the right in one line of code:\n\n\t>>> _ = lens(old_state).worlds[2].levels[1].enemies.values_().x + 1\n\nOr you could do the same thing to every enemy in the entire game\n(assuming that there were other enemies on other levels in the\n`GameState`):\n\n\t>>> _ = (lens(old_state).worlds.values_()\n\t...                     .levels.values_()\n\t...                     .enemies.values_().x) + 1\n\n\n## License\n\npython-lenses is free software: you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the\nFree Software Foundation, either version 3 of the License, or (at your\noption) any later version.\n\nThis program is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General\nPublic License for more details.\n\nYou should have received a copy of the GNU General Public License along\nwith this program. If not, see http://www.gnu.org/licenses/.",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "https://github.com/ingolemo/python-lenses",
    "keywords": "lens lenses immutable functional",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "lenses",
    "platform": "UNKNOWN",
    "project_url": "https://pypi.org/project/lenses/",
    "release_url": "https://pypi.org/project/lenses/0.1.7/",
    "requires_python": "",
    "summary": "A lens library for python",
    "version": "0.1.7"
  },
  "releases": {
    "0.1.7": [
      {
        "comment_text": "",
        "digests": {
          "md5": "40f0c9e8381a41351db2a950ab26c8ab",
          "sha256": "5e024e29b1eab8b5bd5c8b415998657f5905833e84e77c3031dab5a951495d70"
        },
        "downloads": 464,
        "filename": "lenses-0.1.7.tar.gz",
        "has_sig": true,
        "md5_digest": "40f0c9e8381a41351db2a950ab26c8ab",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 23456,
        "upload_time": "2016-05-29T18:36:16",
        "url": "https://files.pythonhosted.org/packages/58/6d/78a7b24a29a31b268e73899c648e4b16bb79566f1826b62ca3cd65348f4d/lenses-0.1.7.tar.gz"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "40f0c9e8381a41351db2a950ab26c8ab",
        "sha256": "5e024e29b1eab8b5bd5c8b415998657f5905833e84e77c3031dab5a951495d70"
      },
      "downloads": 464,
      "filename": "lenses-0.1.7.tar.gz",
      "has_sig": true,
      "md5_digest": "40f0c9e8381a41351db2a950ab26c8ab",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 23456,
      "upload_time": "2016-05-29T18:36:16",
      "url": "https://files.pythonhosted.org/packages/58/6d/78a7b24a29a31b268e73899c648e4b16bb79566f1826b62ca3cd65348f4d/lenses-0.1.7.tar.gz"
    }
  ]
}