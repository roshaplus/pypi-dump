{
  "info": {
    "author": "Roger Ineichen and the Zope Community",
    "author_email": "zope-dev@zope.org",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Environment :: Web Environment",
      "Framework :: Zope3",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: Zope Public License",
      "Natural Language :: English",
      "Operating System :: OS Independent",
      "Programming Language :: Python",
      "Programming Language :: Python :: 2",
      "Programming Language :: Python :: 2.6",
      "Programming Language :: Python :: 2.7",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.3",
      "Programming Language :: Python :: Implementation :: CPython",
      "Topic :: Internet :: WWW/HTTP"
    ],
    "description": "------------\nZ3C template\n------------\n\nThis package allows you to register templates independently from view code.\n\nIn Zope 3, when registering a `browser:page` both presentation and computation\nare registered together. Unfortunately the registration tangles presentation\nand computation so tightly that it is not possible to re-register a different\ntemplate depending on context. (You can override the whole registration but\nthis is not the main point of this package.)\n\nWith z3c.template the registration is split up between the view and the\ntemplate and allows to differentiate the template based on the skin layer and\nthe view.\n\nIn addition this package lays the foundation to differentiate between\ntemplates that provide specific presentation templates and generic layout\ntemplates.\n\n\n.. contents::\n\n=============\nZ3C Templates\n=============\n\nThis package allows us to separate the registration of the view code and the\nlayout.\n\nA template is used for separate the HTML part from a view. This is done in\nz3 via a page templates. Such page template are implemented in the view,\nregistered included in a page directive etc. But they do not use the adapter\npattern which makes it hard to replace existing templates.\n\nAnother part of template is, that they normaly separate one part presenting\ncontent from a view and another part offer a layout used by the content\ntemplate.\n\nHow can this package make it simpler to use templates?\n\nTemplates can be registered as adapters adapting context, request where the\ncontext is a view implementation. Such a template get adapted from the view\nif the template is needed. This adaption makes it very pluggable and modular.\n\nWe offer two base template directive for register content producing templates\nand layout producing tempaltes. This is most the time enough but you also\ncan register different type of templates using a specific interface. This\ncould be usefull if your view implementation needs to separate HTMl in\nmore then one template. Now let's take a look how we an use this templates.\n\n\nContent template\n----------------\n\nFirst let's show how we use a template for produce content from a view:\n\n  >>> import os, tempfile\n  >>> temp_dir = tempfile.mkdtemp()\n  >>> contentTemplate = os.path.join(temp_dir, 'contentTemplate.pt')\n  >>> with open(contentTemplate, 'w') as file:\n  ...     _ = file.write('<div>demo content</div>')\n\nAnd register a view class implementing a interface:\n\n  >>> import zope.interface\n  >>> from z3c.template import interfaces\n  >>> from zope.pagetemplate.interfaces import IPageTemplate\n  >>> from zope.publisher.browser import BrowserPage\n\n  >>> class IMyView(zope.interface.Interface):\n  ...     pass\n  >>> @zope.interface.implementer(IMyView)\n  ... class MyView(BrowserPage):\n  ...     template = None\n  ...     def render(self):\n  ...         if self.template is None:\n  ...             template = zope.component.getMultiAdapter(\n  ...                 (self, self.request), interfaces.IContentTemplate)\n  ...             return template(self)\n  ...         return self.template()\n\nLet's call the view and check the output:\n\n  >>> from zope.publisher.browser import TestRequest\n  >>> request = TestRequest()\n  >>> view = MyView(root, request)\n\nSince the template is not yet registered, rendering the view will fail:\n\n  >>> print(view.render())\n  Traceback (most recent call last):\n  ...\n  ComponentLookupError: ......\n\nLet's now register the template (commonly done using ZCML):\n\n  >>> from zope import component\n  >>> from zope.publisher.interfaces.browser import IDefaultBrowserLayer\n  >>> from z3c.template.template import TemplateFactory\n\nThe template factory allows us to create a ViewPageTeplateFile instance.\n\n  >>> factory = TemplateFactory(contentTemplate, 'text/html')\n  >>> factory\n  <z3c.template.template.TemplateFactory object at ...>\n\nWe register the factory on a view interface and a layer.\n\n  >>> component.provideAdapter(\n  ...     factory,\n  ...     (zope.interface.Interface, IDefaultBrowserLayer),\n  ...     interfaces.IContentTemplate)\n  >>> template = component.getMultiAdapter((view, request),\n  ...     interfaces.IPageTemplate)\n\n  >>> template\n  <...ViewPageTemplateFile...>\n\nNow that we have a registered layout template for the default layer we can\ncall our view again.\n\n  >>> print(view.render())\n  <div>demo content</div>\n\nNow we register a new template on the specific interface of our view.\n\n  >>> myTemplate = os.path.join(temp_dir, 'myTemplate.pt')\n  >>> with open(myTemplate, 'w') as file:\n  ...     _ = file.write('<div>My content</div>')\n  >>> factory = TemplateFactory(myTemplate, 'text/html')\n  >>> component.provideAdapter(\n  ...     factory,\n  ...     (IMyView, IDefaultBrowserLayer), interfaces.IContentTemplate)\n  >>> print(view.render())\n  <div>My content</div>\n\nIt is possible to provide the template directly.\n\nWe create a new template.\n\n  >>> viewContent = os.path.join(temp_dir, 'viewContent.pt')\n  >>> with open(viewContent, 'w') as file:\n  ...     _ = file.write('<div>view content</div>')\n\nand a view:\n\n  >>> from z3c.template import ViewPageTemplateFile\n  >>> @zope.interface.implementer(IMyView)\n  ... class MyViewWithTemplate(BrowserPage):\n  ...     template = ViewPageTemplateFile(viewContent)\n  ...     def render(self):\n  ...         if self.template is None:\n  ...             template = zope.component.getMultiAdapter(\n  ...                 (self, self.request), interfaces.IContentTemplate)\n  ...             return template(self)\n  ...         return self.template()\n  >>> contentView = MyViewWithTemplate(root, request)\n\nIf we render this view we get the implemented layout template and not the\nregistered one.\n\n  >>> print(contentView.render())\n  <div>view content</div>\n\n\nLayout template\n---------------\n\nFirst we nee to register a new view class calling a layout template. Note,\nthat this view uses the __call__ method for invoke a layout template:\n\n  >>> class ILayoutView(zope.interface.Interface):\n  ...     pass\n  >>> @zope.interface.implementer(ILayoutView)\n  ... class LayoutView(BrowserPage):\n  ...     layout = None\n  ...     def __call__(self):\n  ...         if self.layout is None:\n  ...             layout = zope.component.getMultiAdapter(\n  ...                 (self, self.request), interfaces.ILayoutTemplate)\n  ...             return layout(self)\n  ...         return self.layout()\n  >>> view2 = LayoutView(root, request)\n\nDefine and register a new layout template:\n\n  >>> layoutTemplate = os.path.join(temp_dir, 'layoutTemplate.pt')\n  >>> with open(layoutTemplate, 'w') as file:\n  ...     _ = file.write('<div>demo layout</div>')\n  >>> factory = TemplateFactory(layoutTemplate, 'text/html')\n\nWe register the template factory on a view interface and a layer providing the\nILayoutTemplate interface.\n\n  >>> component.provideAdapter(factory,\n  ...     (zope.interface.Interface, IDefaultBrowserLayer),\n  ...      interfaces.ILayoutTemplate)\n  >>> layout = component.getMultiAdapter(\n  ...     (view2, request), interfaces.ILayoutTemplate)\n\n  >>> layout\n  <...ViewPageTemplateFile...>\n\nNow that we have a registered layout template for the default layer we can\ncall our view again.\n\n  >>> print(view2())\n  <div>demo layout</div>\n\nNow we register a new layout template on the specific interface of our view.\n\n  >>> myLayout = os.path.join(temp_dir, 'myLayout.pt')\n  >>> with open(myLayout, 'w') as file:\n  ...     _ = file.write('<div>My layout</div>')\n  >>> factory = TemplateFactory(myLayout, 'text/html')\n  >>> component.provideAdapter(factory,\n  ...     (ILayoutView, IDefaultBrowserLayer),\n  ...      interfaces.ILayoutTemplate)\n  >>> print(view2())\n  <div>My layout</div>\n\nIt is possible to provide the layout template directly.\n\nWe create a new template.\n\n  >>> viewLayout = os.path.join(temp_dir, 'viewLayout.pt')\n  >>> with open(viewLayout, 'w') as file:\n  ...     _ = file.write('''<div>view layout</div>''')\n\n  >>> @zope.interface.implementer(ILayoutView)\n  ... class LayoutViewWithLayoutTemplate(BrowserPage):\n  ...     layout = ViewPageTemplateFile(viewLayout)\n  ...     def __call__(self):\n  ...         if self.layout is None:\n  ...             layout = zope.component.getMultiAdapter((self, self.request),\n  ...                 interfaces.ILayoutTemplate)\n  ...             return layout(self)\n  ...         return self.layout()\n  >>> layoutView = LayoutViewWithLayoutTemplate(root, request)\n\nIf we render this view we get the implemented layout template and not the\nregistered one.\n\n  >>> print(layoutView())\n  <div>view layout</div>\n\n\nSince we return the layout template in the sample views above, how can we get\nthe content from the used view? This is not directly a part of this package\nbut let's show some pattern were can be used for render content in a used\nlayout template. Note, since we offer to register each layout template for\na specific view, you can always very selectiv this layout pattern. This means\nyou can use the defualt z3 macro based layout registration in combination with\nthis layout concept if you register a own layout template.\n\nThe simplest concept is calling the content from the view in the layout\ntemplate is to call it from a method. Let's define a view providing a layout\ntemplate and offer a method for call content.\n\n  >>> class IFullView(zope.interface.Interface):\n  ...     pass\n\n  >>> @zope.interface.implementer(IFullView)\n  ... class FullView(BrowserPage):\n  ...     layout = None\n  ...     def render(self):\n  ...         return u'rendered content'\n  ...     def __call__(self):\n  ...         if self.layout is None:\n  ...             layout = zope.component.getMultiAdapter((self, self.request),\n  ...                 interfaces.ILayoutTemplate)\n  ...             return layout(self)\n  ...         return self.layout()\n  >>> completeView = FullView(root, request)\n\nNow define a layout for the view and register them:\n\n  >>> completeLayout = os.path.join(temp_dir, 'completeLayout.pt')\n  >>> with open(completeLayout, 'w') as file:\n  ...     _ = file.write('''\n  ...   <div tal:content=\"view/render\">\n  ...     Full layout\n  ...   </div>\n  ... ''')\n\n  >>> factory = TemplateFactory(completeLayout, 'text/html')\n  >>> component.provideAdapter(factory,\n  ...     (IFullView, IDefaultBrowserLayer), interfaces.ILayoutTemplate)\n\nNow let's see if the layout template can call the content via calling render\non the view:\n\n  >>> print(completeView.__call__())\n  <div>rendered content</div>\n\n\nContent and Layout\n------------------\n\nNow let's show how we combine this two templates in a real use case:\n\n  >>> class IDocumentView(zope.interface.Interface):\n  ...     pass\n\n  >>> @zope.interface.implementer(IDocumentView)\n  ... class DocumentView(BrowserPage):\n  ...     template = None\n  ...     layout = None\n  ...     attr = None\n  ...     def update(self):\n  ...         self.attr = u'content updated'\n  ...     def render(self):\n  ...         if self.template is None:\n  ...             template = zope.component.getMultiAdapter(\n  ...                 (self, self.request), IPageTemplate)\n  ...             return template(self)\n  ...         return self.template()\n  ...     def __call__(self):\n  ...         self.update()\n  ...         if self.layout is None:\n  ...             layout = zope.component.getMultiAdapter((self, self.request),\n  ...                 interfaces.ILayoutTemplate)\n  ...             return layout(self)\n  ...         return self.layout()\n\nDefine and register a content template...\n\n  >>> template = os.path.join(temp_dir, 'template.pt')\n  >>> with open(template, 'w') as file:\n  ...     _ = file.write('''\n  ...   <div tal:content=\"view/attr\">\n  ...     here comes the value of attr\n  ...   </div>\n  ... ''')\n\n  >>> factory = TemplateFactory(template, 'text/html')\n  >>> component.provideAdapter(factory,\n  ...     (IDocumentView, IDefaultBrowserLayer), IPageTemplate)\n\nand define and register a layout template:\n\n  >>> layout = os.path.join(temp_dir, 'layout.pt')\n  >>> with open(layout, 'w') as file:\n  ...     _ = file.write('''\n  ... <html>\n  ...   <body>\n  ...     <div tal:content=\"structure view/render\">\n  ...       here comes the rendered content\n  ...     </div>\n  ...   </body>\n  ... </html>\n  ... ''')\n\n  >>> factory = TemplateFactory(layout, 'text/html')\n  >>> component.provideAdapter(factory,\n  ...     (IDocumentView, IDefaultBrowserLayer), interfaces.ILayoutTemplate)\n\nNow call the view and check the result:\n\n  >>> documentView = DocumentView(root, request)\n  >>> print(documentView())\n  <html>\n    <body>\n      <div>\n        <div>content updated</div>\n      </div>\n    </body>\n  </html>\n\n\nMacros\n------\n\nUse of macros.\n\n  >>> macroTemplate = os.path.join(temp_dir, 'macroTemplate.pt')\n  >>> with open(macroTemplate, 'w') as file:\n  ...     _ = file.write('''\n  ...   <metal:block define-macro=\"macro1\">\n  ...     <div>macro1</div>\n  ...   </metal:block>\n  ...   <metal:block define-macro=\"macro2\">\n  ...     <div>macro2</div>\n  ...     <div tal:content=\"options/div2\">the content of div 2</div>\n  ...   </metal:block>\n  ...   ''')\n\n  >>> factory = TemplateFactory(macroTemplate, 'text/html', 'macro1')\n  >>> print(factory(view, request)())\n  <div>macro1</div>\n  >>> m2factory = TemplateFactory(macroTemplate, 'text/html', 'macro2')\n  >>> print(m2factory(view, request)(div2=\"from the options\"))\n  <div>macro2</div>\n  <div>from the options</div>\n\n\nWhy didn't we use named templates from the ``zope.formlib`` package?\n\nWhile named templates allow us to separate the view code from the template\nregistration, they are not registrable for a particular layer making it\nimpossible to implement multiple skins using named templates.\n\n\nUse case ``simple template``\n----------------------------\n\nAnd for the simplest possible use we provide a hook for call registered\ntemplates. Such page templates can get called with the getPageTemplate method\nand return a registered bound ViewTemplate a la ViewPageTemplateFile or\nNamedTemplate.\n\nThe getViewTemplate allows us to use the new template registration\nsystem with all existing implementations such as `zope.formlib` and\n`zope.viewlet`.\n\n  >>> from z3c.template.template import getPageTemplate\n  >>> class IUseOfViewTemplate(zope.interface.Interface):\n  ...     pass\n  >>> @zope.interface.implementer(IUseOfViewTemplate)\n  ... class UseOfViewTemplate(object):\n  ...\n  ...     template = getPageTemplate()\n  ...\n  ...     def __init__(self, context, request):\n  ...         self.context = context\n  ...         self.request = request\n\nBy defining the \"template\" property as a \"getPageTemplate\" a lookup for\na registered template is done when it is called.\n\n  >>> simple = UseOfViewTemplate(root, request)\n  >>> print(simple.template())\n  <div>demo content</div>\n\nBecause the demo template was registered for any (\"None\") interface we see the\ndemo template when rendering our new view. We register a new template\nespecially for the new view. Also note that the \"macroTemplate\" has been\ncreated earlier in this test.\n\n  >>> factory = TemplateFactory(contentTemplate, 'text/html')\n  >>> component.provideAdapter(factory,\n  ...     (IUseOfViewTemplate, IDefaultBrowserLayer), IPageTemplate)\n  >>> print(simple.template())\n  <div>demo content</div>\n\n\nContext-specific templates\n--------------------------\n\nThe ``TemplateFactory`` can be also used for (view, request, context)\nlookup. It's useful when you want to override a template for specific\ncontent object or type.\n\nLet's define a sample content type and instantiate a view for it.\n\n  >>> class IContent(zope.interface.Interface):\n  ...     pass\n  >>> @zope.interface.implementer(IContent)\n  ... class Content(object):\n  ...     pass\n\n  >>> content = Content()\n  >>> view = UseOfViewTemplate(content, request)\n\nNow, let's provide a (view, request, context) adapter using TemplateFactory.\n\n  >>> contextTemplate = os.path.join(temp_dir, 'context.pt')\n  >>> with open(contextTemplate, 'w') as file:\n  ...     _ = file.write('<div>context-specific</div>')\n  >>> factory = TemplateFactory(contextTemplate, 'text/html')\n\n  >>> component.provideAdapter(factory,\n  ...     (IUseOfViewTemplate, IDefaultBrowserLayer, IContent),\n  ...     interfaces.IContentTemplate)\n\nFirst. Let's try to simply get it as a multi-adapter.\n\n  >>> template = zope.component.getMultiAdapter((view, request, content),\n  ...                 interfaces.IContentTemplate)\n  >>> print(template(view))\n  <div>context-specific</div>\n\nThe ``getPageTemplate`` and friends will try to lookup a context-specific\ntemplate before doing more generic (view, request) lookup, so our view\nshould already use our context-specific template:\n\n  >>> print(view.template())\n  <div>context-specific</div>\n\n\nUse case ``template by interface``\n----------------------------------\n\nTemplates can also get registered on different interfaces then IPageTemplate\nor ILayoutTemplate.\n\n  >>> from z3c.template.template import getViewTemplate\n  >>> class IMyTemplate(zope.interface.Interface):\n  ...     \"\"\"My custom tempalte marker.\"\"\"\n\n  >>> factory = TemplateFactory(contentTemplate, 'text/html')\n  >>> component.provideAdapter(factory,\n  ...     (zope.interface.Interface, IDefaultBrowserLayer), IMyTemplate)\n\nNow define a view using such a custom template registration:\n\n  >>> class IMyTemplateView(zope.interface.Interface):\n  ...     pass\n  >>> @zope.interface.implementer(IMyTemplateView)\n  ... class MyTemplateView(object):\n  ...\n  ...     template = getViewTemplate(IMyTemplate)\n  ...\n  ...     def __init__(self, context, request):\n  ...         self.context = context\n  ...         self.request = request\n\n  >>> myTempalteView = MyTemplateView(root, request)\n  >>> print(myTempalteView.template())\n  <div>demo content</div>\n\n\nUse case ``named template``\n----------------------------------\n\nTemplates can also get registered on names. In this expample we use a named\ntemplate combined with a custom template marker interface.\n\n  >>> class IMyNamedTemplate(zope.interface.Interface):\n  ...     \"\"\"My custom template marker.\"\"\"\n\n  >>> factory = TemplateFactory(contentTemplate, 'text/html')\n  >>> component.provideAdapter(factory,\n  ...     (zope.interface.Interface, IDefaultBrowserLayer), IMyNamedTemplate,\n  ...     name='my template')\n\nNow define a view using such a custom named template registration:\n\n  >>> class IMyNamedTemplateView(zope.interface.Interface):\n  ...     pass\n  >>> @zope.interface.implementer(IMyNamedTemplateView)\n  ... class MyNamedTemplateView(object):\n  ...\n  ...     template = getViewTemplate(IMyNamedTemplate, 'my template')\n  ...\n  ...     def __init__(self, context, request):\n  ...         self.context = context\n  ...         self.request = request\n\n  >>> myNamedTempalteView = MyNamedTemplateView(root, request)\n  >>> print(myNamedTempalteView.template())\n  <div>demo content</div>\n\n\nUse case ``named layout template``\n----------------------------------\n\nWe can also register a new layout template by name and use it in a view:\n\n  >>> from z3c.template.template import getLayoutTemplate\n\n  >>> editLayout = os.path.join(temp_dir, 'editLayout.pt')\n  >>> with open(editLayout, 'w') as file:\n  ...     _ = file.write('''\n  ...   <div>Edit layout</div>\n  ...   <div tal:content=\"view/render\">content</div>\n  ... ''')\n  >>> factory = TemplateFactory(editLayout, 'text/html')\n  >>> component.provideAdapter(factory,\n  ...     (zope.interface.Interface, IDefaultBrowserLayer),\n  ...      interfaces.ILayoutTemplate, name='edit')\n\nNow define a view using such a custom named template registration:\n\n  >>> class MyEditView(BrowserPage):\n  ...\n  ...     layout = getLayoutTemplate('edit')\n  ...\n  ...     def render(self):\n  ...         return u'edit content'\n  ...\n  ...     def __call__(self):\n  ...         if self.layout is None:\n  ...             layout = zope.component.getMultiAdapter((self, self.request),\n  ...                 interfaces.ILayoutTemplate)\n  ...             return layout(self)\n  ...         return self.layout()\n\n  >>> myEditView = MyEditView(root, request)\n  >>> print(myEditView())\n  <div>Edit layout</div>\n  <div>edit content</div>\n\n\nCleanup\n-------\n\n  >>> import shutil\n  >>> shutil.rmtree(temp_dir)\n\n\nPagelet\n-------\n\nSee ``z3c.pagelet`` for another template based layout generating implementation.\n\n==================\nTemplate directive\n==================\n\nShow how we can use the template directive. Register the meta configuration for\nthe directive.\n\n  >>> import sys\n  >>> from zope.configuration import xmlconfig\n  >>> import z3c.template\n  >>> context = xmlconfig.file('meta.zcml', z3c.template)\n\n\nPageTemplate\n------------\n\nWe need a custom content template\n\n  >>> import os, tempfile\n  >>> temp_dir = tempfile.mkdtemp()\n  >>> content_file = os.path.join(temp_dir, 'content.pt')\n  >>> with open(content_file, 'w') as file:\n  ...     _ = file.write('''<div>content</div>''')\n\nand a interface\n\n  >>> import zope.interface\n  >>> class IView(zope.interface.Interface):\n  ...     \"\"\"Marker interface\"\"\"\n\nand a view class:\n\n  >>> from zope.publisher.browser import TestRequest\n  >>> @zope.interface.implementer(IView)\n  ... class View(object):\n  ...     def __init__(self, context, request):\n  ...         self.context = context\n  ...         self.request = request\n  >>> request = TestRequest()\n  >>> view = View(object(), request)\n\nMake them available under the fake package ``custom``:\n\n  >>> sys.modules['custom'] = type(\n  ...     'Module', (),\n  ...     {'IView': IView})()\n\nand register them as a template within the ``z3c:template`` directive:\n\n  >>> context = xmlconfig.string(\"\"\"\n  ... <configure\n  ...     xmlns:z3c=\"http://namespaces.zope.org/z3c\">\n  ...   <z3c:template\n  ...       template=\"%s\"\n  ...       for=\"custom.IView\"\n  ...       />\n  ... </configure>\n  ... \"\"\" % content_file, context=context)\n\nLet's get the template\n\n  >>> import zope.component\n  >>> from z3c.template.interfaces import IContentTemplate\n  >>> template = zope.component.queryMultiAdapter(\n  ...     (view, request),\n  ...     interface=IContentTemplate)\n\nand check them:\n\n  >>> from z3c.template.template import ViewPageTemplateFile\n  >>> isinstance(template, ViewPageTemplateFile)\n  True\n  >>> isinstance(template.content_type, str)\n  True\n\n  >>> print(template(view))\n  <div>content</div>\n\n\nLayout template\n---------------\n\nDefine a layout template\n\n  >>> layout_file = os.path.join(temp_dir, 'layout.pt')\n  >>> with open(layout_file, 'w') as file:\n  ...     _ = file.write('''<div>layout</div>''')\n\nand register them as a layout template within the ``z3c:layout`` directive:\n\n  >>> context = xmlconfig.string(\"\"\"\n  ... <configure\n  ...     xmlns:z3c=\"http://namespaces.zope.org/z3c\">\n  ...   <z3c:layout\n  ...       template=\"%s\"\n  ...       for=\"custom.IView\"\n  ...       />\n  ... </configure>\n  ... \"\"\" % layout_file, context=context)\n\nLet's get the template\n\n  >>> from z3c.template.interfaces import ILayoutTemplate\n  >>> layout = zope.component.queryMultiAdapter((view, request),\n  ...     interface=ILayoutTemplate)\n\nand check them:\n\n  >>> isinstance(layout, ViewPageTemplateFile)\n  True\n  >>> isinstance(layout.content_type, str)\n  True\n\n  >>> print(layout(view))\n  <div>layout</div>\n\n\nContext-specific template\n-------------------------\n\nMost of views have some object as their context and it's ofter very\nuseful to be able register context-specific template. We can do that\nusing the ``context`` argument of the ZCML directive.\n\nLet's define some content type:\n\n  >>> class IContent(zope.interface.Interface):\n  ...     pass\n  >>> @zope.interface.implementer(IContent)\n  ... class Content(object):\n  ...     pass\n\n  >>> sys.modules['custom'].IContent = IContent\n\nNow, we can register a template for this class. Let's create one and\nregister:\n\n  >>> context_file = os.path.join(temp_dir, 'context.pt')\n  >>> with open(context_file, 'w') as file:\n  ...     _ = file.write('''<div>i'm context-specific</div>''')\n\n  >>> context = xmlconfig.string(\"\"\"\n  ... <configure\n  ...     xmlns:z3c=\"http://namespaces.zope.org/z3c\">\n  ...   <z3c:template\n  ...       template=\"%s\"\n  ...       for=\"custom.IView\"\n  ...       context=\"custom.IContent\"\n  ...       />\n  ... </configure>\n  ... \"\"\" % context_file, context=context)\n\nWe can now lookup it using the (view, request, context) discriminator:\n\n  >>> content = Content()\n  >>> view = View(content, request)\n\n  >>> template = zope.component.queryMultiAdapter((view, request, content),\n  ...     interface=IContentTemplate)\n\n  >>> print(template(view))\n  <div>i'm context-specific</div>\n\nThe same will work with layout registration directive:\n\n  >>> context_layout_file = os.path.join(temp_dir, 'context_layout.pt')\n  >>> with open(context_layout_file, 'w') as file:\n  ...     _ = file.write('''<div>context-specific layout</div>''')\n  >>> context = xmlconfig.string(\"\"\"\n  ... <configure\n  ...     xmlns:z3c=\"http://namespaces.zope.org/z3c\">\n  ...   <z3c:layout\n  ...       template=\"%s\"\n  ...       for=\"custom.IView\"\n  ...       context=\"custom.IContent\"\n  ...       />\n  ... </configure>\n  ... \"\"\" % context_layout_file, context=context)\n\n  >>> layout = zope.component.queryMultiAdapter((view, request, content),\n  ...     interface=ILayoutTemplate)\n\n  >>> print(layout(view))\n  <div>context-specific layout</div>\n\n\nNamed template\n--------------\n\nIts possible to register template by name. Let us register a pagelet with the\nname edit:\n\n  >>> editTemplate = os.path.join(temp_dir, 'edit.pt')\n  >>> with open(editTemplate, 'w') as file:\n  ...     _ = file.write('''<div>edit</div>''')\n\n  >>> context = xmlconfig.string(\"\"\"\n  ... <configure\n  ...     xmlns:z3c=\"http://namespaces.zope.org/z3c\">\n  ...   <z3c:template\n  ...       name=\"edit\"\n  ...       template=\"%s\"\n  ...       for=\"custom.IView\"\n  ...       />\n  ... </configure>\n  ... \"\"\" % editTemplate, context=context)\n\nAnd call it:\n\n  >>> from z3c.template.interfaces import ILayoutTemplate\n  >>> template = zope.component.queryMultiAdapter(\n  ...     (view, request),\n  ...     interface=IContentTemplate, name='edit')\n\n  >>> print(template(view))\n  <div>edit</div>\n\n\nCustom template\n---------------\n\nOr you can define own interfaces and register templates for them:\n\n  >>> from zope.pagetemplate.interfaces import IPageTemplate\n  >>> class IMyTemplate(IPageTemplate):\n  ...     \"\"\"My template\"\"\"\n\nMake the template interface available as a custom module class.\n\n  >>> sys.modules['custom'].IMyTemplate = IMyTemplate\n\nDfine a new template\n\n  >>> interfaceTemplate = os.path.join(temp_dir, 'interface.pt')\n  >>> with open(interfaceTemplate, 'w') as file:\n  ...     _ = file.write('''<div>interface</div>''')\n\n  >>> context = xmlconfig.string(\"\"\"\n  ... <configure\n  ...     xmlns:z3c=\"http://namespaces.zope.org/z3c\">\n  ...   <z3c:template\n  ...       template=\"%s\"\n  ...       for=\"custom.IView\"\n  ...       provides=\"custom.IMyTemplate\"\n  ...       />\n  ... </configure>\n  ... \"\"\" % interfaceTemplate, context=context)\n\nLet's see if we get the template by the new interface:\n\n  >>> from z3c.template.interfaces import ILayoutTemplate\n  >>> template = zope.component.queryMultiAdapter((view, request),\n  ...     interface=IMyTemplate,)\n\n  >>> print(template(view))\n  <div>interface</div>\n\n\nCleanup\n-------\n\nNow we need to clean up the custom module.\n\n  >>> del sys.modules['custom']\n\n=======\nCHANGES\n=======\n\n2.0.0 (2015-11-09)\n------------------\n\n- Standardize namespace __init__\n\n\n2.0.0a2 (2013-02-25)\n--------------------\n\n- Make sure the of the templates content type is a native string instead\n  forced bytes.\n\n\n2.0.0a1 (2013-02-22)\n--------------------\n\n- Added support for Python 3.3.\n\n- Replaced deprecated ``zope.interface.implements`` usage with equivalent\n  ``zope.interface.implementer`` decorator.\n\n- Dropped support for Python 2.4 and 2.5.\n\n\n1.4.1 (2012-02-15)\n------------------\n\n- Remove hooks to use ViewPageTemplateFile from z3c.pt because this breaks when\n  z3c.pt is available, but z3c.ptcompat is not included. As recommended by notes\n  below.\n\n\n1.4.0 (2011-10-29)\n------------------\n\n- Moved z3c.pt include to extras_require chameleon. This makes the package\n  independent from chameleon and friends and allows to include this\n  dependencies in your own project.\n\n- Upgrade to chameleon 2.0 template engine and use the newest z3c.pt and\n  z3c.ptcompat packages adjusted to work with chameleon 2.0.\n\n  See the notes from the z3c.ptcompat package:\n\n  Update z3c.ptcompat implementation to use component-based template engine\n  configuration, plugging directly into the Zope Toolkit framework.\n\n  The z3c.ptcompat package no longer provides template classes, or ZCML\n  directives; you should import directly from the ZTK codebase.\n\n  Note that the ``PREFER_Z3C_PT`` environment option has been\n  rendered obsolete; instead, this is now managed via component\n  configuration.\n\n  Also note that the chameleon CHAMELEON_CACHE environment value changed from\n  True/False to a path. Skip this property if you don't like to use a cache.\n  None or False defined in buildout environment section doesn't work. At least\n  with chameleon <= 2.5.4\n\n  Attention: You need to include the configure.zcml file from z3c.ptcompat\n  for enable the z3c.pt template engine. The configure.zcml will plugin the\n  template engine. Also remove any custom built hooks which will import\n  z3c.ptcompat in your tests or other places.\n\n\n1.3.0 (2011-10-28)\n------------------\n\n- Update to z3c.ptcompat 1.0 (and as a result, to the z3c.pt 2.x series).\n\n- Using Python's ``doctest`` module instead of depreacted\n  ``zope.testing.doctest``.\n\n\n1.2.1 (2009-08-22)\n------------------\n\n* Corrected description of ``ITemplateDirective.name``.\n\n* Added `zcml.txt` to ``long_description`` to show up on pypi.\n\n* Removed zpkg helper files and zcml slugs.\n\n\n1.2.0 (2009-02-26)\n------------------\n\n* Add support for context-specific templates. Now, templates can be\n  registered and looked up using (view, request, context) triple.\n  To do that, pass the ``context`` argument to the ZCML directives.\n  The ``getPageTemplate`` and friends will now try to lookup context\n  specific template first and then fall back to (view, request) lookup.\n\n* Allow use of ``z3c.pt`` using ``z3c.ptcompat`` compatibility layer.\n\n* Forward the template kwargs to the options of the macro\n\n* Changed package's mailing list address to zope-dev at zope.org\n  instead of retired one.\n\n1.1.0 (2007-10-08)\n------------------\n\n* Added an ``IContentTemplate`` interface which is used for\n  ``<z3c:template>``.\n\n1.0.0 (2007-??-??)\n------------------\n\n* Initial release.",
    "docs_url": null,
    "download_url": "UNKNOWN",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "http://pypi.python.org/pypi/z3c.template",
    "keywords": "zope3 template layout zpt pagetemplate",
    "license": "ZPL 2.1",
    "maintainer": null,
    "maintainer_email": null,
    "name": "z3c.template",
    "platform": "UNKNOWN",
    "project_url": "https://pypi.org/project/z3c.template/",
    "release_url": "https://pypi.org/project/z3c.template/2.0.0/",
    "requires_python": null,
    "summary": "A package implementing advanced Page Template patterns.",
    "version": "2.0.0"
  },
  "releases": {
    "1.1.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "a94a46b7b63e1c2a82862f4fbb31472a",
          "sha256": "3e95b73cc3d2f7aa61d2cf1592449a187322a312b0bd47a7ce3ead8e811cc234"
        },
        "downloads": 3646,
        "filename": "z3c.template-1.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "a94a46b7b63e1c2a82862f4fbb31472a",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 17025,
        "upload_time": "2007-10-09T01:07:35",
        "url": "https://files.pythonhosted.org/packages/93/6b/87cd95b593f5668c62e06b54cb5081f6ef7135aa32cff7cb6dd7a779add2/z3c.template-1.1.0.tar.gz"
      }
    ],
    "1.2.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "f75c4c6ca665d2bb5b511ec0f420c448",
          "sha256": "40b4aaa0487eaff946eabac49f33c2da6409dec9c179747366de18af4e6e05b0"
        },
        "downloads": 3440,
        "filename": "z3c.template-1.2.0.tar.gz",
        "has_sig": false,
        "md5_digest": "f75c4c6ca665d2bb5b511ec0f420c448",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 18635,
        "upload_time": "2009-02-26T15:34:35",
        "url": "https://files.pythonhosted.org/packages/11/1b/766f3c3e458c54e2588493a546085c1fda8ac5c6de43e0af1016bbec80d4/z3c.template-1.2.0.tar.gz"
      }
    ],
    "1.2.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "c315cdf17169afd17236e3a78b03ce40",
          "sha256": "1a2fd75e0010d96b09bb15127c7b91723d3ecd8e7ee2979eb01c9f39543e653e"
        },
        "downloads": 8368,
        "filename": "z3c.template-1.2.1.tar.gz",
        "has_sig": false,
        "md5_digest": "c315cdf17169afd17236e3a78b03ce40",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 22015,
        "upload_time": "2009-08-22T13:53:14",
        "url": "https://files.pythonhosted.org/packages/97/dd/74c90b2832fde71de50100ceeafb09c56be11b957a01ec174620aecb806f/z3c.template-1.2.1.tar.gz"
      }
    ],
    "1.3": [],
    "1.3.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "904daeb51a62fe7c1d1d1b5608524bb9",
          "sha256": "684dabdc6b539e8260098585f79316f4fc41a47cd0e7bb3e5ef10c382b468c67"
        },
        "downloads": 2356,
        "filename": "z3c.template-1.3.0.zip",
        "has_sig": false,
        "md5_digest": "904daeb51a62fe7c1d1d1b5608524bb9",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 32335,
        "upload_time": "2011-10-28T04:30:16",
        "url": "https://files.pythonhosted.org/packages/50/3f/76e604b27b9914fbfa4c6548ff38e3d2032b65029902b24e5b97b03d9338/z3c.template-1.3.0.zip"
      }
    ],
    "1.4.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "14543d2f224409e663122a523c844176",
          "sha256": "e9ea540527935a451a11f526cb9c108a98f6c5b9d3ba0a575a05fef7f772009b"
        },
        "downloads": 4574,
        "filename": "z3c.template-1.4.0.zip",
        "has_sig": false,
        "md5_digest": "14543d2f224409e663122a523c844176",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 34277,
        "upload_time": "2011-10-29T23:21:53",
        "url": "https://files.pythonhosted.org/packages/cf/38/3e193a198848c753bbb4d90fe91fd5616a5dab1639e03066b3bb59aa5932/z3c.template-1.4.0.zip"
      }
    ],
    "1.4.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "330e2dba8cd064d5790392afd9f460dd",
          "sha256": "b67d3cd29403f3d540a474067fb203ff590460e92ed805b845416d0245ca9834"
        },
        "downloads": 6483,
        "filename": "z3c.template-1.4.1.tar.gz",
        "has_sig": false,
        "md5_digest": "330e2dba8cd064d5790392afd9f460dd",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 25612,
        "upload_time": "2012-02-15T19:23:29",
        "url": "https://files.pythonhosted.org/packages/d2/de/be4dec58fb7aaf295c20462ec33b5f1e0d55f8281fe49c58cea2462a6fff/z3c.template-1.4.1.tar.gz"
      }
    ],
    "2.0.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "3ccfcfbb6c0ec26db70c80c6627a5332",
          "sha256": "9dbf4d8c86e9229cbba32725e2ebb3a0126cba83e4d248e4d81fea41af0936ba"
        },
        "downloads": 1626,
        "filename": "z3c.template-2.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "3ccfcfbb6c0ec26db70c80c6627a5332",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 26680,
        "upload_time": "2015-11-09T14:17:52",
        "url": "https://files.pythonhosted.org/packages/16/36/56e77bca1ebafc2e4a0c555ac358b4c0a2150d1863d46d0ee34abacbdf17/z3c.template-2.0.0.tar.gz"
      }
    ],
    "2.0.0a1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "b8e5660f57f8a4ea0e6d682c3a1c03f3",
          "sha256": "067ba247f3bca3714fb9296c92b62123592cbe409f9928f8466e67728173d6cc"
        },
        "downloads": 1937,
        "filename": "z3c.template-2.0.0a1.zip",
        "has_sig": false,
        "md5_digest": "b8e5660f57f8a4ea0e6d682c3a1c03f3",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 36715,
        "upload_time": "2013-02-23T01:38:10",
        "url": "https://files.pythonhosted.org/packages/52/fa/41d0ed66bbb838eb8af41a58a584b51cbbe687681f5dde3ecfbcf07a9bb5/z3c.template-2.0.0a1.zip"
      }
    ],
    "2.0.0a2": [
      {
        "comment_text": "",
        "digests": {
          "md5": "931528442436caf3d8f51de7825547d1",
          "sha256": "afad5e81a7cf8d933556857ac6bc2390adf3bd87dc84f8a3ff41bc8270bae079"
        },
        "downloads": 3711,
        "filename": "z3c.template-2.0.0a2.zip",
        "has_sig": false,
        "md5_digest": "931528442436caf3d8f51de7825547d1",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 36872,
        "upload_time": "2013-02-25T14:31:19",
        "url": "https://files.pythonhosted.org/packages/77/76/f45073a1494e88ffad5c9835a220b7382e73f52c639b1dd1ddaf87add4e0/z3c.template-2.0.0a2.zip"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "3ccfcfbb6c0ec26db70c80c6627a5332",
        "sha256": "9dbf4d8c86e9229cbba32725e2ebb3a0126cba83e4d248e4d81fea41af0936ba"
      },
      "downloads": 1626,
      "filename": "z3c.template-2.0.0.tar.gz",
      "has_sig": false,
      "md5_digest": "3ccfcfbb6c0ec26db70c80c6627a5332",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 26680,
      "upload_time": "2015-11-09T14:17:52",
      "url": "https://files.pythonhosted.org/packages/16/36/56e77bca1ebafc2e4a0c555ac358b4c0a2150d1863d46d0ee34abacbdf17/z3c.template-2.0.0.tar.gz"
    }
  ]
}