{
  "info": {
    "author": "",
    "author_email": "pydavid@baguette.io",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved",
      "License :: OSI Approved :: GNU General Public License v3 (GPLv3)",
      "Operating System :: OS Independent",
      "Programming Language :: Python",
      "Programming Language :: Python :: 2.7",
      "Topic :: Software Development :: Libraries :: Application Frameworks"
    ],
    "description": "==================\nbaguette-messaging\n==================\n\n.. image:: https://travis-ci.org/baguette-io/baguette-messaging.svg?branch=master\n    :target: https://travis-ci.org/baguette-io/baguette-messaging\n\nTiny Framework to build micro services.\nCurrently only support **amqp**, **rpc over amqp** and **http stream** based micro services.\n\nHow it works\n============\n\n\nAMQP\n----\n\n| We declare a publisher:\n| the method decorated takes one parameter **publish** (farine.amqp.publisher.Publisher)\n\n.. code:: python\n\n\timport farine.amqp\n\t\n\tclass Publish(object):\n\t\n\t    @farine.amqp.publish(exchange='consume', routing_key='routing_key')\n\t    def publish_dummy(self, publish):\n                \"\"\"\n                :param publish: Send the data through AMQP.\n                :type publish: farine.amqp.publisher.Publisher\n\t        \"\"\"\n\t        publish({'result':0})\n\t\n| And then a consumer :\n| the method decorated takes two parameters **body** (dict) and **message** (kombu.message.Message).\n\n.. code:: python\n\n\timport farine.amqp\n\n\tclass Consume(object):\n\t\n\t    @farine.amqp.consume(exchange='publish', routing_key='routing_key')\n\t    def consume_dummy(self, body, message):\n                \"\"\"\n                :param body: The message's data.\n                :type body: dict\n                :param message: Message class.\n                :type message: kombu.message.Message\n                \"\"\"\n\t        message.ack()\n \n\n\nRPC over AMQP\n-------------\n\n| We need declare two services :\n| the server : Wait for a call(consumer), and answer(publisher).\n| The method decorated just takes **args** and **kwargs**\n\n.. code:: python\n\n\timport farine.rpc\n\t\n\tclass Server(object):\n\t\n\t    @farine.rpc.method()\n\t    def dummy(self, *args, **kwargs):\n\t        return True\n\t\n\n| And the client : Send a call(publisher), and wait for an answer(consumer).\n| the method decorated takes one argument **rpc** (farine.rpc.client.Client).\n| The result will be a dictionnary.\n\n.. code:: python\n\n\timport farine.rpc\n\t\n\tclass Client(object):\n\t\n            @farine.rpc.client('myotherservice')\n\t    def dummy(self, rpc):\n                \"\"\"\n                :param rpc: The RPC client.\n                :type rpc: farine.rpc.client.Client\n                \"\"\"\n\t        result = rpc.dummy()\n\n\nRPC Stream\n----------\n\n| We can also do streaming RPC call.\n| All you need to do is to add *__stream__ = True** to your RPC call.\n| Also, a generator is returned.\n\nExample:\n\n.. code:: python\n\n\timport farine.rpc\n\t\n\tclass Server(object):\n\t\n\t    @farine.rpc.method()\n\t    def dummy(self, *args, **kwargs):\n\t        yield 'a'\n\t        yield 'b'\n\t\n.. code:: python\n\n\timport farine.rpc\n\t\n\tclass Client(object):\n\t\n\t    @farine.rpc.client('myotherservice')\n\t        def dummy(self, rpc):\n                \"\"\"\n                :param rpc: The RPC client.\n                :type rpc: farine.rpc.client.Client\n                \"\"\"\n\t        for result in rpc.dummy(__stream__=True):\n                    print result\n\n\nHTTP Stream\n-----------\n\n| We can declare a service that will listen to an HTTP SSE event :\n| the method decorated takes one argument **data** (dict).\n\n.. code:: python\n\n\timport farine.stream\n\t\n\tclass Client(object):\n\t\n\t    @farine.stream.http()\n\t    def listen_event(self, data):\n                \"\"\"\n                :param data: The event sent.\n                :type data: dict\n                \"\"\"\n\t        return True\n\nOverview\n--------\n\n| You can mix in a service everything:\n| it can be a consumer to an HTTP stream, and send back the result in RPC, etc.\n\nExample:\n\n.. code:: python\n\n\timport farine.rpc\n\timport farine.stream\n\t\n\tclass Client(object):\n\n            @farine.stream.http()\n            def get(self, data):\n                return self.send(data)\n\n\t    @farine.rpc.client('myotherservice')\n\t    def send(self, rpc, data):\n\t        return rpc.process(data)\n\n\nConfiguration\n=============\n\nBy default the configuration file is located in */etc/farine.ini*.\nYou can override this path using the environment variable **FARINE_INI**.\n\n| It must contains one section by service (using the **lowercase class name**).\n| a **DEFAULT** section can also be present.\n\nExample\n-------\n\n::\n\n        [DEFAULT]\n        amqp_uri = amqp://baguette:baguette@127.0.0.1:5672/baguette\n\n        [consume]\n        enabled = true\n\n\n\nLaunch\n======\n\nTo launch a service, just run:\n\n.. code:: shell\n\n\tfarine --start=mymodule\n\nIt will try to import *mymodule.service* and launch it.\n",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "https://github.com/baguette-io/baguette-messaging/",
    "keywords": "micro",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "baguette-messaging",
    "platform": "",
    "project_url": "https://pypi.org/project/baguette-messaging/",
    "release_url": "https://pypi.org/project/baguette-messaging/0.1/",
    "requires_dist": [],
    "requires_python": "",
    "summary": "Baguette messaging framework",
    "version": "0.1"
  },
  "releases": {
    "0.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "e41a8dbdf0234cd77ea3ae7f0e82d1c3",
          "sha256": "92069fa539796036e1764b19a1ab197915398f2918fcd34aee445131c4aa0301"
        },
        "downloads": 0,
        "filename": "baguette-messaging-0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "e41a8dbdf0234cd77ea3ae7f0e82d1c3",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 15317,
        "upload_time": "2017-07-23T09:51:50",
        "url": "https://files.pythonhosted.org/packages/4d/d9/2467ff8a4ba735c9137b62d018e215a4e551092cf32648280b80613f79f5/baguette-messaging-0.1.tar.gz"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "e41a8dbdf0234cd77ea3ae7f0e82d1c3",
        "sha256": "92069fa539796036e1764b19a1ab197915398f2918fcd34aee445131c4aa0301"
      },
      "downloads": 0,
      "filename": "baguette-messaging-0.1.tar.gz",
      "has_sig": false,
      "md5_digest": "e41a8dbdf0234cd77ea3ae7f0e82d1c3",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 15317,
      "upload_time": "2017-07-23T09:51:50",
      "url": "https://files.pythonhosted.org/packages/4d/d9/2467ff8a4ba735c9137b62d018e215a4e551092cf32648280b80613f79f5/baguette-messaging-0.1.tar.gz"
    }
  ]
}