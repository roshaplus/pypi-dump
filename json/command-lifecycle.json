{
  "info": {
    "author": "Richard Tier",
    "author_email": "rikatee@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 4 - Beta",
      "Environment :: Console",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: MIT License",
      "Natural Language :: English",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3.5",
      "Programming Language :: Python :: Implementation :: PyPy",
      "Topic :: Software Development :: Libraries :: Python Modules"
    ],
    "description": "# voice-command-lifecycle #\nPython library to manage the life-cycle of voice commands. Useful working with Alexa Voice Service.\n\n## Installation ##\n```bash\npip install git+https://github.com/richtier/voice-command-lifecycle.git@0.4.0#egg=command_lifecycle\n```\n\n### Wakeword detector ###\nA wakeword is a specific word that triggers the code to spring into action. It allows your code to be idle until the specific word is uttered.\n\nThe audio lifecycle uses [snowboy](https://github.com/Kitt-AI/snowboy#compile-a-python-wrapper) to determine if the wakeword was uttered. The library will need to be installed first.\n\nOnce you have compiled snowboy, copy the compiled `snowboy` folder to the top level of you project. By default, the folder structure should be:\n```\n.\n\u251c\u2500\u2500 ...\n\u251c\u2500\u2500 snowboy\n|   \u251c\u2500\u2500 snowboy-detect-swig.cc\n|   \u251c\u2500\u2500 snowboydetect.py\n|   \u2514\u2500\u2500 resources\n|       \u251c\u2500\u2500 alexa.umdl\n|       \u2514\u2500\u2500 common.res\n\u2514\u2500\u2500 ...\n```\n\nIf the default structure does not suit your needs can customize the [wakeword detector](#wakeword).\n\n## Usage ##\n\nYou should send a steady stream of audio to to the lifecycle by repetitively calling `lifecycle.extend_audio(some_audio_bytes)`. If the wakeword such as \"Alexa\" (default), or \"ok, Google\" was uttered then `handle_command_started` is called. `handle_command_finised` is then called once the command audio that followed the wakeword has finished.\n\n### Microphone audio ###\n\n```py\nimport pyaudio\n\nimport command_lifecycle\n\n\nclass AudioLifecycle(command_lifecycle.BaseAudioLifecycle):\n\n    def handle_command_started(self):\n        super().handle_command_started()\n        print('The audio contained the wakeword!')\n\n    def handle_command_finised(self):\n        super().handle_command_finised()\n        print('the command in the audio has finished')\n\nlifecycle = AudioLifecycle()\n\np = pyaudio.PyAudio()\nstream = p.open(format=pyaudio.paInt16, channels=1, rate=16000, input=True)\n\ntry:\n    print('listening. Start by saying \"Alexa\". Press CTRL + C to exit.')\n    while True:\n        lifecycle.extend_audio(stream.read(1024))\nfinally:\n    stream.stop_stream()\n    stream.close()\n    p.terminate()\n```\n\n\n### File audio ###\n\n```py\nimport wave\n\nimport command_lifecycle\n\n\nclass AudioLifecycle(command_lifecycle.BaseAudioLifecycle):\n    def handle_command_started(self):\n        super().handle_command_started()\n        print('The audio contained the wakeword!')\n\n    def handle_command_finised(self):\n        super().handle_command_finised()\n        print('the command in the audio has finished')\n\n\nlifecycle = AudioLifecycle()\nwith wave.open('./tests/resources/alexa_what_time_is_it.wav', 'rb') as f:\n    while f.tell() < f.getnframes():\n        lifecycle.extend_audio(f.readframes(1024))\n    # pad with silence at the end. See \"Expecting slower or faster commands\".\n    for i in range(lifecycle.timeout_manager.remaining_silent_frames + 1):\n        lifecycle.extend_audio(bytes([0, 0]*(1024*9)))\n```\n\n### Usage with Alexa ###\n\n`command_lifecycle` is useful for interacting with voice services. The lifecycle waits until a wakeword was issued and then start streaming the audio command to the voice service (using [Alexa Voice Service Client](https://github.com/richtier/alexa-voice-service-client)), then do something useful with the response:\n\n```py\nfrom avs_client.avs_client.client import AlexaVoiceServiceClient\nimport pyaudio\n\nimport command_lifecycle\n\n\nclass AudioLifecycle(command_lifecycle.BaseAudioLifecycle):\n    alexa_client = AlexaVoiceServiceClient(\n        client_id='my-client-id'\n        secret='my-secret',\n        refresh_token='my-refresh-token',\n    )\n\n    def __init__(self):\n        self.alexa_client.connect()\n        super().__init__()\n\n    def handle_command_started(self):\n        super().handle_command_started()\n        audio_file = command_lifecycle.to_audio_file()\n        alexa_response_audio = self.alexa_client.send_audio_file(audio_file)\n        if alexa_response_audio:\n            # do something with the AVS audio response, e.g., play it.\n\nlifecycle = AudioLifecycle()\n\np = pyaudio.PyAudio()\nstream = p.open(format=pyaudio.paInt16, channels=1, rate=16000, input=True)\n\ntry:\n    print('listening. Start by saying \"Alexa\". Press CTRL + C to exit.')\n    while True:\n        lifecycle.extend_audio(stream.read(1024))\nfinally:\n    stream.stop_stream()\n    stream.close()\n    p.terminate()\n```\n\n## Customization ##\n\n### Wakeword ###\n\nThe default wakeword is \"Alexa\". This can be changed by sub-classing `command_lifecycle.wakeword.SnowboyWakewordDetector`:\n\n```py\n\nfrom command_lifecycle import wakeword\n\n\nclass MySnowboyWakewordDetector(wakeword.SnowboyWakewordDetector):\n    decoder_model = b'path/to/custom-wakeword-model.umdl'\n\n\nclass AudioLifecycle(lifecycle.BaseAudioLifecycle):\n    audio_detector_class = MySnowboyWakewordDetector\n\n    def handle_command_started(self):\n        super().handle_command_started()\n        print('The audio contained the wakeword!')\n\n    def handle_command_finised(self):\n        super().handle_command_finised()\n        print('the command in the audio has finished')\n\n\nlifecycle = AudioLifecycle()\n# now load the audio into lifecycle\n\n```\n\nSee the [Snowboy docs](https://github.com/Kitt-AI/snowboy#hotword-as-a-service) for steps on creating custom wakeword models.\n\n### Wakeword detector ###\n\nSnowboy is the default wakeword detector. Other wakeword detectors can be used by sub-classing `command_lifecycle.wakeword.BaseWakewordDetector` and setting `wakeword_detector_class` to your custom class:\n\n\n```py\nimport wave\n\nfrom command_lifecycle import lifecycle, wakeword\n\n\nclass MyCustomWakewordDetector(wakeword.BaseWakewordDetector):\n    import_error_message = 'Cannot import wakeword library!'\n    wakeword_library_import_path = 'path.to.wakeword.Library'\n\n    def was_wakeword_uttered(self, buffer):\n        # use the library to check if the audio in the buffer has the wakeword.\n        # not `buffer.get()` returns the audio inside the buffer.\n        ...\n\n    def is_talking(self, buffer):\n        # use the library to check if the audio in the buffer has audible words\n        # not `buffer.get()` returns the audio inside the buffer.\n        ...\n\n\nclass AudioLifecycle(lifecycle.BaseAudioLifecycle):\n    audio_detector_class = MyCustomWakewordDetector\n\n    def handle_command_started(self):\n        super().handle_command_started()\n        print('The audio contained the wakeword!')\n\n    def handle_command_finised(self):\n        super().handle_command_finised()\n        print('the command in the audio has finished')\n\n\nlifecycle = AudioLifecycle()\n# now load the audio into lifecycle\n\n\n```\n\n### Expecting slower or faster commands ###\n\nThe person giving the audio command might take a moment to collect their thoughts before finishing the command. This silence could be interpreted as the command ending, resulting in `handle_command_finised` being called prematurely.\n\nTo avoid this the lifecycle tolerates some silence in the command before the lifecycle timesout the command. This silence can happen at the beginning or middle of the command. Note a side-effect of this is there will be a pause between when the person has stopped talking and when `handle_command_finised` is called.\n\nTo change this default behaviour `timeout_manager_class` can be changed. The available timeout managers are:\n\n| Timeout manager         | Notes                                            |\n| -------------------------| ------------------------------------------------ |\n| `ShortTimeoutManager`      | Allows one second of silence.                    |\n| `MediumTimeoutManager`     | **default** Allows two seconds of silence.       |\n| `LongTimeoutManager`       | Allows tree seconds of silence                   |\n\nTo make a custom timeout manager create a subclass of `command_lifecycle.timeout.BaseTimeoutManager`:\n\n```py\n\nimport wave\n\nfrom command_lifecycle import timeout, wakeword\n\n\nclass MyCustomTimeoutManager(timeout.BaseTimeoutManager):\n    allowed_silent_frames = 40\n\n\nclass AudioLifecycle(lifecycle.BaseAudioLifecycle):\n    timeout_manager_class = MyCustomTimeoutManager\n\n```\n\n\n## Other projects ##\nThis library is used by [alexa-browser-client](https://github.com/richtier/alexa-browser-client), which allows you to talk to Alexa from your browser.\n\n\n",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "https://github.com/richtier/voice-command-lifecycle",
    "keywords": "",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "command-lifecycle",
    "platform": "",
    "project_url": "https://pypi.org/project/command-lifecycle/",
    "release_url": "https://pypi.org/project/command-lifecycle/0.4.0/",
    "requires_dist": [
      "setuptools-git (==1.2)"
    ],
    "requires_python": "",
    "summary": "Python library to manage the life-cycle of voice commands.",
    "version": "0.4.0"
  },
  "releases": {
    "0.4.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "54cf47858c096f67ac022c9573eeaf61",
          "sha256": "36914701598a63039130a58b918f4892d8d50aaf753b310d7f2c3c12e8efd71d"
        },
        "downloads": 0,
        "filename": "command_lifecycle-0.4.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "54cf47858c096f67ac022c9573eeaf61",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "size": 11069,
        "upload_time": "2017-08-26T21:29:43",
        "url": "https://files.pythonhosted.org/packages/a2/34/5765a78d48fb7853353c6fbb5a00c3d64dd3c8097d5d7c6be2ff42975935/command_lifecycle-0.4.0-py3-none-any.whl"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "54cf47858c096f67ac022c9573eeaf61",
        "sha256": "36914701598a63039130a58b918f4892d8d50aaf753b310d7f2c3c12e8efd71d"
      },
      "downloads": 0,
      "filename": "command_lifecycle-0.4.0-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "54cf47858c096f67ac022c9573eeaf61",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "size": 11069,
      "upload_time": "2017-08-26T21:29:43",
      "url": "https://files.pythonhosted.org/packages/a2/34/5765a78d48fb7853353c6fbb5a00c3d64dd3c8097d5d7c6be2ff42975935/command_lifecycle-0.4.0-py3-none-any.whl"
    }
  ]
}