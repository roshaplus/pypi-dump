{
  "info": {
    "author": "Connexions team",
    "author_email": "info@cnx.org",
    "bugtrack_url": null,
    "classifiers": [],
    "description": ".. Note that the reStructuredText (rst) 'note' directive is not used,\n   because github does not style these in a way that makes them obvious.\n   If this document is ever put into a sphinx scroll,\n   therefore outside of the github readme,\n   the adjustment should be made to make notes use the rst 'note' directive.\n\n.. _cnx-epub: https://github.com/connexions/cnx-epub/\n.. _cnx-authoring: https://github.com/connexions/cnx-authoring/\n\n=============================\nConnexions Publishing Service\n=============================\n\n.. image:: https://travis-ci.org/Connexions/cnx-publishing.svg\n   :target: https://travis-ci.org/Connexions/cnx-publishing\n\n.. image:: https://img.shields.io/codecov/c/github/Connexions/cnx-publishing.svg\n  :target: https://codecov.io/gh/Connexions/cnx-publishing\n\nInterface for:\n\n- Accepting publication requests\n- Previewing publication requests\n- Submitting publications to the archive database\n- Accepting or denying role requests\n- Kicking off post-publication jobs\n- Moderating publications for first time publishers\n\nGetting started\n---------------\n\nInstall using one of the following methods (run within the project root)::\n\n    python setup.py install\n\nOr::\n\n    pip install .\n\nInitialize the database with the archive and publishing schema using the\nfollowing command::\n\n    cnx-db init -d cnxarchive -U cnxarchive\n\nTo run the project you can use the supplied script or configure it as a WSGI\napplication in your webserver.\n::\n\n    pserve <your-config>.ini\n\nHere ``<your-config>.ini`` can be the ``development.ini`` in the project root.\nThe settings in this config are the same as the development settings used\nby cnx-archive.\n\nIf you're using **cnx-authoring** together with **cnx-publishing**, please make sure\nyour development.ini use the **same openstax_accounts settings**.\n\nTesting\n-------\n\nThe tests require access to a blank database named ``cnxarchive-testing``\nwith the user ``cnxarchive`` and password ``cnxarchive``. This can easily\nbe created using the following commands::\n\n    psql -c \"CREATE USER cnxarchive WITH SUPERUSER PASSWORD 'cnxarchive';\"\n    createdb -O cnxarchive cnxarchive-testing\n\nThe tests can then be run using::\n\n    python setup.py test\n\nPermissions\n-----------\n\n**Note**: Permissions are assigned to users and groups via\n``cnxpublishing.main.RootFactory``. See that class for details about\nwhich permissions users/groups have in this application.\n\n:view: Allows one to view content.\n:publish: Allows one to publish content.\n:preview: Allows one to view a publication's contents prior\n    to persistence to archive.\n:moderate: Allows one to moderate, accept or reject, a publication.\n\n:publish.assign-acceptance: Allows one to assign user actions requests.\n:publish.remove-acceptance: Allows one to remove user actions requests.\n:publish.assign-acl: Allows one to assign access control on documents.\n:publish.remove-acl: Allows one to remove access control on documents.\n:publish.create-identifier: Allows one to create a content identifier.\n    This is primarily used as a sub-permission on actions requests.\n:publish.remove-identifier: Allows one to remove a content identifier.\n\nHTTP API\n--------\n\n:/contents/{ident_hash}: Location of existing and pending documents.\n                         If the document is pending publication, the response\n                         will contain information about its publication state.\n\n:/resources/{hash}: Location of existing and pending resources.\n\n:/contents/{uuid}/licensors: Retrieve a list of users that have a license\n                             request for this content. This includes those\n                             That have also previously accepted.\n                             Applications can post to this url in order\n                             to create license requests.\n\n:/contents/{uuid}/roles: Retrieve a list of users that have a role request\n                         for this content. This includes those that have\n                         previously accepted.\n                         Applications can post to this url in order\n                         to create role requests.\n\n:/contents/{uuid}/permissions: Retrieve a list of users that have a permission\n                               to publish this content.\n                               Applications can post to this url in order\n                               to create additional permission entries.\n\n:/publications: Accepts EPUB files for publication into a *Connexions Archive*.\n                Returns a mapping of identifiers, keyed by the identifiers given\n                in the EPUB with values that identify where the content will be\n                published.\n\n:/publications/{id}: Poll and poke the state of the publication. #main API point\n\n:/publications/{id}/license-acceptances/{uid}: Route for retrieving and posting\n    information about a particular user's license acceptance. Only the user\n    at ``uid`` can get and post information to on this route.\n\n:/publications/{id}/role-acceptances/{uid}: Route for retrieving and posting\n    role acceptance information. Only the user at ``uid`` can get and post\n    information to on this route.\n\n\nAPI By Example\n--------------\n\n\nInternal versus external usage\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe system is designed in a way that allows internal Connexions applications\nto communicate with publishing in such a way that is both workflow effective\nand less context redundant. In some parts of the code base you will see\nthis refered to as *trusted and untrustred* communication. That is a simple\nway of saying, the apps that are run inside the Connexions network are\nconsidered trusted. Trusted communications require the use of an API key.\n\nAn example *trusted app relationship* would be the communications\nthat happen between a cnx-authoring_ instance and publishing.\n\nExamples that follow...\n~~~~~~~~~~~~~~~~~~~~~~~\n\nAll the examples that follow use the following imports and base\nvariables::\n\n    >>> import json\n    >>> from pprint import pprint\n    >>> import tempfile\n    >>> import requests\n    >>> import cnxepub\n\n    # As configured in development.ini\n    >>> api_key = 'dev'\n    >>> base_url = 'http://localhost:6543'\n\nPublishing content\n~~~~~~~~~~~~~~~~~~\n\nAll publications take a single EPUB file formatted in the internal cnx-epub\nformat (See also the cnx-epub_ package), specifically it needs to be in\na publishing format, which contains a few required details.\n\nThe following is an example publication using some pre-build content::\n\n    # The example content we will publish...\n    >>> from cnxpublishing.tests.use_cases import EXAMPLE_BOOK\n\n    # Set up the epub that will be submitted.\n    >>> _, epub_filepath = tempfile.mkstemp('.publication.epub')\n    >>> publisher = 'ream'\n    >>> publication_message = 'Example publication'\n    >>> with open(epub_filepath, 'wb') as epub:\n    ...     cnxepub.make_publication_epub(EXAMPLE_BOOK, publisher,\n    ...                                   publication_message, epub)\n\n    # Send the book for publication.\n    >>> url = \"http://localhost:6543/publications\"\n    >>> file_payload = [\n    ...     ('epub', ('book.publication.epub', open(epub_filepath, 'rb'),\n    ...               'application/octet-stream',),)]\n    >>> headers = {'x-api-key': api_key}\n    >>> resp = requests.post(url, files=file_payload, headers=headers)\n    >>> assert resp.status_code == 200, resp.status_code\n\n    # The info returned from a successful POST looks something like this.\n    >>> pprint(resp.json())\n    {u'mapping': {u'07509e07-3732-45d9-a102-dd9a4dad5456': u'07509e07-3732-45d9-a102-dd9a4dad5456@1.1',\n                  u'de73751b-7a14-4e59-acd9-ba66478e4710': u'de73751b-7a14-4e59-acd9-ba66478e4710@1'},\n     u'messages': None,\n     u'publication': 1,\n     u'state': u'Waiting for acceptance'}\n\nIn trusted app relationships a *pre-publication* flag can be added to\nthe request. This flag is synonymous with a *dry-run* publication,\nexcept that it does create active role and license acceptance requests.\nThe content will not be published even if all the information is verified\nand all roles and licenors have accepted.\n\nThe response from publication creation will be one of three possiblities.\nThe first and already examined response is the 200 OK, which contains\nthe aforementioned JSON. Another option is a 403, which most likely\nmeans their was a failure to authenticate either through the API key\nor OpenStax Accounts. The other known possiblity is a 400 Bad Request,\nwhich will only be raised if the payload isn't a valid Connexions EPUB.\n\nInspecting the publication\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nAfter a publication has been created, the first response will be a set\nof data. This information contains the identify for the publication,\nthe state of the publication and a mapping of content identifiers to\ntheir final publication identifier.\n\nThe response JSON data of a publication POST is in the same\nstructure when making a GET request on the publication.\n\nThe structure is a single JSON object as follows:\n\n:publication: An integer identifying the publication.\n:state:  This value could be one of five values.\n    ``Done/Success``, which means the publication has been committed\n    to the archive.\n    ``Publishing``, which indicates the process of committing.\n    ``Processing`` is the default state on creation and generally signifies\n    that the publication is being worked on.\n    ``Waiting for acceptance`` is a blocking state that means that one\n    or more roles and licensors on the content needs to accept the\n    the role classification and/or license attributed to them\n    on the content.\n    ``Failed/Error`` is the end failing state. In the event that\n    the failing state it reached, the ``messages`` value of the JSON will\n    contain more detailed information about what failed.\n:messages: Contains a array of JSON or null. If the publication experienced\n    problems validating and/or analyzing any of the content, an error message\n    will appear in the array.\n:mapping: (Only available in the response to a POST.) The value is\n    a mapping of content identifiers keyed by the identifiers\n    sent in the epub to the final identifier, which includes id and version\n    (a.k.a. ident-hash).\n\nThe base structure of error messages looks like this:\n\n:code: An integer that is unique to a specific type of error. For example,\n    error code 9 is a missing required metadata error.\n:type: A string that represent the error's type. This is typically the\n    name of the exception as it appears in the Python code.\n:publication_id: The publication this exception belongs to.\n    This is not particularly useful to those externally reading the data.\n:epub_filename: The name of the document as it appears in the epub file.\n    This is usually never supplied, unless the document cannot be read.\n:pending_document_id: The identifier used internally by publishing\n    that points to the pending document/binder.\n    This is not particularly useful to those externally reading the data.\n:pending_ident_hash: This is the identifier of the would be published content.\n    One can reverse map this identifier to their own using the mapping\n    in the publiation POST response.\n\nAdditional key value pairs are added to the error message based on type.\nFor example, a code 8 'NotAllowed' error would also contain\na ``uuid`` and it's value, where the value is the UUID of the would be\npublished content.\n\nAdjusting publication permissions\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nAs part of the intial publication, the publisher is entered into\nthe interal permissions system as having the publish permission\nfor the epub's content(s). Any additions need to be handled\nvia a separate API call.\n\nWe can take a look at the users that have permissions on a piece of\ncontent using the ``/contents/{id}/permissions`` path. For example::\n\n    >>> uuid = 'de73751b-7a14-4e59-acd9-ba66478e4710'\n    >>> url = \"{}/contents/{}/permissions\".format(base_url, uuid)\n    >>> resp = requests.get(url)\n    >>> pprint(resp.json())\n    [{u'permission': u'publish',\n      u'uid': u'ream',\n      u'uuid': u'de73751b-7a14-4e59-acd9-ba66478e4710'}]\n\nTo give the user 'rings'\nthe publishing ability on a specific piece of content::\n\n    >>> headers = {'x-api-key': api_key, 'content-type': 'application/json'}\n    >>> data = [{'uid': 'rings', 'permission': 'publish'}]\n    >>> resp = requests.post(url, headers=headers, data=json.dumps(data))\n    >>> assert resp.status_code == 202\n    >>> pprint(requests.get(url).json())\n    [{u'permission': u'publish',\n      u'uid': u'ream',\n      u'uuid': u'de73751b-7a14-4e59-acd9-ba66478e4710'},\n     {u'permission': u'publish',\n      u'uid': u'rings',\n      u'uuid': u'de73751b-7a14-4e59-acd9-ba66478e4710'}]\n\nAnd removal is the opposite of an addition. For example, to remove\npublish permission for the user 'rings'::\n\n    >>> resp = requests.delete(url, headers=headers, data=json.dumps(data))\n    >>> assert resp.status_code == 200\n    >>> pprint(requests.get(url).json())\n    [{u'permission': u'publish',\n      u'uid': u'ream',\n      u'uuid': u'de73751b-7a14-4e59-acd9-ba66478e4710'}]\n\n\nChecking role and license acceptance\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nBefore any publication can be commited to the archive,\nthe attributed role(s) (e.g. author, illustrator, etc.) must be accepted.\nFurthermore, all roles must accept the license.\n\nOnly trusted applications can dictate role and license acceptance,\nbut the viewing of the acceptance list is publically accessible.\n\nTo view the current roles and license acceptance use the\n``/contents/{id}/roles`` and ``/contents/{id}/licensors``, respectively.\n\n::\n\n    >>> url = \"{}/contents/{}/roles\".format(base_url, uuid)\n    >>> pprint(requests.get(url).json())\n    [{u'has_accepted': None,\n      u'role': u'Author',\n      u'uid': u'charrose',\n      u'uuid': u'de73751b-7a14-4e59-acd9-ba66478e4710'},\n     {u'has_accepted': None,\n      u'role': u'Illustrator',\n      u'uid': u'frahablar',\n      u'uuid': u'de73751b-7a14-4e59-acd9-ba66478e4710'},\n     {u'has_accepted': None,\n      u'role': u'Translator',\n      u'uid': u'frahablar',\n      u'uuid': u'de73751b-7a14-4e59-acd9-ba66478e4710'},\n     ...]\n\n    >>> url = \"{}/contents/{}/licensors\".format(base_url, uuid)\n    >>> pprint(requests.get(url).json())\n    {u'license_url': u'http://creativecommons.org/licenses/by/4.0/',\n     u'licensors': [{u'has_accepted': None,\n       u'uid': u'charrose',\n       u'uuid': u'de73751b-7a14-4e59-acd9-ba66478e4710'},\n      {u'has_accepted': None,\n       u'uid': u'frahablar',\n       u'uuid': u'de73751b-7a14-4e59-acd9-ba66478e4710'},\n      ...]}\n\nAdjusting role and license acceptance\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe same data format in the response to a GET for role and license\nacceptance can be used to create and delete them.\n\nTo adjust and add a new role::\n\n    >>> url = \"{}/contents/{}/roles\".format(base_url, uuid)\n    >>> headers = {'x-api-key': api_key, 'content-type': 'application/json'}\n    >>> data = [{'uid': 'charrose', 'role': 'Author', 'has_accepted': True}]\n    >>> resp = requests.post(url, data=json.dumps(data), headers=headers)\n    >>> assert resp.status_code == 202\n    >>> pprint(requests.get(url).json())\n    [{u'has_accepted': True,\n      u'role': u'Author',\n      u'uid': u'charrose',\n      u'uuid': u'de73751b-7a14-4e59-acd9-ba66478e4710'},\n     {u'has_accepted': None,\n      u'role': u'Illustrator',\n      u'uid': u'frahablar',\n      u'uuid': u'de73751b-7a14-4e59-acd9-ba66478e4710'},\n     {u'has_accepted': None,\n      u'role': u'Translator',\n      u'uid': u'frahablar',\n      u'uuid': u'de73751b-7a14-4e59-acd9-ba66478e4710'},\n     ...]\n\nAnd deletion is very similar::\n\n    >>> data = [{'uid': 'frahablar', 'role': 'Translator'}]\n    >>> resp = requests.delete(url, data=json.dumps(data), headers=headers)\n    >>> assert resp.status_code == 200\n    >>> pprint(requests.get(url).json())\n    [{u'has_accepted': True,\n      u'role': u'Author',\n      u'uid': u'charrose',\n      u'uuid': u'de73751b-7a14-4e59-acd9-ba66478e4710'},\n     {u'has_accepted': None,\n      u'role': u'Illustrator',\n      u'uid': u'frahablar',\n      u'uuid': u'de73751b-7a14-4e59-acd9-ba66478e4710'},\n     ...]\n\nManipulating license accept is very similar to role acceptance.\nThe only major differences are the wrapping JSON around the acceptances\n(found in the ``licensors`` value) and the lack of a role in the acceptance\nJSON values. Note, the ``license_url`` value is important, because if it\nis changed, it will flush all the acceptances to an unknown state.\nHere is an example of how this would look::\n\n    >>> url = \"{}/contents/{}/licensors\".format(base_url, uuid)\n    >>> headers = {'x-api-key': api_key, 'content-type': 'application/json'}\n    >>> pprint(requests.get(url).json())\n    {u'license_url': u'http://creativecommons.org/licenses/by/4.0/',\n     u'licensors': [{u'has_accepted': None,\n       u'uid': u'charrose',\n       u'uuid': u'de73751b-7a14-4e59-acd9-ba66478e4710'},\n      {u'has_accepted': None,\n       u'uid': u'frahablar',\n       u'uuid': u'de73751b-7a14-4e59-acd9-ba66478e4710'},\n      ...]}\n\n    >>> data = {\n    ...     'license_url': 'http://creativecommons.org/licenses/by/4.0/',\n    ...     'licensors': [{'uid': 'frahablar', 'has_accepted': False}]}\n    >>> resp = requests.post(url, data=json.dumps(data), headers=headers)\n    >>> assert resp.status_code == 202\n    >>> data = {'licensors': [{'uid': 'charrose'}]}\n    >>> resp = requests.delete(url, data=json.dumps(data), headers=headers)\n    >>> assert resp.status_code == 200\n    >>> pprint(requests.get(url).json())\n    {u'license_url': u'http://creativecommons.org/licenses/by/4.0/',\n     u'licensors': [{u'has_accepted': False,\n                     u'uid': u'frahablar',\n                     u'uuid': u'de73751b-7a14-4e59-acd9-ba66478e4710'},\n      ...]}\n\nCreating identifiers on-the-fly\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nOnly trusted applications, those are applications run within the Connexions\nnetwork, are able to create identifiers on-the-fly. This simply means\nthat if content 'xyz123' doesn't exist at '/contents/xyz123', the application\ncan create a stub for it.\n\nThe roles and license accpetance routes as well as the permissions route can\ncreate identifiers where one previously did not exist.\n\n::\n\n    >>> uuid = '7a268e3a-1e3a-4f4d-aaab-5ecd046187c1'\n    >>> url = '{}/contents/{}/permissions'.format(base_url, uuid)\n    >>> headers = {\n    ...     'x-api-key': 'b07',  # b07 is a trusted app in development.ini\n    ...     'content-type': 'application/json'}\n    >>> assert requests.get(url).status_code == 404\n    >>> data = [{'uid': 'impicky', 'permission': 'publish'}]\n    >>> resp = requests.post(url, data=json.dumps(data), headers=headers)\n    >>> assert resp.status_code == 202\n    >>> pprint(requests.get(url).json())\n    [{u'permission': u'publish',\n      u'uid': u'impicky',\n      u'uuid': u'7a268e3a-1e3a-4f4d-aaab-5ecd046187c1'}]\n\nLicense\n-------\n\nThis software is subject to the provisions of the GNU Affero General\nPublic License Version 3.0 (AGPL). See license.txt for details.\nCopyright (c) 2013 Rice University\n",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "https://github.com/connexions/cnx-publishing",
    "keywords": "",
    "license": "LGPL, See also LICENSE.txt",
    "maintainer": "",
    "maintainer_email": "",
    "name": "cnx-publishing",
    "platform": "UNKNOWN",
    "project_url": "https://pypi.org/project/cnx-publishing/",
    "release_url": "https://pypi.org/project/cnx-publishing/0.7.0/",
    "requires_python": "",
    "summary": "Application for accepting publication requests to the Connexions Archive.",
    "version": "0.7.0"
  },
  "releases": {
    "0.0.0": [],
    "0.6.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "f0ce556b98f08f664856f92a484c314c",
          "sha256": "09d3a10012f49e568865ccbb8607c0388303d9f16e47ef19a2ad8915170a16c4"
        },
        "downloads": 92,
        "filename": "cnx-publishing-0.6.0.tar.gz",
        "has_sig": false,
        "md5_digest": "f0ce556b98f08f664856f92a484c314c",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 132667,
        "upload_time": "2016-12-21T15:23:00",
        "url": "https://files.pythonhosted.org/packages/22/11/ae3a6e3737aaa0b816a7a677f17308f32fcdaf814afa59e8792673859e99/cnx-publishing-0.6.0.tar.gz"
      }
    ],
    "0.7.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "7c2cae06eb41498bdd4e5dc3928d754e",
          "sha256": "8ca1406e3425b73ad37b29741fe095e7d6b0c43057c510d15cf89b48f108cde0"
        },
        "downloads": 0,
        "filename": "cnx-publishing-0.7.0.tar.gz",
        "has_sig": false,
        "md5_digest": "7c2cae06eb41498bdd4e5dc3928d754e",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 151992,
        "upload_time": "2017-05-08T19:25:21",
        "url": "https://files.pythonhosted.org/packages/29/a3/5feff1a18d6ecb012e818f0085957a8befd88ac67a5fdcc073adb1b119c8/cnx-publishing-0.7.0.tar.gz"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "7c2cae06eb41498bdd4e5dc3928d754e",
        "sha256": "8ca1406e3425b73ad37b29741fe095e7d6b0c43057c510d15cf89b48f108cde0"
      },
      "downloads": 0,
      "filename": "cnx-publishing-0.7.0.tar.gz",
      "has_sig": false,
      "md5_digest": "7c2cae06eb41498bdd4e5dc3928d754e",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 151992,
      "upload_time": "2017-05-08T19:25:21",
      "url": "https://files.pythonhosted.org/packages/29/a3/5feff1a18d6ecb012e818f0085957a8befd88ac67a5fdcc073adb1b119c8/cnx-publishing-0.7.0.tar.gz"
    }
  ]
}