{
  "info": {
    "author": "Nathaniel J. Smith",
    "author_email": "njs@pobox.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: Apache Software License",
      "License :: OSI Approved :: MIT License",
      "Programming Language :: Python :: 2",
      "Programming Language :: Python :: 2.7",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.5",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: Implementation :: CPython",
      "Programming Language :: Python :: Implementation :: PyPy",
      "Topic :: System :: Networking"
    ],
    "description": "trustme: #1 quality TLS certs while you wait\n============================================\n\n.. image:: https://vignette2.wikia.nocookie.net/jadensadventures/images/1/1e/Kaa%27s_hypnotic_eyes.jpg/revision/latest?cb=20140310173415\n   :width: 200px\n   :align: right\n\nYou wrote a cool network client or server. You encrypt your\nconnections using `TLS\n<https://en.wikipedia.org/wiki/Transport_Layer_Security>`__. Your test\nsuite needs to make TLS connections.\n\nUh oh. Your test suite *probably* doesn't have a valid TLS\ncertificate. Now what?\n\n``trustme`` is a tiny Python package that does one thing: it gives you\na `fake <https://martinfowler.com/bliki/TestDouble.html>`__\ncertificate authority (CA) that you can use to generate fake TLS certs\nto use in your tests. Well, technically they're real certs, they're\njust signed by your CA, which nobody trusts. But you can trust\nit. Trust me.\n\n\nExample\n=======\n\n.. code-block:: python\n\n   from trustme import CA\n\n   # Look, you just became a certificate authority\n   ca = CA()\n\n   # Issue a server cert, signed by your fake CA\n   # https://en.wikipedia.org/wiki/Example.org\n   server_cert = ca.issue_server_cert(u\"my-test-host.example.org\")\n\n   # That's it! You have your certs. Now let's see how to use them.\n\n   ###########\n\n   # The simplest thing to do is to take the raw PEM certificates, and\n   # write them out to some files. Maybe this is useful if you want to \n   # use them for a test suite written in some other language.\n\n   with open(\"fake-ca.pem\", \"wb\") as f:\n       f.write(ca.cert_pem)\n   with open(\"fake-server-private-key-and-cert-chain.pem\", \"wb\") as f:\n       f.write(server_cert.private_key_and_cert_chain_pem)\n\n   ###########\n\n   # Or, you can use them directly, for example to make a within-process\n   # connection between two threads.\n\n   import ssl, socket, threading\n\n   # Client side\n   def fake_ssl_client(raw_client_sock):\n       # Get an ssl.SSLContext object configured to trust your CA\n       ssl_ctx = ca.stdlib_client_context()\n       wrapped_client_sock = ssl_ctx.wrap_socket(\n           raw_client_sock, server_hostname=\"my-test-host.example.org\")\n       # Look, here's the cert presented by the server\n       print(\"Client got server cert:\", wrapped_client_sock.getpeercert())\n       # Send some data to prove the connection is good\n       wrapped_client_sock.send(b\"x\")\n\n   # Server side\n   def fake_ssl_server(raw_server_sock):\n       # Get an ssl.SSLContext object configured to use your server cert\n       ssl_ctx = server_cert.stdlib_server_context()\n       wrapped_server_sock = ssl_ctx.wrap_socket(raw_server_sock, server_side=True)\n       # Prove that we're connected\n       print(\"server encrypted with:\", wrapped_server_sock.cipher())\n       assert wrapped_server_sock.recv(1) == b\"x\"\n\n   # Blah blah blah actually run the things\n   raw_client_sock, raw_server_sock = socket.socketpair()\n   client_thread = threading.Thread(target=fake_ssl_client, args=(raw_client_sock,))\n   server_thread = threading.Thread(target=fake_ssl_server, args=(raw_server_sock,))\n   client_thread.start()\n   server_thread.start()\n   client_thread.join()\n   server_thread.join()\n\n\nDocs\n====\n\n``CA()`` gives you a certificate authority. It has attributes\n``.cert_pem`` which is a bytestring containing what it sounds like,\n``.issue_server_cert(hostname1, [hostname2, ...])`` which does what it\nsays on the tin, and ``.stdlib_client_context()``, which is a\nconvenience method that returns an ``ssl.SSLContext`` object\npreconfigured to trust this CA.\n\n``CA.issue_server_cert`` returns a ``ServerCert`` object, which has\nattributes ``.private_key_pem``, ``.cert_chain_pem``, and\n``.private_key_and_cert_chain_pem``, which are bytestrings containing\nwhat they sound like. It also has a convenience method\n``.stdlib_server_context()`` which returns an ``ssl.SSLContext``\nobject preconfigured to present this cert to any client that\nconnects.\n\nThe ``.stdlib_*_context`` methods accept ``**kwargs``, which are\npassed on to `ssl.create_default_context\n<https://docs.python.org/3/library/ssl.html#ssl.create_default_context>`__.\n\nProbably this should get moved into Sphinx or something but whatever,\nhopefully you get the idea. Or feel free to send a PR converting this\ninto proper docs.\n\n\nFAQ\n===\n\n**Should I use these certs for anything real?** Certainly not.\n\n**Why not just use self-signed certificates?** These are more\nrealistic. You don't have to disable your certificate validation code\nin your test suite, which is good, because you want to test what you\nrun in production, and you would *never* disable your certificate\nvalidation code in production, right? Plus they're just as easy to\nwork with. Maybe easier.\n\n**Why do you only have convenience methods for the stdlib ssl module,\nand not PyOpenSSL / Twisted / ...?** Because you didn't send me a PR\nyet.\n\n**I want to test some weirdo TLS configuration.** I'm happy to accept\nPRs to do simple things like override the default validity period or\nset key sizes or whatever, within reason. But if you have complicated\nneeds then you're probably better offer stealing the code from this\nlibrary and adapting it to do what you want. The underlying API is\npretty straightforward. This is just a convenience library for those\nof us who need a cheat sheet to tie our shoelaces, X.509-wise.\n\n\nVital statistics\n================\n\n**Bug tracker and source code:** https://github.com/python-trio/trustme\n\n**License:** MIT or Apache 2, your choice.\n\n**Install:** ``pip install -U trustme``\n\n**Code of conduct:** Contributors are requested to follow our `code of\nconduct\n<https://github.com/python-trio/trustme/blob/master/CODE_OF_CONDUCT.md>`__\nin all project spaces.\n\n\nAcknowledgements\n================\n\nThis is basically just a trivial wrapper around the awesome Python\n`cryptography <https://cryptography.io/>`__ library. Also, `Glyph\n<https://glyph.twistedmatrix.com/>`__ wrote most of the tricky bits. I\ngot tired of never being able to remember how this works or find the\nmagic snippets to copy/paste, so I stole the code out of `Twisted\n<http://twistedmatrix.com/>`__ and wrapped it in a bow.\n\n\n",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "https://github.com/python-trio/trustme",
    "keywords": "",
    "license": "MIT -or- Apache License 2.0",
    "maintainer": "",
    "maintainer_email": "",
    "name": "trustme",
    "platform": "",
    "project_url": "https://pypi.org/project/trustme/",
    "release_url": "https://pypi.org/project/trustme/0.1.0/",
    "requires_dist": [
      "cryptography"
    ],
    "requires_python": "",
    "summary": "#1 quality TLS certs while you wait, for the discerning tester",
    "version": "0.1.0"
  },
  "releases": {
    "0.1.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "9ac5f505bf4f4054863aa0f6f6e853fe",
          "sha256": "65d270b0d8d28cf1af96a33228d01dfe096248e2e0231070b9ddb0a4232310bd"
        },
        "downloads": 0,
        "filename": "trustme-0.1.0-py2.py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "9ac5f505bf4f4054863aa0f6f6e853fe",
        "packagetype": "bdist_wheel",
        "python_version": "py2.py3",
        "size": 9293,
        "upload_time": "2017-07-18T06:05:44",
        "url": "https://files.pythonhosted.org/packages/eb/d4/76844eee31296cffa6a7bb7ac6a647b21fc51601573cd316677bb629827e/trustme-0.1.0-py2.py3-none-any.whl"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "c6ec3d630ce9659506661665d1200512",
          "sha256": "9cb7a3dd6583cfc751658d01faa6c994b4607da6bd7241f3a291babd6d62773c"
        },
        "downloads": 0,
        "filename": "trustme-0.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "c6ec3d630ce9659506661665d1200512",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 13201,
        "upload_time": "2017-07-18T06:05:47",
        "url": "https://files.pythonhosted.org/packages/42/c5/829584610901dc132c46c79abca3f34ab22507aa977e11d032d86f24e446/trustme-0.1.0.tar.gz"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "9ac5f505bf4f4054863aa0f6f6e853fe",
        "sha256": "65d270b0d8d28cf1af96a33228d01dfe096248e2e0231070b9ddb0a4232310bd"
      },
      "downloads": 0,
      "filename": "trustme-0.1.0-py2.py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "9ac5f505bf4f4054863aa0f6f6e853fe",
      "packagetype": "bdist_wheel",
      "python_version": "py2.py3",
      "size": 9293,
      "upload_time": "2017-07-18T06:05:44",
      "url": "https://files.pythonhosted.org/packages/eb/d4/76844eee31296cffa6a7bb7ac6a647b21fc51601573cd316677bb629827e/trustme-0.1.0-py2.py3-none-any.whl"
    },
    {
      "comment_text": "",
      "digests": {
        "md5": "c6ec3d630ce9659506661665d1200512",
        "sha256": "9cb7a3dd6583cfc751658d01faa6c994b4607da6bd7241f3a291babd6d62773c"
      },
      "downloads": 0,
      "filename": "trustme-0.1.0.tar.gz",
      "has_sig": false,
      "md5_digest": "c6ec3d630ce9659506661665d1200512",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 13201,
      "upload_time": "2017-07-18T06:05:47",
      "url": "https://files.pythonhosted.org/packages/42/c5/829584610901dc132c46c79abca3f34ab22507aa977e11d032d86f24e446/trustme-0.1.0.tar.gz"
    }
  ]
}