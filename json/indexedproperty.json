{
  "info": {
    "author": "Rob Gaddi",
    "author_email": "rgaddi@highlandtechnology.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 4 - Beta",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: MIT License",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.4"
    ],
    "description": "==================\nIndexed Properties\n==================\n\nOverview\n========\n\nThis package supports indexed properties on class instances.  Whereas the\nbuiltin property function allows you create functions for single-valued \nproperties, the indexedproperty package allows you to create properties that\naccept an index argument like the __getitem__/__setitem__/__delitem__\nset::\n\n\t>>> from indexedproperty import indexedproperty\n\t>>> class PropertyTest:\n\t... \tdef __init__(self):\n\t... \t\tself._singleprop = None\n\t... \t\tself._dict = {}\n\t... \t\n\t... \t# Standard builtin property\n\t... \t@property\n\t... \tdef sprop(self):\n\t... \t\treturn self._singleprop\n\t... \t\t\n\t... \t@sprop.setter\n\t... \tdef sprop(self, value):\n\t... \t\tprint('Setting sprop', value)\n\t... \t\tself._singleprop = value\n\t... \t\n\t... \t# Fancy new indexed property\n\t... \t@indexedproperty\n\t... \tdef iprop(self, key):\n\t... \t\treturn self._dict[key]\n\t... \t\t\n\t... \t@iprop.setter\n\t... \tdef iprop(self, key, value):\n\t... \t\tprint('Setting iprop {0}={1}'.format(key, value))\n\t... \t\tself._dict[key] = value\n\t...\n\t>>> x = PropertyTest()\n\t>>> x.sprop = 5\n\tSetting sprop 5\n\t>>> x.sprop\n\t5\n\t>>> x.iprop['Gilliam'] = 'Terry'\n\tSetting iprop Gilliam=Terry\n\t>>> x.iprop['Gilliam']\n\t'Terry'\n\t\nDecorator Functions\n===================\n\nThe most convenient use for this library is through the decorator functions.\n\n\tindexedproperty\n\t\tMarks a function as the getter (__getitem__) for an IndexedProperty. \n\t\tThe .setter (__setitem__) and .deleter(__delitem__) methods may be \n\t\tcalled on the returned IndexedProperty to add additional functionality \n\t\tfor the property\n\t\t\n\tcontainerproperty(base)\n\t\tMarks a function as the getter (__getitem__) for a ContainerProperty. A \n\t\tContainerProperty is indexed on the container provided by base and \n\t\traises a KeyError if the users's key is not \"in\" the base.\n\t\t\n\t\tIf the base supports iter() and len(), the ContainerProperty does as \n\t\twell, and adds an items() iterator similar to the one provided by dict.  \n\t\tBroadcasting is supported on list and tuple keys.\n\t\t\n\trangeproperty([start=0], stop)\n\t\tMarks a function as the getter (__getitem__) for an RangeProperty. This \n\t\tproperty is indexed on the half-open numeric range defined by \n\t\trange(start, stop), and behaves like a Sequence, though with a \n\t\tpotentially non-zero lower bound.\n\t\t\n\t\tRangeProperty elements support iteration, negative index wraparound (if \n\t\tstart >= 0), and broadcasting on list, tuple, range, and slice keys.\n\t\t\nDecorating Methods\n==================\n\nAkin to *property*, the basic operations are to define the setter, getter, and\ndeleter for an IndexedProperty.  The functional form of the decorator assumes\nthe getter, and further assignments are made by the .setter and .deleter\nmethods of the property.\n\nUnlike a property, however, decorators can be created to provide any function\nincluding \"magic\" methods like *__iter__* and *__contains__*, which will work\nas expected.  In all cases, the first argument to the function (typically `self`)\nwill point to an instance of the class that the property is defined in.\n\nOr to say it another way, when you have::\n\n\t@x.__iter__\n\tdef fancyproperty(self):\n\t\t...\n\t\t\n\tdef unfancymethod(self):\n\t\t...\n\t\t\nboth of those get the same self.\n\nOn the base IndexedProperty, you can assign to .iterable_indices with a tuple\nof classes that should be given special treatment.  If the key in the brackets\nis an instance of one of then, then rather than pass the key on to the\ngetter/setter/deleter functions directly, it will be iterated into successive\ncalls.  So if x.iterable_indices = (list, tuple)\n\n+--------------------------+---------------------------------+\n|Doing                     | Does                            |\n+==========================+=================================+\n| x[5]                     | return x.getter(self, 5)        |\n+--------------------------+---------------------------------+\n| x[5,10,15]               | return [x.getter(self, 5),      |\n|                          | x.getter(self, 10),             |\n|                          | x.getter(self, 15)]             |\n+--------------------------+---------------------------------+\n| x[5] = 'Larry'           | x.setter(self, 5, 'Larry')      |\n+--------------------------+---------------------------------+\n| x[5,10,15] = 'Larry'     | x.setter(self, 5, 'Larry')      |\n|                          | x.setter(self, 10, 'Larry')     |\n|                          | x.setter(self, 15, 'Larry')     |\n+--------------------------+---------------------------------+\n| x[5,10,15] = (\"Larry\"    | x.setter(self, 5, \"Larry\")      |\n|               \"can't\",   | x.setter(self, 10, \"can't\")     |\n|               \"spel\")    | x.setter(self, 15, \"spel\")      |\n+--------------------------+---------------------------------+\n\nThe setter broadcasting concept is taken from numpy; you can assign either a\nsingle value or an iterable of values that is the same length as the list of keys.\nStrings are treated as single values, and non-string iterables of a different\nlength than the key list raise ValueError.\n\nYou can also assign the .moduserindex and .modindex functions.\n\n\t* moduserindex(self, index) is called on the original index, i.e. (5, 10, \n\t  15).  It must return a modified (or unmodified) index or raise an\n\t  exception.  This is how RangeProperty turns a slice index into an iterable\n\t  range.\n\t  \n\t* modindex(self, index) is called on each index as it will go to the getter/setter/deleter\n\t  functions.  It must return a modified (or unmodified) index or raise an \n\t  exception.  This is how ContainerProperty raises a KeyError if the index is \n\t  not found in the base list.\n\nSimply assigning these functions is fine for the base IndexedProperty, as the\ndefault versions return the index unaltered so their loss is no big deal.\nAssigning to them on ContainerProperty or RangeProperty will break things; these\nshould be formally subclassed rather than just patched.\n\n__getitem__, __setitem__, and __delitem__ cannot be patched, as it would\nbreak the magic.\n\nSome Use Cases\n==============\n\nHere we have both *rangeproperty* in it's natural habitat, and an utterly\ngratuitious use of assigning additional functions to the property::\n\n\t>>> import indexedproperty as ix\n\t>>> class Uint32:\n\t... \tdef __init__(self, val=0):\n\t... \t\tself.word = val\n\t... \t\t\n\t... \tdef __repr__(self):\n\t... \t\treturn \"{0}(0x{1:x})\".format(type(self).__name__, self.word)\n\t... \n\t... \t@ix.RangeProperty(32)\n\t... \tdef bit(self, b):\n\t... \t\treturn self.word & (1 << b)\n\t... \t\t\n\t... \t@bit.setter\n\t... \tdef bit(self, b, val):\n\t... \t\tv = 1 << b\n\t... \t\tself.word |= v\n\t... \t\tif not val:\n\t... \t\t\tself.word ^= v\n\t... \t\t\t\n\t... \t@bit.count\n\t... \tdef bit(self):\n\t... \t\treturn sum(bool(b) for b in self.bit)\n\t... \n\t... \t@bit.lowest\n\t... \tdef bit(self):\n\t... \t\tfor idx, b in self.bit.items():\n\t... \t\t\tif b:\n\t... \t\t\t\treturn idx\n\t... \t\treturn None\n\t...\n\t... \t@bit.highest\n\t... \tdef bit(self):\n\t... \t\tfor idx in reversed(self.bit.range):\n\t... \t\t\tif self.bit[idx]:\n\t... \t\t\t\treturn idx\n\t... \t\treturn None\n\t... \n\t... \tdef clear(self):\n\t... \t\tself.word = 0\n\t... \t\n\t>>> x = Uint32()\n\t>>> x.bit[1::4] = True\n\t>>> x\n\tUint32(0x22222222)\n\t>>> x.bit[:8]\n\t[0, 2, 0, 0, 0, 32, 0, 0]\n\t>>> x.bit[15:7:-1]\n\t[0, 0, 8192, 0, 0, 0, 512, 0]\n\t>>> x.bit.count()\n\t8\n\t>>> x.bit.lowest()\n\t1\n\t>>> x.bit.highest()\n\t29\n\t>>> (list(x.bit))[::-1] == list(reversed(x.bit))\n\tTrue\n\nHere is *containerproperty* providing both access restriction and broadcasting\nfunctionality to an internal list of properties.\n\n\t>>> import indexedproperty as ix\n\t>>> class FoodRestrictions:\n\t... \t_foodlist = ['apples', 'bananas', 'pears']\n\t... \n\t... \tdef __init__(self):\n\t... \t\tself.fooddict = { k : [] for k in self._foodlist }\n\t... \n\t... \t@ix.containerproperty(_foodlist)\n\t... \tdef lunch(self, idx):\n\t... \t\treturn self.fooddict[idx]\n\t... \n\t... \t@lunch.setter\n\t... \tdef lunch(self, idx, value):\n\t... \t\tself.fooddict[idx] = value\n\t... \n\t>>> x = FoodRestrictions()\n\t>>> x.lunch['apples'] = 'I have an apple'\n\t>>> x.lunch['bread'] = 'But I want bread'\n\tTraceback (most recent call last):\n\tKeyError: 'bread'\n\t>>> x.lunch['pears'] = 5\n\t>>> x.lunch['apples', 'pears']\n\t['I have an apple', 5]\n\t>>> sorted(x.lunch)\n\t['apples', 'bananas', 'pears']\n\t\nWhat's Under The Hood\n=====================\n\nWhen you get a class member defined as an IndexedProperty, what is returned is\na subclass of Trampoline.  The definition of that class is local to the \nspecific IndexedProperty under discussion, and is updated every time a new\nmember is created by one of the IndexedProperty's decorators.  In the above\nexample, when @lunch.setter is executed it updates the class definition for\nthe lunch Trampoline to include a setter() method.\n\nSo when you ask for x.lunch, you get a new instance of that Trampoline subclass\nthat has that setter function, as well as getter, __iter__, __len__, and items,\nand a .obj pointer to x.  The Trampoline the function calls against it back\nagainst the functions originally decorated.\n\nExtending IndexedProperty\n=========================\n\nNew types of indexed properties (such as RangeProperty) can be created by \nsubclassing IndexedProperty.  This can be a bit tricky, because the class \ndoes some of the work and the Trampoline subclass does the rest.\n\nSee the source code for ContainerProperty and RangeProperty for examples of how \nthis is done.  Start with ContainerProperty, it's the more straightforward of \nthe two.\n\nThe important logic to follow is\n\n1) The IndexedProperty subclass has a ._Trampoline member, which is a subclass\nof Trampoline.  Class methods for the trampoline that are not specific to a\ngiven instance of the IndexedProperty can be defined here.  In these methods,\nthe object that the property is a member of is available as ``self.obj``.\n\n2) For class methods (and properties) that **are** instance specific, the\nIndexedProperty subclass has a .tdict member, which is the class dictionary\nfor the Trampoline.\n\n3) Having modified the .tdict (probably in __init__), a call to updatetrampoline()\nwill recreate the **instance's** ._trampolinecls, which is a subclass of the\nIndexedProperty ._Trampoline with overloading defined by .tdict.  This is what\nputs the methods, such as the getter, setter, etc, into the _Trampoline.\n\nAnother very common usage is wanting a variant on ContainerProperty that \nperforms some minor transformation on the key before checking it against the \ncontainer. For example, if the key is a string it should be made uppercase::\n\n\t>>> from indexedproperty import ContainerProperty\n\t>>> class UCProperty(ContainerProperty):\n\t... \t\"\"\"A ContainerProperty that transforms string keys to uppercase.\"\"\"\n\t... \tclass _Trampoline(ContainerProperty._Trampoline):\n\t... \t\tdef modindex(self, index):\n\t... \t\t\tindex = index.upper()\n\t... \t\t\treturn super().modindex(index)\n\t... \t\t\t\n\t>>> class TestClass:\n\t... \t_indices = {'PI':3.14, 'E':2.718, 'I':(0+1j), 'TAU':6.28}\n\t... \t\n\t... \t@UCProperty(_indices)\n\t... \tdef constant(self, key):\n\t... \t\treturn self._indices[key]\n\t\n\t>>> x = TestClass()\n\t>>> x.constant['pi']\n\t3.14\n\t>>> x.constant['PI']\n\t3.14\n\t>>> x.constant['PI'] = 5\n\tTraceback (most recent call last):\n\tNotImplementedError: no property setter defined\n\t>>> sorted(x.constant.items())\n\t[('E', 2.718), ('I', 1j), ('PI', 3.14), ('TAU', 6.28)]\n\t\n:author: Rob Gaddi, Highland Technology\n:date: 21-Mar-2016\n:version: 0.1.1",
    "docs_url": null,
    "download_url": "UNKNOWN",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "UNKNOWN",
    "keywords": "properties",
    "license": "MIT",
    "maintainer": null,
    "maintainer_email": null,
    "name": "indexedproperty",
    "platform": "UNKNOWN",
    "project_url": "https://pypi.org/project/indexedproperty/",
    "release_url": "https://pypi.org/project/indexedproperty/0.1.1/",
    "requires_python": null,
    "summary": "Properties with item-style access",
    "version": "0.1.1"
  },
  "releases": {
    "0.1.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "b1ad483e1fa97ea6dd965e677c6b5edc",
          "sha256": "c32c22bfa3eb5c0e63732fc793565cb2a590ee8fdaa7881ae406e24e80a082b9"
        },
        "downloads": 467,
        "filename": "indexedproperty-0.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "b1ad483e1fa97ea6dd965e677c6b5edc",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 11585,
        "upload_time": "2016-03-19T01:29:49",
        "url": "https://files.pythonhosted.org/packages/39/b0/ad9fe74eb9c21418e89ad4d6c92d647391ef8e44b390aaf6d640a3977696/indexedproperty-0.1.0.tar.gz"
      }
    ],
    "0.1.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "45da528426fe1bdb75f8a99fc8c30c91",
          "sha256": "10aaf3b88af0ae585e7564bbc73783f3455104269a03628500772d076f0877a3"
        },
        "downloads": 163,
        "filename": "indexedproperty-0.1.1.tar.gz",
        "has_sig": false,
        "md5_digest": "45da528426fe1bdb75f8a99fc8c30c91",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 11811,
        "upload_time": "2016-03-21T18:06:46",
        "url": "https://files.pythonhosted.org/packages/f5/70/55f3da2c479bdd0014eb254f19b8f06b8b9a8bc96bf02f656d0346692d49/indexedproperty-0.1.1.tar.gz"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "45da528426fe1bdb75f8a99fc8c30c91",
        "sha256": "10aaf3b88af0ae585e7564bbc73783f3455104269a03628500772d076f0877a3"
      },
      "downloads": 163,
      "filename": "indexedproperty-0.1.1.tar.gz",
      "has_sig": false,
      "md5_digest": "45da528426fe1bdb75f8a99fc8c30c91",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 11811,
      "upload_time": "2016-03-21T18:06:46",
      "url": "https://files.pythonhosted.org/packages/f5/70/55f3da2c479bdd0014eb254f19b8f06b8b9a8bc96bf02f656d0346692d49/indexedproperty-0.1.1.tar.gz"
    }
  ]
}