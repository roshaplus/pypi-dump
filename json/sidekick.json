{
  "info": {
    "author": "F\u00e1bio Mac\u00eado Mendes",
    "author_email": "fabiomacedomendes@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 4 - Beta",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: GNU General Public License (GPL)",
      "Operating System :: OS Independent",
      "Programming Language :: Python",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.4",
      "Programming Language :: Python :: 3.5",
      "Programming Language :: Python :: 3.6",
      "Topic :: Software Development :: Libraries"
    ],
    "description": "========\nSidekick\n========\n\nSidekick is a helpful library that gives you functional superpowers.\nIt implements a few utility functions and types that make functional programming \nmore pleasant in Python. It is designed to be self-contained and it wraps most\nof the functionality in the toolz library. Of course you can also use it in\nconjunction with other functional programming libraries such as funcy, fn.py and\nPyrsistent.\n\nIf you are lazy, simply import everything and start to play ;)\n\n>>> from sidekick import *\n\n\nFunction composition\n====================\n\nHeavily functional in Python code quickly becomes an unholy mess:\n\n>>> import os\n>>> print(\n...     '\\n'.join(\n...         map(\n...             lambda x: '%s) %s' % (x[0] + 1, x[1]), \n...             enumerate(\n...                 sorted(\n...                     filter(\n...                         lambda x: x.endswith('.py'),\n...                         os.listdir(os.getcwd()), \n...                     ),\n...                     key=str.casefold,\n...                 )\n...             )\n...         )    \n...     )\n... )\n1) setup.py\n2) tasks.py\n\nWe formatted for maximum legibility, but even so that are so many nested \nfunctions that it is not even funny. The code above reads all files from  \nthe current directory, keeps only the `.py` files, sort them alphabetically \n(after normalizing case), and finally prints a list of files on the screen.\n\nWe can do better with sidekick:\n\n>>> print(\n...     os.getcwd() | fn\n...         >> os.listdir\n...         >> filter(_.endswith('.py'))\n...         >> order_by(str.casefold)\n...         >> enumerate\n...         >> map(lambda x: '%s) %s' % (x[0] + 1, x[1]))\n...         >> '\\n'.join\n... )\n1) setup.py\n2) tasks.py\n\nLet us unpack all those commands.\n\n**Function pipelines**\n\nThe function pipeline operator ``>>`` is used to compose \nfunctions to form a pipeline where each function passes its results to be \nconsumed by the next one. Hence,\n\n>>> pipeline = f1 >> f2 >> f3 >> ...                            # doctest: +SKIP\n  \nis a function pipeline that calls ``f1()``, than pass the result to ``f2()``, \nwhich goes to ``f3()``, and so on. The code above is equivalent to the nested \nfunction definition:\n\n>>> pipeline = lambda x: ...(f3(f2(f1(x))))                     # doctest: +SKIP\n\nThe pipeline syntax obviously do not work with regular functions. The \ntrick is to use fn() magic object either to create functions that accept \ncomposition or to mark the beginning of a pipeline:\n\n.. ignore-next-block\n.. code-block:: python\n\n    f1 = fn(real_f1)                        # f1 now understands the pipeline!\n    pipeline = f1 >> f2 >> f3 >> ...                            \n    pipeline = fn >> f1 >> f2 >> f3 >> ...  # this also works!\n\nIf you are still not so sure how the pipeline works, consider the more \nself-contained example: \n\n>>> import math\n>>> sqrt = fn(math.sqrt)\n>>> safe_sqrt = abs >> sqrt\n>>> safe_sqrt(-4)\n2.0\n\nIn the code above, the argument is passed first to the abs() function and then \nis redirected it to the sqrt(). The order the operators appear is the same \norder in which the functions are applied.\n\nThe pipeline can also be constructed backwards, reading right to left:\n\n>>> safe_sqrt = sqrt << abs  \n>>> safe_sqrt(-4)\n2.0\n\nIn either case, the argument flows in the same direction that the pipeline \noperator points to. Read it as an arrow that tells the direction information\nflows.\n\n\n**Filter operator**\n\nOnce a pipeline is created, we can feed arguments to it either by calling \nthe resulting function or by using the filter (pipe) operator. A filter takes \nthe value on the left hand side and passes to the function in the right hand \nside:\n\n>>> 4 | sqrt\n2.0\n\nThis is equivalent to the more traditional ``sqrt(4)``. Filters can be chained\nand mixed with function pipelines\n\n>>> 16 | sqrt | sqrt\n2.0\n>>> 16 | sqrt >> sqrt\n2.0\n\nFilters have a lower precedence than pipelines. This means that the expression\n``x | f1 >> f2 | f3``  is interpreted as ``x | (f1 >> f2) | f3``. That is, it \ntakes x, passes to the pipeline constructed by composing f1 with f2 and then \nfinally passes the result to f3.\n\n\n**Recapitulation**\n\nLet us recap. Remember the code we started with: \n\n.. ignore-next-block\n\n>>> print(\n...     os.getcwd() | fn\n...         >> os.listdir\n...         >> filter(_.endswith('.py'))\n...         >> order_by(str.casefold)\n...         >> enumerate\n...         >> map(lambda x: '%s) %s' % (x[0] + 1, x[1]))\n...         >> '\\n'.join\n... )\n\nThis should not be a foreign language anymore. This line of code reads the current \nworking dir returned by os.getcwd() than passes it through a series of \ntransformations:\n\n1. List the files\n2. Select files with the '.py' extension using a quick lambda (more later...)\n3. Sort files by name using casefold to normalize\n4. Enumerate the sorted list\n5. Maps all items to be a string in the ``\"idx) filename'`` format.\n6. Join the list of files with new lines\n7. Finally, pass the result to the print function.    \n\nCompare it to a more idiomatic Python code::\n\n    dir = os.getcwd()\n    files = os.listdir(files)\n    py_files = (f for f in files if f.endswith('.py'))\n    py_files = sorted(py_files, key=str.casefold)\n    lines = ['%s) %s' % item for item in enumerate(files)]\n    print('\\n'.join(lines))\n\nIt all comes to personal taste, but one cannot deny the functional version \nis more compact since it do not require the noise of all those temporary \nvariable definitions.\n\n\nPartial application\n===================\n\nThe fn object can be used as a decorator to give regular functions \nsuperpowers. We already mentioned the pipeline and filter operators. Let us see\nwhat else it can give us.\n\nConsider the function:\n\n.. code-block:: python\n\n    @fn\n    def g(x, y, z):\n        return (x, y, z)\n\nThe function ``g`` can now be used as a filter or as a part of a pipeline. \nLike normal Python functions, fn-functions also use parenthesis to make call. \nIf a function is called with square brackets, however, it makes a partial \napplication:\n\n>>> g2 = g[1, 2]\n>>> g2(3)\n(1, 2, 3)\n\nBy default, partial application respect a auto-currying semantics. We decided to\nnot make currying the default behavior for standard function calls since \ncurrying can be confusing on languages that support a variable number\nof arguments such as Python. If you never heard this name, autocurrying is the \nprocess in which a function that do not receive all required arguments simply \nreturn another function that receives the missing ones. It is an attempt to \nmimick the behavior of curried programming languages define only single-argument\nfunctions (in those languages, e.g., Haskell, a function of two variables is\na function of a single variable that returns another function of one variable).\n\nfn-functions also suports a more explicit and flexible mode of partial function \napplication:\n\n>>> gpart = g.partial(1, y=2)\n\nFinally, both partial and the square-brackets notation understands the special \nplaceholder object ``_`` as a declaration for the position in which a single\nfree argument should be used\n\n>>> g[1, 2](3) == g[_, 2, 3](1) == g[1, _, 3](2)\nTrue\n\nIf the placeholder is repeated, the same argument is passed to all used \npositions\n\n>>> g[_, _, _](1)\n(1, 1, 1)\n\nThe fn object offers a few additional goodies. The first is the ``method`` \nattribute, that declares a function to be autocurrying::\n\n>>> g = fn.curried(lambda x, y, z: x + y + z)\n>>> g(1, 2, 3) == g(1, 2)(3) == g(1)(2)(3) == 6\nTrue\n\nSecondly, the fn object itself accepts the bracket notation and can be used\nto define partial application directly when the function is created::\n\n.. skip-next-block\n.. code-block:: python\n\n    g_ = lambda x, y, z: x + y + z\n    fn[g]           # the same as fn(g)\n    fn[g, 1]        # the same as fn(g)[1]\n    fn[g, _, 2, 3]  # the same as fn(g)[_, 2, 3] (you get the idea!)\n\n\nQuick lambdas\n=============\n\nThe previous section introduced the placeholder object ``_``. It exists in order\nto create quick lambdas for use in functional code. Functional code relies on\nlots of short anonymous functions and seems that nobody likes Python \nlambda's syntax: it is ugly, a bit too verbose and not particularly readable. \nEven Javascript did it right with ES6, so why wouldn't we?\n\nSidekick provides a quick way to define lambdas using the placeholder object. \nJust create an arbitrary Python expression and wrap it with the fn() object. \n\n>>> inc = fn(_ + 1)\n>>> total_cost = fn(_.num_items * _.price)\n\nIn the future, we may create additional placeholders such as ``__`` and ``___`` \nto define functions with multiple arguments. For now, use a lambda.\n\n\nPredicates\n==========\n\nPredicates are functions that receive a single argument and return a boolean. \nThey are used in many contexts, usually to select elements in an collection. \nConsider Python's builtin filter function:\n\n>>> names = ['foo', 'bar', 'ham']\n\nSidekick extends the builtin filter function to accept placeholder expressions\nand curring.\n\n>>> filtered = filter(_.startswith('f'), names)\n\nThe result is a filter object, which we convert to a list using the magic ``| L``\nfilter notation:\n\n>>> filtered | L\n['foo']\n\nIn sidekick we can expliclty tell that a quick lambda or a function is a\npredicate by wrapping it with the predicate function:\n\n>>> startswith_f = predicate(_.startswith('f'))\n>>> filter(startswith_f, names) | L\n['foo']\n\nFor now it is just the same as using a regular function. Predicate functions,\nhowever, compose nicely under boolean expressions. This makes it easier to\ncreate complex predicates instead of relying on awkward lambda functions:\n\n>>> startswith_b = predicate(_.startswith('b'))\n>>> filter(startswith_f | startswith_b, names) | L\n['foo', 'bar']\n\n\nRecord types\n============\n\nClasses are often used as a heavy-weight solution to types that behave \nessentially as a bag of values. Python do not have very good builtin solutions \nto this problem: literal string keys of dictionaries are ugly to read and a \npain to type. ``namedtuples`` have an awkward API and can bring some unwanted \ntuple/sequence semantics in surprising places. Finally, SimpleNamespace fail in \nsubtle ways such as not implementing the hash protocol.\n\nSidekick provides two lightweight functions for creating on-the-fly record \ntypes: :cls:`record` and :cls:`namespace` that resemble the SimpleNamespace \ntype.\n\nJust call ``record()`` with a few named arguments to create a new immutable\nvalue\n\n>>> pt = record(x=1, y=2)\n\nThis defines a new record with .x and .y attributes\n\n>>> pt.x, pt.y\n(1, 2)\n\nRecords are immutable and should be favored when mutability is not strictly \nrequired. If you need a mutable bag of values, use :cls:`namespace`. It behaves \nsimilarly to :cls:`record`, but it allows mutation:\n\n>>> pt = namespace(x=1, y=2)\n\n\nCustom record types\n-------------------\n\nWhile record() and namespace() types can be useful, it is often more prudent to\ndefine the structure of a record type explicitly since it is easy to miss a few\nparameters, or to make a typo. In most cases, you should favor custom record\ntypes created deriving from the Record class:\n\n>>> class Point2D(Record):\n...     x = field()\n...     y = field()\n\n(Of course we could include a few methods, but lets forget about it now).\n\nThis is a little bit more work, but it will surely save you from a few bugs\nlater on. Point2D instances expect to have exactly two attributes named x and y,\nand you cannot skip one of them or set a third z coordinate.\nAnother subtle but useful advantage is that Point2D constructor also accepts\npositional arguments, so ``Point2D(1, 2)`` is also a valid way to construct \nan instance.\n   \nEven if you do not plan to diverge much from OO, Record is a nice starting point \nto defining your own classes. They already implement a few useful methods that\nPython does not provide useful default implementations: no need to override\n__init__, __repr__, __eq__ and __hash__. Also Record subclasses are immutable\nby default. Python classes do not provide a good way for doing this, and with\nrecords you can always opt-out if mutability is required:\n\n>>> class Point2D(Record, mutable=True):\n...     x = field()\n...     y = field()\n\nRecord fields can declare default values and in the future we plan to support\nadditional features such as type-checking and validation.\n\n>>> class Point2D(Record):\n...     x = field()\n...     y = field()\n...     origin = field(default=(0, 0))\n\n\nUnion types\n===========\n\nUnion types represent types that can be in one of a series of different states. \nMost functional languages implement Union types (a.k.a. abstract data types), \nas one of the basic ways to create composite types. \n\n\nUsage\n-----\n    \nA new Union types is declared using the pipe sintax. We define each state by \ninvoking an attribute from the ``opt`` special object: \n\n>>> Maybe = opt.Just(object) | opt.Nothing\n\nThe Maybe type represents values that can either exist in the \"Just\" state or\nbe Nothing. Notice that Nothing is a singleton that accepts no argument, while\nJust requires a single argument which corresponds to the value held by the\nMaybe instance.\n\nWe create instances by calling the Just(...) or the Nothing constructors\n\n>>> x = Maybe.Just(42)\n>>> y = Maybe.Nothing   # ok, that is technically not calling a constructor...\n\nMaybe types is a functional response to the infamous null pointer. Instead of\nhaving the null value lurking around in every corner, we explicitly model \nnullable objects as instances of the Maybe type. \n\nUsing a maybe almost always requires some sort of pattern matching. This is the \nclosest we can get in Python::\n\n    if x.just:\n        print('value is:', x.value)\n    elif x.nothing:\n        print('x is empty')\n    \nThe other possibility is to use the match method::\n\n    # Poor man's version of Haskell's pattern matching\n    is_the_answer = x.case_of(\n        just=lambda x:\n            x == 42,\n\n        nothing=lambda:\n            False,\n    )\n\nFinally, if an specific pattern matching is used repeatedly, we can define a \ntype matching function with the notation::\n\n    is_the_answer_fn = Maybe.case_fn(\n       just=lambda x:\n            x == 42,\n\n        nothing=lambda:\n            False,\n    )\n    is_the_answer = is_the_answer_fn(x)\n\nThis is equivalent to the prior method, but it should be faster if the case \nfunction is called lots of times.\n\n\nThe Maybe type\n--------------\n\nWhile in real functional languages the Maybe type is usually defined just as \nwe shown above, Python is an OO language and it might be more useful to define \nit as a class with a few extra methods. Sidekick's Maybe implements a few \nextra goodies besides the plain definition.\n\n\nThe Result type\n---------------\n\nThe result type (sans extensions) is defined as::\n\n    Result = opt.Ok(object) | opt.Err(object)\n\nHence it has two states: Ok and Err that both can hold additional data. Result\nis a functional way to represent a computation that may fail. It is used where\nin Python one would normally use an exception.\n\n##TODO: specific documentation ",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "https://github.com/fabiommendes/sidekick/",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "sidekick",
    "platform": "any",
    "project_url": "https://pypi.org/project/sidekick/",
    "release_url": "https://pypi.org/project/sidekick/0.0.2/",
    "requires_dist": [],
    "requires_python": "",
    "summary": "A library that gives you functional superpowers.",
    "version": "0.0.2"
  },
  "releases": {
    "0.0.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "0904e48bfac4f08a49e7407661fd862d",
          "sha256": "ac65705c706dd37bcb37f5f48cc4b1bc82222b31af34449f5bcf3aa5087ac36e"
        },
        "downloads": 0,
        "filename": "sidekick-0.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "0904e48bfac4f08a49e7407661fd862d",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 29165,
        "upload_time": "2017-07-26T04:03:05",
        "url": "https://files.pythonhosted.org/packages/a9/7f/f71f8d1a5034bd237044da0a289924f1afafe307a61c7da7660251b6f0ac/sidekick-0.0.1.tar.gz"
      }
    ],
    "0.0.2": [
      {
        "comment_text": "",
        "digests": {
          "md5": "580179f0446e331d85fcc1a7f8d87a4b",
          "sha256": "64ea6f599c5158b63b69188f5d06c2df91480176eb522542314d83e72c8d9673"
        },
        "downloads": 0,
        "filename": "sidekick-0.0.2.tar.gz",
        "has_sig": false,
        "md5_digest": "580179f0446e331d85fcc1a7f8d87a4b",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 39807,
        "upload_time": "2017-08-08T01:53:24",
        "url": "https://files.pythonhosted.org/packages/86/71/8faddce0b403804b941ccfa03c0a64033f811da7b98f7647f0901bd721d7/sidekick-0.0.2.tar.gz"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "580179f0446e331d85fcc1a7f8d87a4b",
        "sha256": "64ea6f599c5158b63b69188f5d06c2df91480176eb522542314d83e72c8d9673"
      },
      "downloads": 0,
      "filename": "sidekick-0.0.2.tar.gz",
      "has_sig": false,
      "md5_digest": "580179f0446e331d85fcc1a7f8d87a4b",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 39807,
      "upload_time": "2017-08-08T01:53:24",
      "url": "https://files.pythonhosted.org/packages/86/71/8faddce0b403804b941ccfa03c0a64033f811da7b98f7647f0901bd721d7/sidekick-0.0.2.tar.gz"
    }
  ]
}