{
  "info": {
    "author": "Vincent Aranega",
    "author_email": "vincent.aranega@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 4 - Beta",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: BSD License",
      "Operating System :: OS Independent",
      "Programming Language :: Python",
      "Programming Language :: Python :: 3.3",
      "Programming Language :: Python :: 3.4",
      "Programming Language :: Python :: 3.5",
      "Programming Language :: Python :: 3.6",
      "Topic :: Software Development",
      "Topic :: Software Development :: Libraries"
    ],
    "description": "====================================================================\nPyEcore: A Pythonic Implementation of the Eclipse Modeling Framework\n====================================================================\n\n|pypi-version| |master-build| |coverage| |license|\n\n.. |master-build| image:: https://travis-ci.org/pyecore/pyecore.svg?branch=master\n    :target: https://travis-ci.org/pyecore/pyecore\n\n.. |develop-build| image:: https://travis-ci.org/pyecore/pyecore.svg?branch=develop\n    :target: https://travis-ci.org/pyecore/pyecore\n\n.. |pypi-version| image:: https://badge.fury.io/py/pyecore.svg\n    :target: https://badge.fury.io/py/pyecore\n\n.. |coverage| image:: https://coveralls.io/repos/github/pyecore/pyecore/badge.svg?branch=master\n    :target: https://coveralls.io/github/pyecore/pyecore?branch=master\n\n.. |license| image:: https://img.shields.io/badge/license-New%20BSD-blue.svg\n    :target: https://raw.githubusercontent.com/pyecore/pyecore/master/LICENSE\n\nPyEcore is a \"Pythonic?\" (sounds pretentious) implementation of EMF/Ecore for\nPython 3. It's purpose is to handle model/metamodels in Python almost the same\nway the Java version does.\n\nHowever, PyEcore enables you to use a simple ``instance.attribute`` notation\ninstead of ``instance.setAttribute(...)/getAttribute(...)`` for the Java\nversion. To achieve this, PyEcore relies on reflection (a lot).\n\nLet see by yourself how it works on a very simple metamodel created on\nthe fly (dynamic metamodel):\n\n.. code-block:: python\n\n    >>> from pyecore.ecore import EClass, EAttribute, EString, EObject\n    >>> A = EClass('A')  # We create metaclass named 'A'\n    >>> A.eStructuralFeatures.append(EAttribute('myname', EString, default_value='new_name')) # We add a name attribute to the A metaclass\n    >>> a1 = A()  # We create an instance\n    >>> a1.myname\n    'new_name'\n    >>> a1.myname = 'a_instance'\n    >>> a1.myname\n    'a_instance'\n    >>> isinstance(a1, EObject)\n    True\n\nPyEcore also support introspection and the EMF reflexive API using basic Python\nreflexive features:\n\n.. code-block:: python\n\n    >>> a1.eClass # some introspection\n    <EClass name=\"A\">\n    >>> a1.eClass.eClass\n    <EClass name=\"EClass\">\n    >>> a1.eClass.eClass is a1.eClass.eClass.eClass\n    True\n    >>> a1.eClass.eStructuralFeatures\n    EOrderedSet([<EStructuralFeature myname: EString(str)>])\n    >>> a1.eClass.eStructuralFeatures[0].name\n    'myname'\n    >>> a1.eClass.eStructuralFeatures[0].eClass\n    <EClass name=\"EAttribute\">\n    >>> a1.__getattribute__('myname')\n    'a_instance'\n    >>> a1.__setattr__('myname', 'reflexive')\n    >>> a1.__getattribute__('myname')\n    'reflexive'\n    >>> a1.eSet('myname', 'newname')\n    >>> a1.eGet('myname')\n    'newname'\n\nRuntime type checking is also performed (regarding what you expressed in your)\nmetamodel:\n\n.. code-block:: python\n\n    >>> a1.myname = 1\n    Traceback (most recent call last):\n        File \"<stdin>\", line 1, in <module>\n        File \".../pyecore/ecore.py\", line 66, in setattr\n            raise BadValueError(got=value, expected=estruct.eType)\n    pyecore.ecore.BadValueError: Expected type EString(str), but got type int with value 1 instead\n\n\nPyEcore does support dynamic metamodel and static ones (see details in next\nsections).\n\n*The project slowly grows and it still requires more love.*\n\nInstallation\n============\n\nPyEcore is available on ``pypi``, you can simply install it using ``pip``:\n\n.. code-block:: bash\n\n    $ pip install pyecore\n\nThe installation can also be performed manually (better in a virtualenv):\n\n.. code-block:: bash\n\n    $ python setup.py install\n\n\n.. contents:: :depth: 2\n\n\nDynamic Metamodels\n==================\n\nDynamic metamodels reflects the ability to create metamodels \"on-the-fly\". You\ncan create metaclass hierarchie, add ``EAttribute`` and ``EReference``.\n\nIn order to create a new metaclass, you need to create an ``EClass`` instance:\n\n.. code-block:: python\n\n    >>> import pyecore.ecore as Ecore\n    >>> MyMetaclass = Ecore.EClass('MyMetaclass')\n\nYou can then create instances of your metaclass:\n\n.. code-block:: python\n\n    >>> instance1 = MyMetaclass()\n    >>> instance2 = MyMetaclass()\n    >>> assert instance1 is not instance2\n\n>From the created instances, we can go back to the metaclasses:\n\n.. code-block:: python\n\n    >>> instance1.eClass\n    <EClass name=\"MyMetaclass\">\n\nThen, we can add metaproperties to the freshly created metaclass:\n\n.. code-block:: python\n\n    >>> instance1.eClass.eAttributes\n    []\n    >>> MyMetaclass.eStructuralFeatures.append(Ecore.EAttribute('name', Ecore.EString))  # We add a 'name' which is a string\n    >>> instance1.eClass.eAttributes  # Is there a new feature?\n    [<pyecore.ecore.EAttribute object at 0x7f7da72ba940>]  # Yep, the new feature is here!\n    >>> str(instance1.name)  # There is a default value for the new attribute\n    'None'\n    >>> instance1.name = 'mystuff'\n    >>> instance1.name\n    'mystuff'\n    >>> # As the feature exists in the metaclass, the name of the feature can be used in the constructor\n    >>> instance3 = MyMetaclass(name='myname')\n    >>> instance3.name\n    'myname'\n\nWe can also create a new metaclass ``B`` and a new meta-references towards\n``B``:\n\n.. code-block:: python\n\n    >>> B = Ecore.EClass('B')\n    >>> MyMetaclass.eStructuralFeatures.append(Ecore.EReference('toB', B, containment=True))\n    >>> b1 = B()\n    >>> instance1.toB = b1\n    >>> instance1.toB\n    <pyecore.ecore.B object at 0x7f7da70531d0>\n    >>> b1.eContainer() is instance1   # because 'toB' is a containment reference\n    True\n\nOpposite and 'collection' meta-references are also managed:\n\n.. code-block:: python\n\n    >>> C = Ecore.EClass('C')\n    >>> C.eStructuralFeatures.append(Ecore.EReference('toMy', MyMetaclass))\n    >>> MyMetaclass.eStructuralFeatures.append(Ecore.EReference('toCs', C, upper=-1, eOpposite=C.eStructuralFeatures[0]))\n    >>> instance1.toCs\n    []\n    >>> c1 = C()\n    >>> c1.toMy = instance1\n    >>> instance1.toCs  # 'toCs' should contain 'c1' because 'toMy' is opposite relation of 'toCs'\n    [<pyecore.ecore.C object at 0x7f7da7053390>]\n\nExplore Dynamic metamodel/model objects\n---------------------------------------\n\nIt is possible, when you are handling an object in the Python console, to ask\nfor all the meta-attributes/meta-references and meta-operations that can\nbe called on it using ``dir()`` on, either a dynamic metamodel object or a\nmodel instance. This allows you to quickly experiment and find the information\nyou are looking for:\n\n.. code-block:: python\n\n    >>> A = EClass('A')\n    >>> dir(A)\n    ['abstract',\n     'delete',\n     'eAllContents',\n     'eAllOperations',\n     'eAllReferences',\n     'eAllStructuralFeatures',\n     'eAllSuperTypes',\n     'eAnnotations',\n     'eAttributes',\n     'eContainer',\n     # ... there is many others\n     'findEOperation',\n     'findEStructuralFeature',\n     'getEAnnotation',\n     'instanceClassName',\n     'interface',\n     'name']\n    >>> a = A()\n    >>> dir(a)\n    []\n    >>> A.eStructuralFeatures.append(EAttribute('myname', EString))\n    >>> dir(a)\n    ['myname']\n\n\nEnhance the Dynamic metamodel\n-----------------------------\n\nEven if you define or use a dynamic metamodel, you can add dedicated methods\n(e.g: ``__repr__``) to the equivalent Python class. Each ``EClass`` instance is\nlinked to a Python class which can be reached using the ``python_class`` field:\n\n.. code-block:: python\n\n    >>> A = EClass('A')\n    >>> A.python_class\n    pyecore.ecore.A\n\nYou can directly add new \"non-metamodel\" related method to this class:\n\n.. code-block:: python\n\n    >>> a = A()\n    >>> a\n    <pyecore.ecore.A at 0x7f4f0839b7b8>\n    >>> A.python_class.__repr__ = lambda self: 'My repr for real'\n    >>> a\n    My repr for real\n\n\nStatic Metamodels\n=================\n\nThe static definition of a metamodel using PyEcore mostly relies on the\nclassical classes definitions in Python. Each Python class is linked to an\n``EClass`` instance and has a special metaclass. The static code for metamodel\nalso provides a model layer and the ability to easily refer/navigate inside the\ndefined meta-layer.\n\n.. code-block:: python\n\n    $ ls library\n    __init__.py library.py\n\n    $ cat library/library.py\n    # ... stuffs here\n    class Writer(EObject, metaclass=MetaEClass):\n        name = EAttribute(eType=EString)\n        books = EReference(upper=-1)\n\n        def __init__(self, name=None, books=None, **kwargs):\n            if kwargs:\n                raise AttributeError('unexpected arguments: {}'.format(kwargs))\n\n            super().__init__()\n            if name is not None:\n                self.name = name\n            if books:\n                self.books.extend(books)\n    # ... Other stuffs here\n\n    $ python\n    ...\n    >>> import library\n    >>> # we can create elements and handle the model level\n    >>> smith = library.Writer(name='smith')\n    >>> book1 = library.Book(title='Ye Old Book1')\n    >>> book1.pages = 100\n    >>> smith.books.append(book1)\n    >>> assert book1 in smith.books\n    >>> assert smith in book1.authors\n    >>> # ...\n    >>> # We can also navigate the meta-level\n    >>> import pyecore.ecore as Ecore  # We import the Ecore metamodel only for tests\n    >>> assert isinstance(library.Book.authors, Ecore.EReference)\n    >>> library.Book.authors.upperBound\n    -1\n    >>> assert isinstance(library.Writer.name, Ecore.EAttribute)\n\n\nThere is two main ways of creating static ``EClass`` with PyEcore. The first\none relies on automatic code generation while the second one uses manual\ndefinition.\n\nThe automatic code generator defines a Python package hierarchie instead of\nonly a Python module. This allows more freedom for dedicated operations and\nreferences between packages.\n\nHow to Generate the Static Metamodel Code\n-----------------------------------------\n\nThe static code is generated from a ``.ecore`` where your metamodel is defined\n(the EMF ``.genmodel`` files are not yet supported (probably in future version).\n\nThere is currently two ways of generating the code for your metamodel. The first\none is to use a MTL generator (in ``/generator``) and the second one is to use a\ndedicated command line tool written in Python, using Pymultigen, Jinja and PyEcore.\n\nUsing the Accelo/MTL Generator\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nTo use this generator, you need Eclipse and the right Acceleo plugins. Once\nEclipse is installed with the right plugins, you need to create a new Acceleo\nproject, copy the  PyEcore generator in it, configure a new Acceleo runner,\nselect your ``.ecore`` and your good to go. There is plenty of documentation\nover the Internet for Acceleo/MTL project creation/management...\n\n**WARNING:** the Acceleo generator is now deprecated, use pyecoregen instead!\n\nUsing the Dedicated CLI Generator (PyEcoregen)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nFor simple generation, the Acceleo generator will still do the job, but for more\ncomplex metamodel and a more robust generation, pyecoregen is significantly better.\nIts use is the prefered solution for the static metamodel code generation.\nAdvantages over the Acceleo generator are the following:\n\n* it gives the ability to deal with generation from the command line,\n* it gives the ability to launch generation programmatically (and very simply),\n* it introduces into PyEcore a framework for code generation,\n* it allows you to code dedicated behavior in mixin classes,\n* it can be installed from `pip`.\n\nThis generator source code can be found at this address with mode details:\nhttps://github.com/pyecore/pyecoregen and is available on Pypi, so you can\ninstall it quite symply using:\n\n.. code-block:: bash\n\n    $ pip install pyecoregen\n\nThis will automatically install all the required dependencies and give you a new\nCLI tool: ``pyecoregen``.\n\nUsing this tool, your static code generation is very simple:\n\n.. code-block:: bash\n\n    $ pyecoregen -e your_ecore_file.ecore -o your_output_path\n\nThe generated code is automatically formatted using ``autopep8``. Once the code\nis generated, your can import it and use it in your Python code.\n\n\nManually defines static ``EClass``\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nTo manually defines static ``EClass``, it is simply a matter of creating a\nPython class, and adding to it the ``@EMetaclass`` class decorator. This\ndecorator will automatically add the righ metaclass to the defined class, and\nintroduce the missing classes in it's inheritance tree. Defining simple\nmetaclass is thus fairly easy:\n\n.. code-block:: python\n\n    @EMetaclass\n    class Person(object):\n        name = EAttribute(eType=EString)\n        age = EAttribute(eType=EInt)\n        children = EReference(upper=-1, containment=True)\n\n        def __init__(self, name):\n            self.name = name\n\n    Person.children.eType = Person  # As the relation is reflexive, it must be set AFTER the metaclass creation\n\n    p1 = Person('Parent')\n    p1.children.append(Person('Child'))\n\n\nWithout more information, all the created metaclass will be added to a default\n``EPackage``, generated on the fly. If the ``EPackage`` must be controlled, a\nglobal variable of ``EPackage`` type, named ``eClass``, must be created in the\nmodule.\n\n.. code-block:: python\n\n    eClass = EPackage(name='pack', nsURI='http://pack/1.0', nsPrefix='pack')\n\n    @EMetaclass\n    class TestMeta(object):\n        pass\n\n    assert TestMeta.eClass.ePackage is eClass\n\nHowever, when ``@EMetaclass`` is used, the direct ``super()`` call in\nthe ``__init__`` constructor cannot be directly called. Instead,\n``super(x, self)`` must be called:\n\n.. code-block:: python\n\n    class Stuff(object):\n        def __init__(self):\n            self.stuff = 10\n\n\n    @EMetaclass\n    class A(Stuff):\n        def __init__(self, tmp):\n            super(A, self).__init__()\n            self.tmp = tmp\n\n\n    a = A()\n    assert a.stuff == 10\n\nIf you want to directly extends the PyEcore metamodel, the ``@EMetaclass`` is\nnot required, and ``super()`` can be used.\n\n.. code-block:: python\n\n    class MyNamedElement(ENamedElement):\n        def __init__(self, tmp=None, **kwargs):\n            super().__init__(**kwargs)\n            self.tmp = tmp\n\n\nStatic/Dynamic ``EOperation``\n=============================\n\nPyEcore also support ``EOperation`` definition for static and dynamic metamodel.\nFor static metamodel, the solution is simple, a simple method with the code is\nadded inside the defined class. The corresponding ``EOperation`` is created on\nthe fly. Theire is still some \"requirements\" for this. In order to be understood\nas an ``EOperation`` candidate, the defined method must have at least one\nparameter and the first parameter must always be named ``self``.\n\nFor dynamic metamodels, the simple fact of adding an ``EOperation`` instance in\nthe ``EClass`` instance, adds an \"empty\" implementation:\n\n.. code-block:: python\n\n    >>> import pyecore.ecore as Ecore\n    >>> A = Ecore.EClass('A')\n    >>> operation = Ecore.EOperation('myoperation')\n    >>> param1 = Ecore.EParameter('param1', eType=Ecore.EString, required=True)\n    >>> operation.eParameters.append(param1)\n    >>> A.eOperations.append(operation)\n    >>> a = A()\n    >>> help(a.myoperation)\n    Help on method myoperation:\n\n    myoperation(param1) method of pyecore.ecore.A instance\n    >>> a.myoperation('test')\n    ...\n    NotImplementedError: Method myoperation(param1) is not yet implemented\n\nFor each ``EParameter``, the ``required`` parameter express the fact that the\nparameter is required or not in the produced operation:\n\n.. code-block:: python\n\n    >>> operation2 = Ecore.EOperation('myoperation2')\n    >>> p1 = Ecore.EParameter('p1', eType=Ecore.EString)\n    >>> operation2.eParameters.append(p1)\n    >>> A.eOperations.append(operation2)\n    >>> a = A()\n    >>> a.operation2(p1='test')  # Will raise a NotImplementedError exception\n\nYou can then create an implementation for the eoperation and link it to the\nEClass:\n\n.. code-block:: python\n\n    >>> def myoperation(self, param1):\n    ...     print(self, param1)\n    ...\n    >>> A.python_class.myoperation = myoperation\n\nTo be able to propose a dynamic empty implementation of the operation, PyEcore\nrelies on Python code generation at runtime.\n\n\nNotifications\n=============\n\nPyEcore gives you the ability to listen to modifications performed on an\nelement. The ``EObserver`` class provides a basic observer which can receive\nnotifications from the ``EObject`` it is register in:\n\n.. code-block:: python\n\n    >>> import library as lib  # we use the wikipedia library example\n    >>> from pyecore.notification import EObserver, Kind\n    >>> smith = lib.Writer()\n    >>> b1 = lib.Book()\n    >>> observer = EObserver(smith, notifyChanged=lambda x: print(x))\n    >>> b1.authors.append(smith)  # observer receive the notification from smith because 'authors' is eOpposite or 'books'\n\nThe ``EObserver`` notification method can be set using a lambda as in the\nprevious example, using a regular function or by class inheritance:\n\n.. code-block:: python\n\n    >>> def print_notif(notification):\n    ...     print(notification)\n    ...\n    >>> observer = EObserver()\n    >>> observer.observe(b1)\n    >>> observer.notifyChanged = print_notif\n    >>> b1.authors.append(smith)  # observer receive the notification from b1\n\nUsing inheritance:\n\n.. code-block:: python\n\n    >>> class PrintNotification(EObserver):\n    ...     def __init__(self, notifier=None):\n    ...         super().__init__(notifier=notifier)\n    ...\n    ...     def notifyChanged(self, notification):\n    ...         print(notification)\n    ...\n    ...\n    >>> observer = PrintNotification(b1)\n    >>> b1.authors.append(smith)  # observer receive the notification from b1\n\nThe ``Notification`` object contains information about the performed\nmodification:\n\n* ``new`` -> the new added value (can be a collection) or ``None`` is remove or unset\n* ``old`` -> the replaced value (always ``None`` for collections)\n* ``feature`` -> the ``EStructuralFeature`` modified\n* ``notifer`` -> the object that have been modified\n* ``kind`` -> the kind of modification performed\n\nThe different kind of notifications that can be currently received are:\n\n* ``ADD`` -> when an object is added to a collection\n* ``ADD_MANY`` -> when many objects are added to a collection\n* ``REMOVE`` -> when an object is removed from a collection\n* ``SET`` -> when a value is set in an attribute/reference\n* ``UNSET`` -> when a value is removed from an attribute/reference\n\n\nDeep Journey Inside PyEcore\n===========================\n\nThis section will provide some explanation of how PyEcore works.\n\nEClasse Instances as Factories\n------------------------------\n\nThe most noticeable difference between PyEcore and Java-EMF implementation is\nthe fact that there is no factories (as you probably already seen). Each EClass\ninstance is in itself a factory. This allows you to do this kind of tricks:\n\n.. code-block:: python\n\n    >>> A = EClass('A')\n    >>> eobject = A()  # We create an A instance\n    >>> eobject.eClass\n    <EClass name=\"A\">\n    >>> eobject2 = eobject.eClass()  # We create another A instance\n    >>> assert isinstance(eobject2, eobject.__class__)\n    >>> from pyecore.ecore import EcoreUtils\n    >>> assert EcoreUtils.isinstance(eobject2, A)\n\n\nIn fact, each EClass instance create a new Python ``class`` named after the\nEClass name and keep a strong relationship towards it. Moreover, EClass\nimplements is a ``callable`` and each time ``()`` is called on an EClass\ninstance, an instance of the associated Python ``class`` is created. Here is a\nsmall example:\n\n.. code-block:: python\n\n    >>> MyClass = EClass('MyClass')  # We create an EClass instance\n    >>> type(MyClass)\n    pyecore.ecore.EClass\n    >>> MyClass.python_class\n    pyecore.ecore.MyClass\n    >>> myclass_instance = MyClass()  # MyClass is callable, creates an instance of the 'python_class' class\n    >>> myclass_instance\n    <pyecore.ecore.MyClass at 0x7f64b697df98>\n    >>> type(myclass_instance)\n    pyecore.ecore.MyClass\n    # We can access the EClass instance from the created instance and go back\n    >>> myclass_instance.eClass\n    <EClass name=\"MyClass\">\n    >>> assert myclass_instance.eClass.python_class is MyClass.python_class\n    >>> assert myclass_instance.eClass.python_class.eClass is MyClass\n    >>> assert myclass_instance.__class__ is MyClass.python_class\n    >>> assert myclass_instance.__class__.eClass is MyClass\n    >>> assert myclass_instance.__class__.eClass is myclass_instance.eClass\n\n\nThe Python class hierarchie (inheritance tree) associated to the EClass instance\n\n.. code-block:: python\n\n    >>> B = EClass('B')  # in complement, we create a new B metaclass\n    >>> list(B.eAllSuperTypes())\n    []\n    >>> B.eSuperTypes.append(A)  # B inherits from A\n    >>> list(B.eAllSuperTypes())\n    {<EClass name=\"A\">}\n    >>> B.python_class.mro()\n    [pyecore.ecore.B,\n     pyecore.ecore.A,\n     pyecore.ecore.EObject,\n     pyecore.ecore.ENotifier,\n     object]\n    >>> b_instance = B()\n    >>> assert isinstance(b_instance, A.python_class)\n    >>> assert EcoreUtils.isinstance(b_instance, A)\n\n\nImporting an Existing XMI Metamodel/Model\n=========================================\n\nXMI support is still a little rough on the edges, but the XMI import is on good tracks.\nCurrently, only basic XMI metamodel (``.ecore``) and model instances can be\nloaded:\n\n.. code-block:: python\n\n    >>> from pyecore.resources import ResourceSet, URI\n    >>> rset = ResourceSet()\n    >>> resource = rset.get_resource(URI('path/to/mm.ecore'))\n    >>> mm_root = resource.contents[0]\n    >>> rset.metamodel_registry[mm_root.nsURI] = mm_root\n    >>> # At this point, the .ecore is loaded in the 'rset' as a metamodel\n    >>> resource = rset.get_resource(URI('path/to/instance.xmi'))\n    >>> model_root = resource.contents[0]\n    >>> # At this point, the model instance is loaded!\n\nThe ``ResourceSet/Resource/URI`` will evolve in the future. At the moment, only\nbasic operations are enabled: ``create_resource/get_resource/load/save...``.\n\n\nDynamic Metamodels Helper\n-------------------------\n\nOnce a metamodel is loaded from an XMI metamodel (from a ``.ecore`` file), the\nmetamodel root that is gathered is an ``EPackage`` instance. To access each\n``EClass`` from the loaded resource, a ``getEClassifier(...)`` call must be\nperformed:\n\n.. code-block:: python\n\n    >>> #...\n    >>> resource = rset.get_resource(URI('path/to/mm.ecore'))\n    >>> mm_root = resource.contents[0]\n    >>> A = mm_root.getEClassifier('A')\n    >>> a_instance = A()\n\nWhen a big metamodel is loaded, this operation can be cumbersome. To ease this\noperation, PyEcore proposes an helper that gives a quick access to each\n``EClass`` contained in the ``EPackage`` and its subpackages. This helper is the\n``DynamicEPackage`` class. Its creation is performed like so:\n\n.. code-block:: python\n\n    >>> #...\n    >>> resource = rset.get_resource(URI('path/to/mm.ecore'))\n    >>> mm_root = resource.contents[0]\n    >>> from pyecore.utils import DynamicEPackage\n    >>> MyMetamodel = DynamicEPackage(mm_root)  # We create a DynamicEPackage for the loaded root\n    >>> a_instance = MyMetamodel.A()\n    >>> b_instance = MyMetamodel.B()\n\n\nAdding External Metamodel Resources\n-----------------------------------\n\nExternal resources for metamodel loading should be added in the resource set.\nFor example, some metamodels use the XMLType instead of the Ecore one.\nThe resource creation should be done by hand first:\n\n.. code-block:: python\n\n    int_conversion = lambda x: int(x)  # translating str to int durint load()\n    String = Ecore.EDataType('String', str)\n    Double = Ecore.EDataType('Double', int, 0, from_string=int_conversion)\n    Int = Ecore.EDataType('Int', int, from_string=int_conversion)\n    IntObject = Ecore.EDataType('IntObject', int, None,\n                                from_string=int_conversion)\n    Boolean = Ecore.EDataType('Boolean', bool, False,\n                              from_string=lambda x: x in ['True', 'true'],\n                              to_string=lambda x: str(x).lower())\n    Long = Ecore.EDataType('Long', int, 0, from_string=int_conversion)\n    EJavaObject = Ecore.EDataType('EJavaObject', object)\n    xmltype = Ecore.EPackage()\n    xmltype.eClassifiers.extend([String,\n                                 Double,\n                                 Int,\n                                 EJavaObject,\n                                 Long,\n                                 Boolean,\n                                 IntObject])\n    xmltype.nsURI = 'http://www.eclipse.org/emf/2003/XMLType'\n    xmltype.nsPrefix = 'xmltype'\n    xmltype.name = 'xmltype'\n    rset.metamodel_registry[xmltype.nsURI] = xmltype\n\n    # Then the resource can be loaded (here from an http address)\n    resource = rset.get_resource(HttpURI('http://myadress.ecore'))\n    root = resource.contents[0]\n\n\nMetamodel References by 'File Path'\n-----------------------------------\n\nIf a metamodel references others in a 'file path' manner (for example, a\nmetamodel ``A`` had some relationship towards a ``B`` metamodel like this:\n``../metamodelb.ecore`` ), PyEcore requires that the ``B`` metamodel is loaded\nfirst and registered against the metamodel path URI like (in the example, against\nthe ``../metamodelb.ecore`` URI).\n\n.. code-block:: python\n\n    >>> # We suppose that the metamodel A.ecore has references towards B.ecore\n    ... # '../../B.ecore'. Path of A.ecore is 'a/b/A.ecore' and B.ecore is '.'\n    >>> resource = rset.get_resource(URI('B.ecore'))  # We load B.ecore first\n    >>> root = resource.contents[0]\n    >>> rset.metamodel_registry['../../B.ecore'] = root  # We register it against the 'file path' uri\n    >>> resource = rset.get_resource(URI('a/b/A.ecore'))  # A.ecore now loads just fine\n\n\nAdding External resources\n-------------------------\n\nWhen a model reference another one, they both need to be added inside the same\nResourceSet.\n\n.. code-block:: python\n\n    rset.get_resource(URI('uri/towards/my/first/resource'))\n    resource = rset.get_resource(URI('uri/towards/my/secon/resource'))\n\nIf for some reason, you want to dynamically create the resource which is\nrequired for XMI deserialization of another one, you need to create an empty\nresource first:\n\n.. code-block:: python\n\n    # Other model is 'external_model'\n    resource = rset.create_resource(URI('the/wanted/uri'))\n    resource.append(external_model)\n\n\nExporting an Existing XMI Resource\n==================================\n\nAs for the XMI import, the XMI export (serialization) is still somehow very\nbasic. Here is an example of how you could save your objects in a file:\n\n.. code-block:: python\n\n    >>> # we suppose we have an already existing model in 'root'\n    >>> from pyecore.resources.xmi import XMIResource\n    >>> from pyecore.resources import URI\n    >>> resource = XMIResource(URI('my/path.xmi'))\n    >>> resource.append(root)  # We add the root to the resource\n    >>> resource.save()  # will save the result in 'my/path.xmi'\n    >>> resource.save(output=URI('test/path.xmi'))  # save the result in 'test/path.xmi'\n\n\nYou can also use a ``ResourceSet`` to deal with this:\n\n.. code-block:: python\n\n    >>> # we suppose we have an already existing model in 'root'\n    >>> from pyecore.resources import ResourceSet, URI\n    >>> rset = ResourceSet()\n    >>> resource = rset.create_resource(URI('my/path.xmi'))\n    >>> resource.append(root)\n    >>> resource.save()\n\n\nDealing with JSON Resources\n===========================\n\nPyEcore is also able to load/save JSON models/metamodels. The JSON format it uses\ntries to be close from the one described in the `emfjson-jackson <https://github.com/emfjson/emfjson-jackson>`_ project.\nThe way the JSON serialization/deserialization works, on a user point of view,\nis pretty much the same than the XMI resources, but as the JSON resource factory\nis not loaded by default (for XMI, it is), you have to manually register it\nfirst. The registration can be performed globally or at a ``ResourceSet`` level.\nHere is how to register the JSON resource factory for a given ``ResourceSet``.\n\n.. code-block:: python\n\n    >>> from pyecore.resources import ResourceSet\n    >>> from pyecore.resources.json import JsonResource\n    >>> rset = ResourceSet()  # We have a resource set\n    >>> rset.resource_factory['json'] = lambda uri: JsonResource(uri)  # we register the factory for '.json' extensions\n\n\nAnd here is how to register the factory at a global level:\n\n.. code-block:: python\n\n    >>> from pyecore.resources import ResourceSet\n    >>> from pyecore.resources.json import JsonResource\n    >>> ResourceSet.resource_factory['json'] = lambda uri: JsonResource(uri)\n\n\nOnce the resource factory is registered, you can load/save models/metamodels\nexactly the same way you would have done it for XMI. Check the XMI section to\nsee how to load/save resources using a ``ResourceSet``.\n\n**NOTE:** Currently, the Json serialization is performed using the defaut Python\n``json`` lib. It means that your PyEcore model is first translated to a huge\n``dict`` before the export/import. For huge models, this implies a memory and\nperformance cost. Future version of this serializer will deal with a different\nway of producing the final file.\n\n\nDeleting Elements\n=================\n\nDeleting elements in EMF is still a sensible point because of all the special\nmodel \"shape\" that can impact the deletion algorithm. PyEcore supports two main\nway of deleting elements: one is a real kind of deletion, while the other is\nmore less direct.\n\nThe ``delete()`` method\n-----------------------\n\nThe first way of deleting element is to use the ``delete()`` method which is\nowned by every ``EObject/EProxy``:\n\n.. code-block:: python\n\n    >>> # we suppose we have an already existing element in 'elem'\n    >>> elem.delete()\n\nThis call is also recursive by default: every sub-object of the deleted element\nis also deleted. This behavior is the one by default as a \"containment\"\nreference is a strong constraint.\n\nThe behavior of the ``delete()`` method can be confusing when there is many\n``EProxy`` in the game. As the ``EProxy`` only gives a partial view of the\nobject while it is not resolved, the ``delete()`` can only correctly remove\nresolved proxies. If a resource or many elements that are referenced in many\nother resources must be destroyed, in order to be sure to not introduce broken\nproxies, the best solution is to resolve all the proxies first, then to delete\nthem.\n\n\nRemoving an element from it's container\n---------------------------------------\n\nYou can also, in a way, removing elements from a model using the XMI\nserialization. If you want to remove an element from a Resource, you have to\nremove it from its container. PyEcore does not serialize elements that are not\ncontained by a ``Resource`` and each reference to this 'not-contained' element\nis not serialized.\n\nModifying Elements Using Commands\n=================================\n\nPyEcore objects can be modified as shown previously, using basic Python\noperators, but these mofifications cannot be undone. To do so, it is required to\nuse ``Command`` and a ``CommandStack``. Each command represent a basic action\nthat can be performed on an element (set/add/remove/move/delete):\n\n.. code-block:: python\n\n    >>> from pyecore.commands import Set\n    >>> # we assume have a metamodel with an A EClass that owns a 'name' feature\n    >>> a = A()\n    >>> set = Set(owner=a, feature='name', value='myname')\n    >>> if set.can_execute:\n    ...     set.execute()\n    >>> a.name\n    myname\n\nIf you use a simple command withtout ``CommandStack``, the ``can_execute`` call\nis mandatory! It performs some prior computation before the actual command\nexecution. Each executed command also supports 'undo' and 'redo':\n\n.. code-block:: python\n\n    >>> if set.can_undo:\n    ...     set.undo()\n    >>> assert a.name is None\n    >>> set.redo()\n    >>> assert a.name == 'myname'\n\nAs for the ``execute()`` method, the ``can_undo`` call must be done before\ncalling the ``undo()`` method. However, there is no ``can_redo``, the ``redo()``\ncall can be mad right away after an undo.\n\nTo compose all of these commands, a ``Compound`` can be used. Basically, a\n``Compound`` acts as a list with extra methods (``execute``, ``undo``,\n``redo``...):\n\n.. code-block:: python\n\n    >>> from pyecore.commands import Compound\n    >>> a = A()  # we use a new A instance\n    >>> c = Compound(Set(owner=a, feature='name', value='myname'),\n    ...              Set(owner=a, feature='name', value='myname2'))\n    >>> len(c)\n    2\n    >>> if c.can_execute:\n    ...     c.execute()\n    >>> a.name\n    myname2\n    >>> if c.can_undo:\n    ...     c.undo()\n    >>> assert a.name is None\n\nIn order to organize and keep a stack of each played command, a ``CommandStack``\ncan be used:\n\n.. code-block:: python\n\n    >>> from pyecore.commands import CommandStack\n    >>> a = A()\n    >>> stack = CommandStack()\n    >>> stack.execute(Set(owner=a, feature='name', value='myname'))\n    >>> stack.execute(Set(owner=a, feature='name', value='myname2'))\n    >>> stack.undo()\n    >>> assert a.name == 'myname'\n    >>> stack.redo()\n    >>> assert a.name == 'myname2'\n\n\nHere is a quick review of each command:\n\n* ``Set`` --> sets a ``feature`` to a ``value`` for an ``owner``\n* ``Add`` --> adds a ``value`` object to a ``feature`` collection from an ``owner`` object (``Add(owner=a, feature='collection', value=b)``). This command can also add a ``value`` at a dedicated ``index`` (``Add(owner=a, feature='collection', value=b, index=0)``)\n* ``Remove`` --> removes a ``value`` object from a ``feature`` collection from an ``owner`` (``Remove(owner=a, feature='collection', value=b)``). This command can also remove an object located at an ``index`` (``Remove(owner=a, feature='collection', index=0)``)\n* ``Move`` --> moves a ``value`` to a ``to_index`` position inside a ``feature`` collection (``Move(owner=a, feature='collection', value=b, to_index=1)``). This command can also move an element from a ``from_index`` to a ``to_index`` in a collection (``Move(owner=a, feature='collection', from_index=0, to_index=1)``)\n* ``Delete`` --> deletes an elements and its contained elements (``Delete(owner=a)``)\n\n\nDynamically Extending PyEcore Base Classes\n==========================================\n\nPyEcore is extensible and there is two ways of modifying it: either by extending\nthe basic concepts (as ``EClass``, ``EStructuralFeature``...), or by directly\nmodifying the same concepts.\n\nExtending PyEcore Base Classes\n------------------------------\n\nTo extend the PyEcore base classes, the only thing to do is to create new\n``EClass`` instances that have some base classes as ``superclass``.\nThe following excerpt shows how you can create an ``EClass`` instance that\nwill add support ``EAnnotation`` to each created instance:\n\n.. code-block:: python\n\n    >>> from pyecore.ecore import *\n    >>> A = EClass('A', superclass=(EModelElement.eClass))  # we need to use '.eClass' to stay in the PyEcore EClass instance level\n    >>> a = A()  # we create an instance that has 'eAnnotations' support\n    >>> a.eAnnotations\n    EOrderedSet()\n    >>> annotation = EAnnotation(source='testSource')\n    >>> annotation.details['mykey'] = 33\n    >>> a.eAnnotations.append(annotation)\n    >>> EOrderedSet([<pyecore.ecore.EAnnotation object at 0x7fb860a99f28>])\n\nIf you want to extend ``EClass``, the process is mainly the same, but there is a\ntwist:\n\n.. code-block:: python\n\n    >>> from pyecore.ecore import *\n    >>> NewEClass = EClass('NewEClass', superclass=(EClass.eClass))  # NewEClass is an EClass instance and an EClass\n    >>> A = NewEClass('A')  # here is the twist, currently, EClass instance MUST be named\n    >>> a = A()  # we can create 'A' instance\n    >>> a\n    <pyecore.ecore.A at 0x7fb85b6c06d8>\n\n\nModifying PyEcore Base Classes\n------------------------------\n\nPyEcore let you dynamically add new features to the base class and thus\nintroduce new feature for base classes instances:\n\n.. code-block:: python\n\n    >>> from pyecore.ecore import *\n    >>> EClass.new_feature = EAttribute('new_feature', EInt)  # EClass has now a new EInt feature\n    >>> A = EClass('A')\n    >>> A.new_feature\n    0\n    >>> A.new_feature = 5\n    >>> A.new_feature\n    5\n\n\nDependencies\n============\n\nThe dependencies required by pyecore are:\n\n* ordered-set which is used for the ``ordered`` and ``unique`` collections expressed in the metamodel,\n* lxml which is used for the XMI parsing.\n\nThese dependencies are directly installed if you choose to use ``pip``.\n\n\nRun the Tests\n=============\n\nTests uses `py.test` and 'coverage'. Everything is driven by `Tox`, so in order\nto run the tests simply run:\n\n.. code-block:: bash\n\n    $ tox\n\n\nLiberty Regarding the Java EMF Implementation\n=============================================\n\n* There is some meta-property that are not still coded inside PyEcore. More will come with time,\n* ``Resource`` can only contain a single root at the moment,\n* External resources (like ``http://www.eclipse.org/emf/2003/XMLType``) must be create by hand an loaded in the ``global_registry`` or as a ``resource`` of a ``ResourceSet``,\n* Proxies are not \"removed\" once resolved as in the the Java version, instead they acts as transparent proxies and redirect each calls to the 'proxied' object.\n\nState\n=====\n\nIn the current state, the project implements:\n\n* the dynamic/static metamodel definitions,\n* reflexive API,\n* inheritance,\n* enumerations,\n* abstract metaclasses,\n* runtime typechecking,\n* attribute/reference creations,\n* collections (attribute/references with upper bound set to ``-1``),\n* reference eopposite,\n* containment reference,\n* introspection,\n* select/reject on collections,\n* Eclipse XMI import (partially, only single root models),\n* Eclipse XMI export (partially, only single root models),\n* simple notification/Event system,\n* EOperations support,\n* code generator for the static part,\n* EMF proxies (first version),\n* object deletion (first version),\n* EMF commands (first version),\n* EMF basic command stack,\n* EMF very basic Editing Domain,\n* JSON import (simple JSON format),\n* JSON export (simple JSON format).\n\nThe things that are in the roadmap:\n\n* new implementation of ``EOrderedSet``, ``EList``, ``ESet`` and ``EBag``,\n* new implementation of ``EStringToStringMapEntry`` and ``EFeatureMapEntry``,\n* multiple roots models,\n* derived collections,\n* URI mapper,\n* documentation,\n* copy/paste (?).\n\nExisting Projects\n=================\n\nThere is not so much projects proposing to handle model and metamodel in Python.\nThe only projects I found are:\n\n* PyEMOF (http://www.lifl.fr/~marvie/software/pyemof.html)\n* EMF4CPP (https://github.com/catedrasaes-umu/emf4cpp)\n* PyEMOFUC (http://www.istr.unican.es/pyemofuc/index_En.html)\n\nPyEMOF proposes an implementation of the OMG's EMOF in Python. The project\ntargets Python2, only supports Class/Primitive Types (no Enumeration), XMI\nimport/export and does not provide a reflexion layer. The project didn't move\nsince 2005.\n\nEMF4CPP proposes a C++ implementation of EMF. This implementation also\nintroduces Python scripts to call the generated C++ code from a Python\nenvironment. It seems that the EMF4CPP does not provide a reflexive layer\neither.\n\nPyEMOFUC proposes, like PyEMOF, a pure Python implementation of the OMG's EMOF.\nIf we stick to a kind of EMF terminology, PyEMOFUC only supports dynamic\nmetamodels and seems to provide a reflexive layer. The project does not appear\nseems to have moved since a while.\n\nContributors\n============\n\nThanks for making PyEcore better!\n\n* Mike Pagel (`@moltob <https://github.com/moltob>`_)\n\nAdditional Resources\n====================\n\n* The article at this address: http://modeling-languages.com/pyecore-python-eclipse-modeling-framework\n  gives more information and implementations details about PyEcore.\n\n\n",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "https://github.com/pyecore/pyecore",
    "keywords": "model metamodel EMF Ecore MDE",
    "license": "BSD 3-Clause",
    "maintainer": "",
    "maintainer_email": "",
    "name": "pyecore",
    "platform": "",
    "project_url": "https://pypi.org/project/pyecore/",
    "release_url": "https://pypi.org/project/pyecore/0.7.0/",
    "requires_dist": [
      "enum34; python_version < \"3.4\"",
      "ordered-set",
      "lxml"
    ],
    "requires_python": "",
    "summary": "A Python(ic) Implementation of the Eclipse Modeling Framework (EMF/Ecore)",
    "version": "0.7.0"
  },
  "releases": {
    "0.1.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "10064470dced9ec620f9003f015046c1",
          "sha256": "94d05b673b7d242049cd93f5a37c3b97a19125610fda65af32e1e208ee83bae9"
        },
        "downloads": 13,
        "filename": "pyecore-0.1.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "10064470dced9ec620f9003f015046c1",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "size": 58447,
        "upload_time": "2017-01-28T12:11:44",
        "url": "https://files.pythonhosted.org/packages/5a/4b/9226e5b872d30e4eba5a8170799c9f8a29a89f3ca05b66a941e8c24c58ff/pyecore-0.1.1-py3-none-any.whl"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "5a7c7ac7df2cc2d2d59c99859bfe45b2",
          "sha256": "f8b9bef7a59d83b7068ba2402383b466d602e9b4f86da6acc303af0ff6404feb"
        },
        "downloads": 15,
        "filename": "pyecore-0.1.1.tar.gz",
        "has_sig": false,
        "md5_digest": "5a7c7ac7df2cc2d2d59c99859bfe45b2",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 40288,
        "upload_time": "2017-01-28T12:11:46",
        "url": "https://files.pythonhosted.org/packages/c2/f7/ee7a871b9aefb992c4248506d0e91cdd73eae37f4715094bc96d9bd413a2/pyecore-0.1.1.tar.gz"
      }
    ],
    "0.1.2": [
      {
        "comment_text": "",
        "digests": {
          "md5": "67c2427fa9a038602f9c8a1728b39472",
          "sha256": "c8de1eac47abdb67b35b833874cea624e4777da69b7141acc7fd483e8a12ecef"
        },
        "downloads": 14,
        "filename": "pyecore-0.1.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "67c2427fa9a038602f9c8a1728b39472",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "size": 58457,
        "upload_time": "2017-01-30T13:43:38",
        "url": "https://files.pythonhosted.org/packages/af/60/bf6fd0026c09b1af8fd0642e889182af34f074c22089e4b630729f6a290d/pyecore-0.1.2-py3-none-any.whl"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "a74211b02a8a4a0f4a0844a167eff999",
          "sha256": "f8ddd73550e33a296ddd094f81a9e44b030a37f03cd82a5d1fbb9f816fdb2f9f"
        },
        "downloads": 14,
        "filename": "pyecore-0.1.2.tar.gz",
        "has_sig": false,
        "md5_digest": "a74211b02a8a4a0f4a0844a167eff999",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 36457,
        "upload_time": "2017-01-30T13:43:40",
        "url": "https://files.pythonhosted.org/packages/17/f9/b8d0b3d22b64f12cb328eb600cc5d6c7f3938eb83bb1e62cd405ebd98d2b/pyecore-0.1.2.tar.gz"
      }
    ],
    "0.1.3": [
      {
        "comment_text": "",
        "digests": {
          "md5": "cea17a5f95f0ac9d8fe9253a26b3e4c6",
          "sha256": "29ca023cbf30d2439ef11b96ef462cfcfd9bbb6973f3d65428288f047fbb1f2e"
        },
        "downloads": 15,
        "filename": "pyecore-0.1.3-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "cea17a5f95f0ac9d8fe9253a26b3e4c6",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "size": 71212,
        "upload_time": "2017-02-21T17:33:07",
        "url": "https://files.pythonhosted.org/packages/65/13/97b7218c2f3ba4283f8a74d3ffa79505e9beb91746e00dd04f046afdee3c/pyecore-0.1.3-py3-none-any.whl"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "9879b643286b7a97135c94232ad99f4c",
          "sha256": "c70fbc6eff0e1b9d77082af86aac632d0d6077df329760e4dfc45567c3964c33"
        },
        "downloads": 15,
        "filename": "pyecore-0.1.3.tar.gz",
        "has_sig": false,
        "md5_digest": "9879b643286b7a97135c94232ad99f4c",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 38857,
        "upload_time": "2017-02-21T17:33:13",
        "url": "https://files.pythonhosted.org/packages/13/b5/66dd32e36690bc2087e637e54086c098fcd06112d8d579b220bc15cc5998/pyecore-0.1.3.tar.gz"
      }
    ],
    "0.1.4": [
      {
        "comment_text": "",
        "digests": {
          "md5": "085ca6bcf91568f7459e5c4b94074c4e",
          "sha256": "29279c50345262137b4323fe5e9c2adab478f617d4985ab8492bfde4f65e2223"
        },
        "downloads": 22,
        "filename": "pyecore-0.1.4-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "085ca6bcf91568f7459e5c4b94074c4e",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "size": 73556,
        "upload_time": "2017-04-03T06:12:00",
        "url": "https://files.pythonhosted.org/packages/b5/27/8ded047b38b91927f1481e6555b60da69990243581ea1e6f858ae9e6a753/pyecore-0.1.4-py3-none-any.whl"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "9a7c6ed5f799029e4c3138b704114683",
          "sha256": "a02478a0e2b20856cda89517681bd90a83968141de927ed0cf05b54ceb825f2a"
        },
        "downloads": 22,
        "filename": "pyecore-0.1.4.tar.gz",
        "has_sig": false,
        "md5_digest": "9a7c6ed5f799029e4c3138b704114683",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 41889,
        "upload_time": "2017-04-03T06:12:03",
        "url": "https://files.pythonhosted.org/packages/2c/40/16d843a160f1274258505d1bc6f481acba065efc94ba692e50a465239eae/pyecore-0.1.4.tar.gz"
      }
    ],
    "0.1.5": [
      {
        "comment_text": "",
        "digests": {
          "md5": "2336586bdb62422951ee6819d1dc327f",
          "sha256": "77cd18f73a935425b03367636675164afe4cde52e8b4dc6d8af75f4066674345"
        },
        "downloads": 31,
        "filename": "pyecore-0.1.5-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "2336586bdb62422951ee6819d1dc327f",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "size": 73615,
        "upload_time": "2017-04-04T16:42:37",
        "url": "https://files.pythonhosted.org/packages/65/1d/21757259f4e67d120ee5b35c57d735c14bc91d4155863c84d489b9ad6cd4/pyecore-0.1.5-py3-none-any.whl"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "c15cd36041f8324543c0d3da0997a9a1",
          "sha256": "11a8d1982f576f41ad184d8b8251548a00e11d8401295284537223d3713a0407"
        },
        "downloads": 28,
        "filename": "pyecore-0.1.5.tar.gz",
        "has_sig": false,
        "md5_digest": "c15cd36041f8324543c0d3da0997a9a1",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 41960,
        "upload_time": "2017-04-04T16:42:39",
        "url": "https://files.pythonhosted.org/packages/42/2a/fe38dc7e83ad0461b648b9559af4622e89322b2f2f4474b1705a4f93ebb8/pyecore-0.1.5.tar.gz"
      }
    ],
    "0.2.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "836be73e7e0a3e103cbe12da48762819",
          "sha256": "e62ad3d19879d816f011cbf21f5660ca4056d155cefcb7ea3870925e7c6240cf"
        },
        "downloads": 0,
        "filename": "pyecore-0.2.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "836be73e7e0a3e103cbe12da48762819",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "size": 74439,
        "upload_time": "2017-04-14T08:28:14",
        "url": "https://files.pythonhosted.org/packages/be/52/022cbd398ed70957fa1658567ded563f118ef3501c929d92e0cedd1c4568/pyecore-0.2.0-py3-none-any.whl"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "8b8653cabf32034d0eb493d1b64e30f4",
          "sha256": "ba977b7bf7ce71a4853e3c70c3475791f0822b1588bd0de04e2f9295effcd633"
        },
        "downloads": 0,
        "filename": "pyecore-0.2.0.tar.gz",
        "has_sig": false,
        "md5_digest": "8b8653cabf32034d0eb493d1b64e30f4",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 42745,
        "upload_time": "2017-04-14T08:28:16",
        "url": "https://files.pythonhosted.org/packages/38/37/7c1c028d5159b4f870fad0470d4404c9182a66e5ba81a77ba520673de8b8/pyecore-0.2.0.tar.gz"
      }
    ],
    "0.3.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "16d582c7741fbdd1ed687d0bbfb803a7",
          "sha256": "e132831e4d1b80b8342ca4e2fa22e73df4d5a337822848eba9609d5a611bb518"
        },
        "downloads": 0,
        "filename": "pyecore-0.3.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "16d582c7741fbdd1ed687d0bbfb803a7",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "size": 79050,
        "upload_time": "2017-05-07T12:51:58",
        "url": "https://files.pythonhosted.org/packages/44/a1/f69d4ad947750b1251338687d419079d9362eb9d6d5c73f7907af1c32963/pyecore-0.3.0-py3-none-any.whl"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "512403bff177375ab2ab8bee6492c89b",
          "sha256": "6d826d9681beb0486d6b4e4e2139b585ec9cacfc866fd921dd14db3beb76b52c"
        },
        "downloads": 0,
        "filename": "pyecore-0.3.0.tar.gz",
        "has_sig": false,
        "md5_digest": "512403bff177375ab2ab8bee6492c89b",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 49003,
        "upload_time": "2017-05-07T12:52:01",
        "url": "https://files.pythonhosted.org/packages/55/8b/a59e7ac80318a4217d84dd25d21bccbeb50ee1676480229fb0fb7b68874a/pyecore-0.3.0.tar.gz"
      }
    ],
    "0.5.10": [
      {
        "comment_text": "",
        "digests": {
          "md5": "31fdfcb092b4991940525544f1a1257e",
          "sha256": "037323ac1561539034ae71c887793818c172ee937d51b194908b952bb0bbdffe"
        },
        "downloads": 0,
        "filename": "pyecore-0.5.10-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "31fdfcb092b4991940525544f1a1257e",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "size": 42552,
        "upload_time": "2017-06-01T21:42:21",
        "url": "https://files.pythonhosted.org/packages/2e/6e/c6d5bd5505472a28eafd94ef11c613b3b8483bf6cbb0d4d665b726caa886/pyecore-0.5.10-py3-none-any.whl"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "a7901d0768cd58ee2518c2de148c7c09",
          "sha256": "643409006a29227a63a8dffc7ddc6fe189129ac54b79b22453cbeeea2f05f455"
        },
        "downloads": 0,
        "filename": "pyecore-0.5.10.tar.gz",
        "has_sig": false,
        "md5_digest": "a7901d0768cd58ee2518c2de148c7c09",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 52432,
        "upload_time": "2017-06-01T21:42:22",
        "url": "https://files.pythonhosted.org/packages/b3/b1/378904b2306f3ec73f529c8d887f966c315dde7e5fa0fae0b64e3fe2f89e/pyecore-0.5.10.tar.gz"
      }
    ],
    "0.5.11": [
      {
        "comment_text": "",
        "digests": {
          "md5": "d858245fc882e295d1b3e2b8a8fcceab",
          "sha256": "e3cf94cbaf65d6024b659517df8b54dfa222ceabfa0c289dcd10fca3b6c1423a"
        },
        "downloads": 0,
        "filename": "pyecore-0.5.11-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "d858245fc882e295d1b3e2b8a8fcceab",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "size": 42814,
        "upload_time": "2017-06-07T06:18:54",
        "url": "https://files.pythonhosted.org/packages/9d/1a/6b09e076e02b56b6c260b21d86cd808a14da1dabc911d2669ba900c90201/pyecore-0.5.11-py3-none-any.whl"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "16f6ac01229e5a1832920958afe98abe",
          "sha256": "c94e062a233e0fff6433cfd4a8cba44666e8a9eae8c64d18fa43b05ffb0a6ace"
        },
        "downloads": 0,
        "filename": "pyecore-0.5.11.tar.gz",
        "has_sig": false,
        "md5_digest": "16f6ac01229e5a1832920958afe98abe",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 52853,
        "upload_time": "2017-06-07T06:18:55",
        "url": "https://files.pythonhosted.org/packages/9a/fd/4776b18ee672ee6f6437ca2d9d6f1fdfc3b26f74db85867b8050abb0aa9c/pyecore-0.5.11.tar.gz"
      }
    ],
    "0.5.4": [
      {
        "comment_text": "",
        "digests": {
          "md5": "c6fa3a50133ce0df7be794f6ea03201a",
          "sha256": "b8c749962e9628a1a19a1ba4de8e87001054af4ddd1971ba0ef6e1b797d716f3"
        },
        "downloads": 0,
        "filename": "pyecore-0.5.4-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "c6fa3a50133ce0df7be794f6ea03201a",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "size": 41314,
        "upload_time": "2017-05-24T14:52:55",
        "url": "https://files.pythonhosted.org/packages/94/75/38a1179e5390e33af1fc3a746d35c2c7ea22ecf4ecbc14be8d9b82a9a1a3/pyecore-0.5.4-py3-none-any.whl"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "3566289d8c5988db38d8a4f054aaab1f",
          "sha256": "33503f0a049135daa55ad77599d48ce7502636967416174e2007fac04f5d7923"
        },
        "downloads": 0,
        "filename": "pyecore-0.5.4.tar.gz",
        "has_sig": false,
        "md5_digest": "3566289d8c5988db38d8a4f054aaab1f",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 45710,
        "upload_time": "2017-05-24T14:52:56",
        "url": "https://files.pythonhosted.org/packages/e9/da/4ea62396a43eddb6150992b942becefd4233d93fb87f117cf801457ea23a/pyecore-0.5.4.tar.gz"
      }
    ],
    "0.5.5": [
      {
        "comment_text": "",
        "digests": {
          "md5": "c856ced15dd9eaee48f9af9a48527010",
          "sha256": "c9c603e7ebffe606c061771c7da572251c2f984d2b61f695e218066dc178da73"
        },
        "downloads": 0,
        "filename": "pyecore-0.5.5-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "c856ced15dd9eaee48f9af9a48527010",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "size": 51580,
        "upload_time": "2017-05-26T20:02:09",
        "url": "https://files.pythonhosted.org/packages/1a/f7/f0c202debb47d66e72402da8b820307808d766ee643ca6f4a96ab4e3a153/pyecore-0.5.5-py3-none-any.whl"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "4c8b0cc153a08c56207ad46cf5925f0f",
          "sha256": "0363830e3b7504bc1a1401cc89b83de70fc420ed644600b169b1e79646441bfb"
        },
        "downloads": 0,
        "filename": "pyecore-0.5.5.tar.gz",
        "has_sig": false,
        "md5_digest": "4c8b0cc153a08c56207ad46cf5925f0f",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 46761,
        "upload_time": "2017-05-26T20:02:11",
        "url": "https://files.pythonhosted.org/packages/0a/4b/42e150ba3df9068cadbfce1bcf5ad73502af368b1e3895988027b7e765a7/pyecore-0.5.5.tar.gz"
      }
    ],
    "0.5.6": [
      {
        "comment_text": "",
        "digests": {
          "md5": "2058249af3e3f1dfaa2d1e0fb6a8d879",
          "sha256": "cadb6b51f34fe80c2c71b9555f9224f416afcaf54346f4366134cd41f024653b"
        },
        "downloads": 0,
        "filename": "pyecore-0.5.6-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "2058249af3e3f1dfaa2d1e0fb6a8d879",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "size": 41560,
        "upload_time": "2017-05-27T15:46:51",
        "url": "https://files.pythonhosted.org/packages/3c/f8/90eb2aa7642e7c0f4a7f60c246b52ccb5ab42b35ba626712c7b956a2893a/pyecore-0.5.6-py3-none-any.whl"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "7b8492b4cb33643cbf333c531fec7342",
          "sha256": "d80eb719bf15aad83ee08ba0e8151c2eb8e80b0a649348c560c42c439d1cb57c"
        },
        "downloads": 0,
        "filename": "pyecore-0.5.6.tar.gz",
        "has_sig": false,
        "md5_digest": "7b8492b4cb33643cbf333c531fec7342",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 50353,
        "upload_time": "2017-05-27T15:46:52",
        "url": "https://files.pythonhosted.org/packages/be/17/4ea3ddde82148ddffc9f585086099e3baf056c4a9e3d7e2f90398bde06bb/pyecore-0.5.6.tar.gz"
      }
    ],
    "0.5.7": [
      {
        "comment_text": "",
        "digests": {
          "md5": "ffe40ac649c754c816085f990065d72b",
          "sha256": "989f395d0878bae3794caa521ee5d776f6d5759b71203abe9976903bb5500d1e"
        },
        "downloads": 0,
        "filename": "pyecore-0.5.7-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "ffe40ac649c754c816085f990065d72b",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "size": 41569,
        "upload_time": "2017-05-29T10:45:47",
        "url": "https://files.pythonhosted.org/packages/3e/a8/ad59ce58198de5e48825baed939e518fbf8d637963af8f983d056b4008f8/pyecore-0.5.7-py3-none-any.whl"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "7ba1042386125e601a4d6618cfd0b9aa",
          "sha256": "188d38816001f7223db5a3c8a88a378130b3d0ebad12146a1b230df38e48167e"
        },
        "downloads": 0,
        "filename": "pyecore-0.5.7.tar.gz",
        "has_sig": false,
        "md5_digest": "7ba1042386125e601a4d6618cfd0b9aa",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 50474,
        "upload_time": "2017-05-29T10:45:48",
        "url": "https://files.pythonhosted.org/packages/10/75/81ef1f556ecf57ffd569b6e9591753aeb7971db06020cef06c5eba6cca35/pyecore-0.5.7.tar.gz"
      }
    ],
    "0.5.8": [
      {
        "comment_text": "",
        "digests": {
          "md5": "d24361998c10677f566c86f85f6e7359",
          "sha256": "5016d82e77d7e997b3563285c725e9759c44ec7170502c7ef2682df15e5d3815"
        },
        "downloads": 0,
        "filename": "pyecore-0.5.8-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "d24361998c10677f566c86f85f6e7359",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "size": 42556,
        "upload_time": "2017-05-29T11:49:25",
        "url": "https://files.pythonhosted.org/packages/42/95/3eb154f77599659f859e606ae0b2837065ab49062b3bfd420226f087ee22/pyecore-0.5.8-py3-none-any.whl"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "932b70bea01502340b834aa7cdf17983",
          "sha256": "fff17eb96dcac1d3d2ad9368a113a41be769c9018ce5685c0ef70fba4aa1e8f6"
        },
        "downloads": 0,
        "filename": "pyecore-0.5.8.tar.gz",
        "has_sig": false,
        "md5_digest": "932b70bea01502340b834aa7cdf17983",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 52119,
        "upload_time": "2017-05-29T11:49:27",
        "url": "https://files.pythonhosted.org/packages/8f/37/a36f0794684e29435ce67c221dfcbfe0fc7787ef125c0cbfa8ae82615032/pyecore-0.5.8.tar.gz"
      }
    ],
    "0.5.9": [
      {
        "comment_text": "",
        "digests": {
          "md5": "cb6209a595ae61957cc0e26e0fcca95e",
          "sha256": "98280c40f6a110175f6ac9f03fb849d2d263cb8479bd6e56692c1c320cc9abe2"
        },
        "downloads": 0,
        "filename": "pyecore-0.5.9-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "cb6209a595ae61957cc0e26e0fcca95e",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "size": 42558,
        "upload_time": "2017-06-01T17:18:34",
        "url": "https://files.pythonhosted.org/packages/52/d5/9872b3da4724fe9ff8794dc14e7f207cf5b42137ed6a571cd70d31ac6400/pyecore-0.5.9-py3-none-any.whl"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "9b8f8f2a1ae371502f982223fae9245a",
          "sha256": "ad92735c12838b1816d6049c427548bc7166669604cee0b2a0fe6b87dcb346cb"
        },
        "downloads": 0,
        "filename": "pyecore-0.5.9.tar.gz",
        "has_sig": false,
        "md5_digest": "9b8f8f2a1ae371502f982223fae9245a",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 52437,
        "upload_time": "2017-06-01T17:18:36",
        "url": "https://files.pythonhosted.org/packages/d7/c1/1710d7b282102a46300164178be905e1fa2989f8ebb884af5d30ba0caf17/pyecore-0.5.9.tar.gz"
      }
    ],
    "0.6.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "2ba835807fde7ea9200d36bea89a77d4",
          "sha256": "7fb68f81a8666a988731c712687aa1d9aabc15a306f230cfa256d7cbeed68e94"
        },
        "downloads": 0,
        "filename": "pyecore-0.6.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "2ba835807fde7ea9200d36bea89a77d4",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "size": 42989,
        "upload_time": "2017-07-07T13:35:04",
        "url": "https://files.pythonhosted.org/packages/43/c1/cf0eacfceaa318540732e48427a1f2cbeb3e8ef1c790db7cc35c1770e2ba/pyecore-0.6.0-py3-none-any.whl"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "5fbcacd89881b44187bfab1b6860ea24",
          "sha256": "f8f9ddde4fc6f4d655c80002eabc159dcd2de4adeb5933b7b7b4f60586fad38b"
        },
        "downloads": 0,
        "filename": "pyecore-0.6.0.tar.gz",
        "has_sig": false,
        "md5_digest": "5fbcacd89881b44187bfab1b6860ea24",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 53769,
        "upload_time": "2017-07-07T13:35:07",
        "url": "https://files.pythonhosted.org/packages/7c/cf/96fd366e0492ba21c9a5726f99eefe7dd6335e8687469176f40b6a02781d/pyecore-0.6.0.tar.gz"
      }
    ],
    "0.7.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "809fd7e93f10caf22757d930160f8e71",
          "sha256": "6dc3424b02f6bd8beb4e64c48c5ac75b90de229886b2987e2b388981c7e8bc6f"
        },
        "downloads": 0,
        "filename": "pyecore-0.7.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "809fd7e93f10caf22757d930160f8e71",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "size": 54513,
        "upload_time": "2017-10-03T19:09:24",
        "url": "https://files.pythonhosted.org/packages/3f/e5/f2797809941feb2d7d97a353a1a7ac4ef6b637ef2588f6a91db5a4b20cff/pyecore-0.7.0-py3-none-any.whl"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "d7ce5c20c89916639e2f64f82da96b3f",
          "sha256": "5c64a92f51741f442a58b935553c7a471e9338de00759b3d350b6de701dbe3f5"
        },
        "downloads": 0,
        "filename": "pyecore-0.7.0.tar.gz",
        "has_sig": false,
        "md5_digest": "d7ce5c20c89916639e2f64f82da96b3f",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 68099,
        "upload_time": "2017-10-03T19:09:25",
        "url": "https://files.pythonhosted.org/packages/33/24/840628643193a84b70ff401a239141408dc35da869b1265d34af131655e2/pyecore-0.7.0.tar.gz"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "809fd7e93f10caf22757d930160f8e71",
        "sha256": "6dc3424b02f6bd8beb4e64c48c5ac75b90de229886b2987e2b388981c7e8bc6f"
      },
      "downloads": 0,
      "filename": "pyecore-0.7.0-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "809fd7e93f10caf22757d930160f8e71",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "size": 54513,
      "upload_time": "2017-10-03T19:09:24",
      "url": "https://files.pythonhosted.org/packages/3f/e5/f2797809941feb2d7d97a353a1a7ac4ef6b637ef2588f6a91db5a4b20cff/pyecore-0.7.0-py3-none-any.whl"
    },
    {
      "comment_text": "",
      "digests": {
        "md5": "d7ce5c20c89916639e2f64f82da96b3f",
        "sha256": "5c64a92f51741f442a58b935553c7a471e9338de00759b3d350b6de701dbe3f5"
      },
      "downloads": 0,
      "filename": "pyecore-0.7.0.tar.gz",
      "has_sig": false,
      "md5_digest": "d7ce5c20c89916639e2f64f82da96b3f",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 68099,
      "upload_time": "2017-10-03T19:09:25",
      "url": "https://files.pythonhosted.org/packages/33/24/840628643193a84b70ff401a239141408dc35da869b1265d34af131655e2/pyecore-0.7.0.tar.gz"
    }
  ]
}