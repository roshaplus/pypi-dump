{
  "info": {
    "author": "Andre Martins",
    "author_email": "afm@cs.cmu.edu",
    "bugtrack_url": null,
    "classifiers": [],
    "description": "AD3 (approximate MAP decoder with Alternating Direction Dual Decomposition)\nCopyright (C) 2012\nAndre Martins\nPriberam Labs, Lisbon, Portugal &\nInstituto de Telecomunicacoes, Instituto Superior Tecnico, Lisbon, Portugal\nAll Rights Reserved.\n\nhttp://www.ark.cs.cmu.edu/AD3\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n\nThis is a README for AD3 v2.0\n=================================\n\nAD3 (Alternating Directions Dual Decomposition) is an LP-MAP decoder for\nundirected constrained factor graphs. In other words, it is an approximate MAP\ndecoder that retrieves the solution of an LP relaxation of the original problem.\nIt applies the ADMM method which is described in refs. [1,3,4,5,6] below.\n\nThe input is a factor graph, which may contain both soft factors, associated\nwith log-potentials, and hard constraint factors, associated with a logic\nfunction. Factors can be dense, sparse, or combinatorial. Specialized factors\ncan be implemented by the practicioner (see below for instructions and\nexamples).\n\nThe output is the LP-MAP assignment, with a posterior value for each variable.\nIf all variables are integer, the relaxation is tight and the solution is the\ntrue MAP. Otherwise, some entries can be in the unit interval. External tools\ncan be used to obtain a valid solution using rounding heuristics. Optionally,\na flag can be set that applies a branch-and-bound procedure and retrieves the\ntrue MAP (but it can be slow if the relaxation has many fractional components).\n\n\nNew features since AD3 v1.0:\n============================\n\n* AD3 v2.0 can handle dense, sparse, and combinatorial factors, with binary or \nmulti-valued variables. This comes in addition to the PAIR and logic factors \n(XOR, OR, OR-with-output, and ATMOSTONE) already handled by AD3 v1.0. The \nsubproblems for these factors are addressed with the active set method described \nin ref. [6] below.\n\n* AD3 v2.0 allows the practicioner to implement her own specialized factor, \nwhich will be automatically handled by the AD3 algorithm. The practicioner only \nneeds to implement a method for computing the local MAP for that factor. We \ninclude example files to illustrate how this can be done for sequential factors, \ntree factors and head automaton factors (used in dependency parsing). \n\n* AD3 v2.0 can now process input UAI files (see \nhttp://www.cs.huji.ac.il/project/PASCAL/fileFormat.php), in addition to the FG \nfiles already processed by AD3 v1.0. A standalone tool is included to decode the \nfactor graphs encoded in these files.\n\n* AD3 v2.0 can also be compiled as a library (libad3), whose methods can be \ncalled from an external program. See below for usage examples.\n\n\n1. Requirements\n===============\nRunning AD3 v2.0 requires a standard C++ compiler. The code is self-contained. \nThe only dependency is Eigen (http://eigen.tuxfamily.org/), which is included in \nthe release (current version is Eigen 3.1.1). It has been tested on Linux, but \nit should run in other platforms with minor adaptations.\n\n\n2. Contents\n===========\nThis tarball contains a folder called ad3_v2, which we will refer to as the \n\"root\" folder. Underneath it, there are the following files and folders:\n\nad3_multi.cpp\n    Source file for the standalone application.\n    \nad3/\n    Folder containing the source and header files for AD3.\n\ndata/\n    Folder containing some example input files.\n    \nexamples/\n    Folder containing some example implementations that use libad3.\n\nEigen/\n    Folder containing the Eigen header files (downloaded from \n    http://eigen.tuxfamily.org/)\n\nMakefile\n    Makefile for generating all the executables and library files.\n\nLICENSE\n    Text of the GNU Lesser General Public License, Version 3.\n\nREADME\n    This file.\n\n\n\n3. Installation\n===============\n\nAD3 v2.0 can be downloaded from http://www.ark.cs.cmu.edu/AD3. \nTo compile the code, cd the root folder and type:\n\n> make\n\nThis will create an executable file ad3_multi in the root folder, a static \nlibrary libad3 in the ad3 folder, and several executables in the example \nfolders. To test, type:\n\n> ./ad3_multi\n\nwhich should produce the following output:\n\n    Usage: ad3_multi --format=[ad3(*)|uai] --file_graphs=[IN] \\\n    --file_posteriors=[OUT] --algorithm=[ad3(*)|psdd|mplp] \\\n    (--max_iterations=[NUM] --eta=[NUM] --adapt_eta=[true(*)|false] \\\n    --residual_threshold=[NUM] --convert_to_binary=[true|false(*)] \\\n    --exact=[true|false(*)])\n\nThen, type:\n\n    > ./ad3_multi --format=uai --file_graphs=data/30markers.uai \\\n    --file_posteriors=posteriors.out | tail -4\n\nIt should print something like:\n\n    Solution value after 37 iterations (AD3) = -1005.47\n    Took 0.296 sec.\n    Solution is integer.\n    Elapsed time: 0.296 sec.\n\nand a file named \"posteriors.out\" should be created in the root folder.\n\n\n\n4. Input flags\n==============\n\nThe following flags can be set:\n\n    Usage: ad3_multi --format=[ad3(*)|uai] --file_graphs=[IN] \\\n    --file_posteriors=[OUT] --algorithm=[ad3(*)|psdd|mplp] \\\n    (--max_iterations=[NUM] --eta=[NUM] --adapt_eta=[true(*)|false] \\\n    --residual_threshold=[NUM] --convert_to_binary=[true|false(*)] \\\n    --exact=[true|false(*)])\n\n--file_graphs=[IN]\n    Specifies the path to the input file, containing the structure of the factor graphs \n    and their log-potentials. \n\n--format=[ad3(*)|uai]\n    Specifies the format of the input file. Default is \"ad3\" which is described \n    below. An alternative for factor graphs with dense factors, is the \"uai\" \n    format, which is described at \n    http://www.cs.huji.ac.il/project/PASCAL/fileFormat.php.\n   \n--file_posteriors=[OUT] \n    Specifies the path to the output file, containing the LP-MAP or MAP solution. \n    See below for an description of the format of this file.\n\n--algorithm=[ad3(*)|psdd|mplp]\n    Decoding algorithm. Default is AD3, other choices are the projected \n    subgradient algorithm and generalized MPLP. \n         \n--max_iterations=[NUM]\n    Maximum number of iterations, for any of the algorithms above. \n    Default is 1000.\n\n--eta=[NUM] \n    Value of the penalty constant in AD3, or the initial stepsize in the \n    projected subgradient algorithm. In AD3, if adapt_eta is true, this is the \n    initial penalty, otherwise every iteration will apply this amount of penalty. \n    Default is 0.1.\n   \n--adapt_eta=[true(*)|false]\n    If true, adapt eta using the strategy described in ref. [2] below. \n    Default is true.\n\n--residual_threshold=[NUM]\n    Threshold for the primal and dual residuals in AD3. The algorithm will be \n    stopped if both residuals are below this threshold. \n    Default is 1e-6.\n\n--exact=[true|false(*)]\n    If true, apply a branch-and-bound procedure for obtaining the exact MAP \n    (note: this can be quite slow if the relaxation is \"too fractional\"). \n    Default is false.\n   \n--convert_to_binary=[true|false(*)]\n    If true, convert a factor graph with multi-valued variables to one which \n    only containts binary variables and hard constraints. This is an alternative\n    to the active set method, but it is usually much slower.\n    Default is false.\n\n\n\n5. AD3 format for the input files\n=================================\n\nNOTE: for factor graphs with dense factors and multi-valued variables, we \nrecommend using the (more standard) UAI file format instead. However, the AD3\nfile format is recommended for factor graphs with hard constraint logic factors.\nThey also allow specifying multiple factor graphs in a single file.\n\nIMPORTANT NOTE: AD3 files contain log-potentials, while UAI file contain \npotentials.\n\nAD3 files are in ASCII format and contain the following information: \n\n    [BLOCK DESCRIBING FACTOR GRAPH 1]\n\n    [BLOCK DESCRIBING FACTOR GRAPH 2]\n\n    ...\n\n    [BLOCK DESCRIBING FACTOR GRAPH K]\n\nThat is, each block is a description of a single factor graph, and blocks are \nseparated by empty lines.\n\nEach block should be of the following format:\n\n    [NUMBER OF VARIABLES]\n    [NUMBER OF FACTORS]\n    Log-potential of variable 1\n    Log-potential of variable 2\n    ...\n    Log-potential of variable N\n    [LINE DESCRIBING FACTOR 1]\n    [LINE DESCRIBING FACTOR 2]\n    ...\n    [LINE DESCRIBING FACTOR M]\n\nThe line describing each factor should have the following fields, separated by \nwhitespaces: \n    [FACTOR TYPE] [FACTOR DEGREE] [INDEX OF VAR 1] ... [INDEX OF VAR L] ([FACTOR LOG-POTENTIAL])\n\nThe meaning of these fields is the following:\n    [FACTOR TYPE] can be one of XOR, OR, OROUT, ATMOSTONE, or PAIR.\n    [FACTOR DEGREE] is the number of variables linked to the factor (always 2 \n        for PAIR factors).\n    [INDEX OF VAR i] contains one-based indices of the variables. For the logic \n        factors (i.e., all the above except PAIR) a dash used as a prefix means \n        that the variable is negated. \n    [FACTOR POTENTIAL] is optional and should be included iff FACTOR TYPE is \n        \"PAIR\", in which case it contains a score for the configuration where \n        both input variables are TRUE (the other three configurations receive a \n        score of zero).\n        \nSome examples:\n\n    \"XOR 3 15 1417 -1419\"\n        A XOR factor linked to three variables (15, 1417 and 1419) where the \n        last variable is negated. This is actually equivalent to \n        XOR-with-output. The feasible configurations are (TRUE, FALSE, TRUE), \n        (FALSE, TRUE, TRUE) and (FALSE, FALSE, FALSE).\n        \n    \"ATMOSTONE 3 15 1417 1419\"\n        A ATMOSTONE factor linked to three variables (15, 1417 and 1419). The \n        feasible configurations are (TRUE, FALSE, FALSE), (FALSE, TRUE, FALSE), \n        (FALSE, FALSE, TRUE) and (FALSE, FALSE, FALSE).\n\n    \"OR 2 1 2\"\n        A OR factor linked to two variables (1 and 2). All configurations are \n        feasible except (FALSE, FALSE).\n        \n    \"OROUT 3 10 20 30\"\n        A OR-with-output factor with two inputs (10 and 20) and one output (30). \n        If either 10 or 20 are TRUE, 30 must be TRUE; otherwise 30 must be FALSE.\n\n    \"OROUT 3 -10 -20 -30\"\n        A OR-with-output factor with two negated inputs (10 and 20) and one \n        negated output (30). This is actually equivalent to a AND-with-output. \n        If both 10 or 20 are TRUE, 30 must be TRUE; otherwise 30 must be FALSE.\n        \n    \"PAIR 2 25 26 0.048103\"\n        A PAIR factor connecting variables 25 and 26. The potential function \n        evaluates to 0.048103 if both variables are TRUE, and to 0 otherwise.\n\nSome examples of input files:\n\n1) Example of input file (example1.fg) for a constrained factor graph consisting \nof three variables connected by a OR factor:\n\n     3\n     1\n     0.75\n     1.25\n     -0.5\n     OR 3 1 2 3\n\nIn this case the probability distribution is \n\n     P(y1,y2,y3) = 0,                                    if y1 = y2 = y3 = 0\n                   1/Z exp(0.75*y1 + 1.25*y2 - 0.5*y3),  otherwise.\n\n     \n2) Example of input file (example2.fg) that in addition have the two first \nvariables connected by a PAIR factor:\n\n     3\n     2\n     0.75\n     1.25\n     -0.5\n     OR 3 1 2 3\n     PAIR 2 1 2 -1.05\n\nIn this case the probability distribution is \n\n     P(y1,y2,y3) = \n         0,                                                 if y1 = y2 = y3 = 0\n         1/Z exp(0.75*y1 + 1.25*y2 - 0.5*y3 - 1.05*y1*y2),  otherwise.\n\n3) Example of input file (coref.fg) for a toy coreference task with transitivity \nconstraints and some constraints requiring that each entity cluster has at least \na noun (all expressable as OR factors). Here the LP-MAP is fractional, but the \nbranch and bound procedure (flag --exact=true) is able to retrieve the true MAP.\n\n4) Example of input file (parsing_excerpt.fg) for dependency parsing in Slovene, \ntaken from ref. [4] below. This is for a single sentence, and the LP-MAP is \ninteger.\n\n5) Input file used in ref. [5] below, for FrameNet semantic parsing. Contains \nseveral factor graphs, one per predicate in the dev-set, with various \nconstraints regarding the kind of roles and their spans associated with the \npredicate frame. (Thanks to Dipanjan Das for generating this file.)\n\n\n\n6. Output file\n==============\n\nThe output file contains one floating point number per line, and as many lines \nas the number of binary variables (or states of multi-valued variables) plus the \nnumber of factor log-potential values (e.g., a PAIR factor has one log-potential\nvalue, a DENSE factor with 5 variables and 3 states each has 3^5 log-potential\nvalues). The values in each line contain the LP-MAP value for each variable, \nby order of index, followed by the LP-MAP values for each factor configuration, \nby order of appearance.\n\nNOTE: Internally, multi-valued variables are treated as arrays of binary \nvariables, one per state. \n\n\n\n7. Using the static library\n============================\n\nTo use AD3 in your C++ project, either copy the source/header files in the\nad3 folder, or link statically with libad3. You can look at the makefiles\nin the example folders. \n\nAs a simple example, the following code will create a fully connected Potts \nmodel with 3 variables with 5 states each, and will run AD3 on it. Other \nsimple examples are in the example folders, including one for non-projective \ndependency parsing with head automata, one for co-reference resolution, and \nanother for decoding Potts grids.\n\n#include \"ad3/FactorGraph.h\"\n\nint main(int argc, char **argv) {\n  // Create the factor graph.\n  AD3::FactorGraph factor_graph;\n\n  // Create 3 multi-valued variables with 5 states each.\n  std::vector<AD3::MultiVariable*> multi_variables(3);\n  for (int i = 0; i < 3; ++i) {\n    multi_variables[i] = factor_graph.CreateMultiVariable(5);\n\n    // Set uniform log-potentials.\n    for (int k = 0; k < 5; ++k) {\n      score = 0.0;\n      multi_variables[i]->SetLogPotential(k, score);\n    }\n  }\n\n  // Set the factor log-potentials.\n  vector<double> additional_log_potentials;\n  double alpha = 0.5; // The \"smoothness\" degree.\n  for (int k = 0; k < 5; ++k) {\n    for (int l = 0; l < 5; ++l) {\n      additional_log_potentials.push_back((k == l)? alpha : 0.0);\n    }\n  }\n  \n  // Create 3 factors connecting all the variables pairs.\n  vector<AD3::MultiVariable*> multi_variables_local(2);\n  multi_variables_local[0] = multi_variables[0];\n  multi_variables_local[1] = multi_variables[1];\n  factor_graph.CreateFactorDense(multi_variables_local,\n                                 additional_log_potentials);\n  multi_variables_local[0] = multi_variables[0];\n  multi_variables_local[1] = multi_variables[2];\n  factor_graph.CreateFactorDense(multi_variables_local,\n                                 additional_log_potentials);\n  multi_variables_local[0] = multi_variables[1];\n  multi_variables_local[1] = multi_variables[2];\n  factor_graph.CreateFactorDense(multi_variables_local,\n                                 additional_log_potentials);\n\n\n  vector<double> posteriors;\n  vector<double> additional_posteriors;\n  double value;\n\n  // Run AD3.\n  factor_graph.SetEtaAD3(0.1);\n  factor_graph.AdaptEtaAD3(true);\n  factor_graph.SetMaxIterationsAD3(1000);\n  factor_graph.SolveLPMAPWithAD3(&posteriors, &additional_posteriors, &value);\n  \n  return 0;\n}\n\n \n\n8. Contributing to AD3\n=======================\n\nTo contribute to AD3, you can fork the following github repository:\n\nhttp://github.com/andre-martins/AD3.\n\n\n9. Further Reading\n==================\n\nIf this code is used, please cite the paper [3] below. \n\n[1] Andr\u00e9 F. T. Martins, Noah A. Smith, Eric P. Xing, Pedro M. Q. Aguiar, and M\u00e1rio A. T. Figueiredo.\n\"Augmented Dual Decomposition for MAP Inference.\"\nNIPS Workshop in Optimization for Machine Learning, Whistler, Canada, December 2010.\n\n[2] S. Boyd, N. Parikh, E. Chu, B. Peleato, and J. Eckstein.\n\"Distributed Optimization and Statistical Learning via the Alternating Direction Method of Multipliers.\"\nFoundations and Trends in Machine Learning, Michael Jordan, Editor in Chief, 3(1):1\u2013122, 2011. \n\n[3] Andr\u00e9 F. T. Martins, M\u00e1rio A. T. Figueiredo, Pedro M. Q. Aguiar, Noah A. Smith, and Eric P. Xing.\n\"An Augmented Lagrangian Approach to Constrained MAP Inference.\"\nInternational Conference on Machine Learning (ICML'11), Bellevue, Washington, USA, June 2011.\n\n[4] Andr\u00e9 F. T. Martins, Noah A. Smith, M\u00e1rio A. T. Figueiredo, Pedro M. Q. Aguiar.\n\"Dual Decomposition With Many Overlapping Components.\"\nEmpirical Methods in Natural Language Processing (EMNLP'11), Edinburgh, UK, July 2011.\n\n[5] Dipanjan Das, Andr\u00e9 F. T. Martins, and Noah A. Smith.\n\"An Exact Dual Decomposition Algorithm for Shallow Semantic Parsing with Constraints\"\nProceedings of *SEM 2012.\n      \n[6] Andr\u00e9 F. T. Martins. \n\"The Geometry of Constrained Structured Prediction: Applications to Natural Language Syntax.\"\nPhD thesis, Carnegie Mellon University and Instituto Superior Tecnico, 2012. \n\n\n8. Contact\n==========\nIf you find any bugs or have questions, please email Andr\u00e9 Martins (afm@cs.cmu.edu).\n\n\n9. Version History\n==================\n1.0 - First public release (2012-06-01)\n2.0 - Second public release (2012-09-08)\n\n",
    "docs_url": null,
    "download_url": "UNKNOWN",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "http://www.ark.cs.cmu.edu/AD3",
    "keywords": null,
    "license": "UNKNOWN",
    "maintainer": null,
    "maintainer_email": null,
    "name": "ad3",
    "platform": "UNKNOWN",
    "project_url": "https://pypi.org/project/ad3/",
    "release_url": "https://pypi.org/project/ad3/2.0.2/",
    "requires_python": null,
    "summary": "UNKNOWN",
    "version": "2.0.2"
  },
  "releases": {
    "2.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "fa620170ea82079cc8ff7d27aa88fa8a",
          "sha256": "4df7becd1a30cdc191d2999fa14b2839b46627cc2fdf19810601af57bb8f0a88"
        },
        "downloads": 4930,
        "filename": "ad3-2.0.tar.gz",
        "has_sig": false,
        "md5_digest": "fa620170ea82079cc8ff7d27aa88fa8a",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 518459,
        "upload_time": "2013-08-11T17:09:57",
        "url": "https://files.pythonhosted.org/packages/cd/d1/6d0964e2c7b1497d74b4935666f5e60c22d88555b73b2acf205bea4a61fe/ad3-2.0.tar.gz"
      }
    ],
    "2.0.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "e6ae6e673e407638346b5fe0f566dd2a",
          "sha256": "eec4304248a3f2e87230386536813704be5bd56719ac1217f2f56018d4bb38ba"
        },
        "downloads": 2658,
        "filename": "ad3-2.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "e6ae6e673e407638346b5fe0f566dd2a",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 541482,
        "upload_time": "2014-11-25T20:45:25",
        "url": "https://files.pythonhosted.org/packages/a5/9c/5ce51fa4e9d58af2ced501163e14d7bf5061b62e698c532bf58fe54545c6/ad3-2.0.1.tar.gz"
      }
    ],
    "2.0.2": [
      {
        "comment_text": "",
        "digests": {
          "md5": "1511c787a549144929d5bc4959f4a8ba",
          "sha256": "c162476e2a8480ff57b352aa35c4ec78c2fd3db10bf0b2118fe770d8b391e5d1"
        },
        "downloads": 5063,
        "filename": "ad3-2.0.2.tar.gz",
        "has_sig": false,
        "md5_digest": "1511c787a549144929d5bc4959f4a8ba",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 541674,
        "upload_time": "2015-04-20T21:39:02",
        "url": "https://files.pythonhosted.org/packages/8c/12/0d4b0c9f7e194431341637b98a3eeca26f387c3eb34b665dd6b8a023de1c/ad3-2.0.2.tar.gz"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "1511c787a549144929d5bc4959f4a8ba",
        "sha256": "c162476e2a8480ff57b352aa35c4ec78c2fd3db10bf0b2118fe770d8b391e5d1"
      },
      "downloads": 5063,
      "filename": "ad3-2.0.2.tar.gz",
      "has_sig": false,
      "md5_digest": "1511c787a549144929d5bc4959f4a8ba",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 541674,
      "upload_time": "2015-04-20T21:39:02",
      "url": "https://files.pythonhosted.org/packages/8c/12/0d4b0c9f7e194431341637b98a3eeca26f387c3eb34b665dd6b8a023de1c/ad3-2.0.2.tar.gz"
    }
  ]
}