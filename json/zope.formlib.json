{
  "info": {
    "author": "Zope Foundation and Contributors",
    "author_email": "zope-dev@zope.org",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Environment :: Web Environment",
      "Framework :: Zope3",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: Zope Public License",
      "Natural Language :: English",
      "Operating System :: OS Independent",
      "Programming Language :: Python",
      "Programming Language :: Python :: 2",
      "Programming Language :: Python :: 2.6",
      "Programming Language :: Python :: 2.7",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.3",
      "Programming Language :: Python :: 3.4",
      "Programming Language :: Python :: Implementation :: CPython",
      "Programming Language :: Python :: Implementation :: PyPy",
      "Topic :: Internet :: WWW/HTTP"
    ],
    "description": ".. contents::\n\n========\nOverview\n========\n\nForms are web components that use widgets to display and input data.\nTypically a template displays the widgets by accessing an attribute or\nmethod on an underlying class.\n\n\n=====\nForms\n=====\n\nForms are web components that use widgets to display and input data.\nTypically a template displays the widgets by accessing an attribute or\nmethod on an underlying class.\n\nThis document describes some tools to assist in form development.  In\nthe examples, we will show \"forms\" that are generated with simple\nprint statements to keep the examples simpler.  Most forms will use\ntemplates in practice.\n\nThis document starts with low-level APIs.  We eventually build up to\nhigher-level APIs that allow forms to be defined with just a little bit\nof meta data.  Impatient readers may wish to skip to the later\nsections, especially the section on `Helpful base classes`_. :)\n\nA form class can define ordered collections of \"form fields\" using\nthe `Fields` constructor. Form fields are distinct from and build on\nschema fields.  A schema field specified attribute values.  Form\nfields specify how a schema field should be used in a form.  The\nsimplest way to define a collection of form fields is by passing a\nschema to the `Fields` constructor:\n\n    >>> from zope import interface, schema\n    >>> class IOrder(interface.Interface):\n    ...     identifier = schema.Int(title=u\"Identifier\", readonly=True)\n    ...     name = schema.TextLine(title=u\"Name\")\n    ...     min_size = schema.Float(title=u\"Minimum size\")\n    ...     max_size = schema.Float(title=u\"Maximum size\")\n    ...     color = schema.TextLine(title=u\"Color\", required=False)\n    ...     now = schema.Datetime(title=u\"Now\", readonly=True)\n\n    >>> from zope.formlib import form\n    >>> class MyForm:\n    ...     form_fields = form.Fields(IOrder)\n\nThis sets up a set of form fields from the interface, IOrder.\n\n    >>> len(MyForm.form_fields)\n    6\n\n    >>> [w.__name__ for w in MyForm.form_fields]\n    ['identifier', 'name', 'min_size', 'max_size', 'color', 'now']\n\nWe can access individual form fields by name:\n\n    >>> MyForm.form_fields['name'].__name__\n    'name'\n\nWe can also select and order subsets using the select method of form fields:\n\n    >>> [w.__name__ for w in MyForm.form_fields.select('name', 'identifier')]\n    ['name', 'identifier']\n\nor by omitting fields:\n\n    >>> [w.__name__ for w in MyForm.form_fields.omit('now', 'identifier')]\n    ['name', 'min_size', 'max_size', 'color']\n\nWe can omit read-only fields using the omit_readonly option when\nsetting up the fields:\n\n    >>> class MyForm:\n    ...     form_fields = form.Fields(IOrder, omit_readonly=True)\n    >>> [w.__name__ for w in MyForm.form_fields]\n    ['name', 'min_size', 'max_size', 'color']\n\n\nGetting HTML\n============\n\nHaving defined form fields, we can use them to generate HTML\nforms. Typically, this is done at run time by form class\ninstances. Let's look at an example that displays some input widgets:\n\n    >>> class MyForm:\n    ...     form_fields = form.Fields(IOrder, omit_readonly=True)\n    ...\n    ...     def __init__(self, context, request):\n    ...         self.context, self.request = context, request\n    ...\n    ...     def __call__(self, ignore_request=False):\n    ...         widgets = form.setUpWidgets(\n    ...             self.form_fields, 'form', self.context, self.request,\n    ...             ignore_request=ignore_request)\n    ...         return '\\n'.join([w() for w in widgets])\n\nHere we used ``form.setUpWidgets`` to create widget instances from our\nform-field specifications.  The second argument to ``setUpWidgets`` is a\nform prefix.  All of the widgets on this form are given the same\nprefix.  This allows multiple forms to be used within a single form\ntag, assuming that each form uses a different form prefix.\n\nNow, we can display the form:\n\n    >>> from zope.publisher.browser import TestRequest\n    >>> request = TestRequest()\n    >>> print(MyForm(None, request)()) # doctest: +NORMALIZE_WHITESPACE\n    <input class=\"textType\" id=\"form.name\" name=\"form.name\" size=\"20\"\n           type=\"text\" value=\"\"  />\n    <input class=\"textType\" id=\"form.min_size\" name=\"form.min_size\" size=\"10\"\n           type=\"text\" value=\"\"  />\n    <input class=\"textType\" id=\"form.max_size\" name=\"form.max_size\" size=\"10\"\n           type=\"text\" value=\"\"  />\n    <input class=\"textType\" id=\"form.color\" name=\"form.color\" size=\"20\"\n           type=\"text\" value=\"\"  />\n\n\nIf the request contains any form data, that will be reflected in the\noutput:\n\n    >>> request.form['form.name'] = u'bob'\n    >>> print(MyForm(None, request)()) # doctest: +NORMALIZE_WHITESPACE\n    <input class=\"textType\" id=\"form.name\" name=\"form.name\" size=\"20\"\n           type=\"text\" value=\"bob\"  />\n    <input class=\"textType\" id=\"form.min_size\" name=\"form.min_size\" size=\"10\"\n           type=\"text\" value=\"\"  />\n    <input class=\"textType\" id=\"form.max_size\" name=\"form.max_size\" size=\"10\"\n           type=\"text\" value=\"\"  />\n    <input class=\"textType\" id=\"form.color\" name=\"form.color\"\n           size=\"20\" type=\"text\" value=\"\"  />\n\n\nSometimes we don't want this behavior: we want to ignore the request values,\nparticularly after a form has been processed and before it is drawn again.\nThis can be accomplished with the 'ignore_request' argument in\nsetUpWidgets.\n\n    >>> print(MyForm(None, request)(ignore_request=True))\n    ... # doctest: +NORMALIZE_WHITESPACE\n    <input class=\"textType\" id=\"form.name\" name=\"form.name\" size=\"20\"\n           type=\"text\" value=\"\"  />\n    <input class=\"textType\" id=\"form.min_size\" name=\"form.min_size\" size=\"10\"\n           type=\"text\" value=\"\"  />\n    <input class=\"textType\" id=\"form.max_size\" name=\"form.max_size\" size=\"10\"\n           type=\"text\" value=\"\"  />\n    <input class=\"textType\" id=\"form.color\" name=\"form.color\" size=\"20\"\n           type=\"text\" value=\"\"  />\n\n\nReading data\n============\n\nOf course, we don't just want to display inputs.  We want to get the\ninput data.  We can use getWidgetsData for that:\n\n    >>> from pprint import pprint\n    >>> class MyForm:\n    ...     form_fields = form.Fields(IOrder, omit_readonly=True)\n    ...\n    ...     def __init__(self, context, request):\n    ...         self.context, self.request = context, request\n    ...\n    ...     def __call__(self):\n    ...         widgets = form.setUpWidgets(\n    ...             self.form_fields, 'form', self.context, self.request)\n    ...\n    ...         if 'submit' in self.request:\n    ...             data = {}\n    ...             errors = form.getWidgetsData(widgets, 'form', data)\n    ...             if errors:\n    ...                 print('There were errors:')\n    ...                 for error in errors:\n    ...                     print(error)\n    ...         else:\n    ...             data = None\n    ...\n    ...         for w in widgets:\n    ...             print(w())\n    ...             error = w.error()\n    ...             if error:\n    ...                 print(error)\n    ...\n    ...         return data\n\nWe check for a 'submit' variable in the form and, if we see it, we try\nto get the data, and errors.  We call `getWidgetsData`, passing:\n\n- Our widgets\n\n- The form prefix, and\n\n- A data dictionary to contain input values found\n\nThe keys in the data dictionary have the form prefix stripped off.\n\nIf there are errors, we print them.  When we display the widgets, we\nalso check for errors and show them if present.  Let's add a submit\nvariable:\n\n    >>> request.form['form.min_size'] = u''\n    >>> request.form['form.max_size'] = u''\n    >>> request.form['submit'] = u'Submit'\n    >>> MyForm(None, request)() # doctest: +NORMALIZE_WHITESPACE\n    There were errors:\n    ('min_size', u'Minimum size', RequiredMissing('min_size'))\n    ('max_size', u'Maximum size', RequiredMissing('max_size'))\n    <input class=\"textType\" id=\"form.name\" name=\"form.name\" size=\"20\"\n           type=\"text\" value=\"bob\"  />\n    <input class=\"textType\" id=\"form.min_size\" name=\"form.min_size\" size=\"10\"\n           type=\"text\" value=\"\"  />\n    <span class=\"error\">Required input is missing.</span>\n    <input class=\"textType\" id=\"form.max_size\" name=\"form.max_size\" size=\"10\"\n           type=\"text\" value=\"\"  />\n    <span class=\"error\">Required input is missing.</span>\n    <input class=\"textType\" id=\"form.color\" name=\"form.color\" size=\"20\"\n           type=\"text\" value=\"\"  />\n    {'name': u'bob'}\n\n\nNote that we got an error because we omitted the values for min_size\nand max size.  If we provide an invalid value, we'll get an error too:\n\n    >>> request.form['form.min_size'] = u'bob'\n    >>> MyForm(None, request)() # doctest: +NORMALIZE_WHITESPACE +ELLIPSIS\n    There were errors:\n    (u'Invalid floating point data', ...ValueError...)\n    ('max_size', u'Maximum size', RequiredMissing('max_size'))\n    <input class=\"textType\" id=\"form.name\" name=\"form.name\" size=\"20\"\n           type=\"text\" value=\"bob\"  />\n    <input class=\"textType\" id=\"form.min_size\" name=\"form.min_size\" size=\"10\"\n           type=\"text\" value=\"bob\"  />\n    <span class=\"error\">Invalid floating point data</span>\n    <input class=\"textType\" id=\"form.max_size\" name=\"form.max_size\" size=\"10\"\n           type=\"text\" value=\"\"  />\n    <span class=\"error\">Required input is missing.</span>\n    <input class=\"textType\" id=\"form.color\" name=\"form.color\" size=\"20\"\n           type=\"text\" value=\"\"  />\n    {'name': u'bob'}\n\nIf we provide valid data, we'll get the data back:\n\n    >>> request.form['form.min_size'] = u'42'\n    >>> request.form['form.max_size'] = u'142'\n    >>> pprint(MyForm(None, request)(), width=1)\n    ... # doctest: +NORMALIZE_WHITESPACE\n    <input class=\"textType\" id=\"form.name\" name=\"form.name\" size=\"20\"\n           type=\"text\" value=\"bob\"  />\n    <input class=\"textType\" id=\"form.min_size\" name=\"form.min_size\" size=\"10\"\n           type=\"text\" value=\"42.0\"  />\n    <input class=\"textType\" id=\"form.max_size\" name=\"form.max_size\" size=\"10\"\n           type=\"text\" value=\"142.0\"  />\n    <input class=\"textType\" id=\"form.color\" name=\"form.color\" size=\"20\"\n           type=\"text\" value=\"\"  />\n    {'max_size': 142.0,\n     'min_size': 42.0,\n     'name': u'bob'}\n\nIt's up to the form to decide what to do with the information.\n\nInvariants\n==========\n\nThe `getWidgetsData` function checks individual field constraints.\nInterfaces can also provide invariants that we may also want to check.\nThe `checkInvariants` function can be used to do that.\n\nIn our order example, it makes sense to require that the maximum is\ngreater than or equal to the minimum:\n\n    >>> class IOrder(interface.Interface):\n    ...     identifier = schema.Int(title=u\"Identifier\", readonly=True)\n    ...     name = schema.TextLine(title=u\"Name\")\n    ...     min_size = schema.Float(title=u\"Minimum size\")\n    ...     max_size = schema.Float(title=u\"Maximum size\")\n    ...     now = schema.Datetime(title=u\"Now\", readonly=True)\n    ...\n    ...     @interface.invariant\n    ...     def maxGreaterThanMin(order):\n    ...         if order.max_size < order.min_size:\n    ...             raise interface.Invalid(\"Maximum is less than Minimum\")\n\nWe can update our form to check the invariant using 'checkInvariants':\n\n    >>> class MyForm:\n    ...     form_fields = form.Fields(IOrder, omit_readonly=True)\n    ...\n    ...     def __init__(self, context, request):\n    ...         self.context, self.request = context, request\n    ...\n    ...     def __call__(self):\n    ...         widgets = form.setUpWidgets(\n    ...             self.form_fields, 'form', self.context, self.request)\n    ...\n    ...         if 'submit' in self.request:\n    ...             data = {}\n    ...             errors = form.getWidgetsData(widgets, 'form', data)\n    ...             invariant_errors = form.checkInvariants(\n    ...                 self.form_fields, data, self.context)\n    ...             if errors:\n    ...                 print('There were field errors:')\n    ...                 for error in errors:\n    ...                     print(error)\n    ...\n    ...             if invariant_errors:\n    ...                 print('There were invariant errors:')\n    ...                 for error in invariant_errors:\n    ...                     print(error)\n    ...         else:\n    ...             data = None\n    ...\n    ...         for w in widgets:\n    ...             print(w())\n    ...             error = w.error()\n    ...             if error:\n    ...                 print(error)\n    ...\n    ...         return data\n\nIf we display the form again, we'll get the same result:\n\n    >>> pprint(MyForm(None, request)(), width=1)\n    ... # doctest: +NORMALIZE_WHITESPACE\n    <input class=\"textType\" id=\"form.name\" name=\"form.name\" size=\"20\"\n           type=\"text\" value=\"bob\"  />\n    <input class=\"textType\" id=\"form.min_size\" name=\"form.min_size\" size=\"10\"\n           type=\"text\" value=\"42.0\"  />\n    <input class=\"textType\" id=\"form.max_size\" name=\"form.max_size\" size=\"10\"\n           type=\"text\" value=\"142.0\"  />\n    {'max_size': 142.0,\n     'min_size': 42.0,\n     'name': u'bob'}\n\nBut if we reduce the maximum below the minimum, we'll get an invariant\nerror:\n\n    >>> request.form['form.min_size'] = u'42'\n    >>> request.form['form.max_size'] = u'14'\n\n    >>> pprint(MyForm(None, request)(), width=1)\n    ... # doctest: +NORMALIZE_WHITESPACE\n    There were invariant errors:\n    Maximum is less than Minimum\n    <input class=\"textType\" id=\"form.name\" name=\"form.name\" size=\"20\"\n           type=\"text\" value=\"bob\"  />\n    <input class=\"textType\" id=\"form.min_size\" name=\"form.min_size\" size=\"10\"\n           type=\"text\" value=\"42.0\"  />\n    <input class=\"textType\" id=\"form.max_size\" name=\"form.max_size\" size=\"10\"\n           type=\"text\" value=\"14.0\"  />\n    {'max_size': 14.0,\n     'min_size': 42.0,\n     'name': u'bob'}\n\nWe can have field errors and invariant errors:\n\n    >>> request.form['form.name'] = u''\n\n    >>> pprint(MyForm(None, request)(), width=1)\n    ... # doctest: +NORMALIZE_WHITESPACE\n    There were field errors:\n    ('name', u'Name', RequiredMissing('name'))\n    There were invariant errors:\n    Maximum is less than Minimum\n    <input class=\"textType\" id=\"form.name\" name=\"form.name\" size=\"20\"\n           type=\"text\" value=\"\"  />\n    <span class=\"error\">Required input is missing.</span>\n    <input class=\"textType\" id=\"form.min_size\" name=\"form.min_size\" size=\"10\"\n           type=\"text\" value=\"42.0\"  />\n    <input class=\"textType\" id=\"form.max_size\" name=\"form.max_size\" size=\"10\"\n           type=\"text\" value=\"14.0\"  />\n    {'max_size': 14.0,\n     'min_size': 42.0}\n\nIf the inputs for some fields tested by invariants are missing, the\ninvariants are ignored:\n\n    >>> request.form['form.max_size'] = u''\n\n    >>> pprint(MyForm(None, request)()) # doctest: +NORMALIZE_WHITESPACE\n    There were field errors:\n    ('name', u'Name', RequiredMissing('name'))\n    ('max_size', u'Maximum size', RequiredMissing('max_size'))\n    <input class=\"textType\" id=\"form.name\" name=\"form.name\" size=\"20\"\n           type=\"text\" value=\"\"  />\n    <span class=\"error\">Required input is missing.</span>\n    <input class=\"textType\" id=\"form.min_size\" name=\"form.min_size\" size=\"10\"\n           type=\"text\" value=\"42.0\"  />\n    <input class=\"textType\" id=\"form.max_size\" name=\"form.max_size\" size=\"10\"\n           type=\"text\" value=\"\"  />\n    <span class=\"error\">Required input is missing.</span>\n    {'min_size': 42.0}\n\n\nEdit Forms\n==========\n\nA common application of forms is edit forms.  Edit forms are special\nin 2 ways:\n\n- We want to get the initial data for widgets from the object being\n  edited.\n\n- If there are no errors, we want to apply the changes back to the\n  object being edited.\n\nThe form package provides some functions to assist with creating edit\nforms.  When we set up our form_fields, we use the `render_context`\noption, which uses data from the context passed to setUpWidgets.\nLet's create a content class that provides `IOrder` and a simple form\nthat uses it:\n\n    >>> import datetime\n    >>> @interface.implementer(IOrder)\n    ... class Order:\n    ...\n    ...     def __init__(self, identifier):\n    ...         self.identifier = identifier\n    ...         self.name = 'unknown'\n    ...         self.min_size = 0.0\n    ...         self.max_size = 0.0\n    ...\n    ...     now = property(lambda self: datetime.datetime.now())\n\n    >>> order = Order(1)\n\n    >>> class MyForm:\n    ...     form_fields = form.Fields(\n    ...                  IOrder, omit_readonly=True, render_context=True)\n    ...\n    ...     def __init__(self, context, request):\n    ...         self.context, self.request = context, request\n    ...\n    ...     def __call__(self, ignore_request=False):\n    ...         widgets = form.setUpWidgets(\n    ...             self.form_fields, 'form', self.context, self.request,\n    ...             ignore_request=ignore_request)\n    ...\n    ...         return '\\n'.join([w() for w in widgets])\n\n    >>> print(MyForm(order, request)()) # doctest: +NORMALIZE_WHITESPACE\n    <input class=\"textType\" id=\"form.name\" name=\"form.name\" size=\"20\"\n           type=\"text\" value=\"\" />\n    <input class=\"textType\" id=\"form.min_size\" name=\"form.min_size\" size=\"10\"\n           type=\"text\" value=\"42.0\" />\n    <input class=\"textType\" id=\"form.max_size\" name=\"form.max_size\" size=\"10\"\n           type=\"text\" value=\"\" />\n\nNote that, in this case, we got the values from the request, because\nwe used an old request.  If we want to redraw the form after processing a\nrequest, it is safest to pass ignore_request = True to setUpWidgets so that\nthe form is redrawn with the values as found in the object, not on the request.\n\n    >>> print(MyForm(order, request)(ignore_request=True))\n    ... # doctest: +NORMALIZE_WHITESPACE\n    <input class=\"textType\" id=\"form.name\" name=\"form.name\" size=\"20\"\n           type=\"text\" value=\"unknown\"  />\n    <input class=\"textType\" id=\"form.min_size\" name=\"form.min_size\" size=\"10\"\n           type=\"text\" value=\"0.0\"  />\n    <input class=\"textType\" id=\"form.max_size\" name=\"form.max_size\" size=\"10\"\n           type=\"text\" value=\"0.0\"  />\n\nIf we use a new request, we will of course get the same result:\n\n    >>> request = TestRequest()\n    >>> print(MyForm(order, request)()) # doctest: +NORMALIZE_WHITESPACE\n    <input class=\"textType\" id=\"form.name\" name=\"form.name\" size=\"20\"\n           type=\"text\" value=\"unknown\"  />\n    <input class=\"textType\" id=\"form.min_size\" name=\"form.min_size\" size=\"10\"\n           type=\"text\" value=\"0.0\"  />\n    <input class=\"textType\" id=\"form.max_size\" name=\"form.max_size\" size=\"10\"\n           type=\"text\" value=\"0.0\"  />\n\nIf we include read-only fields in an edit form, they will get display widgets:\n\n    >>> class MyForm:\n    ...     form_fields = form.Fields(IOrder, render_context=True)\n    ...     form_fields = form_fields.omit('now')\n    ...\n    ...     def __init__(self, context, request):\n    ...         self.context, self.request = context, request\n    ...\n    ...     def __call__(self):\n    ...         widgets = form.setUpWidgets(\n    ...             self.form_fields, 'form', self.context, self.request)\n    ...\n    ...         return '\\n'.join([w() for w in widgets])\n\n    >>> print(MyForm(order, request)()) # doctest: +NORMALIZE_WHITESPACE\n    1\n    <input class=\"textType\" id=\"form.name\" name=\"form.name\" size=\"20\"\n           type=\"text\" value=\"unknown\"  />\n    <input class=\"textType\" id=\"form.min_size\" name=\"form.min_size\" size=\"10\"\n           type=\"text\" value=\"0.0\"  />\n    <input class=\"textType\" id=\"form.max_size\" name=\"form.max_size\" size=\"10\"\n           type=\"text\" value=\"0.0\"  />\n\nWhen the form is submitted, we need to apply the changes back to the\nobject. We can use the `applyChanges` function for that:\n\n    >>> class MyForm:\n    ...     form_fields = form.Fields(IOrder, render_context=True)\n    ...     form_fields = form_fields.omit('now')\n    ...\n    ...     def __init__(self, context, request):\n    ...         self.context, self.request = context, request\n    ...\n    ...     def __call__(self):\n    ...         widgets = form.setUpWidgets(\n    ...             self.form_fields, 'form', self.context, self.request)\n    ...\n    ...         if 'submit' in self.request:\n    ...             data = {}\n    ...             errors = form.getWidgetsData(widgets, 'form', data)\n    ...             invariant_errors = form.checkInvariants(\n    ...                 self.form_fields, data, self.context)\n    ...             if errors:\n    ...                 print('There were field errors:')\n    ...                 for error in errors:\n    ...                     print(error)\n    ...\n    ...             if invariant_errors:\n    ...                 print('There were invariant errors:')\n    ...                 for error in invariant_errors:\n    ...                     print(error)\n    ...\n    ...             if not errors and not invariant_errors:\n    ...                 changed = form.applyChanges(\n    ...                     self.context, self.form_fields, data)\n    ...\n    ...         else:\n    ...             data = changed = None\n    ...\n    ...         for w in widgets:\n    ...             print(w())\n    ...             error = w.error()\n    ...             if error:\n    ...                 print(error)\n    ...\n    ...         if changed:\n    ...             print('Object updated')\n    ...         else:\n    ...             print('No changes')\n    ...\n    ...         return data\n\nNow, if we submit the form with some data:\n\n    >>> request.form['form.name'] = u'bob'\n    >>> request.form['form.min_size'] = u'42'\n    >>> request.form['form.max_size'] = u'142'\n    >>> request.form['submit'] = u''\n    >>> pprint(MyForm(order, request)(), width=1)\n    ... # doctest: +NORMALIZE_WHITESPACE\n    1\n    <input class=\"textType\" id=\"form.name\" name=\"form.name\" size=\"20\"\n           type=\"text\" value=\"bob\"  />\n    <input class=\"textType\" id=\"form.min_size\" name=\"form.min_size\" size=\"10\"\n           type=\"text\" value=\"42.0\"  />\n    <input class=\"textType\" id=\"form.max_size\" name=\"form.max_size\" size=\"10\"\n           type=\"text\" value=\"142.0\"  />\n    Object updated\n    {'max_size': 142.0,\n     'min_size': 42.0,\n     'name': u'bob'}\n\n    >>> order.name\n    u'bob'\n\n    >>> order.max_size\n    142.0\n\n    >>> order.min_size\n    42.0\n\nNote, however, that if we submit the same request, we'll see that no\nchanges were applied:\n\n    >>> pprint(MyForm(order, request)(), width=1)\n    ... # doctest: +NORMALIZE_WHITESPACE\n    1\n    <input class=\"textType\" id=\"form.name\" name=\"form.name\" size=\"20\"\n           type=\"text\" value=\"bob\"  />\n    <input class=\"textType\" id=\"form.min_size\" name=\"form.min_size\" size=\"10\"\n           type=\"text\" value=\"42.0\"  />\n    <input class=\"textType\" id=\"form.max_size\" name=\"form.max_size\" size=\"10\"\n           type=\"text\" value=\"142.0\"  />\n    No changes\n    {'max_size': 142.0,\n     'min_size': 42.0,\n     'name': u'bob'}\n\nbecause the new and old values are the same.\n\nThe code we included in `MyForm` above is generic: it applies to any\nedit form.\n\nActions\n=======\n\nOur commit logic is a little complicated.  It would be far more\ncomplicated if there were multiple submit buttons.\n\nWe can use action objects to provide some distribution of application logic.\n\nAn action is an object that represents a handler for a submit button.\n\nIn the most common case, an action accepts a label and zero or more options\nprovided as keyword parameters:\n\ncondition\n  A callable or name of a method to call to test whether the action is\n  applicable.  if the value is a method name, then the method will be\n  passed the action when called, otherwise, the callable will be\n  passed the form and the action.\n\nvalidator\n  A callable or name of a method to call to validate and collect\n  inputs.  This is called only if the action was submitted and if the\n  action either has no condition, or the condition evaluates to a true\n  value.  If the validator is provided as a method name, the method\n  will be called with the action and a dictionary in which to save data.\n  If the validator is provided as a callable, the callable will be\n  called with the form, the action, and a dictionary in which to save data.\n  The validator normally returns a (usually empty) list of widget\n  input errors.  It may also return None to behave as if the action\n  wasn't submitted.\n\nsuccess\n  A handler, called when the the action was submitted and there are no\n  validation errors.  The handler may be provided as either a callable\n  or a method name.  If the handler is provided as a method name, the\n  method will be called with the action and a dictionary containing the\n  form data.  If the success handler is provided as a callable, the\n  callable will be called with the form, the action, and a dictionary\n  containing the data.  The handler may return a form result\n  (e.g. page), or may return None to indicate that the form should\n  generate it's own output.\n\nfailure\n  A handler, called when the the action was submitted and there are\n  validation errors.  The handler may be provided as either a callable\n  or a method name.  If the handler is provided as a method name, the\n  method will be called with the action, a dictionary containing the form\n  data, and a list of errors.  If the failure handler is provided as a\n  callable, the callable will be called with the form, the action, a\n  dictionary containing the data, and a list of errors.  The handler\n  may return a form result (e.g. page), or may return None to indicate\n  that the form should generate it's own output.\n\nprefix\n  A form prefix for the action.  When generating submit actions, the\n  prefix should be combined with the action name, separating the two\n  with a dot. The default prefix is \"actions\"form.\n\nname\n  The action name, without a prefix.  If the label is a valid Python\n  identifier, then the lower-case label will be used, otherwise, a hex encoding\n  of the label will be used.  If for some strange reason the labels in\n  a set of actions with the same prefix is not unique, a name will\n  have to be given for some actions to get unique names.\n\ndata\n  A bag of extra information that can be used by handlers, validators,\n  or conditions.\n\nLet's update our edit form to use an action. We are also going to\nrearrange our form quite a bit to make things more modular:\n\n- We've created a separate `validation` method to validate inputs and\n  compute errors.\n\n- We've created a `handle_edit_action` method for applying changes.\n\n- We've created a template method for displaying the form.\n  Normally, this would be a ZPT template, but we just provide a Python\n  version here.\n\n- We've created a call method that is described below\n\n- We've defined a number of instance attributes for passing\n  information between the various methods:\n\n  - `status` is a string that, if set, is displayed at the top of the\n    form.\n\n  - `errors` is the set of errors found when validating.\n\n  - `widgets` is a list of set-up widgets\n\nHere's the new version:\n\n    >>> class MyForm:\n    ...     form_fields = form.Fields(IOrder, render_context=True)\n    ...     form_fields = form_fields.omit('now')\n    ...\n    ...     status = errors = None\n    ...     prefix = 'form'\n    ...\n    ...     actions = form.Actions(\n    ...         form.Action('Edit', success='handle_edit_action'),\n    ...         )\n    ...\n    ...     def __init__(self, context, request):\n    ...         self.context, self.request = context, request\n    ...\n    ...     def validate(self, action, data):\n    ...         return (form.getWidgetsData(self.widgets, self.prefix, data) +\n    ...                 form.checkInvariants(\n    ...                     self.form_fields, data, self.context))\n    ...\n    ...     def handle_edit_action(self, action, data):\n    ...         if form.applyChanges(self.context, self.form_fields, data):\n    ...             self.status = 'Object updated'\n    ...         else:\n    ...             self.status = 'No changes'\n    ...\n    ...     def template(self):\n    ...         if self.status:\n    ...             print(self.status)\n    ...\n    ...         result = []\n    ...\n    ...         if self.errors:\n    ...             result.append('There were errors:')\n    ...             for error in self.errors:\n    ...                 result.append(str(error))\n    ...\n    ...         for w in self.widgets:\n    ...             result.append(w())\n    ...             error = w.error()\n    ...             if error:\n    ...                 result.append(str(error))\n    ...\n    ...         for action in self.actions:\n    ...             result.append(action.render())\n    ...\n    ...         return '\\n'.join(result)\n    ...\n    ...     def __call__(self):\n    ...         self.widgets = form.setUpWidgets(\n    ...             self.form_fields, self.prefix, self.context, self.request)\n    ...\n    ...         data = {}\n    ...         errors, action = form.handleSubmit(\n    ...                              self.actions, data, self.validate)\n    ...         self.errors = errors\n    ...\n    ...         if errors:\n    ...             result = action.failure(data, errors)\n    ...         elif errors is not None:\n    ...             result = action.success(data)\n    ...         else:\n    ...             result = None\n    ...\n    ...         if result is None:\n    ...             result = self.template()\n    ...\n    ...         return result\n\nLets walk through the `__call__` method.\n\n- We set up our widgets as before.\n\n- We use `form.handleSubmit` to validate our data.  We pass the form,\n  actions, prefix, and `validate` method.  For each action,\n  `form.handleSubmit` checks to see if the action was submitted.  If the\n  action was submitted, it checks to see if it has a validator.  If\n  the action has a validator, the action's validator is called,\n  otherwise the validator passed is called.  The validator result (a\n  list of widget input errors) and the action are returned.  If no\n  action was submitted, then `None` is returned for the errors and the\n  action.\n\n- If a action was submitted and there were no errors, we call the\n  success method on the action.  If the action has a handler defined,\n  it will be called and the return value is returned, otherwise None\n  is returned.  A return value of None indicates that the form should\n  generate it's own result.\n\n- If a action was submitted but there were errors, we call the\n  action's failure method.  If the action has a failure handler\n  defined, it will be called and the return value is returned,\n  otherwise None is returned.  A return value of None indicates that\n  the form should generate it's own result.\n\n- No action was submitted, the result is set to None.\n\n- If we don't have a result, we generate one with our template.\n\nLet's try the new version of our form:\n\n    >>> print(MyForm(order, request)()) # doctest: +NORMALIZE_WHITESPACE\n    1\n    <input class=\"textType\" id=\"form.name\" name=\"form.name\" size=\"20\"\n           type=\"text\" value=\"bob\"  />\n    <input class=\"textType\" id=\"form.min_size\" name=\"form.min_size\" size=\"10\"\n           type=\"text\" value=\"42.0\"  />\n    <input class=\"textType\" id=\"form.max_size\" name=\"form.max_size\" size=\"10\"\n           type=\"text\" value=\"142.0\"  />\n    <input type=\"submit\" id=\"form.actions.edit\" name=\"form.actions.edit\"\n           value=\"Edit\" class=\"button\" />\n\nIn this case, we didn't get any output about changes because the\nrequest form data didn't include a submit action that matched our\naction definition. Let's add one and try again:\n\n    >>> request.form['form.actions.edit'] = u''\n    >>> print(MyForm(order, request)()) # doctest: +NORMALIZE_WHITESPACE\n    No changes\n    1\n    <input class=\"textType\" id=\"form.name\" name=\"form.name\" size=\"20\"\n           type=\"text\" value=\"bob\"  />\n    <input class=\"textType\" id=\"form.min_size\" name=\"form.min_size\" size=\"10\"\n           type=\"text\" value=\"42.0\"  />\n    <input class=\"textType\" id=\"form.max_size\" name=\"form.max_size\" size=\"10\"\n           type=\"text\" value=\"142.0\"  />\n    <input type=\"submit\" id=\"form.actions.edit\" name=\"form.actions.edit\"\n           value=\"Edit\" class=\"button\" />\n\nThis time, we got a status message indicating that there weren't any\nchanges.\n\nLet's try changing some data:\n\n    >>> request.form['form.max_size'] = u'10/0'\n    >>> print(MyForm(order, request)())\n    ... # doctest: +NORMALIZE_WHITESPACE\n    There were errors:\n    (u'Invalid floating point data',...ValueError...)\n    1\n    <input class=\"textType\" id=\"form.name\" name=\"form.name\" size=\"20\"\n           type=\"text\" value=\"bob\"  />\n    <input class=\"textType\" id=\"form.min_size\" name=\"form.min_size\" size=\"10\"\n           type=\"text\" value=\"42.0\"  />\n    <input class=\"textType\" id=\"form.max_size\" name=\"form.max_size\" size=\"10\"\n           type=\"text\" value=\"10/0\"  />\n    <span class=\"error\">Invalid floating point data</span>\n    <input type=\"submit\" id=\"form.actions.edit\" name=\"form.actions.edit\"\n           value=\"Edit\" class=\"button\" />\n\nOops, we had a typo, let's fix it:\n\n    >>> request.form['form.max_size'] = u'10.0'\n    >>> print(MyForm(order, request)()) # doctest: +NORMALIZE_WHITESPACE\n    There were errors:\n    Maximum is less than Minimum\n    1\n    <input class=\"textType\" id=\"form.name\" name=\"form.name\" size=\"20\"\n           type=\"text\" value=\"bob\"  />\n    <input class=\"textType\" id=\"form.min_size\" name=\"form.min_size\" size=\"10\"\n           type=\"text\" value=\"42.0\"  />\n    <input class=\"textType\" id=\"form.max_size\" name=\"form.max_size\" size=\"10\"\n           type=\"text\" value=\"10.0\"  />\n    <input type=\"submit\" id=\"form.actions.edit\" name=\"form.actions.edit\"\n           value=\"Edit\" class=\"button\" />\n\nOh yeah, we need to reduce the minimum too: :)\n\n    >>> request.form['form.min_size'] = u'1.0'\n    >>> print(MyForm(order, request)()) # doctest: +NORMALIZE_WHITESPACE\n    Object updated\n    1\n    <input class=\"textType\" id=\"form.name\" name=\"form.name\" size=\"20\"\n           type=\"text\" value=\"bob\"  />\n    <input class=\"textType\" id=\"form.min_size\" name=\"form.min_size\" size=\"10\"\n           type=\"text\" value=\"1.0\"  />\n    <input class=\"textType\" id=\"form.max_size\" name=\"form.max_size\" size=\"10\"\n           type=\"text\" value=\"10.0\"  />\n    <input type=\"submit\" id=\"form.actions.edit\" name=\"form.actions.edit\"\n           value=\"Edit\" class=\"button\" />\n\nAh, much better.  And our order has been updated:\n\n    >>> order.max_size\n    10.0\n\n    >>> order.min_size\n    1.0\n\nHelpful base classes\n====================\n\nOur form has a lot of repetitive code. A number of helpful base\nclasses provide standard form implementation.\n\nForm\n----\n\nThe `Form` base class provides a number of common attribute definitions.\nIt provides:\n\n`__init__`\n  A constructor\n\n`validate`\n  A default validation method\n\n`__call__`\n  To render the form\n\n`template`\n  A default template.  Note that this is a NamedTemplate named \"default\",\n  so the template may also be overridden by registering an alternate\n  default template.\n\n`prefix`\n  A string added to all widget and action names.\n\n`setPrefix`\n  method for changing the prefix\n\n`availableActions`\n  method for getting available actions\n\n`adapters`\n  Dictionary of objects implementing each given schema\n\nSubclasses need to:\n\n- Provide a form_fields variable containing a list of form fields\n\n- a actions attribute containing a list of action definitions\n\nSubclasses may:\n\n- Provide a label function or message id to produce\n  a form label.\n\n- Override the setUpWidgets method to control how widgets are\n  set up.  This is fairly rarely needed.\n\n- Override the template.  The form defines variables:\n\n  status\n     providing a short summary of the operation performed.\n\n  widgets\n     A collection of widgets, which can be accessed through iteration\n     or by name\n\n  errors\n     A (possibly empty) list of errors\n\n\nLet's update our example to use the base class:\n\n    >>> class MyForm(form.Form):\n    ...     form_fields = form.Fields(IOrder, render_context=True)\n    ...     form_fields = form_fields.omit('now')\n    ...\n    ...     @form.action(\"Edit\", failure='handle_edit_action_failure')\n    ...     def handle_edit_action(self, action, data):\n    ...         if form.applyChanges(self.context, self.form_fields, data):\n    ...             self.status = 'Object updated'\n    ...         else:\n    ...             self.status = 'No changes'\n    ...\n    ...     def handle_edit_action_failure(self, action, data, errors):\n    ...         self.status = 'There were %d errors.' % len(errors)\n\nWe inherited most of our behavior from the base class.\n\nWe also used the `action` decorator.  The action decorator:\n\n- creates an `actions` variable if one isn't already created,\n\n- defines an action with the given label and any other arguments, and\n\n- appends the action to the `actions` list.\n\nThe `action` decorator accepts the same arguments as the `Action`\nclass with the exception of the `success` option.\n\nThe creation of the `actions` is a bit magic, but provides\nsimplification in common cases.\n\nNow we can try out our form:\n\n    >>> print(MyForm(order, request)()) # doctest: +NORMALIZE_WHITESPACE\n    No changes\n    1\n    <input class=\"textType\" id=\"form.name\" name=\"form.name\" size=\"20\"\n           type=\"text\" value=\"bob\"  />\n    <input class=\"textType\" id=\"form.min_size\" name=\"form.min_size\" size=\"10\"\n           type=\"text\" value=\"1.0\"  />\n    <input class=\"textType\" id=\"form.max_size\" name=\"form.max_size\" size=\"10\"\n           type=\"text\" value=\"10.0\"  />\n    <input type=\"submit\" id=\"form.actions.edit\" name=\"form.actions.edit\"\n           value=\"Edit\" class=\"button\" />\n\n    >>> request.form['form.min_size'] = u'20.0'\n    >>> print(MyForm(order, request)()) # doctest: +NORMALIZE_WHITESPACE\n    There were 1 errors.\n    Invalid: Maximum is less than Minimum\n    1\n    <input class=\"textType\" id=\"form.name\" name=\"form.name\" size=\"20\"\n           type=\"text\" value=\"bob\"  />\n    <input class=\"textType\" id=\"form.min_size\" name=\"form.min_size\" size=\"10\"\n           type=\"text\" value=\"20.0\"  />\n    <input class=\"textType\" id=\"form.max_size\" name=\"form.max_size\" size=\"10\"\n           type=\"text\" value=\"10.0\"  />\n    <input type=\"submit\" id=\"form.actions.edit\" name=\"form.actions.edit\"\n           value=\"Edit\" class=\"button\" />\n\n    >>> request.form['form.max_size'] = u'30.0'\n    >>> print(MyForm(order, request)()) # doctest: +NORMALIZE_WHITESPACE\n    Object updated\n    1\n    <input class=\"textType\" id=\"form.name\" name=\"form.name\" size=\"20\"\n           type=\"text\" value=\"bob\"  />\n    <input class=\"textType\" id=\"form.min_size\" name=\"form.min_size\" size=\"10\"\n           type=\"text\" value=\"20.0\"  />\n    <input class=\"textType\" id=\"form.max_size\" name=\"form.max_size\" size=\"10\"\n           type=\"text\" value=\"30.0\"  />\n    <input type=\"submit\" id=\"form.actions.edit\" name=\"form.actions.edit\"\n           value=\"Edit\" class=\"button\" />\n\n    >>> order.max_size\n    30.0\n\n    >>> order.min_size\n    20.0\n\nEditForm\n--------\n\nOur `handle_edit_action` action is common to edit forms.  An\n`EditForm` base class captures this commonality.  It also sets up\nwidget widgets a bit differently.  The `EditForm` base class sets up\nwidgets as if the form fields had been set up with the `render_context`\noption.\n\n    >>> class MyForm(form.EditForm):\n    ...     form_fields = form.Fields(IOrder)\n    ...     form_fields = form_fields.omit('now')\n\n    >>> request.form['form.actions.apply'] = u''\n    >>> print(MyForm(order, request)()) # doctest: +NORMALIZE_WHITESPACE\n    No changes\n    1\n    <input class=\"textType\" id=\"form.name\" name=\"form.name\" size=\"20\"\n           type=\"text\" value=\"bob\"  />\n    <input class=\"textType\" id=\"form.min_size\" name=\"form.min_size\" size=\"10\"\n           type=\"text\" value=\"20.0\"  />\n    <input class=\"textType\" id=\"form.max_size\" name=\"form.max_size\" size=\"10\"\n           type=\"text\" value=\"30.0\"  />\n    <input type=\"submit\" id=\"form.actions.apply\" name=\"form.actions.apply\"\n           value=\"Apply\" class=\"button\" />\n\n    >>> request.form['form.min_size'] = u'40.0'\n    >>> print(MyForm(order, request)()) # doctest: +NORMALIZE_WHITESPACE\n    There were errors\n    Invalid: Maximum is less than Minimum\n    1\n    <input class=\"textType\" id=\"form.name\" name=\"form.name\" size=\"20\"\n           type=\"text\" value=\"bob\"  />\n    <input class=\"textType\" id=\"form.min_size\" name=\"form.min_size\" size=\"10\"\n           type=\"text\" value=\"40.0\"  />\n    <input class=\"textType\" id=\"form.max_size\" name=\"form.max_size\" size=\"10\"\n           type=\"text\" value=\"30.0\"  />\n    <input type=\"submit\" id=\"form.actions.apply\" name=\"form.actions.apply\"\n           value=\"Apply\" class=\"button\" />\n\n    >>> request.form['form.max_size'] = u'50.0'\n    >>> print(MyForm(order, request)())\n    ... # doctest: +NORMALIZE_WHITESPACE +ELLIPSIS\n    Updated on ... ... ...  ...:...:...\n    1\n    <input class=\"textType\" id=\"form.name\" name=\"form.name\" size=\"20\"\n           type=\"text\" value=\"bob\"  />\n    <input class=\"textType\" id=\"form.min_size\" name=\"form.min_size\" size=\"10\"\n           type=\"text\" value=\"40.0\"  />\n    <input class=\"textType\" id=\"form.max_size\" name=\"form.max_size\" size=\"10\"\n           type=\"text\" value=\"50.0\"  />\n    <input type=\"submit\" id=\"form.actions.apply\" name=\"form.actions.apply\"\n           value=\"Apply\" class=\"button\" />\n\n    >>> order.max_size\n    50.0\n\n    >>> order.min_size\n    40.0\n\nNote that `EditForm` shows the date and time when content are\nmodified.\n\nMultiple Schemas and Adapters\n=============================\n\nForms can use fields from multiple schemas.  This can be done in a\nnumber of ways.  For example, multiple schemas can be passed to\n`form.Fields`:\n\n    >>> class IDescriptive(interface.Interface):\n    ...     title = schema.TextLine(title=u\"Title\")\n    ...     description = schema.TextLine(title=u\"Description\")\n\n    >>> class MyForm(form.EditForm):\n    ...     form_fields = form.Fields(IOrder, IDescriptive)\n    ...     form_fields = form_fields.omit('now')\n\nIn addition, if the the object being edited doesn't provide any of the\nschemas, it will be adapted to the schemas it doesn't provide.\n\nSuppose we have a generic adapter for storing descriptive information\non objects:\n\n    >>> from zope import component\n    >>> @component.adapter(interface.Interface)\n    ... @interface.implementer(IDescriptive)\n    ... class Descriptive(object):\n    ...     def __init__(self, context):\n    ...         self.context = context\n    ...\n    ...     def title():\n    ...         def get(self):\n    ...             try:\n    ...                 return self.context.__title\n    ...             except AttributeError:\n    ...                 return ''\n    ...         def set(self, v):\n    ...             self.context.__title = v\n    ...         return property(get, set)\n    ...     title = title()\n    ...\n    ...     def description():\n    ...         def get(self):\n    ...             try:\n    ...                 return self.context.__description\n    ...             except AttributeError:\n    ...                 return ''\n    ...         def set(self, v):\n    ...             self.context.__description = v\n    ...         return property(get, set)\n    ...     description = description()\n\n    >>> component.provideAdapter(Descriptive)\n\nNow, we can use a single form to edit both the regular order data and\nthe descriptive data:\n\n    >>> request = TestRequest()\n    >>> print(MyForm(order, request)()) # doctest: +NORMALIZE_WHITESPACE\n    1\n    <input class=\"textType\" id=\"form.name\" name=\"form.name\" size=\"20\"\n           type=\"text\" value=\"bob\"  />\n    <input class=\"textType\" id=\"form.min_size\" name=\"form.min_size\" size=\"10\"\n           type=\"text\" value=\"40.0\"  />\n    <input class=\"textType\" id=\"form.max_size\" name=\"form.max_size\" size=\"10\"\n           type=\"text\" value=\"50.0\"  />\n    <input class=\"textType\" id=\"form.title\" name=\"form.title\" size=\"20\"\n           type=\"text\" value=\"\"  />\n    <input class=\"textType\" id=\"form.description\" name=\"form.description\"\n           size=\"20\"\n           type=\"text\" value=\"\"  />\n    <input type=\"submit\" id=\"form.actions.apply\" name=\"form.actions.apply\"\n           value=\"Apply\" class=\"button\" />\n\n    >>> request.form['form.name'] = u'bob'\n    >>> request.form['form.min_size'] = u'10.0'\n    >>> request.form['form.max_size'] = u'20.0'\n    >>> request.form['form.title'] = u'Widgets'\n    >>> request.form['form.description'] = u'Need more widgets'\n    >>> request.form['form.actions.apply'] = u''\n    >>> myform = MyForm(order, request)\n    >>> print(myform())\n    ... # doctest: +NORMALIZE_WHITESPACE +ELLIPSIS\n    Updated on ... ... ...  ...:...:...\n    1\n    <input class=\"textType\" id=\"form.name\" name=\"form.name\" size=\"20\"\n           type=\"text\" value=\"bob\"  />\n    <input class=\"textType\" id=\"form.min_size\" name=\"form.min_size\" size=\"10\"\n           type=\"text\" value=\"10.0\"  />\n    <input class=\"textType\" id=\"form.max_size\" name=\"form.max_size\" size=\"10\"\n           type=\"text\" value=\"20.0\"  />\n    <input class=\"textType\" id=\"form.title\" name=\"form.title\" size=\"20\"\n           type=\"text\" value=\"Widgets\"  />\n    <input class=\"textType\" id=\"form.description\" name=\"form.description\"\n           size=\"20\"\n           type=\"text\" value=\"Need more widgets\"  />\n    <input type=\"submit\" id=\"form.actions.apply\" name=\"form.actions.apply\"\n           value=\"Apply\" class=\"button\" />\n\n    >>> order.min_size\n    10.0\n\n    >>> order.title #doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n    ...\n    AttributeError: Order instance has no attribute 'title'\n\n    >>> Descriptive(order).title\n    u'Widgets'\n\nOften, we'd like to get at the adapters used.  If `EditForm` is used,\nthe adapters are available in the adapters attribute, which is a\ndictionary that allows adapters to be looked up by by schema or schema\nname:\n\n    >>> myform.adapters[IOrder].__class__.__name__\n    'Order'\n\n    >>> myform.adapters['IOrder'].__class__.__name__\n    'Order'\n\n    >>> myform.adapters[IDescriptive].__class__.__name__\n    'Descriptive'\n\n    >>> myform.adapters['IDescriptive'].__class__.__name__\n    'Descriptive'\n\nIf you aren't using `EditForm`, you can get a dictionary populated in\nthe same way by `setUpWidgets` by passing the dictionary as an\n`adapters` keyword argument.\n\n\nNamed Widget Access\n===================\n\nThe value returned from `setUpWidgets` supports named-based lookup as well as\niteration:\n\n    >>> myform.widgets['name'].__class__.__name__\n    'TextWidget'\n\n    >>> myform.widgets['name'].name\n    'form.name'\n\n    >>> myform.widgets['title'].__class__.__name__\n    'TextWidget'\n\n    >>> myform.widgets['title'].name\n    'form.title'\n\nForm-field manipulations\n========================\n\nThe form-field constructor is very flexible.  We've already seen that\nwe can supply multiple schemas.  Here are some other things you can\ndo.\n\nSpecifying individual fields\n----------------------------\n\nYou can specify individual fields for a form.  Here, we'll create a\nform that collects just the name from `IOrder` and the title from\n`IDescriptive`:\n\n    >>> class MyForm(form.EditForm):\n    ...     form_fields = form.Fields(IOrder['name'],\n    ...                               IDescriptive['title'])\n    ...     actions = ()\n\n    >>> print(MyForm(order, TestRequest())()) # doctest: +NORMALIZE_WHITESPACE\n    <input class=\"textType\" id=\"form.name\" name=\"form.name\" size=\"20\"\n           type=\"text\" value=\"bob\"  />\n    <input class=\"textType\" id=\"form.title\" name=\"form.title\" size=\"20\"\n           type=\"text\" value=\"Widgets\"  />\n\nYou can also use stand-alone fields:\n\n    >>> class MyForm(form.EditForm):\n    ...     form_fields = form.Fields(\n    ...         schema.TextLine(__name__='name', title=u\"Who?\"),\n    ...         IDescriptive['title'],\n    ...         )\n    ...     actions = ()\n\n    >>> print(MyForm(order, TestRequest())()) # doctest: +NORMALIZE_WHITESPACE\n    <input class=\"textType\" id=\"form.name\" name=\"form.name\" size=\"20\"\n           type=\"text\" value=\"bob\"  />\n    <input class=\"textType\" id=\"form.title\" name=\"form.title\" size=\"20\"\n           type=\"text\" value=\"Widgets\"  />\n\nBut make sure the fields have a '__name__', as was done above.\n\nConcatenating field collections\n-------------------------------\n\nIt is sometimes convenient to combine multiple field collections.\nField collections support concatenation. For example, we may want to\ncombine field definitions:\n\n    >>> class MyExpandedForm(form.Form):\n    ...     form_fields = (\n    ...         MyForm.form_fields\n    ...         +\n    ...         form.Fields(IDescriptive['description'])\n    ...         )\n    ...     actions = ()\n\n    >>> print(MyExpandedForm(order, TestRequest())())\n    ... # doctest: +NORMALIZE_WHITESPACE\n    <input class=\"textType\" id=\"form.name\" name=\"form.name\"\n           size=\"20\" type=\"text\" value=\"\"  />\n    <input class=\"textType\" id=\"form.title\" name=\"form.title\"\n           size=\"20\" type=\"text\" value=\"\"  />\n    <input class=\"textType\" id=\"form.description\" name=\"form.description\"\n           size=\"20\" type=\"text\" value=\"\"  />\n\nUsing fields for display\n------------------------\n\nNormally, any writable fields get input widgets.  We may want to\nindicate that some fields should be used for display only. We can do\nthis using the `for_display` option when setting up form_fields:\n\n    >>> class MyForm(form.EditForm):\n    ...     form_fields = (\n    ...         form.Fields(IOrder, for_display=True).select('name')\n    ...         +\n    ...         form.Fields(IOrder).select('min_size', 'max_size')\n    ...         )\n\n\n    >>> print(MyForm(order, TestRequest())()) # doctest: +NORMALIZE_WHITESPACE\n    bob\n    <input class=\"textType\" id=\"form.min_size\" name=\"form.min_size\"\n           size=\"10\" type=\"text\" value=\"10.0\"  />\n    <input class=\"textType\" id=\"form.max_size\" name=\"form.max_size\"\n           size=\"10\" type=\"text\" value=\"20.0\"  />\n    <input type=\"submit\" id=\"form.actions.apply\" name=\"form.actions.apply\"\n           value=\"Apply\" class=\"button\" />\n\nNote that if all of the fields in an edit form are for display:\n\n    >>> class MyForm(form.EditForm):\n    ...     form_fields = form.Fields(IOrder, for_display=True\n    ...                               ).select('name', 'min_size', 'max_size')\n\n    >>> print(MyForm(order, TestRequest())()) # doctest: +NORMALIZE_WHITESPACE\n    bob\n    10.0\n    20.0\n\nwe don't get an edit action.  This is because the edit action defined\nby `EditForm` has a condition to prevent it's use when there are no\ninput widgets. Check it out for an example of using action conditions.\n\nUsing fields for input\n----------------------\n\nWe may want to indicate that some fields should be used for input even\nif the underlying schema field is read-only. We can do this using the\n`for_input` option when setting up form_fields:\n\n    >>> class MyForm(form.Form):\n    ...     form_fields = form.Fields(IOrder, for_input=True,\n    ...                                   render_context=True)\n    ...     form_fields = form_fields.omit('now')\n    ...\n    ...     actions = ()\n\n\n    >>> print(MyForm(order, TestRequest())()) # doctest: +NORMALIZE_WHITESPACE\n    <input class=\"textType\" id=\"form.identifier\" name=\"form.identifier\"\n           size=\"10\" type=\"text\" value=\"1\"  />\n    <input class=\"textType\" id=\"form.name\" name=\"form.name\"\n           size=\"20\" type=\"text\" value=\"bob\"  />\n    <input class=\"textType\" id=\"form.min_size\" name=\"form.min_size\"\n           size=\"10\" type=\"text\" value=\"10.0\"  />\n    <input class=\"textType\" id=\"form.max_size\" name=\"form.max_size\"\n           size=\"10\" type=\"text\" value=\"20.0\"  />\n\nDisplaying or editing raw data\n==============================\n\nSometimes, you want to display or edit data that doesn't come from an\nobject.  One way to do this is to pass the data to setUpWidgets.\n\nLets look at an example:\n\n    >>> class MyForm(form.Form):\n    ...\n    ...     form_fields = form.Fields(IOrder)\n    ...     form_fields = form_fields.omit('now')\n    ...\n    ...     actions = ()\n    ...\n    ...     def setUpWidgets(self, ignore_request=False):\n    ...         self.widgets = form.setUpWidgets(\n    ...             self.form_fields, self.prefix, self.context, self.request,\n    ...             data=dict(identifier=42, name=u'sally'),\n    ...             ignore_request=ignore_request\n    ...             )\n\nIn this case, we supplied initial data for the identifier and the\nname.  Now if we display the form, we'll see our data and defaults for\nthe fields we didn't supply data for:\n\n    >>> print(MyForm(None, TestRequest())()) # doctest: +NORMALIZE_WHITESPACE\n    42\n    <input class=\"textType\" id=\"form.name\" name=\"form.name\"\n           size=\"20\" type=\"text\" value=\"sally\"  />\n    <input class=\"textType\" id=\"form.min_size\" name=\"form.min_size\"\n           size=\"10\" type=\"text\" value=\"\"  />\n    <input class=\"textType\" id=\"form.max_size\" name=\"form.max_size\"\n           size=\"10\" type=\"text\" value=\"\"  />\n\nIf data are passed in the request, they override initial data for\ninput fields:\n\n    >>> request = TestRequest()\n    >>> request.form['form.name'] = u'fred'\n    >>> request.form['form.identifier'] = u'0'\n    >>> request.form['form.max_size'] = u'100'\n    >>> print(MyForm(None, request)()) # doctest: +NORMALIZE_WHITESPACE\n    42\n    <input class=\"textType\" id=\"form.name\" name=\"form.name\"\n           size=\"20\" type=\"text\" value=\"fred\"  />\n    <input class=\"textType\" id=\"form.min_size\" name=\"form.min_size\"\n           size=\"10\" type=\"text\" value=\"\"  />\n    <input class=\"textType\" id=\"form.max_size\" name=\"form.max_size\"\n           size=\"10\" type=\"text\" value=\"100.0\"  />\n\nWe'll get display fields if we ask for display fields when setting up\nour form fields:\n\n    >>> class MyForm(form.Form):\n    ...\n    ...     form_fields = form.Fields(IOrder, for_display=True)\n    ...     form_fields = form_fields.omit('now')\n    ...\n    ...     actions = ()\n    ...\n    ...     def setUpWidgets(self, ignore_request=False):\n    ...         self.widgets = form.setUpWidgets(\n    ...             self.form_fields, self.prefix, self.context, self.request,\n    ...             data=dict(identifier=42, name=u'sally'),\n    ...             ignore_request=ignore_request\n    ...             )\n\n    >>> print(MyForm(None, request)()) # doctest: +NORMALIZE_WHITESPACE\n    42\n    sally\n    <BLANKLINE>\n    <BLANKLINE>\n\n\nNote that we didn't get data from the request because we are using all\ndisplay widgets.\n\nPassing `ignore_request=True` to the `setUpWidgets` function ignores\nthe request for all values passed in the data dictionary, in order to\nhelp with redrawing a form after a successful action handler.  We'll\nfake that quickly by forcing ignore_request to be `True`.\n\n    >>> class MyForm(form.Form):\n    ...\n    ...     form_fields = form.Fields(IOrder)\n    ...     form_fields = form_fields.omit('now')\n    ...\n    ...     actions = ()\n    ...\n    ...     def setUpWidgets(self, ignore_request=False):\n    ...         self.widgets = form.setUpWidgets(\n    ...             self.form_fields, self.prefix, self.context, self.request,\n    ...             data=dict(identifier=42, name=u'sally'),\n    ...             ignore_request=True # =ignore_request\n    ...             )\n\n    >>> print(MyForm(None, request)()) # doctest: +NORMALIZE_WHITESPACE\n    42\n    <input class=\"textType\" id=\"form.name\" name=\"form.name\"\n           size=\"20\" type=\"text\" value=\"sally\"  />\n    <input class=\"textType\" id=\"form.min_size\" name=\"form.min_size\"\n           size=\"10\" type=\"text\" value=\"\"  />\n    <input class=\"textType\" id=\"form.max_size\" name=\"form.max_size\"\n           size=\"10\" type=\"text\" value=\"\"  />\n\n\nSpecifying Custom Widgets\n=========================\n\nIt is possible to use custom widgets for specific fields.  This can be\ndone for a variety of reasons, but the provided mechanism should work\nfor any of them.\n\nCustom widgets are specified by providing a widget factory that should\nbe used instead of the registered field view.  The factory will be\ncalled in the same way as any other field view factory, with the bound\nfield and the request as arguments.\n\nLet's create a simple custom widget to use in our demonstration::\n\n    >>> import zope.formlib.widget\n\n    >>> class ISODisplayWidget(zope.formlib.widget.DisplayWidget):\n    ...\n    ...     def __call__(self):\n    ...         return '<span class=\"iso-datetime\">2005-05-04</span>'\n\nTo set the custom widget factory for a field, assign to the\n`custom_widget` attribute of the form field object::\n\n    >>> class MyForm(form.Form):\n    ...     actions = ()\n    ...\n    ...     form_fields = form.Fields(IOrder).select(\"now\")\n    ...\n    ...     # Here we set the custom widget:\n    ...\n    ...     form_fields[\"now\"].custom_widget = ISODisplayWidget\n\n    >>> print(MyForm(None, request)())\n    <span class=\"iso-datetime\">2005-05-04</span>\n\nSpecifying Fields individually\n------------------------------\n\nAll of the previous examples set up fields as collections.  We can\nalso set up forms individually and pass them to the Fields\nconstructor.  This is especially useful for passing options that\nreally only apply to a single field.  The previous example can be\nwritten more simply as:\n\n    >>> class MyForm(form.Form):\n    ...     actions = ()\n    ...\n    ...     form_fields = form.Fields(\n    ...         form.Field(IOrder['now'], custom_widget=ISODisplayWidget),\n    ...         )\n\n    >>> print(MyForm(None, request)())\n    <span class=\"iso-datetime\">2005-05-04</span>\n\nComputing default values\n------------------------\n\nWe saw earlier that we could provide initial widget data by passing a\ndictionary to setUpWidgets.  We can also supply a function or method\nname when we set up form fields.\n\nWe might like to include the `now` field in our forms.  We can provide\na function for getting the needed initial value:\n\n    >>> import datetime\n\n    >>> class MyForm(form.Form):\n    ...     actions = ()\n    ...\n    ...     def now(self):\n    ...         return datetime.datetime(2002, 12, 2, 12, 30)\n    ...\n    ...     form_fields = form.Fields(\n    ...         form.Fields(IOrder).omit('now'),\n    ...         form.Field(IOrder['now'], get_rendered=now),\n    ...         )\n\n    >>> print(MyForm(None, request)()) # doctest: +NORMALIZE_WHITESPACE\n    <BLANKLINE>\n    <input class=\"textType\" id=\"form.name\" name=\"form.name\"\n           size=\"20\" type=\"text\" value=\"fred\"  />\n    <input class=\"textType\" id=\"form.min_size\" name=\"form.min_size\"\n           size=\"10\" type=\"text\" value=\"\"  />\n    <input class=\"textType\" id=\"form.max_size\" name=\"form.max_size\"\n           size=\"10\" type=\"text\" value=\"100.0\"  />\n    <span class=\"dateTime\">2002 12 2  12:30:00 </span>\n\nNow try the same with the AddFormBase which uses a setUpInputWidget:\n\n    >>> class MyAddForm(form.AddFormBase):\n    ...     actions = ()\n    ...\n    ...     def now(self):\n    ...         return datetime.datetime(2002, 12, 2, 12, 30)\n    ...\n    ...     form_fields = form.Fields(\n    ...         form.Fields(IOrder).omit('now'),\n    ...         form.Field(IOrder['now'], get_rendered=now),\n    ...         )\n    ...\n    ...     def setUpWidgets(self, ignore_request=True):\n    ...         super(MyAddForm, self).setUpWidgets(ignore_request)\n\n    >>> print(MyAddForm(None, request)()) # doctest: +NORMALIZE_WHITESPACE\n    <input class=\"textType\" id=\"form.identifier\" name=\"form.identifier\"\n           size=\"10\" type=\"text\" value=\"\"  />\n    <input class=\"textType\" id=\"form.name\" name=\"form.name\" size=\"20\"\n           type=\"text\" value=\"\"  />\n    <input class=\"textType\" id=\"form.min_size\" name=\"form.min_size\"\n           size=\"10\" type=\"text\" value=\"\"  />\n    <input class=\"textType\" id=\"form.max_size\" name=\"form.max_size\"\n           size=\"10\" type=\"text\" value=\"\"  />\n    <input class=\"textType\" id=\"form.now\" name=\"form.now\" size=\"20\"\n           type=\"text\" value=\"2002-12-02 12:30:00\"  />\n\nNote that a EditForm can't make use of a get_rendered method. The get_rendered\nmethod does only set initial values.\n\nNote that the function passed must take a form as an argument.  The\n`setUpWidgets` function takes an optional 'form' argument, which\n**must** be passed if any fields use the get_rendered option.  The\nform base classes always pass the form to `setUpWidgets`.\n\nAdvanced Usage Hints\n====================\n\nThis section documents patterns for advanced usage of the formlib package.\n\nMultiple button groups\n----------------------\n\nMultiple button groups can be accomplished many ways, but the way we've found\nthat reuses the most code is the following:\n\n    >>> class MyForm(form.Form):\n    ...     form_fields = form.Fields(IOrder)\n    ...     primary_actions = form.Actions()\n    ...     secondary_actions = form.Actions()\n    ...     # can use @zope.cachedescriptors.property.Lazy for performance\n    ...     def actions(self):\n    ...         return list(self.primary_actions) + list(self.secondary_actions)\n    ...     @form.action(u'Edit', primary_actions)\n    ...     def handle_edit_action(self, action, data):\n    ...         if form.applyChanges(self.context, self.form_fields, data):\n    ...             self.status = 'Object updated'\n    ...         else:\n    ...             self.status = 'No changes'\n    ...     @form.action(u'Submit for review...', secondary_actions)\n    ...     def handle_review_action(self, action, data):\n    ...         print(\"do something here\")\n    ...\n\nThe template then can render the button groups separately--something like the\nfollowing, for instance:\n\n    <input tal:repeat=\"action view/primary_actions\"\n       tal:replace=\"structure action/render\"\n       />\n\nand\n\n    <input tal:repeat=\"action view/secondary_actions\"\n       tal:replace=\"structure action/render\"\n       />\n\nBut the form machinery can still find the correct button. # TODO: demo\n\nDividing display of widget errors and invariant errors\n------------------------------------------------------\n\nEven though the form machinery only has a single errors attribute, if designers\nwish to render widget errors differently than invariant errors, they can be\nseparated reasonably easily.  The separation takes advantage of the fact that\nall widget errors should implement zope.formlib.interfaces.IWidgetInputError,\nand invariant errors shouldn't, because they don't come from a widget.\nTherefore, a simple division such as the following should suffice.\n\n# TODO\n\n\nOmitting the form prefix\n------------------------\n\nFor certain use cases (e.g. forms that post data to a different server whose\nsoftware you do not control) it is important to be able to generate forms\n*without* a prefix. Using an empty string for the prefix omits it entirely.\n\n    >>> form_fields = form.Fields(IOrder).select('name')\n    >>> request = TestRequest()\n    >>> widgets = form.setUpWidgets(form_fields, '', None, request)\n    >>> print(widgets['name']()) # doctest: +NORMALIZE_WHITESPACE\n    <input class=\"textType\" id=\"name\" name=\"name\" size=\"20\"\n           type=\"text\" value=\"\"  />\n\nOf course, getting the widget data still works.\n\n    >>> request.form['name'] = 'foo'\n    >>> widgets = form.setUpWidgets(form_fields, '', None, request)\n    >>> data = {}\n    >>> form.getWidgetsData(widgets, '', data)\n    []\n    >>> data\n    {'name': u'foo'}\n\nAnd the value from the request is also visible in the rendered form.\n\n    >>> print(widgets['name']()) # doctest: +NORMALIZE_WHITESPACE\n    <input class=\"textType\" id=\"name\" name=\"name\" size=\"20\"\n           type=\"text\" value=\"foo\"  />\n\nThe same is true when using the other setup*Widgets helpers.\n\n    >>> widgets = form.setUpInputWidgets(form_fields, '', None, request)\n    >>> print(widgets['name']()) # doctest: +NORMALIZE_WHITESPACE\n    <input class=\"textType\" id=\"name\" name=\"name\" size=\"20\"\n           type=\"text\" value=\"foo\"  />\n\n    >>> order = Order(42)\n    >>> widgets = form.setUpEditWidgets(form_fields, '', order, request)\n    >>> print(widgets['name']()) # doctest: +NORMALIZE_WHITESPACE\n    <input class=\"textType\" id=\"name\" name=\"name\" size=\"20\"\n           type=\"text\" value=\"foo\"  />\n\n    >>> widgets = form.setUpDataWidgets(form_fields, '', None, request)\n    >>> print(widgets['name']()) # doctest: +NORMALIZE_WHITESPACE\n    <input class=\"textType\" id=\"name\" name=\"name\" size=\"20\"\n           type=\"text\" value=\"foo\"  />\n\nForm actions have their own prefix in addition to the form prefix. This can be\nsuppressed for each action by passing the empty string as the 'prefix'\nargument.\n\n    >>> class MyForm(form.Form):\n    ...\n    ...     prefix = ''\n    ...     form_fields = form.Fields()\n    ...\n    ...     @form.action('Button 1', name='button1')\n    ...     def handle_button1(self, action, data):\n    ...         self.status = 'Button 1 detected'\n    ...\n    ...     @form.action('Button 2', prefix='', name='button2')\n    ...     def handle_button2(self, action, data):\n    ...         self.status = 'Button 2 detected'\n    ...\n    >>> request = TestRequest()\n    >>> request.form['actions.button1'] = ''\n    >>> print(MyForm(None, request)()) # doctest: +NORMALIZE_WHITESPACE\n    Button 1 detected\n    <input type=\"submit\" id=\"actions.button1\" name=\"actions.button1\"\n           value=\"Button 1\" class=\"button\" />\n    <input type=\"submit\" id=\"button2\" name=\"button2\"\n           value=\"Button 2\" class=\"button\" />\n    >>> request = TestRequest()\n    >>> request.form['button2'] = ''\n    >>> print(MyForm(None, request)()) # doctest: +NORMALIZE_WHITESPACE\n    Button 2 detected\n    <input type=\"submit\" id=\"actions.button1\" name=\"actions.button1\"\n           value=\"Button 1\" class=\"button\" />\n    <input type=\"submit\" id=\"button2\" name=\"button2\"\n           value=\"Button 2\" class=\"button\" />\n\nIt is also possible to keep the form prefix and just suppress the 'actions' prefix.\n\n    >>> class MyForm(form.Form):\n    ...\n    ...     form_fields = form.Fields()\n    ...\n    ...     @form.action('Button', prefix='', name='button')\n    ...     def handle_button(self, action, data):\n    ...         self.status = 'Button detected'\n    ...\n    >>> request = TestRequest()\n    >>> request.form['form.button'] = ''\n    >>> print(MyForm(None, request)()) # doctest: +NORMALIZE_WHITESPACE\n    Button detected\n    <input type=\"submit\" id=\"form.button\" name=\"form.button\"\n           value=\"Button\" class=\"button\" />\n\nAdditional Cases\n================\n\n\nAutomatic Context Adaptation\n----------------------------\n\nAs you may know already, the formlib will automatically adapt the context to\nfind a widget and data for a particular field. In an early version of\n``zope.formlib``, it simply used ``field.interface`` to get the interface to\nadapt to. Unfortunately, this call returns the interface the field has been\ndefined in and not the interface you got the field from. The following lines\ndemonstrate the correct behavior:\n\n  >>> import zope.interface\n  >>> import zope.schema\n\n  >>> class IFoo(zope.interface.Interface):\n  ...     title = zope.schema.TextLine()\n\n  >>> class IFooBar(IFoo):\n  ...     pass\n\nHere is the unexpected behavior that caused formlib to do the wrong thing:\n\n  >>> IFooBar['title'].interface\n  <InterfaceClass __builtin__.IFoo>\n\nNote: If this behavior ever changes, the formlib can be simplified again.\n\n  >>> @zope.interface.implementer(IFooBar)\n  ... class FooBar(object):\n  ...     title = u'initial'\n  >>> foobar = FooBar()\n\n  >>> class Blah(object):\n  ...     def __conform__(self, iface):\n  ...         if iface is IFooBar:\n  ...             return foobar\n  >>> blah = Blah()\n\nLet's now generate the form fields and instantiate the widgets:\n\n  >>> from zope.formlib import form\n\n  >>> form_fields = form.FormFields(IFooBar)\n\n  >>> request = TestRequest()\n  >>> widgets = form.setUpEditWidgets(form_fields, 'form', blah, request)\n  >>> print(widgets.get('title')())\n  <input class=\"textType\" id=\"form.title\" name=\"form.title\"\n         size=\"20\" type=\"text\" value=\"initial\" />\n\nHere are some more places where the behavior was incorrect:\n\n  >>> widgets = form.setUpWidgets(form_fields, 'form', blah, request)\n  >>> print(widgets.get('title')())\n  <input class=\"textType\" id=\"form.title\" name=\"form.title\"\n         size=\"20\" type=\"text\" value=\"\" />\n\n  >>> form.checkInvariants(form_fields, {'title': 'new'}, blah)\n  []\n\n  >>> form.applyChanges(blah, form_fields, {'title': 'new'})\n  True\n\n\nEvent descriptions\n------------------\n\nThe ObjectModifiedEvent can be annotated with descriptions about the involved\nschemas and fields. The formlib provides these annotations with the help of the\napplyData function, which returns a list of modification descriptions:\n\n    >>> form.applyData(blah, form_fields, {'title': 'modified'})\n    {<InterfaceClass __builtin__.IFooBar>: ['title']}\n\nThe events are annotated with these descriptions. We need a subscriber to log these\ninfos:\n\n    >>> def eventLog(event):\n    ...     desc = event.descriptions[0]\n    ...     print('Modified:', desc.interface.__identifier__, desc.attributes)\n    >>> zope.event.subscribers.append(eventLog)\n\n\n    >>> class MyForm(form.EditForm):\n    ...     form_fields = form.FormFields(IFooBar)\n\n    >>> request = TestRequest()\n    >>> request.form['form.title'] = u'again modified'\n    >>> request.form['form.actions.apply'] = u''\n    >>> MyForm(FooBar(), request)()\n    Modified: __builtin__.IFooBar ('title',)\n    ...\n\nCleanup:\n\n    >>> zope.event.subscribers.remove(eventLog)\n\nActions that cause a redirect\n-----------------------------\n\nWhen an action causes a redirect, the following `render` phase is omitted as\nthe result will not be displayed anyway. This is both a performance\nimprovement and for avoiding application bugs with one-time session\ninformation.\n\n    >>> class MyForm(form.Form):\n    ...     form_fields = form.FormFields(IFooBar)\n    ...     @form.action(\"Redirect\")\n    ...     def redirect(self, action, data):\n    ...         print('Action: redirect')\n    ...         self.request.response.redirect('foo')\n    ...     @form.action(\"Stay\")\n    ...     def redirect(self, action, data):\n    ...         print('Action: stay')\n    ...         pass\n    ...     def render(self):\n    ...         print('render was called')\n    ...         return ''\n\n    >>> request = TestRequest()\n    >>> print(MyForm(None, request)()) # doctest: +NORMALIZE_WHITESPACE\n    render was called\n    >>> request.form['form.actions.redirect'] = u''\n    >>> print(MyForm(None, request)()) # doctest: +NORMALIZE_WHITESPACE\n    Action: redirect\n\n    >>> request = TestRequest()\n    >>> request.form['form.actions.stay'] = u''\n    >>> print(MyForm(None, request)()) # doctest: +NORMALIZE_WHITESPACE\n    Action: stay\n    render was called\n\nPrevent form submit for GET requests\n------------------------------------\n\nIt can be useful to only accept form submits over POST requests. This, for\nexample, prevents replaying data-modifying actions when reloading a page in a\nweb browser (most web browsers warn users for re-submitting the form when\nreloading a page that was the result of a POST request). This also helps (but\nis not enough by itself!) in preventing CSRF attacks.\n\nWhenever a form component has set the ``method`` attribute on the class, it\nis used when validating the form data.\n\n    >>> class MyPOSTForm(form.Form):\n    ...     method = 'POST'\n    ...\n    ...     form_fields = form.FormFields(IFooBar)\n    ...\n    ...     @form.action(\"Handle\")\n    ...     def handle(self, action, data):\n    ...         print('Action: handle %s' % data)\n    ...\n    ...     def render(self):\n    ...         return ''\n\nThis is a GET request for a form that specifies it can only validate POST\nrequests::\n\n    >>> request = TestRequest()\n    >>> request.form['form.title'] = u'Submitted Title'\n    >>> request.form['form.actions.handle'] = u''\n    >>> MyPOSTForm(None, request)() # doctest: +NORMALIZE_WHITESPACE +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n    ...\n    MethodNotAllowed: None, <zope.publisher.browser.TestRequest instance URL=http://127.0.0.1>\n\nBy setting the correct request method we validate input::\n\n    >>> request = TestRequest()\n    >>> request.method = 'POST'\n    >>> request.form['form.title'] = u'Submitted Title'\n    >>> request.form['form.actions.handle'] = u''\n    >>> print(MyPOSTForm(None, request)()) # doctest: +NORMALIZE_WHITESPACE\n    Action: handle {'title': 'Submitted Title'}\n\nAlthough slightly convoluted, we could require the submit to go over a\nGET request::\n\n    >>> class MyGETForm(form.Form):\n    ...     method = 'GET'\n    ...\n    ...     form_fields = form.FormFields(IFooBar)\n    ...\n    ...     @form.action(\"Handle\")\n    ...     def handle(self, action, data):\n    ...         print('Action: handle %s' % data)\n    ...\n    ...     def render(self):\n    ...         return ''\n\n    >>> request = TestRequest()\n    >>> request.method = 'POST'\n    >>> request.form['form.actions.handle'] = u''\n    >>> MyGETForm(None, request)() # doctest: +NORMALIZE_WHITESPACE +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n    ...\n    MethodNotAllowed: None, <zope.publisher.browser.TestRequest instance URL=http://127.0.0.1>\n\n    >>> request = TestRequest()\n    >>> request.form['form.title'] = u'Submitted Title'\n    >>> request.form['form.actions.handle'] = u''\n    >>> print(MyGETForm(None, request)()) # doctest: +NORMALIZE_WHITESPACE\n    Action: handle {'title': 'Submitted Title'}\n\nNote how the default value for ``method`` is None, meaning all request\nmethods are accepted::\n\n    >>> class MyForm(form.Form):\n    ...     form_fields = form.FormFields(IFooBar)\n    ...\n    ...     @form.action(\"Handle\")\n    ...     def handle(self, action, data):\n    ...         print('Action: handle %s' % data)\n    ...\n    ...     def render(self):\n    ...         return ''\n\n    >>> request = TestRequest()\n    >>> request.method = 'POST'\n    >>> request.form['form.title'] = u'Submitted Title'\n    >>> request.form['form.actions.handle'] = u''\n    >>> print(MyForm(None, request)()) # doctest: +NORMALIZE_WHITESPACE\n    Action: handle {'title': 'Submitted Title'}\n\n    >>> request = TestRequest()\n    >>> request.form['form.title'] = u'Submitted Title'\n    >>> request.form['form.actions.handle'] = u''\n    >>> print(MyForm(None, request)()) # doctest: +NORMALIZE_WHITESPACE\n    Action: handle {'title': 'Submitted Title'}\n\nPrevent Cross-site Request Forgery (CSRF) attacks\n-------------------------------------------------\n\nSee also: http://en.wikipedia.org/wiki/Cross-site_request_forgery.\n\nThe CSRF protection in zope.formlib assumes the attacker cannot get hold of\ninformation stored in a cookie that is send to the domain handling the form\nsubmit. zope.formlib verifies that the token as sent with the cookie is\nidentical to the value as sent with the form (as a hidden input field).\n\nzope.formlib will set a random token in the cookie when first accessing the\nform. Any subsequent form rendering and submit handling will use the token\nstored in this cookie.\n\nThus this token is reused for all forms for as long the cookie is available.\n\nThe cookie is set to expiry when the web browser quits.\n\nThis protection works best when used in combination with the afformentioned\nacceptable request method restriction.\n\nIssues to research:\n\n* Is the name \"__csrftoken__ acceptable?\n\n* I do not see a scheme for having a token per form without keep server-\n  side, which I try to avoid.\n\n* One cannot *submit* a form as the very first request to that form, as the\n  token will not have been set just yet. I think this acceptable.\n\n* Tests for applications that use form components with CSRF protection\n  enabled, is cumbersome. Can we help that somehow?\n\n* Is using os.urandom() for generating a token sufficient *and*\n  available cross-platform? Could uuid.uuid4() be an alternative?\n\nWhen first visting a form, a CSRF token will be set in the cookie::\n\n    >>> class MyForm(form.Form):\n    ...     protected = True\n    ...\n    ...     form_fields = form.FormFields(IFooBar)\n    ...\n    ...     @form.action(\"Handle\")\n    ...     def handle(self, action, data):\n    ...         print('Action: handle %s' % data)\n\n    >>> request = TestRequest()\n    >>> myform = MyForm(None, request)\n    >>> _ = myform()  # \"render\" the form.\n    >>> csrfcookie = request.response.getCookie('__csrftoken__')\n    >>> csrfcookie['httponly']\n    True\n    >>> csrftoken = csrfcookie['value']\n    >>> csrftoken == myform.csrftoken\n    True\n\nWhen submitting the form, the token in the cookie (that will be sent\nas part of the request) needs to be identical to the value of the\nhidden form field \"__csrftoken__\"::\n\n    >>> request = TestRequest(\n    ...     **{'HTTP_COOKIE': '__csrftoken__=%s;' % csrftoken})\n    >>> request.form['form.title'] = 'Submitted title'\n    >>> request.form['form.actions.handle'] = 'true'\n    >>> request.form['__csrftoken__'] = csrftoken\n    >>> myform = MyForm(None, request)\n    >>> _ = myform()\n    Action: handle {'title': u'Submitted title'}\n\nIf for some reason the cookie is not set, the form will raise an error::\n\n    >>> request = TestRequest(**{'HTTP_COOKIE': ''})\n    >>> request.form['form.title'] = 'Submitted title'\n    >>> request.form['form.actions.handle'] = 'true'\n    >>> request.form['__csrftoken__'] = csrftoken\n    >>> myform = MyForm(None, request)\n    >>> _ = myform()   #doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n    ...\n    InvalidCSRFTokenError: Invalid CSRF token\n\nAs an attacker cannot read the cookie value, he can only guess the\ncorresponding form value, that is hard get right, so most proably wrong::\n\n    >>> request = TestRequest(\n    ...     **{'HTTP_COOKIE': '__csrftoken__=%s;' % csrftoken})\n    >>> request.form['form.title'] = 'Submitted title'\n    >>> request.form['form.actions.handle'] = 'true'\n    >>> request.form['__csrftoken__'] = 'a guessed value'\n    >>> myform = MyForm(None, request)\n    >>> _ = myform()  #doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n    ...\n    InvalidCSRFTokenError: Invalid CSRF token\n\nWhen the form value is missing altogether, the form obviously raises an error\ntoo::\n\n    >>> request = TestRequest(\n    ...     **{'HTTP_COOKIE': '__csrftoken__=%s;' % csrftoken})\n    >>> request.form['form.title'] = 'Submitted title'\n    >>> request.form['form.actions.handle'] = 'true'\n    >>> myform = MyForm(None, request)\n    >>> _ = myform()   #doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n    ...\n    InvalidCSRFTokenError: Invalid CSRF token\n\nTo repeat: this protection works as long as the cookie value is identical to\nthe submitted form value. No state is kept on the server. We can demonstrate\nthis by inventing a token value here in the test ourselves::\n\n    >>> csrftoken = 'MYNICETOKENVALUE'\n    >>> request = TestRequest(\n    ...     **{'HTTP_COOKIE': '__csrftoken__=%s;' % csrftoken})\n    >>> request.form['form.title'] = 'Submitted title'\n    >>> request.form['form.actions.handle'] = 'true'\n    >>> request.form['__csrftoken__'] = csrftoken\n    >>> myform = MyForm(None, request)\n    >>> _ = myform()\n    Action: handle {'title': u'Submitted title'}\n\nIt is possible to have multiple forms in one page. Of course only one of\nthese forms can be submitted at one point in time, but the CSRF token should\nnot confuse things::\n\n    >>> class FormOne(form.Form):\n    ...     prefix = 'form_one'\n    ...\n    ...     protected = True\n    ...\n    ...     form_fields = form.FormFields(IFooBar)\n    ...\n    ...     @form.action(\"Handle\")\n    ...     def handle(self, action, data):\n    ...         print('Action: handle in Form One')\n\n    >>> class FormTwo(form.Form):\n    ...     prefix = 'form_two'\n    ...\n    ...     protected = True\n    ...\n    ...     form_fields = form.FormFields(IFooBar)\n    ...\n    ...     @form.action(\"Handle\")\n    ...     def handle(self, action, data):\n    ...         print('Action: handle in Form Two')\n\n    >>> from zope.publisher.browser import BrowserPage\n    >>> class MultiForm(BrowserPage):\n    ...     def __init__(self, context, request):\n    ...         self.formone = FormOne(context, request)\n    ...         self.formtwo = FormTwo(context, request)\n    ...\n    ...     def __call__(self):\n    ...         return '\\n'.join((self.formone(), self.formtwo()))\n    ...\n\nRender the initial multi form view::\n\n    >>> request = TestRequest()\n    >>> multi = MultiForm(None, request)\n    >>> result = multi()\n    >>> print(result)\n    <input class=\"textType\" id=\"form_one.title\"\n      name=\"form_one.title\" size=\"20\" type=\"text\" value=\"\"  />\n    <inut type=\"hidden\" name=\"__csrftoken__\" value=\"...\"\n    <input type=\"submit\" id=\"form_one.actions.handle\"\n      name=\"form_one.actions.handle\" value=\"Handle\" class=\"button\" />\n    <input class=\"textType\" id=\"form_two.title\"\n      name=\"form_two.title\" size=\"20\" type=\"text\" value=\"\"  />\n    <inut type=\"hidden\" name=\"__csrftoken__\" value=\"...\"\n    <input type=\"submit\" id=\"form_two.actions.handle\"\n      name=\"form_two.actions.handle\" value=\"Handle\" class=\"button\" />\n\nThe CSRF tokens in both the hidden form fields should be identical to the one\nset in the cookie::\n\n    >>> csrftoken = request.response.getCookie('__csrftoken__')['value']\n    >>> len(result.split(str(csrftoken)))\n    3\n    >>> multi.formone.csrftoken == multi.formtwo.csrftoken == csrftoken\n    True\n\nWe can indeed submit data to the forms::\n\n    >>> request = TestRequest(\n    ...     **{'HTTP_COOKIE': '__csrftoken__=%s;' % csrftoken})\n    >>> request.form['form_one.title'] = 'Submitted title'\n    >>> request.form['form_one.actions.handle'] = 'true'\n    >>> request.form['__csrftoken__'] = csrftoken\n    >>> multi = MultiForm(None, request)\n    >>> _ = multi()\n    Action: handle in Form One\n\n    >>> request = TestRequest(\n    ...     **{'HTTP_COOKIE': '__csrftoken__=%s;' % csrftoken})\n    >>> request.form['form_two.title'] = 'Submitted title'\n    >>> request.form['form_two.actions.handle'] = 'true'\n    >>> request.form['__csrftoken__'] = csrftoken\n    >>> multi = MultiForm(None, request)\n    >>> _ = multi()\n    Action: handle in Form Two\n\nThere is a view for the InvalidCSRFTokenError::\n\n    >>> from zope.component import getMultiAdapter\n    >>> from zope.formlib.interfaces import InvalidCSRFTokenError\n    >>> from zope.formlib.errors import InvalidCSRFTokenErrorView\n    >>> error = InvalidCSRFTokenError('Invalid CSRF token')\n    >>> request = TestRequest()\n    >>> print(InvalidCSRFTokenErrorView(error, request)())\n    Invalid CSRF token\n\n\n===============\nBrowser Widgets\n===============\n\nFormlib defines widgets: views on bound schema fields. Many of these\nare straightforward.  For instance, see the `TextWidget` in\ntextwidgets.py, which is a subclass of BrowserWidget in widget.py.  It\nis registered as an `IBrowserRequest` view of an `ITextLine` schema\nfield, providing the `IInputWidget` interface::\n\n  <view\n      type=\"zope.publisher.interfaces.browser.IBrowserRequest\"\n      for=\"zope.schema.interfaces.ITextLine\"\n      provides=\"zope.formlib.interfaces.IInputWidget\"\n      factory=\".TextWidget\"\n      permission=\"zope.Public\"\n      />\n\nThe widget then receives the field and the request as arguments to the factory\n(i.e., the `TextWidget` class).\n\nSome widgets in formlib extend this pattern. The widget registration\nis extended for `Choice` fields and for the `collection` fields.\n\nDefault Choice Field Widget Registration and Lookup\n===================================================\n\nAll field widgets are obtained by looking up a browser `IInputWidget`\nor `IDisplayWidget` view for the field object.  For `Choice` fields,\nthe default registered widget defers all of its behavior to the result\nof another lookup: a browser widget view for the field *and* the\nChoice field's vocabulary.\n\nThis allows registration of Choice widgets that differ on the basis of the\nvocabulary type.  For example, a widget for a vocabulary of images might have\na significantly different user interface than a widget for a vocabulary of\nwords.  A dynamic vocabulary might implement `IIterableVocabulary` if its\ncontents are below a certain length, but not implement the marker \"iterable\"\ninterface if the number of possible values is above the threshhold.\n\nThis also means that choice widget factories are called with with an additional\nargument.  Rather than being called with the field and the request as\narguments, choice widgets receive the field, vocabulary, and request as\narguments.\n\nSome `Choice` widgets may also need to provide a source interface,\nparticularly if the vocabulary is too big to iterate over.\n\nDefault Collection Field Widget Registration and Lookup\n=======================================================\n\nThe default configured lookup for collection fields -- List, Tuple, and Set, for\ninstance -- begins with the usual lookup for a browser widget view for the\nfield object.  This widget defers its display to the result of another lookup:\na browser widget view registered for the field and the field's `value_type`\n(the type of the contained values).  This allows registrations for collection\nwidgets that differ on the basis of the members -- a widget for entering a list\nof text strings might differ significantly from a widget for entering a list of\ndates...or even a list of choices, as discussed below.\n\nThis registration pattern has three implications that should be highlighted. \n\n* First, collection fields that do not specify a `value_type` probably cannot\n  have a reasonable widget.\n\n* Second, collection widgets that wish to be the default widget for a\n  collection with any `value_type` should be registered for the collection\n  field and a generic value_type: the `IField` interface.  Do  not register the\n  generic widget for the collection field only or you will break the lookup\n  behavior as described here.\n\n* Third, like choice widget factories, sequence widget factories (classes or\n  functions) take three arguments.  Typical sequence widgets receive the\n  field, the `value_type`, and the request as arguments.\n\nCollections of Choices\n----------------------\n\nIf a collection field's `value_type` is a `Choice` field, the second widget\nagain defers its behavior, this time to a third lookup based on the collection\nfield and the choice's vocabulary.  This means that a widget for a list of\nlarge image choices can be different than a widget for a list of small image\nchoices (with a different vocabulary interface), different from a widget for a\nlist of keyword choices, and different from a set of keyword choices.\n\nSome advanced applications may wish to do a further lookup on the basis of the\nunique attribute of the collection field--perhaps looking up a named view with\na \"unique\" or \"lenient\" token depending on the field's value, but this is not\nenabled in the default Zope 3 configuration.\n\nRegistering Widgets for a New Collection Field Type\n---------------------------------------------------\n\nBecause of this lookup pattern, basic widget registrations for new field types\nmust follow a recipe.  For example, a developer may introduce a new Bag field\ntype for simple shopping cart functionality and wishes to add widgets for it\nwithin the default Zope 3 collection widget registration.  The bag widgets\nshould be registered something like this. \n\nThe only hard requirement is that the developer must register the bag + choice\nwidget: the widget is just the factory for the third dispatch as described\nabove, so the developer can use the already implemented widgets listed below::\n\n  <view\n      type=\"zope.publisher.interfaces.browser.IBrowserRequest\"\n      for=\"zope.schema.interfaces.IBag\n           zope.schema.interfaces.IChoice\"\n      provides=\"zope.formlib.interfaces.IDisplayWidget\"\n      factory=\".ChoiceCollectionDisplayWidget\"\n      permission=\"zope.Public\"\n      />\n\n  <view\n      type=\"zope.publisher.interfaces.browser.IBrowserRequest\"\n      for=\"zope.schema.interfaces.IBag\n           zope.schema.interfaces.IChoice\"\n      provides=\"zope.formlib.interfaces.IInputWidget\"\n      factory=\".ChoiceCollectionInputWidget\"\n      permission=\"zope.Public\"\n      />\n\nBeyond this, the developer may also have a generic bag widget she wishes to\nregister.  This might look something like this, assuming there's a\n`BagSequenceWidget` available in this package::\n\n  <view\n      type=\"zope.publisher.interfaces.browser.IBrowserRequest\"\n      for=\"zope.schema.interfaces.IBag\n           zope.schema.interfaces.IField\"\n      provides=\"zope.formlib.interfaces.IInputWidget\"\n      factory=\".BagSequenceWidget\"\n      permission=\"zope.Public\"\n      />\n\nThen any widgets for the bag and a vocabulary would be registered according to\nthis general pattern, in which `IIterableVocabulary` would be the interface of\nany appropriate vocabulary and `BagWidget` is some appropriate widget::\n\n  <view\n      type=\"zope.publisher.interfaces.browser.IBrowserRequest\"\n      for=\"zope.schema.interfaces.IBag\n           zope.schema.interfaces.IIterableVocabulary\"\n      provides=\"zope.formlib.interfaces.IInputWidget\"\n      factory=\".BagWidget\"\n      permission=\"zope.Public\"\n      />\n\n\nChoice widgets and the missing value\n====================================\n\nChoice widgets for a non-required field include a \"no value\" item to allow for\nnot selecting any value at all. This value used to be omitted for required\nfields on the assumption that the widget should avoid invalid input from the\nstart.\n\nHowever, if the context object doesn't yet have a field value set and there's\nno default value, a dropdown widget would have to select an arbitrary value\ndue to the way it is displayed in the browser. This way, the field would\nalways validate, but possibly with a value the user never chose consciously.\n\nStarting with version zope.app.form 3.6.0, dropdown widgets for\nrequired fields display a \"no value\" item even for required fields if\nan arbitrary value would have to be selected by the widget otherwise.\n\nTo switch the old behaviour back on for backwards compatibility, do\n\n  zope.formlib.itemswidgets.EXPLICIT_EMPTY_SELECTION = False\n\nduring application start-up.\n\n\n==============\nError handling\n==============\n\nThese are a couple of functional tests that were written on-the-go ... In the\nfuture this might become more extensive ...\n\nDisplaying invalidation errors\n==============================\n\nValidation errors, e.g. cause by invariants, are converted into readable text\nby adapting them to IWidgetInputErrorView:\n\n    >>> from zope.publisher.browser import TestRequest\n    >>> from zope.interface.exceptions import Invalid\n    >>> from zope.component import getMultiAdapter\n    >>> from zope.formlib.interfaces import IWidgetInputErrorView\n    >>> error = Invalid(\"You are wrong!\")\n    >>> message = getMultiAdapter((error, TestRequest()),\n    ...         IWidgetInputErrorView).snippet()\n    >>> message\n    u'<span class=\"error\">You are wrong!</span>'\n\nInterface invariant methods raise zope.interface.Invalid exception. Test if\nthis exception gets handled by the error_views.\n\n    >>> myError = Invalid('My error message')\n    >>> import zope.formlib.form\n    >>> mybase = zope.formlib.form.FormBase(None, TestRequest())\n    >>> mybase.errors = (myError,)\n    >>> save = mybase.error_views()\n    >>> next(save)\n    u'<span class=\"error\">My error message</span>'\n\nNow we need to set up the translation framework:\n\n    >>> from zope import component, interface\n    >>> from zope.i18n.interfaces import INegotiator\n    >>> @interface.implementer(INegotiator)\n    ... class Negotiator:\n    ...     def getLanguage(*ignored): return 'test'\n    >>> component.provideUtility(Negotiator())\n    >>> from zope.i18n.testmessagecatalog import TestMessageFallbackDomain\n    >>> component.provideUtility(TestMessageFallbackDomain)\n\nAnd yes, we can even handle an i18n message in an Invalid exception:\n\n    >>> from zope.i18nmessageid import MessageFactory\n    >>> _ = MessageFactory('my.domain')\n    >>> myError = Invalid(_('My i18n error message'))\n    >>> mybase = zope.formlib.form.FormBase(None, TestRequest())\n    >>> mybase.errors = (myError,)\n    >>> save = mybase.error_views()\n    >>> next(save)\n    u'<span class=\"error\">[[my.domain][My i18n error message]]</span>'\n\nDisplaying widget input errors\n==============================\n\nWidgetInputError exceptions also work with i18n messages:\n\n    >>> from zope.formlib.interfaces import WidgetInputError\n    >>> myError = WidgetInputError(\n    ...     field_name='summary',\n    ...     widget_title=_(u'Summary'),\n    ...     errors=_(u'Foo'))\n    >>> mybase = zope.formlib.form.FormBase(None, TestRequest())\n    >>> mybase.errors = (myError,)\n    >>> save = mybase.error_views()\n    >>> next(save)\n    u'[[my.domain][Summary]]: <span class=\"error\">[[my.domain][Foo]]</span>'\n\n\n=======\nChanges\n=======\n\n4.3.0 (2014-12-24)\n==================\n\n- Add support for PyPy.  (PyPy3 is pending release of a fix for:\n  https://bitbucket.org/pypy/pypy/issue/1946)\n\n- Add support for Python 3.4.\n\n- Add support for testing on Travis.\n\n- Explicitly hide span in ``orderedSelectionList.pt``.  This only\n  contains hidden inputs, but Internet Explorer 10 was showing them\n  anyway.\n\n- Support for CSRF protection.\n\n- Added support for restricting the acceptable request method for the\n  form submit.\n\n\n4.3.0a1 (2013-02-27)\n====================\n\n- Added support for Python 3.3.\n\n\n4.2.1 (2013-02-22)\n==================\n\n- Moved default values for the `BooleanDisplayWidget` from module to class\n  definition to make them changeable in instance.\n\n\n4.2.0 (2012-11-27)\n==================\n\n- LP #1017884:  Add redirect status codes (303, 307) to the set which prevent\n  form rendering.\n\n- Replaced deprecated ``zope.component.adapts`` usage with equivalent\n  ``zope.component.adapter`` decorator.\n\n- Replaced deprecated ``zope.interface.implements`` usage with equivalent\n  ``zope.interface.implementer`` decorator.\n\n- Dropped support for Python 2.5.\n\n- Make separator of ``SourceSequenceDisplayWidget`` configurable.\n\n\n4.1.1 (2012-03-16)\n==================\n\n- Added `ignoreContext` attribute to form classes to control whether\n  `checkInvariants` takes the context of the form into account when\n  checking interface invariants.\n\n  By default `ignoreContext` is set to ``False``.  On the `AddForm` it is\n  ``True`` by default because the context of this form is naturally not\n  suitable as context for the interface invariant.\n\n\n4.1.0 (2012-03-15)\n==================\n\n- `checkInvariants` now takes the context of the form into account when\n  checking interface invariants.\n\n- Tests are no longer compatible with Python 2.4.\n\n\n4.0.6 (2011-08-20)\n==================\n\n- Fixed bug in ``orderedSelectionList.pt`` template.\n\n4.0.5 (2010-09-16)\n==================\n\n- Fixed Action name parameter handling, since 4.0.3 all passed names were\n  lowercased.\n\n4.0.4 (2010-07-06)\n==================\n\n- Fixed tests to pass under Python 2.7.\n\n- Fix validation of \"multiple\" attributes in orderedSelectionList.pt.\n\n4.0.3 (2010-05-06)\n==================\n\n- Keep Actions from raising exceptions when passed Unicode lables [LP:528468].\n\n- Improve display of the \"nothing selected\" case for optional Choice fields\n  [LP:269782].\n\n- Improve truth testing for ItemDisplayWidget [LP:159232].\n\n- Don't blow up if TypeError raised during token conversion [LP:98491].\n\n4.0.2 (2010-03-07)\n==================\n\n- Adapted tests for Python 2.4 (enforce sorting for short pprint output)\n\n4.0.1 (2010-02-21)\n==================\n\n- Documentation uploaded to PyPI now contains widget documentation.\n- Escape MultiCheckBoxWidget content [LP:302427].\n\n4.0 (2010-01-08)\n================\n\n- Widget implementation and all widgets from zope.app.form have been\n  moved into zope.formlib, breaking zope.formlib's dependency on\n  zope.app.form (instead zope.app.form now depends on zope.formlib).\n\n  Widgets can all be imported from ``zope.formlib.widgets``.\n\n  Widget base classes and render functionality is in\n  ``zope.formlib.widget``.\n\n  All relevant widget interfaces are now in ``zope.formlib.interfaces``.\n\n3.10.0 (2009-12-22)\n===================\n\n- Use named template from zope.browserpage in favor of zope.app.pagetemplate.\n\n3.9.0 (2009-12-22)\n==================\n\n- Use ViewPageTemplateFile from zope.browserpage.\n\n3.8.0 (2009-12-22)\n==================\n\n- Adjusted test output to new zope.schema release.\n\n3.7.0 (2009-12-18)\n==================\n\n- Rid ourselves from zope.app test dependencies.\n\n- Fix: Button label needs escaping\n\n3.6.0 (2009-05-18)\n==================\n\n- Remove deprecated imports.\n\n- Remove dependency on zope.app.container (use ``IAdding`` from\n  ``zope.browser.interfaces``) instead.  Depend on\n  ``zope.browser>=1.1`` (the version with ``IAdding``).\n\n- Moved ``namedtemplate`` to ``zope.app.pagetemplate``, to cut some\n  dependencies on ``zope.formlib`` when using this feature. Left BBB\n  imports here.\n\n3.5.2 (2009-02-21)\n==================\n\n- Adapt tests for Python 2.5 output.\n\n3.5.1 (2009-01-31)\n==================\n\n- Adapt tests to upcoming zope.schema release 3.5.1.\n\n3.5.0 (2009-01-26)\n==================\n\nNew Features\n------------\n\n- Test dependencies are declared in a `test` extra now.\n\n- Introduced ``zope.formlib.form.applyData`` which works like\n  ``applyChanges`` but returns a dictionary with information about\n  which attribute of which schema changed.  This information is then\n  sent along with the ``IObjectModifiedEvent``.\n\n  This fixes https://bugs.launchpad.net/zope3/+bug/98483.\n\nBugs Fixed\n----------\n\n- Actions that cause a redirect (301, 302) do not cause the `render` method to\n  be called anymore.\n\n- The zope.formlib.form.Action class didn't fully implement\n  zope.formlib.interfaces.IAction.\n\n- zope.formlib.form.setupWidgets and zope.formlib.form.setupEditWidgets did\n  not check for write access on the adapter but on context. This fixes\n  https://bugs.launchpad.net/zope3/+bug/219948\n\n\n3.4.0 (2007-09-28)\n==================\n\nNo further changes since 3.4.0a1.\n\n3.4.0a1 (2007-04-22)\n====================\n\nInitial release as a separate project, corresponds to zope.formlib\nfrom Zope 3.4.0a1",
    "docs_url": null,
    "download_url": "UNKNOWN",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "http://pypi.python.org/pypi/zope.formlib",
    "keywords": "zope3 form widget",
    "license": "ZPL 2.1",
    "maintainer": null,
    "maintainer_email": null,
    "name": "zope.formlib",
    "platform": "UNKNOWN",
    "project_url": "https://pypi.org/project/zope.formlib/",
    "release_url": "https://pypi.org/project/zope.formlib/4.3.0/",
    "requires_python": null,
    "summary": "Form generation and validation library for Zope",
    "version": "4.3.0"
  },
  "releases": {
    "3.10.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "364d31a451341c519cdbd8d0e00eb2d9",
          "sha256": "22224e756a7aee73c6d0b12c2fbf6dc0b74327610d045928bf6029fa33a86df7"
        },
        "downloads": 3466,
        "filename": "zope.formlib-3.10.0.zip",
        "has_sig": false,
        "md5_digest": "364d31a451341c519cdbd8d0e00eb2d9",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 77570,
        "upload_time": "2009-12-22T22:50:00",
        "url": "https://files.pythonhosted.org/packages/ce/7f/28f007cf50433a1e620a9c66c295850eb3c9b7001ffac2970b8ecf95b05a/zope.formlib-3.10.0.zip"
      }
    ],
    "3.4.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "76df52e3063eb112a5be6d2959d7f8f8",
          "sha256": "25b103ad1fd0b61f9fea5a6b0c70e7c752b8e7e6c82dda782be158a6fcd1bccb"
        },
        "downloads": 44190,
        "filename": "zope.formlib-3.4.0-py2.4.egg",
        "has_sig": false,
        "md5_digest": "76df52e3063eb112a5be6d2959d7f8f8",
        "packagetype": "bdist_egg",
        "python_version": "2.4",
        "size": 87492,
        "upload_time": "2007-09-28T12:12:50",
        "url": "https://files.pythonhosted.org/packages/57/0b/4684f9d1805446f7e1600bfeb114c772cafd0cfd263b9c8f4b6da4ace523/zope.formlib-3.4.0-py2.4.egg"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "e0c46e29b10703988c0d0f873f9f4b9c",
          "sha256": "ec93f41fe222ae3497adb1b58fd313e2ba6720e6650239fa01d79184b2e6124f"
        },
        "downloads": 13285,
        "filename": "zope.formlib-3.4.0.tar.gz",
        "has_sig": false,
        "md5_digest": "e0c46e29b10703988c0d0f873f9f4b9c",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 63846,
        "upload_time": "2007-09-28T12:12:46",
        "url": "https://files.pythonhosted.org/packages/f6/36/e8117add00bb4c4542d52e36f852a82d856a123375da5d7d833f0bb819d2/zope.formlib-3.4.0.tar.gz"
      }
    ],
    "3.4dev-r73110": [
      {
        "comment_text": "",
        "digests": {
          "md5": "d2111b8fc80c421bcc7de27feeee26e0",
          "sha256": "9d10a10b6064552f3a9a346c49bd3b026c909c61855ca26ae38c8d3893c17487"
        },
        "downloads": 3656,
        "filename": "zope.formlib-3.4dev_r73110-py2.4.egg",
        "has_sig": false,
        "md5_digest": "d2111b8fc80c421bcc7de27feeee26e0",
        "packagetype": "bdist_egg",
        "python_version": "2.4",
        "size": 74228,
        "upload_time": "2007-03-21T07:00:21",
        "url": "https://files.pythonhosted.org/packages/13/f0/5c143edd36ce41dc4481c27c3736a3be5331ee236f3eddea6340f1471b87/zope.formlib-3.4dev_r73110-py2.4.egg"
      }
    ],
    "3.5.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "4bcef5394f2e0a9c48cad0bb3187c422",
          "sha256": "03cedfa2679fa99e54b645697d1b97ed022dc63b092b4707f365af5cbb99c5f8"
        },
        "downloads": 3140,
        "filename": "zope.formlib-3.5.0.zip",
        "has_sig": true,
        "md5_digest": "4bcef5394f2e0a9c48cad0bb3187c422",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 81055,
        "upload_time": "2009-01-26T20:03:32",
        "url": "https://files.pythonhosted.org/packages/7d/c5/f2abb07f61bf2e612e2dcaf621c6258c799b3e63c1e737ecb8186be7d230/zope.formlib-3.5.0.zip"
      }
    ],
    "3.5.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "40ba0310e382e6022ecf9854f1aef4eb",
          "sha256": "a41d4592f81b890d62369e99e35613e4f142e344e82cc356ab1635f897973941"
        },
        "downloads": 3639,
        "filename": "zope.formlib-3.5.1.tar.gz",
        "has_sig": false,
        "md5_digest": "40ba0310e382e6022ecf9854f1aef4eb",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 67992,
        "upload_time": "2009-01-31T15:06:11",
        "url": "https://files.pythonhosted.org/packages/50/ed/e6dfca1c29b76b3c8f6e9919ab981a4a6020b15269add268bafc0ac924b4/zope.formlib-3.5.1.tar.gz"
      }
    ],
    "3.5.2": [
      {
        "comment_text": "",
        "digests": {
          "md5": "7ef67c20b881ca38516522f1737d1fdf",
          "sha256": "fe7146d8a5ceefaf1d685b9912fe91d9b9d8ad38336bd40de1a0fd9c05bc745b"
        },
        "downloads": 4798,
        "filename": "zope.formlib-3.5.2.zip",
        "has_sig": true,
        "md5_digest": "7ef67c20b881ca38516522f1737d1fdf",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 81273,
        "upload_time": "2009-02-21T13:21:35",
        "url": "https://files.pythonhosted.org/packages/1c/10/d570697b63d2c403711752eb08c5c5a4b1fdd72fab362dc5588f25f84efa/zope.formlib-3.5.2.zip"
      }
    ],
    "3.6.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "35f28b74be78e8dd2eab69840b0c386c",
          "sha256": "f51411e26e2ceb2dfb03e0180023e436fc0c71647341f138ba3d207ee2e11f7f"
        },
        "downloads": 12494,
        "filename": "zope.formlib-3.6.0.tar.gz",
        "has_sig": false,
        "md5_digest": "35f28b74be78e8dd2eab69840b0c386c",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 64693,
        "upload_time": "2009-05-18T22:04:27",
        "url": "https://files.pythonhosted.org/packages/fe/ed/d2375dc117340eb76925371a02be3b3042378d4c1601a3a8b4eaf505a464/zope.formlib-3.6.0.tar.gz"
      }
    ],
    "3.7.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "3bca8f86251d93a09c86832f35dfcba2",
          "sha256": "93c70c75c17d15394392c241b364c245fd53653c29bc2042dcb6e51872743ce6"
        },
        "downloads": 29754,
        "filename": "zope.formlib-3.7.0.zip",
        "has_sig": false,
        "md5_digest": "3bca8f86251d93a09c86832f35dfcba2",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 77252,
        "upload_time": "2009-12-18T02:31:25",
        "url": "https://files.pythonhosted.org/packages/25/aa/1ba9260635f12c63f91493959bfd1271c40c1bcc66955dc3294352dcca21/zope.formlib-3.7.0.zip"
      }
    ],
    "3.8.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "43be0dd19e0530b5a74fa8277b0c88a7",
          "sha256": "9197798ae507bdf5a79afa318e0e774d154dded826fd42c7d6970a5d7a055632"
        },
        "downloads": 2748,
        "filename": "zope.formlib-3.8.0.zip",
        "has_sig": false,
        "md5_digest": "43be0dd19e0530b5a74fa8277b0c88a7",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 77345,
        "upload_time": "2009-12-22T16:06:10",
        "url": "https://files.pythonhosted.org/packages/dc/4f/dcafb94fbd2ef9c1521d12cbf995ffe422a462d7b426826ddb783c8cca8e/zope.formlib-3.8.0.zip"
      }
    ],
    "3.9.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "87d83031feecece5ea87dac6781d1fa4",
          "sha256": "4860326622d3abd48dc682ce07ce2aedd7a9d8ed96b414529205166860efdad8"
        },
        "downloads": 2729,
        "filename": "zope.formlib-3.9.0.zip",
        "has_sig": false,
        "md5_digest": "87d83031feecece5ea87dac6781d1fa4",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 77453,
        "upload_time": "2009-12-22T20:52:28",
        "url": "https://files.pythonhosted.org/packages/be/c8/38a0f230c8db347d9e7e7adde4d520944f46e005a02569fd41ce676888d7/zope.formlib-3.9.0.zip"
      }
    ],
    "4.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "4fae74df27ff348c67e261283939baf0",
          "sha256": "a2fd09260bf0d2e8cdcda232adffde0d5e75800c8ea445d64ff1d48fdca5628e"
        },
        "downloads": 7313,
        "filename": "zope.formlib-4.0.tar.gz",
        "has_sig": false,
        "md5_digest": "4fae74df27ff348c67e261283939baf0",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 135999,
        "upload_time": "2010-01-08T19:49:24",
        "url": "https://files.pythonhosted.org/packages/2d/6b/4bc56ba9becf06f4f186abb9b42558acd4f4d45090c4a38ffd6ccf635673/zope.formlib-4.0.tar.gz"
      }
    ],
    "4.0.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "5dffffb60cc906c14ad3db149bb30549",
          "sha256": "16d533f24700cd1ae631601956fe6e77748495c0e43bba975499c6dee813d8e5"
        },
        "downloads": 3608,
        "filename": "zope.formlib-4.0.1.zip",
        "has_sig": false,
        "md5_digest": "5dffffb60cc906c14ad3db149bb30549",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 198259,
        "upload_time": "2010-02-22T00:24:57",
        "url": "https://files.pythonhosted.org/packages/fa/99/e3a0328c88745b0e4eaa316a16697947ff28e0e85459c776fa2112ca800f/zope.formlib-4.0.1.zip"
      }
    ],
    "4.0.2": [
      {
        "comment_text": "",
        "digests": {
          "md5": "a901bf2d2addff73192808cba680c955",
          "sha256": "9e05540ac4b64fc73a8a900ab3dfc99e6e91d4a12a3ed007dccd74f9cc557ea0"
        },
        "downloads": 5249,
        "filename": "zope.formlib-4.0.2.tar.gz",
        "has_sig": false,
        "md5_digest": "a901bf2d2addff73192808cba680c955",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 142020,
        "upload_time": "2010-03-07T05:00:57",
        "url": "https://files.pythonhosted.org/packages/19/9a/7ea43b56741cb7fcac5aae75bed9a27aef8ad15f4298fd29056633544869/zope.formlib-4.0.2.tar.gz"
      }
    ],
    "4.0.3": [
      {
        "comment_text": "",
        "digests": {
          "md5": "8288d1672562f3d6252abd911df10e00",
          "sha256": "ed9ae68be738b21f8563f131918b0dd3280e76da870ddfcb5348da68f5071731"
        },
        "downloads": 4060,
        "filename": "zope.formlib-4.0.3.tar.gz",
        "has_sig": false,
        "md5_digest": "8288d1672562f3d6252abd911df10e00",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 143258,
        "upload_time": "2010-05-07T03:37:29",
        "url": "https://files.pythonhosted.org/packages/e8/9f/7cb0c565bbde9eebd20e7c248c3fc263cea43aa9917190d1a638f4f31c3c/zope.formlib-4.0.3.tar.gz"
      }
    ],
    "4.0.4": [
      {
        "comment_text": "",
        "digests": {
          "md5": "d99313a916bb4573228e05f2f669f39f",
          "sha256": "d16f6ea48332386b1a3a6dfc7d4c2bbe4e7619cbb960196d1a20eb825e30c308"
        },
        "downloads": 4454,
        "filename": "zope.formlib-4.0.4.zip",
        "has_sig": false,
        "md5_digest": "d99313a916bb4573228e05f2f669f39f",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 196423,
        "upload_time": "2010-07-06T19:51:28",
        "url": "https://files.pythonhosted.org/packages/97/69/9ccd8d41daddbecf9223e40802343adba8f10bafcd9fc9055f3815fadd2f/zope.formlib-4.0.4.zip"
      }
    ],
    "4.0.5": [
      {
        "comment_text": "",
        "digests": {
          "md5": "5c14094a0354207894ffdd630d46c5d0",
          "sha256": "f7cf01399d73b387f0da42735b1082fd5c945fa3f4ef92fb7752360914d1c05a"
        },
        "downloads": 22816,
        "filename": "zope.formlib-4.0.5.tar.gz",
        "has_sig": false,
        "md5_digest": "5c14094a0354207894ffdd630d46c5d0",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 142339,
        "upload_time": "2010-09-16T13:44:31",
        "url": "https://files.pythonhosted.org/packages/f9/e3/2e891d59ef334c28d0cc9565973c14d2d5c53714e4cd8127d732113c9adc/zope.formlib-4.0.5.tar.gz"
      }
    ],
    "4.0.6": [
      {
        "comment_text": "",
        "digests": {
          "md5": "eed9c94382d11a4dececd0a48ac1d3f2",
          "sha256": "eccca7a4fa967f4a37570230d6d83faaf3cba5f6a046610848d0b7f10ee625e8"
        },
        "downloads": 70006,
        "filename": "zope.formlib-4.0.6.zip",
        "has_sig": false,
        "md5_digest": "eed9c94382d11a4dececd0a48ac1d3f2",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 197047,
        "upload_time": "2011-08-20T15:27:34",
        "url": "https://files.pythonhosted.org/packages/d3/72/417e1df7122d10c8694a4f67549bba55b74d6ffca3942c737118c890bbe6/zope.formlib-4.0.6.zip"
      }
    ],
    "4.1.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "38b7df2ee60a01f996c263a1a9815688",
          "sha256": "3cd24fa6d308145c99641903319397000f39a983e6d943f36756c82fde5a4a62"
        },
        "downloads": 2397,
        "filename": "zope.formlib-4.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "38b7df2ee60a01f996c263a1a9815688",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 141672,
        "upload_time": "2012-03-15T09:20:37",
        "url": "https://files.pythonhosted.org/packages/c2/68/7cb5bda79887bc834aba388cc5c8f3d79ec5215171b89a60143657d01777/zope.formlib-4.1.0.tar.gz"
      }
    ],
    "4.1.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "f3efc06eaed37f095c4b4ce2930b5b60",
          "sha256": "4dd8e08a1ae1cb48818abcef2d5ec52aef7e59b5c2c50565b9eea95fcaf3fe9a"
        },
        "downloads": 6890,
        "filename": "zope.formlib-4.1.1.tar.gz",
        "has_sig": false,
        "md5_digest": "f3efc06eaed37f095c4b4ce2930b5b60",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 142251,
        "upload_time": "2012-03-16T11:17:33",
        "url": "https://files.pythonhosted.org/packages/24/42/c3bcec23c32a3f27c63f6abe11e11b1cb4e8ce62d6fa55c2de53d4e50cb1/zope.formlib-4.1.1.tar.gz"
      }
    ],
    "4.2.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "41ece1d9d5f3f0e4227c63bc1249e9b5",
          "sha256": "45ca50d5e25a4acff8775d090bddd49f46b37faa7db4a1a67317f3b47eb82670"
        },
        "downloads": 3132,
        "filename": "zope.formlib-4.2.0.tar.gz",
        "has_sig": false,
        "md5_digest": "41ece1d9d5f3f0e4227c63bc1249e9b5",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 143878,
        "upload_time": "2012-11-27T13:37:33",
        "url": "https://files.pythonhosted.org/packages/f2/a3/0a1d28657c3e20bfb5ee96220907f6510df3aa94e3aec883ec0be8b3a15b/zope.formlib-4.2.0.tar.gz"
      },
      {
        "comment_text": "",
        "digests": {
          "md5": "250e8535bf83424b371f1de170a4b62d",
          "sha256": "818599abaf74f024f16dc9f07102714be6d8804cca2faf381b43de18fc23c2cf"
        },
        "downloads": 3162,
        "filename": "zope.formlib-4.2.0.zip",
        "has_sig": false,
        "md5_digest": "250e8535bf83424b371f1de170a4b62d",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 201665,
        "upload_time": "2012-11-28T08:09:34",
        "url": "https://files.pythonhosted.org/packages/96/08/c2968694c88d1c808346905b7f5db4a64c18a6e7d15cdfbeac62be6d3550/zope.formlib-4.2.0.zip"
      }
    ],
    "4.2.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "12358eea66fba006a0d296c40ba5a9dd",
          "sha256": "1642316a424e7da38fa2d899429e2a71c35bce4b8c51b992e66acc4be744df9a"
        },
        "downloads": 14659,
        "filename": "zope.formlib-4.2.1.zip",
        "has_sig": false,
        "md5_digest": "12358eea66fba006a0d296c40ba5a9dd",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 201845,
        "upload_time": "2013-02-22T12:35:01",
        "url": "https://files.pythonhosted.org/packages/92/2d/0626d45b07b205b6f67a1f93b2ed158d587bfb3055817c6bbb2258cb661c/zope.formlib-4.2.1.zip"
      }
    ],
    "4.3.0": [
      {
        "comment_text": "",
        "digests": {
          "md5": "2931c38931c155afc7c1cc35c3671f34",
          "sha256": "323000867593b46b3d81601aee1067950f6c64bd4f6b879f5219f7bfdd56cf7a"
        },
        "downloads": 19290,
        "filename": "zope.formlib-4.3.0.tar.gz",
        "has_sig": false,
        "md5_digest": "2931c38931c155afc7c1cc35c3671f34",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 158443,
        "upload_time": "2014-12-24T17:59:34",
        "url": "https://files.pythonhosted.org/packages/43/43/3709278281f6b02d857e55cc7f59a4e5bde77cfa981103adb3d1e59ea8aa/zope.formlib-4.3.0.tar.gz"
      }
    ],
    "4.3.0a1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "5432b107130e5a325ba722d5b21c30e5",
          "sha256": "b9aaeed634420504be5480e36931eb3942bf3ddaf46b1adf6e4e248cc5ad70b6"
        },
        "downloads": 6136,
        "filename": "zope.formlib-4.3.0a1.zip",
        "has_sig": false,
        "md5_digest": "5432b107130e5a325ba722d5b21c30e5",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 205222,
        "upload_time": "2013-02-28T00:53:00",
        "url": "https://files.pythonhosted.org/packages/10/2a/30909a0c9cfdeba2c8e21f70e63527988643a333ed181db78cb624330e7f/zope.formlib-4.3.0a1.zip"
      }
    ],
    "4.3.0a2": [
      {
        "comment_text": "",
        "digests": {
          "md5": "7ba1d4b6cd6311445dc11a6316f13d99",
          "sha256": "9bc0b8a7277f6419a48f991eab2f94f7bbb59f960c644f850dbe2c5bc9d7715f"
        },
        "downloads": 7451,
        "filename": "zope.formlib-4.3.0a2.zip",
        "has_sig": false,
        "md5_digest": "7ba1d4b6cd6311445dc11a6316f13d99",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 215139,
        "upload_time": "2013-11-21T13:21:16",
        "url": "https://files.pythonhosted.org/packages/ac/4b/0c15c6aabcc9060a7194cb1fe7b1730db789aadb7f278cd9f5a32d152ecb/zope.formlib-4.3.0a2.zip"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "2931c38931c155afc7c1cc35c3671f34",
        "sha256": "323000867593b46b3d81601aee1067950f6c64bd4f6b879f5219f7bfdd56cf7a"
      },
      "downloads": 19290,
      "filename": "zope.formlib-4.3.0.tar.gz",
      "has_sig": false,
      "md5_digest": "2931c38931c155afc7c1cc35c3671f34",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 158443,
      "upload_time": "2014-12-24T17:59:34",
      "url": "https://files.pythonhosted.org/packages/43/43/3709278281f6b02d857e55cc7f59a4e5bde77cfa981103adb3d1e59ea8aa/zope.formlib-4.3.0.tar.gz"
    }
  ]
}