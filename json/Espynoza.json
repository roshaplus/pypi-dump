{
  "info": {
    "author": "Ren\u00e9 Schmit",
    "author_email": "rene.schmit@plaakert.lu",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 3 - Alpha",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: MIT License",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.6",
      "Topic :: Software Development :: Build Tools"
    ],
    "description": "# Remark:\n**Info will be completed a.s.a.p., but if you happen to stumble on this project, feel free to use.**\n\n\nPlease be patient, doc. will be worked on before first public announcement\n\n# Introduction\nEspynoza is a framework for writing, configuring and managing applications on ESP8266 microcontroller boards.\n\nEspynoza supports remote uploading of files/sources via USB cable, or via Wifi/MQTT once the basic software is installed. Multiple MQTT servers may be configured as well as distinct Wifi Access Points.\n\nAll user actions are made through a command-line interface, *Espynoza.py* (use --help for details). Configuration is made via Python files (basically variable assignments). Configuration files exist on the global level, as well as for the individual target devices.\n\nThe framework, running on the target device, handles initial connection to the Wifi network, and then establishes a connection with the specified MQTT broker. The host server may then send commands to the target device, using standard Python syntax, and will receive data produced on the target. The frameworks main loop calls (user-definable) handlers to perform actions such as setting outputs and reading sensor data. A watchdog will reboot the target if the board hangs.\n\nRight now, some simple sample handlers are provided with Espynoza, more will follow soon. The aim is to create a library that will allow the user to build a system by writing a configuration file for simple cases, but that may be extended by writing small code fragments in Python for more special cases.\n\nSpecial care has been been taken to use as little memory as possible on the target devices. Python files may be compiled on the host system before being uploaded to avoid out of memory conditions during system startup. Only the files needed for the targets configuration are loaded into RAM.\n\n(BTW, in case you wonder why some things are designed the way they are, I plan to write a web/database-based application to make using Espynoza easier. But first things first...)\n\n## Version\nCurrent version is *0.1*, the initial commit.\nThis version should be considered alpha quality, even though the code should work if Espynoza and all needed libraries and tools are installed correctly.\nRight now, the number of available handlers is limited to simple digital and analog IO, as well as some I2C or similar serial communication protocol devices. More will follow as soon as the basic code is stable.\n\n# Download and Install\n## Requirements\n* Hardware\n  * Host computer\n    * PC running Linux (maybe other OS)\n    * or a Raspberry Pi running Linux (Ubuntu Jessie works)\n    * Python >= 3.6 (3.6 minimum, as format strings are used)\n  * Target\n    * ESP6288\n    * (more to come)\n\n* Software packages\n  * git\n  * MicroPython\n  * Mosquitto (and paho-mqtt)\n  * ampy (from Adafruit)\n  * esptool.py\n  * (esp-open-sdk -- optional, needed to build custom runtimes, no support yet)\n\n## Install\n\n*Remark*: the following instructions worked for me, your mileage may vary. Please drop me a note if you have problems, I will try to help, and amend these instructions.\n\n**Espinoza**: clone Espynoza from GitHub using this command:\n```\ngit clone https://github.com/finalstate/Espynoza.git\n```\nThis will create a directory called Espynoza containig the Espynoza.py cli tool, a basic configuration file and a number of sub-directories.\n\nMoreover you will need to install the following packages to use Espynoza. Install them in some convenient place on your disk, not into the Espinoza directory.\n\n**MicroPython**: the MicroPython language files, and its compiler. Install this using Github, and build the compiler yourself (the pre-build one provided for download is notoriously out of date, and your code might not work with it):\n```\ngit clone https://github.com/micropython/micropython.git\ncd micropython/mpy-cross\nmake\n```\nThis will create the mpy-cross compiler executable. Open the file *EspyConfig.py* in the Espynoza root directory. There you will find the following line:\n```\nC_MpyCross = './bin/mpy-cross'\n```\nYou may either change this to point to your brand-new compiler, or create the bin sub-directory and create a symbolic link to the compiler in this directory (or use your own strategy, Espynoza is designed to be flexible).\n\n**Mosquitto**: the MQTT broker used as a communication hub for Espynoza (and potentially many more sub-systems of your IoT installation.)\n\nIf you use Debian or Ubuntu, the following should work:\n\n```\nsudo su\napt-get update\napt-get upgrade\napt-get install mosquitto mosquitto-clients\n```\n\nPlease refer to the mosquitto documentation for configuration and usage. The out-of-the-box config should be OK if you are happy without security settings...\n\n## Clone from GitHub\n\n*Remark*: the following instructions worked for me, your mileage may vary. Please drop me a note if you have problems, I will try to help, and amend these instructions.\n\n**Espinoza**: clone Espynoza from GitHub using this command:\n```\ngit clone https://github.com/finalstate/Espynoza.git\n```\nThis will create a directory called Espynoza containig the Espynoza.py cli tool, a basic configuration file and a number of sub-directories.\n\nMoreover you will need to install the following packages to use Espynoza. Install them in some convenient place on your disk, not into the Espinoza directory.\n\n**esptool**: This tool is used to flash the target flash memory, and to upload the MicroPython firmware\n```\nsudo pip3 install esptool\n```\n\n**ampy**: This library is used to initially upload Python files to the target board. Install like this:\n```\nsudo pip3 install adafruit-ampy\n```\n\n**paho-mqtt**: a Python library for using MQTT. Again, we install using pip:\n\n```\nsudo pip3 install paho-mqtt\n```\n\n# Tutorial\nHere is a simple tutorial to get you started with Espynoza. First, we will set up some basic hardware, and then install the software on it to get a feeling for how Espinoza works and what it can do for us.\n\n## Hardware setup\nYou need to get hold of an ESP6288 development board. Any board that has a USB port for uploading should work. We will, for the purpose of this tutorial, connect an LED to Port xxx to play with output lines, and a simple wire to Port yyy to try out input lines. Please note that we will use the Dnn numbering scheme as printed on (most?) boards when dealing with hardware, but will use the pin numbers as used in the official ESP documentation when writing software.\n\n## Software configuration\nLets try to keep this simple for now. EspyConfig.py should be OK for this tutorial if you dont have done anything special during installation. Lets go into the *etc/* sub-directory. There, we find a file called *DemoDeviceList.py*. (We may use it as is, or we may make a copy of it that we call *DeviceList.py*. The later will be used if it exists. Do this if you do not want to run into problems when pulling the newest Espinoza library).\n\nOpen this file in your preferred text editor. It contains the configuration of your IoT installation as a whole. Later on, we will see how an individual target device is configured. We will need to make some changes in this file, specifically the Wifi and MQTT settings, and the basic settings of our target devices.\n\nSo, lets start with WiFi setup. Change the following network settings so they fit your local network:\n```python\nC_Network = {\n              'DNS'     : '192.168.1.1', \n              'Gateway' : '192.168.1.1',\n              'Netmask' : '255.255.255.0',\n            }\n```\n\nIn this tutorial, we will suppose that you have a single Wifi router. Uncomment the following line (leave the first one as is, it doesn't bother us right now), and change the name of the Hotspot and the Password to your settings:\n```python\nC_WifiPasswords = {\n                    ''         : '**PWD**',\n                  \n#                   'HotSpot1' : '**PWD**',\n                  }\n```\n\nIf your MQTT broker is configured to use a login and password, comment the first line, and uncomment the second one. Change the IP address you see to the one used by your MQTT broker. Change login and password if appropriate.\n```python\nC_MQTTCredentials = {\n                      '192.168.1.99' : (None,   None     ),\n#                     '192.168.1.98' : ('esp', '*******' ),\n                    }\n```\n\nAnd finally, we need to add our target to the device descriptor. Copy one of the lines and modify it like this:\n```python\nC_DeviceDescriptor = {\n                      # Target     : (Config,      AP, IP Address,      Broker,          Description                ),\n                        'Tutorial' : ('Tutorial',  '', '192.168.1.42',   '192.168.1.99', 'Tutorial board'           ),\n                                                   \n                        'SimpleIO' : ('SimpleIO',  '', '192.168.1.100', '192.168.1.215', 'Blink and rotary encoder' ),\n                     ...\n```\nChange the dictionaries key to the name you want to give to your board. The associated parameter list begins with the name of the target configuration that we will define below. Here, we give it the same name as the target, but if you have several targets that use the same configuration (such as temperature sensors in different rooms), you may use different target board names, and reuse the same configuration file. Next comes the SSID name of the Access Point you want the device to connect to. Then, find and enter an address in your LAN that is not used, here, I used 192.168.1.42. The second quad.dot.address is the address of the broker this particular board uses, change it to the one you used above. Finally, there is a string describing the board, change it to whatever you like, it is currently only used for documentation purposes.\n\nBtw, if you leave the AP name empty, the target will scan the Ether for access points and try to use those found, one by one, starting with the strongest, until a connection works. Of course, you will then need to set the password for the Access Point in the *<Demo>DeviceList.py* file, and booting the board will take longer. Also, more RAM will be used. But hey, it will work, and having multiple access points for redundancy, or better signal coverage, also has its advantages. (Unfortunately, right now, with auto-detection, all access points must have the same password. Stay tuned...)\n\nSave the file, it should be OK for now. But we are not done yet with the configuration...\n\nMake a copy of file *Newbie.py*, name it *Tutorial.py*. That's to say, use the config name you defined in the *<Demo>DeviceList.py* file. Open this file in your editor, and change the following items:\n**C_Handlers**: we will configure our IO here. Insert the following lines:\n```python\nC_Handlers = {\n               'DigitalOut': { 'Period' : 250,   'Params' : (('Led',    True ), ) }\n               'DigitalIn' : { 'Period' :    1,  'Params' : (('Wire',    500 ), ) },\n             }\n```\nNow, what does this mean. Lets see item by item.\n\n*DigitalOut* and *DigitalIn* are handler names. Think of them as drivers for your input and output devices. If you are curious, see the files *DigitalOut.py* and *DigitalIn.py* in the *usr/* directory.\n\nThe 'Period' parameter indicates how often the handlers 'periodic' method should be called. It is the number of milliseconds that the target should wait between two calls to the handlers 'periodic' method. The *DigitalOut* handler will blink the Led we connected every 500 ms (250 ms between individual togglings), and the *DigitalIn* pin will be read every millisecond.\n\nNext, we have the Parameters. These are different for all handlers, see the source file of the given Handler for a description. For *DigitalOut*, they are: The pin name to use, and if the Led should blink. We will see later what else than blinking we can do with this handler. *DigitalIn*s first parameter is also the pin name. The second parameter is used for debouncing, any changes happening at intervals (in milliseconds) shorter than this will be ignored.\n\n**C_Pins**:\nFinally, we need to define our pins:\n```python\n# Pin  : ESP pin id, \n# Mode : 0=IN | 1=OUT | 2=OPEN_DRAIN, \n# Value: if  IN: 1=PULL_UP | None=None)\n#        if OUT: 0=OFF | 1=ON | None=leave (default state)\nC_Pins = {\n           'Led'  : (0,  1, 0), \n           'Wire' : (1,  0, None),\n         }\n```\n\nThis dictionaries keys are the names of the Pins, as we used them above. The first parameter is the pin number. Here, we use the Espressif numbering, not the Dx stuff from the Arduino world. The second parameter defines if the pin is used as an Input or as an Output. Finally, the 'Wire' input pin has a third value which indicates whether it is configured as a PULL_UP input or not.\n\nAnd this concludes the configuration of our target. Next, we need to get it on our target, and then we may finally play with it.\n\n## Running it\nFirst, we need to prepare the board, i.e. flash it and upload the firmware. This is, of course, only possible via an USB connection, so we need to plug the board into the computer running Espynoza. Once we have done this, we execute the following command:\n```\n./Espynoza.py -t Tutorial -v --usb --flash\n```\nWe pass the following parameters:\n  * -t Tutorial -> This is the name of the board, and _not_ the the configuration name\n  * -v -> verbose. We get some information about what the tool is currently doing\n  * --usb -> upload via USB.\n  * --flash -> the command, here telling the tool to flash and init the board\n\nBtw, if you want to see the commands and options the tool implements, simply type\n```\n./Espynoza.py --help\n```\nFlashing the target takes some time, so be patient.\n\nOnce the flashing done, we are ready to transfer the base software. Make sure your Mosquitto instance is running, it will be used from now on. The first time, we still need to do this over USB, however, so here we go\n```\n./Espynoza.py -t Tutorial -v --usb --base\n```\nAgain, this takes some time, but now, we get a more fine-grained status report. Please be aware that this step may fail from time to time, as ampy, the tool used for the serial/USB transfer, is not very reliable. If you get an error, simply try again, normally it works on second or third attempt.\n\n\nThe board is automatically rebooted when done. If your board has the blue status light, it will blink during boot, and stay out once a Access Point has been contacted. If you monitor your MQTT traffic, you will notice some messages coming from your board. Try it with this command (add username/password if necessary):\n```\nmosquitto_sub  -v -q 1 -t '#'\n```\n\nWe're almost done now. For one thing, we will no longer need the USB connection, so you may connect your board to a simple power supply if you like.\n\nWhat still needs to be done is the uploading of the handlers. We do this with the following command:\n```\n./Espynoza.py -t Tutorial -v --handlers\n```\nNotice that we no longer use the --usb option, we are now 'over the air'. If you monitor MQTT traffic, you will also see _a lot_ of traffic, some strange stuff. This is your handlers, pre-compiled on your host. Python sources, with the exception of the main.py stub, is by default pre-compiled, if you prefer the put the raw sources onto your target, for whatever reason, use the --source option.\n\nOh, and if you want to reload the base software onto the target, you may do so OTA now.\n```\n./Espynoza.py -t Tutorial -v --base\n```\nYou may change and upload the configuration with\n```\n./Espynoza.py -t Tutorial -v --configure\n```\nagain OTA.\n\nIf you connected your Led correctly, it should blink now, at 2Hz. Try changing this frequency, change the configuration and upload it. The board should automatically reboot, and the tool should show the progress.\n\nConnecting your input wire to the 3V or GND pin should trigger some message sending. If so, input also works. Play around with the debouncing interval...\n\nBut there is more: we can interactively play with the system, OTA:\n```\n./Espynoza.py -t Tutorial -v -c \"1+2\"\n```\nThis returns the result, 3. And\n```\n./Espynoza.py -t Tutorial -v -c \"gc.mem_free()\"\n```\ntells us how much memory is still available on the target. In fact, we may execute any legal Python statement using Espynoza.py. And this is also the way to interact with the IO drivers. Execute:\n```\n./Espynoza.py -t Tutorial -v -c \"User.Handlers['DigitalOut']['Handler'].set('Led',1)\"\n```\nThis will put the Led on. Well, it would, but the Led blinks. So, switch of the blinking in the configuration file *Tutorial.py*, reload the config, and try again. And passing 0 to the set function turns it of again.\n\nHave a look at your MQTT output. You will find this line:\n```\nesp/SimpleIO/cmd User.Handlers['DigitalOut']['Handler'].set('Led',1)\n```\n\nThe topic is _esp/SimpleIO/cmd_ and the message is the Python code that puts the Led on. Sending this command using _any_ MQTT client will put the Led on. Do you have a MQTT client on your smartphone? Try it out. Perhaps not the most user-friendly way for IoT interactions, put I am sure you see the potential.\n\nHave a look at the file *usr/DigitalOut.py*. As you can see, set(...) is a method of the handler. There is also a toggle method. Try it out using Espynoza.py. Add your own method to DigitalOut, and try it. Or better, copy the handler to another file, change your config to use your version instead and then modify your private copy. This will avoid loosing your work when upgrading Espinoza.\n\n## Troubleshooting\nTo be completed \n\n\n# Architecture overview\n## File organization\n\n# Reference\n\n# Contributing\n\n# Known issues\n- out of order file chunk transfers\n- dir name ESP is sub-optimal\n\n# Upcoming\n(help welcome :-) )\n\n* custom firmware building support\n* https support for mqtt connections\n* cli commands: rename board, move target to another broker\n\n* ESP32 support (if and when MicroPython supports the stuff needed)",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "https://github.com/finalstate/Espynoza",
    "keywords": "IoT esp8266 MicroPython runtime uploader MQTT OverTheAir",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "Espynoza",
    "platform": "",
    "project_url": "https://pypi.org/project/Espynoza/",
    "release_url": "https://pypi.org/project/Espynoza/0.1/",
    "requires_dist": [],
    "requires_python": ">=3.6",
    "summary": "Runtime and upload utilities for MicroPython/ESP8266 boards",
    "version": "0.1"
  },
  "releases": {
    "0.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "846268c10a10e957e5f71ad05fa319fb",
          "sha256": "56a150efe92a112c087c0d5252eed15d94a64fa19bff76db81b96039d95c8549"
        },
        "downloads": -1,
        "filename": "Espynoza-0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "846268c10a10e957e5f71ad05fa319fb",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 28137,
        "upload_time": "2018-01-13T10:44:40",
        "url": "https://files.pythonhosted.org/packages/00/6b/faac69e3e8bd542228c4a1dc8cb121fdc60322fbf9ea1e46816d68004522/Espynoza-0.1.tar.gz"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "846268c10a10e957e5f71ad05fa319fb",
        "sha256": "56a150efe92a112c087c0d5252eed15d94a64fa19bff76db81b96039d95c8549"
      },
      "downloads": -1,
      "filename": "Espynoza-0.1.tar.gz",
      "has_sig": false,
      "md5_digest": "846268c10a10e957e5f71ad05fa319fb",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 28137,
      "upload_time": "2018-01-13T10:44:40",
      "url": "https://files.pythonhosted.org/packages/00/6b/faac69e3e8bd542228c4a1dc8cb121fdc60322fbf9ea1e46816d68004522/Espynoza-0.1.tar.gz"
    }
  ]
}