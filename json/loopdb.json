{
  "info": {
    "author": "Mihails Delmans",
    "author_email": "md656@cam.ac.uk",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 4 - Beta",
      "Intended Audience :: Developers",
      "Intended Audience :: Science/Research",
      "License :: OSI Approved :: MIT License",
      "Programming Language :: Python :: 2.7",
      "Topic :: Scientific/Engineering :: Bio-Informatics"
    ],
    "description": "Welcome to LoopDB\n=================\n\nLoopDB is a module for creating and storing DNA parts for Loop Assembly. It comes with a prebuilt\nschema for implementing original Loop Assembly protocol, but is completely general and allows\nalternative schema definitions ( see *manual-example* ).\n\nFor a quick introduction please read the **Getting started** section. Have a look at the **Tables**\nsection for a brief description of the underlying data structure. Check out example folders with\nsome code to get you started. Refer to **Advanced** for getting hold of **SQLAlchemy** functions.\n\n**Any other questions?** Please file an issue, or contact me at m.delmans@gmail.com\n\nGetting started\n===============\n\nInstalling LoopDB\n'''''''''''''''''\n\nLoopDB is available through PyPi, so you can just\n\n::\n\n    pip install loopdb\n\nSetting up a database\n'''''''''''''''''''''\n\nLoopDB is based on `SQLAlchemy <http://www.sqlalchemy.org>`__, which allows to use most of the\ncommon database back-ends. We recommend using `PostgreSQL <https://www.postgresql.org>`__. After you\nhave installed PostgreSQL, or any other database server, create a new database. With PostgreSQL it\ncan be done with\n\n::\n\n    createdb loopdb\n\nInitialising LoopDB\n'''''''''''''''''''\n\nCreate a loopDB instance by\n\n.. code:: python\n\n    from loopDB import LoopDB\n\n    loopDB = LoopDB( 'postgresql:///loopdb', clean = True )\n\nwhere the first argument is the address of your database, and ``clean`` flag determines whether the\ndatabase should be emptied before initialisation. Default is ``clean=False``. ##### Setting up a\nschema\n\nNow it's time to create a schema for the Loop Assembly. This involves setting up the restriction\nenzyme, restriction enzyme site, base sequence and backbone tables, which will be used for defying\nand storing parts. Read more about data structure in the **Tables** section. You have two options to\ncrate a schema, either using a json file or manually. Please refer to the *schema-example* and\n*manual-example*.\n\nAdding a part\n'''''''''''''\n\nYou can define a new Level 0 part by using ``LoopDB.addPart()`` method, followed by the\n``LoopDB.commit()`` method\n\n.. code:: python\n\n    myPart = loopDB.addPart(name = \"My Part\", seq = \"ATG...\", backbone = \"L0-CDS\")\n    loopDB.commit()\n\nwhere backbone is a name of a backbone you want to use for your part. If you are adding more than\none part, you can commit only onece after you issued several ``addPart()`` commands. Alternatively\nyou can load the part from a GenBank file, whcih will preserve and store all the sequence\nannotations.\n\n.. code:: python\n\n    genBankPart = loopDB.addPart(name = \"My GB Part\",\n                        gbFile = \"part.gb\", backbone = \"L0-CDS\")\n\nAssembling a part\n'''''''''''''''''\n\nAfter you have defined several Level 0 parts you can use them to run an assembly using the same\n``addPart()`` method. The only difference is that instead of specifying the sequence you should pass\na ``children`` argument containing names of the parts for assembly\n\n.. code:: python\n\n    myPromoter      = loopDB.addPart(name = \"My Promoter\",\n                            seq = \"GGA...\", backbone = \"L0-Prom5\")\n    myCDS           = loopDB.addPart(name = \"My CDS\",\n                            seq = \"ATG...\", backbone = \"L0-CDS\")\n    myTerminator    = loopDB.addPart(name = \"My Part\",\n                            seq = \"TCT...\", backbone = \"L0-Term3\")\n    myGene          = loopDB.addPart(name = \"My Gene\",\n                            children = [myPromoter, myCDS, myTerminator], backbone = \"Ly1\")\n    loopDB.commit()\n\nOne you have several Level 1 parts you can use the same method to assemble Level 2 parts and so on.\nFurthermore, you can mix and match different levels, as long as their backbones have compatible\nrestriction sites. Having said that, make sure that the parts you pass to ``addPart()`` method are\nin right order and are assembled in a compatible backbone, i.e. the 3' overhang of each successive\npart matches 5' overhang of the previous part; and 3' overhang of the first part and 5' overhang of\nthe last part match the corresponding sequences of the template backbone.\n\nRetrieving parts\n''''''''''''''''\n\nYou can retrieve an existing part by passing part name to ``LoopDB.getPart()`` method. You can also\nuse, ``getBaseSeq()``, ``getBackbone()``, etc. to retrieve existing records for every LoopDB table.\n\n.. code:: python\n\n        myPart = loopDB.getPart(\"MyPart\")\n\nFurther, you can access part's children or retrieve part sequence, by using the following properties\n\n.. code:: python\n\n        myPart.seq\n        >> 'ATGGT...'\n        myPart.fullSeq\n        >> 'GTAGCAT ATG... GCTGAT'\n        myPart.children\n        >> [<tables.Part object at 0x10d5c8b10>, <tables.Part object at 0x10d5c8d50>]\n\nThe difference between ``seq`` and ``fullSeq`` is that the first one will return only the actual\nsequence of the part, while the second one will return the complete sequence, including that of the\nbackbone. Additionally you can use ``record`` and ``fullRecord`` properties to get partial or\ncomplete `Biopython <http://biopython.org>`__ ``SeqRecord`` that will include all the annotations.\n\nTables\n======\n\nLoopDB creates several tables behid the scene, which are used to store part elements.\n\nRE Table\n''''''''\n\nRE Table stores Restriction enzyme definitions.\n\n::\n\n    RE Table\n        name:       Name of restriction enzyme\n        seq:        Recognition sequence of the enzyme\n\nRES Table\n'''''''''\n\nRES Table stores pairs of restriction enzyme overhangs, that will be further used to define\nreceivers and adapters for Base sequences and Backbones.\n\n::\n\n    RES Table\n        name:       Name of a restriction site\n        site5:      Sequence of a 5' overhang\n        site3:      Sequence of a 3' overhang\n\nBaseSeq Table\n'''''''''''''\n\nBaseSeq Table stores definitions of Base sequences, which conceptually are meta-backbones composed\nof a backbone sequence and receiver overhangs. In original Loop Assembly schema there are two Base\nsequences: Ly (level odd) and Lx (Level even).\n\n::\n\n    BaseSeq Table\n        name:       Name of a Base sequence\n        seq:        Sequence\n        receiver:   RES corresponding to the receiver overhangs\n\nBackbone Table\n''''''''''''''\n\nBackbone table stores definitions of the backbones, which conceptually are variants of the Base\nsequences, defined by unique adapter overhangs. In original Loop Assembly schema these are Lx1 - Lx4\nand Ly1 - Ly4.\n\n::\n\n    Backbone Table\n        name:       Name of a Backbone\n        baseSeq:    Corresponding BaseSeq\n        adapter:    RES corresponding to the adapter overhangs.\n        *seq:       Backbone sequence\n        *record:    Corresponding SeqRecord\n\nPart Table\n''''''''''\n\nHere LoopDB stores all the parts.\n\n::\n\n    Part\n        name:       Name of a Part\n        backbone:   Corresponding backbone\n        seq:        Original part sequence (Only for Level 0 parts)\n        children:   List of references to subparts (For Level 1 and higher)\n        *level:     Level of the part, defines as maximum level of the children + 1.\n        *partSeq:   Paert sequence : a recursive sum of all part's children sequences (seq), including overhangs.\n        *fullSeq:   Same as *partSeq but with backbone sequence included.\n        *record:    SeqRecord with *partSeq as a sequnce pluss all annotations from the supplied gb files.\n        *fullRecord: Same as *record but with backbone sequence and annotation.\n\n*Note: Asterisks \\* denote properties that are not stored in the database, but are genrated on the\nfly.* # Advanced LoopDB is based on SQLAlchemy, which offers an advanced database querying system (\napart from many more other things ). You can get SQLAlchemy ``Session`` either by using\n``LoopDB.session`` or creating a new session via ``LoopDB.Session()`` method.\n\n.. code:: python\n\n    loopDB = LoopDB(...)\n    session = loopDB.Session()\n    parts = session.query(Part).filter( ... ).all()\n    session.close()\n\n    # OR\n\n    parts = loopDB.session.query(Part).filter( ... ).all()\n\nFor more information on querying see `SQLAlchemy\ntutorial <https://docs.sqlalchemy.org/en/latest/orm/tutorial.html#querying>`__.\n\nYou can also have a look in ``tables.py`` file to see the definition of the SQLAlchemy tables and\ntheir methods.\n\nAny questions?\n==============\n\nPlease feel free to file an issue or contact me at m.delmans@gmail.com\n",
    "docs_url": null,
    "download_url": "https://github.com/HaseloffLab/LoopDB/archive/0.2.tar.gz",
    "downloads": {
      "last_day": 0,
      "last_month": 0,
      "last_week": 0
    },
    "home_page": "https://github.com/HaseloffLab/LoopDB",
    "keywords": "bioinfomratics parts synthetic biology loop assembly",
    "license": "GPL",
    "maintainer": null,
    "maintainer_email": null,
    "name": "loopdb",
    "platform": "UNKNOWN",
    "project_url": "https://pypi.org/project/loopdb/",
    "release_url": "https://pypi.org/project/loopdb/0.2/",
    "requires_python": null,
    "summary": "A module for creating and storing DNA parts for Loop Assembly",
    "version": "0.2"
  },
  "releases": {
    "0.1": [
      {
        "comment_text": "",
        "digests": {
          "md5": "b205963763fcfe2d5f90fb96345e94e0",
          "sha256": "6a5b9fb90eab0a5fde140845de9dd84714a03410269cd59483c619c712987304"
        },
        "downloads": 235,
        "filename": "loopdb-0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "b205963763fcfe2d5f90fb96345e94e0",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 7390,
        "upload_time": "2017-04-06T09:37:14",
        "url": "https://files.pythonhosted.org/packages/f9/07/7f37150e9f1c6b8a27c9ee1d0bf5977c59de5063fd776a20107d667c8d6d/loopdb-0.1.tar.gz"
      }
    ],
    "0.2": [
      {
        "comment_text": "",
        "digests": {
          "md5": "f9487abdb8ad110f48408caa697304c1",
          "sha256": "92e391961b838681aef8c697f6f94acecae6df0e41a880155b3adf7aa6db1798"
        },
        "downloads": 0,
        "filename": "loopDB-0.2.tar.gz",
        "has_sig": false,
        "md5_digest": "f9487abdb8ad110f48408caa697304c1",
        "packagetype": "sdist",
        "python_version": "source",
        "size": 7345,
        "upload_time": "2017-04-10T19:02:34",
        "url": "https://files.pythonhosted.org/packages/36/4c/b4aaef374c352f23d081a397226b8a3ba666d2c77859bf0a11ab18c2fb6b/loopDB-0.2.tar.gz"
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "md5": "f9487abdb8ad110f48408caa697304c1",
        "sha256": "92e391961b838681aef8c697f6f94acecae6df0e41a880155b3adf7aa6db1798"
      },
      "downloads": 0,
      "filename": "loopDB-0.2.tar.gz",
      "has_sig": false,
      "md5_digest": "f9487abdb8ad110f48408caa697304c1",
      "packagetype": "sdist",
      "python_version": "source",
      "size": 7345,
      "upload_time": "2017-04-10T19:02:34",
      "url": "https://files.pythonhosted.org/packages/36/4c/b4aaef374c352f23d081a397226b8a3ba666d2c77859bf0a11ab18c2fb6b/loopDB-0.2.tar.gz"
    }
  ]
}